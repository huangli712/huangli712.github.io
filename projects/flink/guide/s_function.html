<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Special functions · Flink</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">Flink</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="../intro.html">Introduction</a></li><li><a class="tocitem" href="../install.html">Installation</a></li><li><a class="tocitem" href="../usage.html">Basic usage</a></li><li><span class="tocitem">User&#39;s guide</span><ul><li><a class="tocitem" href="m_constants.html">Constants</a></li><li><a class="tocitem" href="m_linkedlist.html">Linked list</a></li><li><a class="tocitem" href="m_mpi.html">Message passing interface</a></li><li><a class="tocitem" href="m_parser.html">Configuration parser</a></li><li><a class="tocitem" href="m_sparse.html">Sparse matrix</a></li><li><a class="tocitem" href="m_spring.html">Pseudorandom number generator</a></li><li><a class="tocitem" href="m_stack.html">Stack</a></li><li><a class="tocitem" href="m_tetra.html">Analytical tetrahedron algorithm</a></li><li><a class="tocitem" href="s_error.html">Error and exception</a></li><li><a class="tocitem" href="s_fourier.html">Fourier transformation</a></li><li class="is-active"><a class="tocitem" href="s_function.html">Special functions</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Type"><span>Type</span></a></li><li><a class="tocitem" href="#Source"><span>Source</span></a></li><li><a class="tocitem" href="#Usage"><span>Usage</span></a></li><li><a class="tocitem" href="#Theory"><span>Theory</span></a></li></ul></li><li><a class="tocitem" href="s_integrator.html">Integration</a></li><li><a class="tocitem" href="s_matrix.html">Matrix</a></li><li><a class="tocitem" href="s_spline.html">Spline interpolation</a></li><li><a class="tocitem" href="s_util.html">Utility</a></li><li><a class="tocitem" href="s_vector.html">Vector</a></li></ul></li><li><span class="tocitem">Appendix</span><ul><li><a class="tocitem" href="../appendix/make.html">make.sys</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User&#39;s guide</a></li><li class="is-active"><a href="s_function.html">Special functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="s_function.html">Special functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/huangli712/flink/blob/master/docs/src/guide/s_function.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>Provide some subroutines to calculate the special functions.</p><h2 id="Type"><a class="docs-heading-anchor" href="#Type">Type</a><a id="Type-1"></a><a class="docs-heading-anchor-permalink" href="#Type" title="Permalink"></a></h2><p>subroutines</p><h2 id="Source"><a class="docs-heading-anchor" href="#Source">Source</a><a id="Source-1"></a><a class="docs-heading-anchor-permalink" href="#Source" title="Permalink"></a></h2><p><code>src/s_function.f90</code></p><h2 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h2><p><strong>(1)</strong> Orthogonal polynomial basis.</p><pre><code class="language-fortran hljs">subroutine s_leg_basis(lemax, legrd, lmesh, rep_l)
subroutine s_che_basis(chmax, chgrd, cmesh, rep_c)
subroutine s_svd_basis(svmax, svgrd, smesh, rep_s, bose, beta)</code></pre><p><code>lemax</code> means maximum order for legendre orthogonal polynomial, <code>legrd</code> means number of mesh points for legendre orthogonal polynomial, <code>lmesh</code> means mesh for legendre orthogonal polynomial in [-1,1], <code>rep_l</code> saves legendre orthogonal polynomial defined on [-1,1].</p><p><code>chmax</code> means maximum order for chebyshev orthogonal polynomial, <code>chgrd</code> means number of mesh points for chebyshev orthogonal polynomial, <code>cmesh</code> means mesh for chebyshev orthogonal polynomial in [-1,1], <code>rep_c</code> saves chebyshev orthogonal polynomial defined on [-1,1].</p><p><code>svmax</code> means maximum order for svd orthogonal polynomial, <code>svgrd</code> means number of mesh points for svd orthogonal polynomial, <code>smesh</code> means mesh for svd orthogonal polynomial in [-1,1], <code>rep_s</code> saves svd orthogonal polynomial defined on [-1,1], <code>bose</code> determines whether the bosonic kernel is used, <code>beta</code> means inverse system temperature <span>$\beta$</span>.</p><p><strong>(2)</strong> Spheric Bessel function.</p><pre><code class="language-fortran hljs">subroutine s_sph_jl(lmax, x, jl)</code></pre><p>It computes the spherical Bessel functions of the first kind, <span>$j_l(x)$</span>, for argument <span>$x$</span> and <span>$l = 0, 1, \ldots, l_{max}$</span>.</p><p><strong>(3)</strong> Bernstein polynomial.</p><pre><code class="language-fortran hljs">subroutine s_bezier(n, x, bern)</code></pre><p><code>n</code> means the degree of the bernstein polynomials to be used. For any given <span>$n$</span>, there is a set of <span>$n + 1$</span> bernstein polynomials, each of degree <span>$n$</span>, which form a basis for polynomials on [0,1]. <code>x</code> means the evaluation point. <code>bern</code> saves the values of the <span>$n+1$</span> bernstein polynomials at <span>$x$</span>.</p><p><strong>(4)</strong> Some helper functions for <code>s_svd_basis()</code>.</p><pre><code class="language-fortran hljs">function s_safe_exp(x)</code></pre><p>It is a safe exp call to avoid data overflow.</p><pre><code class="language-fortran hljs">function s_f_kernel(tau, omega, beta)
function s_b_kernel(tau, omega, beta)</code></pre><p>They are used to calculate fermionic or bosonic kernel functions. <code>tau</code> means <span>$\tau$</span>, <code>omega</code> means <span>$\omega$</span>, <code>beta</code> means inverse system temperature <span>$\beta$</span>.</p><h2 id="Theory"><a class="docs-heading-anchor" href="#Theory">Theory</a><a id="Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Theory" title="Permalink"></a></h2><p><strong>Legendre orthogonal polynomial</strong></p><p>The Legendre orthogonal polynomials obey the three term recurrence relation, known as Bonnet’s recursion formula:</p><p class="math-container">\[\begin{equation}
P_0(x) = 1
\end{equation}\]</p><p class="math-container">\[\begin{equation}
P_1(x) = x
\end{equation}\]</p><p class="math-container">\[\begin{equation}
(n+1) P_{n+1}(x) = (2n+1) P_n(x) - n P_{n-1}(x)
\end{equation}\]</p><p><strong>Chebyshev orthogonal polynomial</strong></p><p>The Chebyshev orthogonal polynomials of the second kind can be defined by the following recurrence relation:</p><p class="math-container">\[\begin{equation}
U_0(x) = 1
\end{equation}\]</p><p class="math-container">\[\begin{equation}
U_1(x) = 2x
\end{equation}\]</p><p class="math-container">\[\begin{equation}
U_{n+1}(x) = 2xU_n(x) - U_{n-1}(x)
\end{equation}\]</p><p><strong>SVD orthogonal polynomial</strong></p><p>In the imaginary-frequency domain, the Lehmann representation reads,</p><p class="math-container">\[\begin{equation}
G(i\nu) = \int_{-\infty}^\infty d\omega
\underbrace{\frac{1}{i\nu - \omega}}_{\equiv K(i\nu, \omega)}
A(\omega),
\end{equation}\]</p><p>where <span>$A(\omega)$</span> is a spectral function. <span>$K(i\nu,\omega)$</span> is the so-called analytic continuation kernel. The Lehmann representation can be transformed to the imaginary-time domain as</p><p class="math-container">\[\begin{equation}
G(\tau) = -\int_{-\infty}^\infty
d\omega K(\tau,\omega) A(\omega),
\end{equation}\]</p><p>where <span>$0 &lt; \tau &lt; \beta$</span> and</p><p class="math-container">\[\begin{equation}
K(\tau,\omega) \equiv
-\frac{1}{\beta} \sum_{i\nu} e^{-i\nu \tau} K(i\nu,\omega)=
\begin{cases}
    \frac{e^{-\tau\omega}}{1+e^{-\beta\omega}} &amp; (\mathrm{fermion}),\\
    \frac{e^{-\tau\omega}}{1-e^{-\beta\omega}} &amp; (\mathrm{boson}).
\end{cases}
\end{equation}\]</p><p>The minus sign originates from our convention <span>$K(\tau, \omega) &gt; 0$</span>. To avoid the divergence of the bosonic kernel at <span>$\omega=0$</span>, we reformulate Equation of <span>$G(\tau)$</span> as</p><p class="math-container">\[\begin{equation}
G(\tau)= -\int_{-\infty}^\infty d{\omega}
K^\mathrm{L}(\tau,\omega) \rho(\omega),
\end{equation}\]</p><p>where <span>$K^\mathrm{L}(\tau,\omega)$</span> is the <em>logistic kernel</em> defined as</p><p class="math-container">\[K^\mathrm{L}(\tau,\omega) =
\frac{e^{-\tau\omega}}{1+e^{-\beta\omega}},\]</p><p>and <span>$\rho(\omega)$</span> is the modified spectral function</p><p class="math-container">\[\begin{equation}
\rho(\omega) \equiv
\begin{cases}
    A(\omega) &amp; (\mathrm{fermion}),\\
    \frac{A(\omega)}{\tanh(\beta \omega/2)} &amp; (\mathrm{boson}).
\end{cases}
\end{equation}\]</p><p>The singular value expnasion of the kernel reads</p><p class="math-container">\[\begin{equation}
K^\mathrm{L}(\tau, \omega) = \sum_{l=0}^\infty U_l(\tau) S_l V_l(\omega)
\end{equation}\]</p><p>for <span>$\omega \in [-\omega_{max}, \omega_{max}]$</span> with <span>$\omega_{max}$</span> (<span>$&gt; 0$</span>) being a cut-off frequency. <span>$U_l(\tau)$</span> and <span>$V_l(\omega)$</span> are left and right singular functions and <span>$S_l$</span> is the singular values (with <span>$S_0&gt;S_1&gt;S_2&gt;...&gt;0$</span>). The two sets of singular functions <span>$U$</span> and <span>$V$</span> make up the basis functions of the so-called Intermediate Representation (IR), which depends on <span>$\beta$</span> and the cutoff <span>$\omega_{max}$</span>. For the peculiar choice of the regularization for the bosonic kernel using <span>$K^\mathrm{L}$</span>, these basis functions do not depend on statistical properties. The basis functions <span>$U_l(\tau)$</span> are transformed to the imaginary-frequency axis as</p><p class="math-container">\[U_l(i\nu) \equiv \int_0^\beta d \tau e^{i\nu\tau} U_l(\tau).\]</p><p>Some of the information regarding real-frequency properties of the system is often lost during transition into the imaginary-time domain, so that the imaginary-frequency Green&#39;s function does hold less information than the real-frequency Green&#39;s function. The reason for using IR lies within its compactness and ability to display that information in imaginary quantities.</p><p>The decay of the singular values depends on <span>$\beta$</span> and <span>$\omega_{max}$</span> only through the dimensionless parameter <span>$\Lambda \equiv \beta\omega_{max}$</span>.</p><p><strong>Spheric Bessel function</strong></p><p>The following recursion relation</p><p class="math-container">\[\begin{equation}
j_{l+1}(x)=\frac{2l+1}{x}j_l(x)-j_{l-1}(x)
\end{equation}\]</p><p>is used either downwards for <span>$x &lt; l$</span> or upwards for <span>$x \ge l$</span>. For <span>$x \ll 1$</span>, the following asymtotic form is used:</p><p class="math-container">\[\begin{equation}
j_l(x) \approx \frac{x^l}{(2l+1)!!}.
\end{equation}\]</p><p>This procedure is numerically stable and accurate to near this machine precision for <span>$l \le 50$</span>.</p><p><strong>Bernstein polynomial</strong></p><p>The bernstein polynomials are assumed to be based on [0,1]. The formula reads:</p><p class="math-container">\[\begin{equation}
B(N,I)(X) = \frac{N!}{I!(N-I)!} (1-X)^{(N-I)} X^I
\end{equation}\]</p><p>First values:</p><pre><code class="nohighlight hljs">B(0,0)(X) = 1
B(1,0)(X) =      1-X
B(1,1)(X) =                X
B(2,0)(X) =     (1-X)**2
B(2,1)(X) = 2 * (1-X)    * X
B(2,2)(X) =                X**2
B(3,0)(X) =     (1-X)**3
B(3,1)(X) = 3 * (1-X)**2 * X
B(3,2)(X) = 3 * (1-X)    * X**2
B(3,3)(X) =                X**3
B(4,0)(X) =     (1-X)**4
B(4,1)(X) = 4 * (1-X)**3 * X
B(4,2)(X) = 6 * (1-X)**2 * X**2
B(4,3)(X) = 4 * (1-X)    * X**3
B(4,4)(X) =                X**4</code></pre><p>Special values:</p><ul><li>B(N,I)(X) has a unique maximum value at X = I/N.</li><li>B(N,I)(X) has an I-fold zero at 0 and and N-I fold zero at 1.</li><li>For X = 1/2,</li></ul><p class="math-container">\[B(N,I)(1/2) = \frac{C(N,K)}{2^N}\]</p><ul><li>For a fixed X and N, the polynomials add up to 1:</li></ul><p class="math-container">\[\sum_{I=0}^{N} B(N,I)(X) = 1\]</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="s_fourier.html">« Fourier transformation</a><a class="docs-footer-nextpage" href="s_integrator.html">Integration »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 15 August 2023 21:06">Tuesday 15 August 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

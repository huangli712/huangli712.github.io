var documenterSearchIndex = {"docs":
[{"location":"guide/s_vector.html#Introduction","page":"Vector","title":"Introduction","text":"","category":"section"},{"location":"guide/s_vector.html","page":"Vector","title":"Vector","text":"It provides a lot of subroutines to manupulate the vectors.","category":"page"},{"location":"guide/s_vector.html#Type","page":"Vector","title":"Type","text":"","category":"section"},{"location":"guide/s_vector.html","page":"Vector","title":"Vector","text":"subroutines","category":"page"},{"location":"guide/s_vector.html#Source","page":"Vector","title":"Source","text":"","category":"section"},{"location":"guide/s_vector.html","page":"Vector","title":"Vector","text":"src/s_vector.f90","category":"page"},{"location":"guide/s_vector.html#Usage","page":"Vector","title":"Usage","text":"","category":"section"},{"location":"guide/s_vector.html","page":"Vector","title":"Vector","text":"(1) Mesh generation","category":"page"},{"location":"guide/s_vector.html","page":"Vector","title":"Vector","text":"subroutine s_linspace_i(xmin, xmax, n, x)\nsubroutine s_linspace_d(xmin, xmax, n, x)\nsubroutine s_linspace_z(xmin, xmax, n, x)","category":"page"},{"location":"guide/s_vector.html","page":"Vector","title":"Vector","text":"To create a linear mesh x in interval [xmin, xmax], n is size of array x.","category":"page"},{"location":"guide/s_vector.html","page":"Vector","title":"Vector","text":"(2) Calculate sum of vector.","category":"page"},{"location":"guide/s_vector.html","page":"Vector","title":"Vector","text":"subroutine s_cumsum_i(n, v, vsum)\nsubroutine s_cumsum_d(n, v, vsum)\nsubroutine s_cumsum_z(n, v, vsum)","category":"page"},{"location":"guide/s_vector.html","page":"Vector","title":"Vector","text":"Return the cumsum of an array v. n is size of array v, and vsum is cumsum of array v.","category":"page"},{"location":"guide/s_vector.html","page":"Vector","title":"Vector","text":"(3) Calculate product of vector.","category":"page"},{"location":"guide/s_vector.html","page":"Vector","title":"Vector","text":"subroutine s_cumprod_i(n, v, vprod)\nsubroutine s_cumprod_d(n, v, vprod)\nsubroutine s_cumprod_z(n, v, vprod)","category":"page"},{"location":"guide/s_vector.html","page":"Vector","title":"Vector","text":"Return the cumproduct of an array v. n is size of array v, and vprod is cumprod of array v.","category":"page"},{"location":"guide/s_vector.html","page":"Vector","title":"Vector","text":"(4) Swap two vectors.","category":"page"},{"location":"guide/s_vector.html","page":"Vector","title":"Vector","text":"subroutine s_swap_i(n, ix, iy)\nsubroutine s_swap_d(n, dx, dy)\nsubroutine s_swap_z(n, zx, zy)","category":"page"},{"location":"guide/s_vector.html","page":"Vector","title":"Vector","text":"Exchange two vectors, where n is dimension of the vectors.","category":"page"},{"location":"guide/s_vector.html","page":"Vector","title":"Vector","text":"(5) Linear mixing for vectors.","category":"page"},{"location":"guide/s_vector.html","page":"Vector","title":"Vector","text":"subroutine s_mix_i(n, ix, iy, alpha)\nsubroutine s_mix_d(n, dx, dy, alpha)\nsubroutine s_mix_z(n, zx, zy, alpha)","category":"page"},{"location":"guide/s_vector.html","page":"Vector","title":"Vector","text":"Perform linear mixing for two vectors, where n is dimension of the vectors, and alpha is the mixing parameter alpha.","category":"page"},{"location":"guide/s_vector.html","page":"Vector","title":"Vector","text":"(6) Convert diagonal elements of matrix to vector.","category":"page"},{"location":"guide/s_vector.html","page":"Vector","title":"Vector","text":"subroutine s_vecadd_i(n, ix, iy, alpha)\nsubroutine s_vecadd_d(n, dx, dy, alpha)\nsubroutine s_vecadd_z(n, zx, zy, alpha)","category":"page"},{"location":"guide/s_vector.html","page":"Vector","title":"Vector","text":"Try to add diagonal elements of a matrix to a vector, where n is dimension of the vectors, and alpha is the prefactor. *x is vector, and *y is a n-by-n matrix.","category":"page"},{"location":"guide/s_vector.html","page":"Vector","title":"Vector","text":"note: Note\n_i means integer version, _d real(dp) version, and _z complex(dp) version.","category":"page"},{"location":"guide/m_spring.html#Introduction","page":"Pseudorandom number generator","title":"Introduction","text":"","category":"section"},{"location":"guide/m_spring.html","page":"Pseudorandom number generator","title":"Pseudorandom number generator","text":"The following two random number generators (generates a random number between 0 and 1, real double precision) are supported by now.","category":"page"},{"location":"guide/m_spring.html","page":"Pseudorandom number generator","title":"Pseudorandom number generator","text":"MT19937","category":"page"},{"location":"guide/m_spring.html","page":"Pseudorandom number generator","title":"Pseudorandom number generator","text":"Mersenne Twister pseudorandom number generator\nby Makoto Matsumoto and Takuji Nishimura\nMersenne Twister: A 623-dimensionally equidistributed uniform pseudorandom number generator\nACM Trans. on Modeling and Computer Simulation Vol. 8, No. 1, January pp.3-30 (1998).","category":"page"},{"location":"guide/m_spring.html","page":"Pseudorandom number generator","title":"Pseudorandom number generator","text":"SFMT","category":"page"},{"location":"guide/m_spring.html","page":"Pseudorandom number generator","title":"Pseudorandom number generator","text":"SIMD-oriented Fast Mersenne Twister\nby Mutsuo Saito and Makoto Matsumoto\nSIMD-oriented Fast Mersenne Twister: a 128-bit Pseudorandom Number Generator\nMonte Carlo and Quasi-Monte Carlo Methods 2006, Springer, 2008, pp. 607-622.","category":"page"},{"location":"guide/m_spring.html#Type","page":"Pseudorandom number generator","title":"Type","text":"","category":"section"},{"location":"guide/m_spring.html","page":"Pseudorandom number generator","title":"Pseudorandom number generator","text":"module","category":"page"},{"location":"guide/m_spring.html#Source","page":"Pseudorandom number generator","title":"Source","text":"","category":"section"},{"location":"guide/m_spring.html","page":"Pseudorandom number generator","title":"Pseudorandom number generator","text":"src/m_spring.f90","category":"page"},{"location":"guide/m_spring.html#Usage","page":"Pseudorandom number generator","title":"Usage","text":"","category":"section"},{"location":"guide/m_spring.html","page":"Pseudorandom number generator","title":"Pseudorandom number generator","text":"(1) Use MT19937.","category":"page"},{"location":"guide/m_spring.html","page":"Pseudorandom number generator","title":"Pseudorandom number generator","text":"use spring\ncall spring_mt_init(seed)\nr = spring_mt_stream()\nr = spring_mt_string()","category":"page"},{"location":"guide/m_spring.html","page":"Pseudorandom number generator","title":"Pseudorandom number generator","text":"(2) Use SFMT.","category":"page"},{"location":"guide/m_spring.html","page":"Pseudorandom number generator","title":"Pseudorandom number generator","text":"use spring\ncall spring_sfmt_init(seed)\nr = spring_sfmt_stream()\nr = spring_sfmt_string()","category":"page"},{"location":"guide/m_spring.html","page":"Pseudorandom number generator","title":"Pseudorandom number generator","text":"The functions spring_mt_stream() and sprint_sfmt_stream() obtain a psuedo random real number in the range (0,1), i.e., a number greater than 0 and less than 1. The functions spring_mt_string() and sprint_sfmt_string() obtain a psuedo random real number in the range [0,1], i.e., a number greater than or equal to 0 and less than or equal to 1.","category":"page"},{"location":"guide/m_spring.html","page":"Pseudorandom number generator","title":"Pseudorandom number generator","text":"note: Note\nSince SFMT has a better performance, it is preferable.","category":"page"},{"location":"guide/s_matrix.html#Introduction","page":"Matrix","title":"Introduction","text":"","category":"section"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"It provides a lot of subroutines to manipulate the matrix and implement the linear algebra.","category":"page"},{"location":"guide/s_matrix.html#Type","page":"Matrix","title":"Type","text":"","category":"section"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"subroutines","category":"page"},{"location":"guide/s_matrix.html#Source","page":"Matrix","title":"Source","text":"","category":"section"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"src/s_matrix.f90","category":"page"},{"location":"guide/s_matrix.html#Usage","page":"Matrix","title":"Usage","text":"","category":"section"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"(1) Build constants (0) matrix.","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"subroutine s_zeros_i(n, A)\nsubroutine s_zeros_d(n, A)\nsubroutine s_zeros_z(n, A)","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"To build a matrix with all elements are zero. Here n means size of matrix, A means input/output matrix.","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"(2) Build constants (1) matrix.","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"subroutine s_ones_i(n, A)\nsubroutine s_ones_d(n, A)\nsubroutine s_ones_z(n, A)","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"To build a matrix with all elements are zero. Here n means size of matrix, A means input/output matrix.","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"(3) Build constants (any values) matrix.","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"subroutine s_any_i(n, i, A)\nsubroutine s_any_d(n, d, A)\nsubroutine s_any_z(n, z, A)","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"To build a matrix with all elements are given by i, d, or z. Here n means size of matrix, A means input/output matrix. i, d, and z are initial values of matrix elements.","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"(4) Build diagonal matrix.","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"subroutine s_eye_i(n, k, A)\nsubroutine s_eye_d(n, k, A)\nsubroutine s_eye_z(n, k, A)","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"To build a matrix with ones on the diagonal and zeros elsewhere. Here n means size of matrix, A means input/output matrix, k means  index of the diagonal.","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"(5) Build identity matrix.","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"subroutine s_identity_i(n, A)\nsubroutine s_identity_d(n, A)\nsubroutine s_identity_z(n, A)","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"To build an identity matrix. Here n means size of matrix, A means input/output matrix.","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"(6) Build diagonal matrix from vector.","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"subroutine s_diag_i(n, v, A)\nsubroutine s_diag_d(n, v, A)\nsubroutine s_diag_z(n, v, A)","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"To build a diagonal matrix from a vector. Here n means size of matrix, A means input/output matrix, v means input vector.","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"(7) Calculate trace for matrix.","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"subroutine s_trace_d(n, A, tr)\nsubroutine s_trace_z(n, A, tr)","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"Return trace for a matrix. Here n means size of matrix, A means input/output matrix, tr means matrix's trace.","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"(8) Calculate determinant for matrix.","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"subroutine s_det_d(ndim, dmat, ddet)\nsubroutine s_det_z(ndim, zmat, zdet)","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"where ndim means dimension of the matrix, ddet and zdet are the determinants, dmat and zmat are the input matrices.","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"(9) Calculate matrix inversion.","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"subroutine s_inv_d(ndim, dmat)\nsubroutine s_inv_z(ndim, zmat)","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"where ndim means dimension of the matrix, dmat and zmat are the input/output matrices.","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"(10) General eigensystem problem.","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"subroutine s_eig_dg(ldim, ndim, amat, eval, evec)\nsubroutine s_eig_zg(ldim, ndim, zmat, zeig, zvec)\nsubroutine s_eigvals_dg(ldim, ndim, amat, eval)\nsubroutine s_eigvals_zg(ldim, ndim, zmat, zeig)","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"Here ldim is leading dimension of matrix, ndim is the order of the matrix, amat and zmat are the input matrices, eval and zeig mean eigenvalues, evec and zvec mean eigenvectors.","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"(11) Symmetric eigensystem problem.","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"subroutine s_eig_sy(ldim, ndim, amat, eval, evec)\nsubroutine s_eig_he(ldim, ndim, amat, eval, evec)\nsubroutine s_eigvals_sy(ldim, ndim, amat, eval)\nsubroutine s_eigvals_he(ldim, ndim, amat, eval)","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"Here ldim is leading dimension of matrix, ndim is the order of the matrix, amat is the input matrix, eval means eigenvalues, evec means eigenvectors.","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"(12) Linear equation solver.","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"subroutine s_solve_dg(n, nrhs, A, B)\nsubroutine s_solve_zg(n, nrhs, A, B)\nsubroutine s_solve_sy(n, nrhs, A, B)\nsubroutine s_solve_he(n, nrhs, A, B)","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"Try to solve a linear system AX = B. Here, n is the number of linear equations, nrhs is the number of right-hand sides, A and B are input matrices. On exit, B is overwritten by the solution matrix X.","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"(13) General singular value decomposition.","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"subroutine s_svd_dg(m, n, min_mn, amat, umat, svec, vmat)\nsubroutine s_svd_zg(m, n, min_mn, amat, umat, svec, vmat)","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"To perform the singular values decomposition for a general m-by-n matrix A, where A = U Sigma V, return its left vectors, right vectors, and singular values. Here, m is number of rows of A matrix, n is number of columns of A matrix, min_mn is minimal value of m and n, amat means A, umat means  left vectors U, svec means singular values Sigma, vmat means right vectors V.","category":"page"},{"location":"guide/s_matrix.html","page":"Matrix","title":"Matrix","text":"note: Note\n_i means integer version, _d real(dp) version, and _z complex(dp) version. _dg means real(dp) general version, _zg complex(dp) general version, _sy real(dp) symmetric version, _he complex(dp) Hermitian version.","category":"page"},{"location":"install.html","page":"Installation","title":"Installation","text":"As mentioned before, almost all of my Fortran codes depend on the Flink library. So, if you want to try my codes, perhaps you have to compile and install Flink at first. Do not be nervous. It is quite easy.","category":"page"},{"location":"install.html","page":"Installation","title":"Installation","text":"Step 1","category":"page"},{"location":"install.html","page":"Installation","title":"Installation","text":"At first, you have to download the latest source codes from the official repository of Flink. If every thing is OK, you will have a compressed file, such as flink.zip or flink.tar.gz.","category":"page"},{"location":"install.html","page":"Installation","title":"Installation","text":"Step 2","category":"page"},{"location":"install.html","page":"Installation","title":"Installation","text":"And then you need to decompress it with unzip or tar.","category":"page"},{"location":"install.html","page":"Installation","title":"Installation","text":"Step 3","category":"page"},{"location":"install.html","page":"Installation","title":"Installation","text":"The next step is to compile Flink. Please execute the following three commands in your terminal.","category":"page"},{"location":"install.html","page":"Installation","title":"Installation","text":"$ cd flink/build\n$ editor make.inc\n$ make","category":"page"},{"location":"install.html","page":"Installation","title":"Installation","text":"Once the compilation is finished (It takes about a few seconds usually), we can find libflink.a and a lot of *.mod files under the flink/src directory. That is all.","category":"page"},{"location":"install.html","page":"Installation","title":"Installation","text":"note: Note\nIn order to compile Flink, you have to ensure that a MPI-enabled Fortran compiler (which is compatibe with Fortran 2018 standard), and a numerical library which implements the BLAS and LAPACK interfaces (such as Intel MKL), are installed and configured correctly in your system. You can setup your compiling environment via editing the build/make.inc file.See make.inc for more details.","category":"page"},{"location":"guide/m_mpi.html#Introduction","page":"Message passing interface","title":"Introduction","text":"","category":"section"},{"location":"guide/m_mpi.html","page":"Message passing interface","title":"Message passing interface","text":"This module wraps the most useful mpi calls by using generic programming techniques. It supports most of the collective operations (such as BCAST, GATHER, REDUCE, etc.). These subroutines are","category":"page"},{"location":"guide/m_mpi.html","page":"Message passing interface","title":"Message passing interface","text":"MPI_INIT()\nMPI_FINALIZE()\nMPI_WTIME()\nMPI_WTICK()\nMPI_BARRIER()\nMPI_DIMS_CREATE()\nMPI_CART_CREATE()\nMPI_CART_COORDS()\nMPI_COMM_SPLIT()\nMPI_COMM_RANK()\nMPI_COMM_SIZE()\nMPI_GET_PROCESSOR_NAME()\nMPI_BCAST()\nMPI_GATHER()\nMPI_GATHERV()\nMPI_ALLGATHER()\nMPI_ALLGATHERV()\nMPI_REDUCE()\nMPI_ALLREDUCE()","category":"page"},{"location":"guide/m_mpi.html","page":"Message passing interface","title":"Message passing interface","text":"etc. However, none of the point-to-point operations is supported. In the module, we also try to implement a light-weight error handler. Enjoy it!","category":"page"},{"location":"guide/m_mpi.html#Type","page":"Message passing interface","title":"Type","text":"","category":"section"},{"location":"guide/m_mpi.html","page":"Message passing interface","title":"Message passing interface","text":"module","category":"page"},{"location":"guide/m_mpi.html#Source","page":"Message passing interface","title":"Source","text":"","category":"section"},{"location":"guide/m_mpi.html","page":"Message passing interface","title":"Message passing interface","text":"src/m_mpi.f90","category":"page"},{"location":"guide/m_mpi.html#Usage","page":"Message passing interface","title":"Usage","text":"","category":"section"},{"location":"guide/m_mpi.html","page":"Message passing interface","title":"Message passing interface","text":"(1) Include mpi support.","category":"page"},{"location":"guide/m_mpi.html","page":"Message passing interface","title":"Message passing interface","text":"use mmpi","category":"page"},{"location":"guide/m_mpi.html","page":"Message passing interface","title":"Message passing interface","text":"Please pay attention to the module name. It is mmpi, instead of mpi.","category":"page"},{"location":"guide/m_mpi.html","page":"Message passing interface","title":"Message passing interface","text":"(2) Init mpi environment.","category":"page"},{"location":"guide/m_mpi.html","page":"Message passing interface","title":"Message passing interface","text":"call mp_init()            ! init mpi environment\ncall mp_comm_rank(myid)   ! get current process it\ncall mp_comm_size(nprocs) ! get number of processes","category":"page"},{"location":"guide/m_mpi.html","page":"Message passing interface","title":"Message passing interface","text":"(3) Broadcast data.","category":"page"},{"location":"guide/m_mpi.html","page":"Message passing interface","title":"Message passing interface","text":"real(dp), allocatable :: real_data(:,:,:)\ninteger, allocatable :: int_data(:)\ncomplex(dp), allocatable :: cmplx_data(:,:,:,:)\n\ncall mp_bcast(real_data, master)\ncall mp_bcast(int_data, master)\ncall mp_bcast(cmplx_data, master)","category":"page"},{"location":"guide/m_mpi.html","page":"Message passing interface","title":"Message passing interface","text":"Here master == 0 which means the master node/root process.","category":"page"},{"location":"guide/m_mpi.html","page":"Message passing interface","title":"Message passing interface","text":"(4) Allreduce data.","category":"page"},{"location":"guide/m_mpi.html","page":"Message passing interface","title":"Message passing interface","text":"real(dp), allocatable :: real_data(:)\nreal(dp), allocatable :: real_data_mpi(:)\n\ncall mp_allreduce(real_data, real_data_mpi)     ! all-readuce data\nreal_data = real_data_mpi / number_of_processes ! calculate the average","category":"page"},{"location":"guide/m_mpi.html","page":"Message passing interface","title":"Message passing interface","text":"(5) Setup barrier.","category":"page"},{"location":"guide/m_mpi.html","page":"Message passing interface","title":"Message passing interface","text":"call mp_barrier()","category":"page"},{"location":"guide/m_mpi.html","page":"Message passing interface","title":"Message passing interface","text":"(6) Finialize mpi environment.","category":"page"},{"location":"guide/m_mpi.html","page":"Message passing interface","title":"Message passing interface","text":"call mp_finalize()","category":"page"},{"location":"guide/s_integrator.html#Introduction","page":"Integration","title":"Introduction","text":"","category":"section"},{"location":"guide/s_integrator.html","page":"Integration","title":"Integration","text":"This module is used to perform simple numerical integration.","category":"page"},{"location":"guide/s_integrator.html#Type","page":"Integration","title":"Type","text":"","category":"section"},{"location":"guide/s_integrator.html","page":"Integration","title":"Integration","text":"subroutines","category":"page"},{"location":"guide/s_integrator.html#Source","page":"Integration","title":"Source","text":"","category":"section"},{"location":"guide/s_integrator.html","page":"Integration","title":"Integration","text":"src/s_integrator.f90","category":"page"},{"location":"guide/s_integrator.html#Usage","page":"Integration","title":"Usage","text":"","category":"section"},{"location":"guide/s_integrator.html","page":"Integration","title":"Integration","text":"To use s_int_trapezoid() or s_int_simpson(), you have to define the integrand at first. For example:","category":"page"},{"location":"guide/s_integrator.html","page":"Integration","title":"Integration","text":"function f(x)\n    use constants, only : dp\n\n    implicit none\n\n    real(dp) :: x\n    real(dp) :: f\n\n    f = x * x\nend function f","category":"page"},{"location":"guide/s_integrator.html","page":"Integration","title":"Integration","text":"Next, you have to determine the lower bound a and upper bound b, and the number of points n. Noted that now both the s_int_trapezoid() and s_int_simpson() functions only support the 1-D numerical integration.","category":"page"},{"location":"guide/s_integrator.html","page":"Integration","title":"Integration","text":"(1) Use s_int_trapezoid().","category":"page"},{"location":"guide/s_integrator.html","page":"Integration","title":"Integration","text":"procedure( real(dp) ) :: s_int_trapezoid\nprocedure( real(dp) ) :: f\nreal(dp) :: val\n\nval = s_int_trapezoid(f, a, b, n)","category":"page"},{"location":"guide/s_integrator.html","page":"Integration","title":"Integration","text":"(2) Use s_int_simpson().","category":"page"},{"location":"guide/s_integrator.html","page":"Integration","title":"Integration","text":"procedure( real(dp) ) :: s_int_simpson\nprocedure( real(dp) ) :: f\nreal(dp) :: val\n\nval = s_int_simpson(f, a, b, n)","category":"page"},{"location":"guide/s_integrator.html#Theory","page":"Integration","title":"Theory","text":"","category":"section"},{"location":"guide/s_integrator.html","page":"Integration","title":"Integration","text":"Trapezoid rule","category":"page"},{"location":"guide/s_integrator.html","page":"Integration","title":"Integration","text":"beginequation\nint_a^b f(x) dx approx\nfrach2\nleft\nf(x_0) + 2f(x_1) + cdots + 2f(x_n-1) + f(x_n)\nright\nendequation","category":"page"},{"location":"guide/s_integrator.html","page":"Integration","title":"Integration","text":"where h = (b-a)n.","category":"page"},{"location":"guide/s_integrator.html","page":"Integration","title":"Integration","text":"Simpson rule","category":"page"},{"location":"guide/s_integrator.html","page":"Integration","title":"Integration","text":"beginequation\nint_a^b f(x) dx approx\nfrach3\nleft\nf(x_0) + f(x_n) +\n4 sum_i = 1^n2 f(x_2i-1) +\n2 sum_i = 1^n2-1 f(x_2i)\nright\nendequation","category":"page"},{"location":"guide/s_integrator.html","page":"Integration","title":"Integration","text":"where h = (b-a)n, and n must be even number.","category":"page"},{"location":"intro.html#Welcome","page":"Introduction","title":"Welcome","text":"","category":"section"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"Flink is a Fortran utility library. It provides some useful features with which you can develop your scientific computation codes quickly. Actually, almost all of my Fortran codes depend on the Flink library. They are","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"iQIST\nDyson\nAnd so on...","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"note: Note\nFlink obeys the Fortran 2018 standard.","category":"page"},{"location":"intro.html#Features","page":"Introduction","title":"Features","text":"","category":"section"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"Modules\nPhysical and numerical constants (src/m_constants.f90)\nData structure: linked list (src/m_linkedlist.f90)\nMessage passing interface (src/m_mpi.f90)\nSparse matrix (src/m_sparse.f90)\nConfiguration file (src/m_parser.f90)\nPseudo random number generator (src/m_spring.f90)\nData structure: stack (src/m_stack.f90)\nAnalytical tetrahedron method (src/m_tetra.f90)\nSubroutines\nWarning and error messages (src/s_error.f90)\nFourier transformation (src/s_fourier.f90)\nSpecial functions (src/s_function.f90)\nNumerical integration (src/s_integrator.f90)\nLinear algebra: matrix (src/s_matrix.f90)\nSpline interpolation (src/s_spline.f90)\nAuxiliary tools (src/s_util.f90)\nLinear algebra: vector (src/s_vector.90)","category":"page"},{"location":"intro.html#Author","page":"Introduction","title":"Author","text":"","category":"section"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"Li Huang\nInstitute of Materials, China Academy of Engineering Physics, Sichuan Jiangyou, PRC\nemail: huangli at caep.cn","category":"page"},{"location":"guide/s_error.html#Introduction","page":"Error and exception","title":"Introduction","text":"","category":"section"},{"location":"guide/s_error.html","page":"Error and exception","title":"Error and exception","text":"To deal with the error and exception.","category":"page"},{"location":"guide/s_error.html#Type","page":"Error and exception","title":"Type","text":"","category":"section"},{"location":"guide/s_error.html","page":"Error and exception","title":"Error and exception","text":"subroutines","category":"page"},{"location":"guide/s_error.html#Source","page":"Error and exception","title":"Source","text":"","category":"section"},{"location":"guide/s_error.html","page":"Error and exception","title":"Error and exception","text":"src/s_error.f90","category":"page"},{"location":"guide/s_error.html#Usage","page":"Error and exception","title":"Usage","text":"","category":"section"},{"location":"guide/s_error.html","page":"Error and exception","title":"Error and exception","text":"(1) Display the error, exception, or message on the terminal.","category":"page"},{"location":"guide/s_error.html","page":"Error and exception","title":"Error and exception","text":"subroutine s_print_error(sub, msg)\nsubroutine s_print_exception(sub, msg)\nsubroutine s_print_message(sub, msg)","category":"page"},{"location":"guide/s_error.html","page":"Error and exception","title":"Error and exception","text":"where sub is the name of subroutine or function that emits the error, exception, or message, msg explains the error, exception, or message.","category":"page"},{"location":"guide/s_error.html","page":"Error and exception","title":"Error and exception","text":"(2) Write the error, exception, or message to external file.","category":"page"},{"location":"guide/s_error.html","page":"Error and exception","title":"Error and exception","text":"subroutine s_write_error(sub, msg, file_unit)\nsubroutine s_write_exception(sub, msg, file_unit)\nsubroutine s_write_message(sub, msg, file_unit)","category":"page"},{"location":"guide/s_error.html","page":"Error and exception","title":"Error and exception","text":"where sub is the name of subroutine or function that emits the error, exception, or message, msg explains the error, exception, or message, file_unit denotes the handler of external file.","category":"page"},{"location":"guide/s_util.html#Introduction","page":"Utility","title":"Introduction","text":"","category":"section"},{"location":"guide/s_util.html","page":"Utility","title":"Utility","text":"It provides some utility subroutines and functions.","category":"page"},{"location":"guide/s_util.html#Type","page":"Utility","title":"Type","text":"","category":"section"},{"location":"guide/s_util.html","page":"Utility","title":"Utility","text":"subroutines","category":"page"},{"location":"guide/s_util.html#Source","page":"Utility","title":"Source","text":"","category":"section"},{"location":"guide/s_util.html","page":"Utility","title":"Utility","text":"src/s_util.f90","category":"page"},{"location":"guide/s_util.html#Usage","page":"Utility","title":"Usage","text":"","category":"section"},{"location":"guide/s_util.html","page":"Utility","title":"Utility","text":"(1) C-like assertion.","category":"page"},{"location":"guide/s_util.html","page":"Utility","title":"Utility","text":"subroutine s_assert(condition)\nsubroutine s_assert2(condition, message)","category":"page"},{"location":"guide/s_util.html","page":"Utility","title":"Utility","text":"where condition is the logical condition that we have to assert, message is the additional message.","category":"page"},{"location":"guide/s_util.html","page":"Utility","title":"Utility","text":"(2) Sort algorithm.","category":"page"},{"location":"guide/s_util.html","page":"Utility","title":"Utility","text":"subroutine s_sorter1_i(nsize, list)\nsubroutine s_sorter1_d(nsize, list)\nsubroutine s_sorter2_i(nsize, list, indx)\nsubroutine s_sorter2_d(nsize, list, indx)\nsubroutine s_qsorter(nsize, list)\nsubroutine s_qscorer(pstart, pend, nsize, list)","category":"page"},{"location":"guide/s_util.html","page":"Utility","title":"Utility","text":"The s_sorter1() and s_sorter2() subroutines implement the bubble algorithm, and the s_qsorter() subroutine implements the quick sort algorithm. The s_qscorer() subroutine is called by the s_qsorter() internally. DO NOT call it directly!","category":"page"},{"location":"guide/s_util.html","page":"Utility","title":"Utility","text":"Here, nsize is size of the list, list is the dataset to be sorted. In s_sorter2(), the index of the dataset (indx) is also sorted.","category":"page"},{"location":"guide/s_util.html","page":"Utility","title":"Utility","text":"note: Note\n_i means integer version, _d real(dp) version.","category":"page"},{"location":"guide/s_util.html","page":"Utility","title":"Utility","text":"(3) Combination algrbra.","category":"page"},{"location":"guide/s_util.html","page":"Utility","title":"Utility","text":"subroutine s_combination(ntiny, nlarg, value)","category":"page"},{"location":"guide/s_util.html","page":"Utility","title":"Utility","text":"     ! the small number\n     integer, intent(in)  :: ntiny\n\n     ! the large number\n     integer, intent(in)  :: nlarg\n\n     ! result value of the combination algebra\n     integer, intent(out) :: value","category":"page"},{"location":"guide/s_util.html","page":"Utility","title":"Utility","text":"It calculates combination algebra.","category":"page"},{"location":"guide/s_util.html","page":"Utility","title":"Utility","text":"(4) String manipulation.","category":"page"},{"location":"guide/s_util.html","page":"Utility","title":"Utility","text":"subroutine s_str_upcase(s)\nsubroutine s_str_lowcase(s)","category":"page"},{"location":"guide/s_util.html","page":"Utility","title":"Utility","text":"     ! input/output string\n     character(len=*), intent(inout) :: s","category":"page"},{"location":"guide/s_util.html","page":"Utility","title":"Utility","text":"They are used to convert the input string s to upcase or lowcase.","category":"page"},{"location":"guide/s_util.html","page":"Utility","title":"Utility","text":"subroutine s_str_count(string, substr, count)","category":"page"},{"location":"guide/s_util.html","page":"Utility","title":"Utility","text":"     ! string to be examined\n     character(len=*), intent(in) :: string\n\n     ! substring in question\n     character(len=*), intent(in) :: substr\n\n     ! return value, number of occurrences\n     integer, intent(out) :: count","category":"page"},{"location":"guide/s_util.html","page":"Utility","title":"Utility","text":"It return the number of times a substring occurs.","category":"page"},{"location":"guide/s_util.html","page":"Utility","title":"Utility","text":"subroutine s_str_compress(string)","category":"page"},{"location":"guide/s_util.html","page":"Utility","title":"Utility","text":"     ! character string to be compressed.\n     character(len=*), intent(inout) :: string","category":"page"},{"location":"guide/s_util.html","page":"Utility","title":"Utility","text":"It return a copy of an input string with all whitespace (spaces and tabs) is removed.","category":"page"},{"location":"guide/s_util.html","page":"Utility","title":"Utility","text":"(5) Date time manipulation.","category":"page"},{"location":"guide/s_util.html","page":"Utility","title":"Utility","text":"subroutine s_time_builder(date_time_string)","category":"page"},{"location":"guide/s_util.html","page":"Utility","title":"Utility","text":"     ! output date and time\n     character(len=20), intent(out) :: date_time_string","category":"page"},{"location":"guide/s_util.html","page":"Utility","title":"Utility","text":"It returns a string containing date and time in human readable format.","category":"page"},{"location":"guide/s_util.html","page":"Utility","title":"Utility","text":"subroutine s_time_analyzer(time_iter, time_niter)","category":"page"},{"location":"guide/s_util.html","page":"Utility","title":"Utility","text":"     ! time used in this iteration\n     real(dp), intent(in) :: time_iter\n\n     ! time used in total iteration\n     real(dp), intent(in) :: time_niter","category":"page"},{"location":"guide/s_util.html","page":"Utility","title":"Utility","text":"It is used to print the iteration timing information about continuous time quantum Monte Carlo quantum impurity solver.","category":"page"},{"location":"guide/m_tetra.html#Introduction","page":"Analytical tetrahedron algorithm","title":"Introduction","text":"","category":"section"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"In this module, two tetrahedron integration algorithms are implemented. They are:","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"P. E. Blochl tetrahedron integration algorithm,\nLambin-Vigneron tetrahedron integration algorithm.","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"Note that the former is used to calculate the DFT density of states, while the later is used to calculate the lattice Green's functions during the DFT + DMFT calculations. Besides, we also implement three smearing algorithm, which can be used to calculate the DFT density of states as well. They are:","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"Gaussian smearing algorithm,\nFermi-Dirac smearing algorithm,\nMarzari-Vanderbilt cold smearing algorithm.","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"This module depends on the s_util.f90/s_qsorter() subroutine.","category":"page"},{"location":"guide/m_tetra.html#Type","page":"Analytical tetrahedron algorithm","title":"Type","text":"","category":"section"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"module","category":"page"},{"location":"guide/m_tetra.html#Source","page":"Analytical tetrahedron algorithm","title":"Source","text":"","category":"section"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"src/m_tetra.f90","category":"page"},{"location":"guide/m_tetra.html#Usage","page":"Analytical tetrahedron algorithm","title":"Usage","text":"","category":"section"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"(1) P. E. Blochl tetrahedron integration algorithm.","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"call tetra_blochl_weight1(z, e, dos, tos)","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"or","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"call tetra_blochl_weight2(z, e, ddd, ttt)","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"For the external energy z and the one-particle energies at the corners of the tetrahedron e, the subroutine tetra_blochl_weight1() returns total contributions of the given tetrahedron to the density of states dos and integrated density of states tos, the subroutine tetra_blochl_weight2() returns corner-dependent contributions of the given tetrahedron to the density of states ddd and integrated density of states ttt.","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"(2) Lambin-Vigneron tetrahedron integration algorithm.","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"call tetra_lambin_weight(z, e, weights)","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"For the external energy z and the energy eigenvalues for four corners at given tetrahedron, the subroutine tetra_lambin_weight() returns corner-dependent integration weights weights for lattice Green's function. Note that now z, e, and weights are all complex.","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"(3) Gaussian smearing algorithm.","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"call smearing_gauss_weight1(z, e, dos, tos)","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"or","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"call smearing_gauss_weight2(z, e, dos, tos)","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"or","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"call smearing_gauss_weight3(z, e, dd, tt)","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"Here, z means external energy, e means energy at given k-point and band in smearing_gauss_weight1(), corner energies at given tetrahedron in smearing_gauss_weight2() and smearing_gauss_weight3(). In smearing_gauss_weight1() and smearing_gauss_weight2(), the total contributions of the given tetrahedron to the density of states dos and integrated density of states tos are returned. In smearing_gauss_weight3(), the corner-dependent contributions (integration weights) of the given tetrahedron to the density of states dd and integrated density of states tt are returned.","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"(4) Fermi-Dirac smearing algorithm.","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"call smearing_fermi_weight1(z, e, dos, tos)","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"or","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"call smearing_fermi_weight2(z, e, dos, tos)","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"or","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"call smearing_fermi_weight3(z, e, dd, tt)","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"Here, z means external energy, e means energy at given k-point and band in smearing_fermi_weight1(), corner energies at given tetrahedron in smearing_fermi_weight2() and smearing_fermi_weight3(). In smearing_fermi_weight1() and smearing_fermi_weight2(), the total contributions of the given tetrahedron to the density of states dos and integrated density of states tos are returned. In smearing_fermi_weight3(), the corner-dependent contributions (integration weights) of the given tetrahedron to the density of states dd and integrated density of states tt are returned.","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"(5) Marzari-Vanderbilt cold smearing algorithm.","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"call smearing_marzari_weight1(z, e, dos, tos)","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"or","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"call smearing_marzari_weight2(z, e, dos, tos)","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"or","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"call smearing_marzari_weight3(z, e, dd, tt)","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"Here, z means external energy, e means energy at given k-point and band in smearing_marzari_weight1(), corner energies at given tetrahedron in smearing_marzari_weight2() and smearing_marzari_weight3(). In smearing_marzari_weight1() and smearing_marzari_weight2(), the total contributions of the given tetrahedron to the density of states dos and integrated density of states tos are returned. In smearing_marzari_weight3(), the corner-dependent contributions (integration weights) of the given tetrahedron to the density of states dd and integrated density of states tt are returned.","category":"page"},{"location":"guide/m_tetra.html#Theory","page":"Analytical tetrahedron algorithm","title":"Theory","text":"","category":"section"},{"location":"guide/m_tetra.html#Analytical-Tetrahedron-Integration-(Blochl's-Algorithm)","page":"Analytical tetrahedron algorithm","title":"Analytical Tetrahedron Integration (Blochl's Algorithm)","text":"","category":"section"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"Number of states","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"Here we list the expressions for the integrated density of states or number of states function n(epsilon) from a given tetrahedron. The number of states function is used to determine the Fermi level. The expressions shown are similar to those given in previous papers. For the sake of simplicity we have omitted all band indices. The one-particle energies at the corners of the tetrahedron are epsilon_1, epsilon_2, epsilon_3, epsilon_4, which are ordered according to increasing values. epsilon_ij is a shorthand notation for epsilon_i - epsilon_j. V_T is the reciprocal-space volume of the tetrahedron, and V_G is the volume of the reciprocal unit cell.","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nn(epsilon) = 0\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"for epsilon  epsilon_1,","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nn(epsilon) = fracV_TV_G frac(epsilon - epsilon_1)^3epsilon_21epsilon_31epsilon_41\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"for epsilon_1  epsilon  epsilon_2,","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nn(epsilon) = fracV_TV_G\nfrac1epsilon_31epsilon_41\nleft\nepsilon^2_21 +\n3epsilon_21(epsilon-epsilon_2) +\n3(epsilon - epsilon_2)^2 -\nfracepsilon_31 + epsilon_42epsilon_32epsilon_42(epsilon - epsilon_2)^3\nright\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"for epsilon_2  epsilon  epsilon_3,","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nn(epsilon) = fracV_TV_G\nleft(\n1 - frac(epsilon_4 - epsilon)^3epsilon_41epsilon_42epsilon_43\nright)\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"for epsilon_3  epsilon  epsilon_4, and","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nn(epsilon) = fracV_TV_G\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"for epsilon  epsilon_4.","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"Integration weights","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"Here we give the expressions that result in the integration weights w_nj. By w_1, w_2, w_3, and w_4 we denote the contribution to the integration weights at the four corners of a tetrahedron, which are again ordered according to increasing one-particle energies. Note that the band index n is suppressed.","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"For a fully tetrahedron, i.e., epsilon_F  epsilon_1, the contributions vanish:","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nw_1 = w_2 = w_3 = w_4 = 0\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"For epsilon_1  epsilon_F  epsilon_2, we obtain","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nw_1 = C\nleft\n4 - (epsilon_F - epsilon_1)\nleft(frac1epsilon_21 + frac1epsilon_31 + frac1epsilon_41right)\nright\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nw_2 = C fracepsilon_F - epsilon_1epsilon_21\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nw_3 = C fracepsilon_F - epsilon_1epsilon_31\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nw_4 = C fracepsilon_F - epsilon_1epsilon_41\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"with","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nC = fracV_T4V_G frac(epsilon_F - epsilon_1)^3epsilon_21epsilon_31epsilon_41\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"For epsilon_2  epsilon_F  epsilon_3, we obtain","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nw_1 = C_1 +\n(C_1 + C_2) fracepsilon_3 - epsilon_Fepsilon_31 +\n(C_1 + C_2 + C_3)fracepsilon_4 - epsilon_Fepsilon_41\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nw_2 = C_1 + C_2 + C_3 +\n(C_2 + C_3) fracepsilon_3 - epsilon_Fepsilon_32 +\nC_3 fracepsilon_4 - epsilon_Fepsilon_42\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nw_3 = (C_1 + C_2) fracepsilon_F - epsilon_1epsilon_31 +\n(C_2 + C_3) fracepsilon_F - epsilon_2epsilon_32\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nw_4 = (C_1 + C_2 + C_3)fracepsilon_F - epsilon_1epsilon_41 +\nC_3 fracepsilon_F - epsilon_2epsilon_42\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"with","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nC_1 = fracV_T4V_G frac(epsilon_F - epsilon_1)^2epsilon_41epsilon_31\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nC_2 = fracV_T4V_G\nfrac(epsilon_F - epsilon_1)(epsilon_F - epsilon_2)(epsilon_3 - epsilon_F)epsilon_41epsilon_32epsilon_31\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nC_3 = fracV_T4V_G\nfrac(epsilon_F - epsilon_2)^2(epsilon_4 - epsilon_F)epsilon_42epsilon_32epsilon_41\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"For epsilon_3  epsilon_F  epsilon_4, the weights are","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nw_1 = fracV_T4V_G - C fracepsilon_4 - epsilon_Fepsilon_41\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nw_2 = fracV_T4V_G - C fracepsilon_4 - epsilon_Fepsilon_42\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nw_3 = fracV_T4V_G - C fracepsilon_4 - epsilon_Fepsilon_43\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nw_4 = fracV_T4V_G - C\nleft\n4 - left(frac1epsilon_41 + frac1epsilon_42 + frac1epsilon_43right)\n(epsilon_4 - epsilon_F)\nright\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"with","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nC = fracV_T4V_G frac(epsilon_4 - epsilon_F)^3epsilon_41epsilon_42epsilon_43\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"For a fully occupied tetrahedron the contribution for each corner is identical:","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nw_1 = w_2 = w_3 = w_4 = fracV_T4V_G\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"The corresponding correction dw_i to the integration weights has an extremely simple form:","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\ndw_i = sum_T frac140 D_T (epsilon_F) sum^4_j=1 (epsilon_j - epsilon_i)\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"Density of states","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"The contribution of one tetrahedron to the density of states at energy epsilon is given by","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nD_T(epsilon) = 0\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"for epsilon  epsilon_1 and for epsilon_4  epsilon,","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nD_T(epsilon) = fracV_TV_G\nfrac3(epsilon-epsilon_1)^2epsilon_21epsilon_31epsilon_41\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"for epsilon_1  epsilon  epsilon_2,","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nD_T(epsilon) = fracV_TV_G\nfrac1epsilon_31epsilon_41\nleft\n3epsilon_21 + 6(epsilon - epsilon_2)\n- 3frac(epsilon_31 + epsilon_42)(epsilon - epsilon_2)^2epsilon_32epsilon_42\nright\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"for epsilon_2  epsilon  epsilon_3, and","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nD_T(epsilon) = fracV_TV_G\nfrac3(epsilon_4 - epsilon)^2epsilon_41epsilon_42epsilon_43\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"for epsilon_3  epsilon  epsilon_4.","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"References:","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"[1] P. E. Blochl, O. Jepsen, and O. K. Anderson, Phys. Rev. B 49, 16223 (1994)","category":"page"},{"location":"guide/m_tetra.html#Analytical-Tetrahedron-Integration-(Lambin-Vigneron's-Algorithm)","page":"Analytical tetrahedron algorithm","title":"Analytical Tetrahedron Integration (Lambin-Vigneron's Algorithm)","text":"","category":"section"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"In this part we will write up the equations of Lambin and Vigneron for the weight factors used in the analytical tetrahedron method. The purpose of this is to rewrite their formulas in a simpler, more readable and hopefully more stable form.","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"Before we start writing out the equations let us define a few symbols. The external frequency is denoted by z and the energy at corner number i is denoted by epsilon_i.  We define z_i = z-epsilon_i and also epsilon_ij = epsilon_i-epsilon_j.","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"In the general case when all the tetrahedron corners have different energies the equation for the weight factor at corner i is according to LV","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginalign\nr_i\nequiv\n6int_0^1dcint_0^1-cdbint_0^1-b-cda\nfrac(1-a-b-c)delta_i1+adelta_i2+bdelta_i3+cdelta_i4\nz_1-aepsilon_21-bepsilon_31-cepsilon_41 \n=\nfracz_i^2prod_kneq iepsilon_ki+sum_jneq i\nfracz_j^3prod_kneq jepsilon_kj\nfraclogleft(fracz_jz_iright)epsilon_ij\nendalign","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"If we now use the identity:","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\n  0 = sum_i=1^4fracz_i^2prod_jneq i(z_i-z_j) =\n  sum_i=1^4fracz_i^2prod_jneq iepsilon_ji\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"the equation for the weight factor can be written as","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginalign\nr_i\n=\nsum_j neq i\nfracz_j^2prod_k neq jepsilon_kj\nleft\nfracz_jepsilon_ijlogleft(fracz_jz_iright)-1\nright \n=\nsum_j neq i\nfracz_jprod_k neq ijepsilon_kj\nBig\nfracz_jepsilon_ji-\nfracz_j^2epsilon_ij^2logleft(1+fracepsilon_jiz_jright)\nBig \n=\nsum_j neq i\nfracz_jprod_k neq ijepsilon_kjlvleft(fracz_jepsilon_jiright)\nendalign","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"Here we have defined the so called Lambin-Vigneron function as:","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nlv(x) = xleft(1-xlogleft1+frac1xrightright)\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"This is a simple function which is easy to compute and also has the added benefit of having nice asymptotic limits, i.e.","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\n  lim_xrightarrow 0lv(x) = 0\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"and","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\n  lim_xrightarrow inftylv(x) = frac12\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"For considering the cases where the some of the corner energies are identical it is useful to write out the equations above explicitly for each corner:","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginalign\nr_1 =\n fracz_2epsilon_32epsilon_42lvleft(fracz_2epsilon_21right)\n+fracz_3epsilon_23epsilon_43lvleft(fracz_3epsilon_31right)\n+fracz_4epsilon_24epsilon_34lvleft(fracz_4epsilon_41right)\n \nr_2 =\n fracz_1epsilon_31epsilon_41lvleft(fracz_1epsilon_12right)\n+fracz_3epsilon_13epsilon_43lvleft(fracz_3epsilon_32right)\n+fracz_4epsilon_14epsilon_34lvleft(fracz_4epsilon_42right)\n \nr_3 =\n fracz_1epsilon_21epsilon_41lvleft(fracz_1epsilon_13right)\n+fracz_2epsilon_12epsilon_42lvleft(fracz_2epsilon_23right)\n+fracz_4epsilon_14epsilon_24lvleft(fracz_4epsilon_43right)\n \nr_4 =\n fracz_1epsilon_21epsilon_31lvleft(fracz_1epsilon_14right)\n+fracz_2epsilon_12epsilon_32lvleft(fracz_2epsilon_24right)\n+fracz_3epsilon_13epsilon_23lvleft(fracz_3epsilon_34right)\nendalign","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"The next case we consider is when two corners have equal energies and we assume here that the corners have been ordered in such as way that epsilon_1 = epsilon_2.  Looking at the formulas above we see that the limit epsilon_1 rightarrow epsilon_2 is trivial take for the weight factors for corners 1 and 2 but for corners 3 and 4 two terms must be taken together and using Mathematica we get:","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginalign\nr_2 =\n frac12fracz_2epsilon_32epsilon_42\n+fracz_3epsilon_23epsilon_43lvleft(fracz_3epsilon_32right)\n+fracz_4epsilon_24epsilon_34lvleft(fracz_4epsilon_42right)\n \nr_3 =\n fracz_2epsilon_23epsilon_24\n -leftfrac2z_3epsilon_23epsilon_24+fracz_4epsilon_24^2right\n lvleft(fracz_2epsilon_23right)\n+fracz_4epsilon_24^2lvleft(fracz_4epsilon_43right)\n \nr_4 =\n fracz_2epsilon_23epsilon_24\n -leftfrac2z_4epsilon_23epsilon_24+fracz_3epsilon_23^2right\n lvleft(fracz_2epsilon_24right)\n+fracz_3epsilon_23^2lvleft(fracz_3epsilon_34right)\nendalign","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"The next case we consider is epsilon_1 = epsilon_2 and epsilon_4 = epsilon_3 and we see from the formulas in equation (see above) that the limit epsilon_4 rightarrow epsilon_3 is trivial for corners 3 and 4 and the weight factor for corner 2 follows from symmetry. Hence we get:","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginalign\nr_2 =\n fracz_3epsilon_32^2+frac12fracz_2epsilon_32^2\n -3fracz_2epsilon_32^2lvleft(fracz_3epsilon_32right)\n \nr_3 =\n fracz_2epsilon_23^2+frac12fracz_3epsilon_23^2\n -3fracz_3epsilon_23^2lvleft(fracz_2epsilon_23right)\nendalign","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"Next case is epsilon_1 = epsilon_2 = epsilon_3 and this case we can either obtain from the formulas in equation (44) or simply do the corresponding integral which is simple in this case since we have:","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginalign\n  r_3 = int_0^1dcint_0^1-cdbint_0^1-b-cda\n  fracbz_3-cepsilon_43\n  \n  r_4 = int_0^1dcint_0^1-cdbint_0^1-b-cda\n  fraccz_3-cepsilon_43\nendalign","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"Performing these integrals we obtain:","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginalign\nr_3 =\n frac2z_3-5z_46epsilon_34^2+\n fracz_4epsilon_34^2lvleft(fracz_4epsilon_43right) \nr_4 =\n fracz_4epsilon_43^2+frac12fracz_3epsilon_43^2\n -3fracz_3epsilon_43^2lvleft(fracz_4epsilon_43right)\nendalign","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"The final case is of course the simplest one where all the corners have the same energy and in that case we obtain:","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nr_4 = frac14frac1z_4\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"References:","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"[1] Gunnar Palsson, PhD Thesis, Rutgers University (2001)","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"[2] P. Lambin and J. P. Vigneron, Phys. Rev. B 29, 3430 (1984)","category":"page"},{"location":"guide/m_tetra.html#Smearning-algorithm","page":"Analytical tetrahedron algorithm","title":"Smearning algorithm","text":"","category":"section"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"Gaussian smearing","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nn(x) = frac1 - texterfc(-x) 8\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nD(x) = frac14 fracexp(-x^22)sqrtpigamma\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"where x = (z - e)  gamma. gamma is a adjustable parameter, z is the external energy, e is the energy at given k-point and band or corner energies at given tetrahedron.","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"Fermi-Dirac smearing","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nn(x) = frac11 + exp(-x)\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nD(x) = frac12 frac11 + cosh(x)\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"where x = (z - e)  gamma. gamma is a adjustable parameter, z is the external energy, e is the energy at given k-point and band or corner energies at given tetrahedron.","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"Marzari-Vanderbilt cold smearing","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nn(x) = fractexterf(tildex)2 + frac1sqrt2pi\nexp(-tildex^2) + frac12\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"beginequation\nD(x) = frac2sqrtpi\nexp(-tildex^2)( 2 - sqrt2x )\nendequation","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"where x = (z - e)  gamma and tildex = x - frac1sqrt2. gamma is a adjustable parameter, z is the external energy, e is the energy at given k-point and band or corner energies at given tetrahedron.","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"References:","category":"page"},{"location":"guide/m_tetra.html","page":"Analytical tetrahedron algorithm","title":"Analytical tetrahedron algorithm","text":"[1] N. Marzari, D. Vanderbilt, et al., Phys. Rev. Lett. 82, 3296 (1999)","category":"page"},{"location":"guide/s_function.html#Introduction","page":"Special functions","title":"Introduction","text":"","category":"section"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"Provide some subroutines to calculate the special functions.","category":"page"},{"location":"guide/s_function.html#Type","page":"Special functions","title":"Type","text":"","category":"section"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"subroutines","category":"page"},{"location":"guide/s_function.html#Source","page":"Special functions","title":"Source","text":"","category":"section"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"src/s_function.f90","category":"page"},{"location":"guide/s_function.html#Usage","page":"Special functions","title":"Usage","text":"","category":"section"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"(1) Orthogonal polynomial basis.","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"subroutine s_leg_basis(lemax, legrd, lmesh, rep_l)\nsubroutine s_che_basis(chmax, chgrd, cmesh, rep_c)\nsubroutine s_svd_basis(svmax, svgrd, smesh, rep_s, bose, beta)","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"lemax means maximum order for legendre orthogonal polynomial, legrd means number of mesh points for legendre orthogonal polynomial, lmesh means mesh for legendre orthogonal polynomial in [-1,1], rep_l saves legendre orthogonal polynomial defined on [-1,1].","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"chmax means maximum order for chebyshev orthogonal polynomial, chgrd means number of mesh points for chebyshev orthogonal polynomial, cmesh means mesh for chebyshev orthogonal polynomial in [-1,1], rep_c saves chebyshev orthogonal polynomial defined on [-1,1].","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"svmax means maximum order for svd orthogonal polynomial, svgrd means number of mesh points for svd orthogonal polynomial, smesh means mesh for svd orthogonal polynomial in [-1,1], rep_s saves svd orthogonal polynomial defined on [-1,1], bose determines whether the bosonic kernel is used, beta means inverse system temperature beta.","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"(2) Spheric Bessel function.","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"subroutine s_sph_jl(lmax, x, jl)","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"It computes the spherical Bessel functions of the first kind, j_l(x), for argument x and l = 0 1 ldots l_max.","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"(3) Bernstein polynomial.","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"subroutine s_bezier(n, x, bern)","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"n means the degree of the bernstein polynomials to be used. For any given n, there is a set of n + 1 bernstein polynomials, each of degree n, which form a basis for polynomials on [0,1]. x means the evaluation point. bern saves the values of the n+1 bernstein polynomials at x.","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"(4) Some helper functions for s_svd_basis().","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"function s_safe_exp(x)","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"It is a safe exp call to avoid data overflow.","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"function s_f_kernel(tau, omega, beta)\nfunction s_b_kernel(tau, omega, beta)","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"They are used to calculate fermionic or bosonic kernel functions. tau means tau, omega means omega, beta means inverse system temperature beta.","category":"page"},{"location":"guide/s_function.html#Theory","page":"Special functions","title":"Theory","text":"","category":"section"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"Legendre orthogonal polynomial","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"The Legendre orthogonal polynomials obey the three term recurrence relation, known as Bonnets recursion formula:","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"beginequation\nP_0(x) = 1\nendequation","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"beginequation\nP_1(x) = x\nendequation","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"beginequation\n(n+1) P_n+1(x) = (2n+1) P_n(x) - n P_n-1(x)\nendequation","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"Chebyshev orthogonal polynomial","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"The Chebyshev orthogonal polynomials of the second kind can be defined by the following recurrence relation:","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"beginequation\nU_0(x) = 1\nendequation","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"beginequation\nU_1(x) = 2x\nendequation","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"beginequation\nU_n+1(x) = 2xU_n(x) - U_n-1(x)\nendequation","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"SVD orthogonal polynomial","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"In the imaginary-frequency domain, the Lehmann representation reads,","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"beginequation\nG(inu) = int_-infty^infty domega\nunderbracefrac1inu - omega_equiv K(inu omega)\nA(omega)\nendequation","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"where A(omega) is a spectral function. K(inuomega) is the so-called analytic continuation kernel. The Lehmann representation can be transformed to the imaginary-time domain as","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"beginequation\nG(tau) = -int_-infty^infty\ndomega K(tauomega) A(omega)\nendequation","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"where 0  tau  beta and","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"beginequation\nK(tauomega) equiv\n-frac1beta sum_inu e^-inu tau K(inuomega)=\nbegincases\n    frace^-tauomega1+e^-betaomega  (mathrmfermion)\n    frace^-tauomega1-e^-betaomega  (mathrmboson)\nendcases\nendequation","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"The minus sign originates from our convention K(tau omega)  0. To avoid the divergence of the bosonic kernel at omega=0, we reformulate Equation of G(tau) as","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"beginequation\nG(tau)= -int_-infty^infty domega\nK^mathrmL(tauomega) rho(omega)\nendequation","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"where K^mathrmL(tauomega) is the logistic kernel defined as","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"K^mathrmL(tauomega) =\nfrace^-tauomega1+e^-betaomega","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"and rho(omega) is the modified spectral function","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"beginequation\nrho(omega) equiv\nbegincases\n    A(omega)  (mathrmfermion)\n    fracA(omega)tanh(beta omega2)  (mathrmboson)\nendcases\nendequation","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"The singular value expnasion of the kernel reads","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"beginequation\nK^mathrmL(tau omega) = sum_l=0^infty U_l(tau) S_l V_l(omega)\nendequation","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"for omega in -omega_max omega_max with omega_max ( 0) being a cut-off frequency. U_l(tau) and V_l(omega) are left and right singular functions and S_l is the singular values (with S_0S_1S_20). The two sets of singular functions U and V make up the basis functions of the so-called Intermediate Representation (IR), which depends on beta and the cutoff omega_max. For the peculiar choice of the regularization for the bosonic kernel using K^mathrmL, these basis functions do not depend on statistical properties. The basis functions U_l(tau) are transformed to the imaginary-frequency axis as","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"U_l(inu) equiv int_0^beta d tau e^inutau U_l(tau)","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"Some of the information regarding real-frequency properties of the system is often lost during transition into the imaginary-time domain, so that the imaginary-frequency Green's function does hold less information than the real-frequency Green's function. The reason for using IR lies within its compactness and ability to display that information in imaginary quantities.","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"The decay of the singular values depends on beta and omega_max only through the dimensionless parameter Lambda equiv betaomega_max.","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"Spheric Bessel function","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"The following recursion relation","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"beginequation\nj_l+1(x)=frac2l+1xj_l(x)-j_l-1(x)\nendequation","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"is used either downwards for x  l or upwards for x ge l. For x ll 1, the following asymtotic form is used:","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"beginequation\nj_l(x) approx fracx^l(2l+1)\nendequation","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"This procedure is numerically stable and accurate to near this machine precision for l le 50.","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"Bernstein polynomial","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"The bernstein polynomials are assumed to be based on [0,1]. The formula reads:","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"beginequation\nB(NI)(X) = fracNI(N-I) (1-X)^(N-I) X^I\nendequation","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"First values:","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"B(0,0)(X) = 1\nB(1,0)(X) =      1-X\nB(1,1)(X) =                X\nB(2,0)(X) =     (1-X)**2\nB(2,1)(X) = 2 * (1-X)    * X\nB(2,2)(X) =                X**2\nB(3,0)(X) =     (1-X)**3\nB(3,1)(X) = 3 * (1-X)**2 * X\nB(3,2)(X) = 3 * (1-X)    * X**2\nB(3,3)(X) =                X**3\nB(4,0)(X) =     (1-X)**4\nB(4,1)(X) = 4 * (1-X)**3 * X\nB(4,2)(X) = 6 * (1-X)**2 * X**2\nB(4,3)(X) = 4 * (1-X)    * X**3\nB(4,4)(X) =                X**4","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"Special values:","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"B(N,I)(X) has a unique maximum value at X = I/N.\nB(N,I)(X) has an I-fold zero at 0 and and N-I fold zero at 1.\nFor X = 1/2,","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"B(NI)(12) = fracC(NK)2^N","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"For a fixed X and N, the polynomials add up to 1:","category":"page"},{"location":"guide/s_function.html","page":"Special functions","title":"Special functions","text":"sum_I=0^N B(NI)(X) = 1","category":"page"},{"location":"guide/s_fourier.html#Introduction","page":"Fourier transformation","title":"Introduction","text":"","category":"section"},{"location":"guide/s_fourier.html","page":"Fourier transformation","title":"Fourier transformation","text":"Support forward and backward fourier transformation. We usually use the following subroutines to perform fourier transformation for the Green's function.","category":"page"},{"location":"guide/s_fourier.html#Type","page":"Fourier transformation","title":"Type","text":"","category":"section"},{"location":"guide/s_fourier.html","page":"Fourier transformation","title":"Fourier transformation","text":"subroutines","category":"page"},{"location":"guide/s_fourier.html#Source","page":"Fourier transformation","title":"Source","text":"","category":"section"},{"location":"guide/s_fourier.html","page":"Fourier transformation","title":"Fourier transformation","text":"src/s_fourier.f90","category":"page"},{"location":"guide/s_fourier.html#Usage","page":"Fourier transformation","title":"Usage","text":"","category":"section"},{"location":"guide/s_fourier.html","page":"Fourier transformation","title":"Fourier transformation","text":"(1) Forward FFT, from G(tau) to G(iomega_n).","category":"page"},{"location":"guide/s_fourier.html","page":"Fourier transformation","title":"Fourier transformation","text":"subroutine s_fft_forward(ntime, tmesh, ftau, mfreq, rmesh, fmat)","category":"page"},{"location":"guide/s_fourier.html","page":"Fourier transformation","title":"Fourier transformation","text":"(2) Backward FFT, from G(iomega_n) to G(tau).","category":"page"},{"location":"guide/s_fourier.html","page":"Fourier transformation","title":"Fourier transformation","text":"subroutine s_fft_backward(mfreq, rmesh, fmat, ntime, tmesh, ftau, beta)","category":"page"},{"location":"guide/s_fourier.html","page":"Fourier transformation","title":"Fourier transformation","text":"Here, ntime is number of imaginary time points, tmesh means tau, ftau means G(tau), mfreq is number of Matsubara frequency points, rmesh means omega_n, fmat means G(iomega_n), beta means inverse temperature of system beta.","category":"page"},{"location":"guide/s_fourier.html","page":"Fourier transformation","title":"Fourier transformation","text":"note: Note\nThe s_fft_tails() subroutine is called by the s_fft_backward() subroutine internally. DO NOT call it directly!","category":"page"},{"location":"appendix/make.html#Introduction","page":"make.inc","title":"Introduction","text":"","category":"section"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"The make.inc file is the key component of the building system. You have to modify it to fulfill your requirements. If it is not configured correctly, the building system won't work correctly as well. So in the following we would like to provide a detailed explanations for it.","category":"page"},{"location":"appendix/make.html#Prerequisites","page":"make.inc","title":"Prerequisites","text":"","category":"section"},{"location":"appendix/make.html#Operation-system","page":"make.inc","title":"Operation system","text":"","category":"section"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"Linux\nmacOS","category":"page"},{"location":"appendix/make.html#Fortran-compiler","page":"make.inc","title":"Fortran compiler","text":"","category":"section"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"Intel Fortran Compiler","category":"page"},{"location":"appendix/make.html#Linear-algebra-library","page":"make.inc","title":"Linear algebra library","text":"","category":"section"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"Apple Accelerate framework\nReference implementations for BLAS and LAPACK at Netlib\nIntel Math Kernel Library","category":"page"},{"location":"appendix/make.html#MPI-environment","page":"make.inc","title":"MPI environment","text":"","category":"section"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"MPICH\nOpenmpi","category":"page"},{"location":"appendix/make.html#OpenMP-environment","page":"make.inc","title":"OpenMP environment","text":"","category":"section"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"(Optional)","category":"page"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"Though it is not mandatory, we still strongly recommend to update the above software components on your systems to the latest versions. The OpenMP environment is optional.","category":"page"},{"location":"appendix/make.html#Explanations","page":"make.inc","title":"Explanations","text":"","category":"section"},{"location":"appendix/make.html#F90","page":"make.inc","title":"F90","text":"","category":"section"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"The Fortran compiler. Both the parallel and sequential Fortran compilers are supported. Note that only the Intel Fortran compiler was extensively tested. And we recommend to use the very latest version of Intel Fortran compiler (i.e, Intel Parallel Studio 2019).","category":"page"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"Possible options:","category":"page"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"mpif90\nmpifort\nmpiifort\nifort","category":"page"},{"location":"appendix/make.html#LINKER","page":"make.inc","title":"LINKER","text":"","category":"section"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"Linker. Here it should be the same with the Fortran compiler. Do not change it.","category":"page"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"Possible options:","category":"page"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"$(F90)","category":"page"},{"location":"appendix/make.html#ARCHIVER","page":"make.inc","title":"ARCHIVER","text":"","category":"section"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"Archiver. It is used to pack the binary objects into a library. Do not modify it for ever.","category":"page"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"Possible options:","category":"page"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"ar -ruv","category":"page"},{"location":"appendix/make.html#MPI","page":"make.inc","title":"MPI","text":"","category":"section"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"Specify whether MPI is enable. If you want to compile a sequential code, please comment it out with '#' symbol and then setup F90 to 'ifort'. We strongly suggest to compile the MPI parallelized codes.","category":"page"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"Possible options:","category":"page"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"-DMPI","category":"page"},{"location":"appendix/make.html#OMP","page":"make.inc","title":"OMP","text":"","category":"section"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"Specify whether OpenMP is enable. If you want to disable it, please comment it out. In default it is disabled. So far the OpenMP was used to speedup the measurements of some selected two-particle quantities.","category":"page"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"Possible options:","category":"page"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"-qopenmp","category":"page"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"If you are using old version Intel Fortran compiler, this option may be '-openmp'.","category":"page"},{"location":"appendix/make.html#FPP","page":"make.inc","title":"FPP","text":"","category":"section"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"Specify whether the Fortran preprocessor (FPP) is used. It has to be enabled or else the source codes can not be compiled correctly.","category":"page"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"Possible options:","category":"page"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"-fpp","category":"page"},{"location":"appendix/make.html#CPP","page":"make.inc","title":"CPP","text":"","category":"section"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"Collection of preprocessor directives. Do not modify it unless you are an expert.","category":"page"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"Possible options:","category":"page"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"$(FPP)\n$(MPI)\n$(OMP)","category":"page"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"Please make sure that the '$(FPP)' option is always present.","category":"page"},{"location":"appendix/make.html#CHECK","page":"make.inc","title":"CHECK","text":"","category":"section"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"Used to specify what types of check should be done.","category":"page"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"Possible options:","category":"page"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"-nogen-interfaces\n-warn all\n-check all\n-traceback\n-g","category":"page"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"The '-nogen-interfaces' option ask the compiler to do not generate an interface block for each routine defined in the source file. The '-warn all' option means the check is done in compiling. The '-check all' option means the check will be done in running. The '-traceback' option enables us to track the exact position (line number and file name) where an error occurs. The '-g' option enables the compiler to generate debug information and embed them into the final program. Note that all of the '-check all', '-traceback', and '-g' options will decrease the efficiency greatly.","category":"page"},{"location":"appendix/make.html#MTUNE","page":"make.inc","title":"MTUNE","text":"","category":"section"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"Collection of optimization options.","category":"page"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"Possible options:","category":"page"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"-O3\n-xHost","category":"page"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"The '-O3' option means the highest optimization. The '-xHost' option enables the compiler to try to generate the most suitable code for the current computer architecture.","category":"page"},{"location":"appendix/make.html#FFLAGS","page":"make.inc","title":"FFLAGS","text":"","category":"section"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"Collection of Fortran compiler options. Do not modify them for ever.","category":"page"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"Possible options:","category":"page"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"-c\n$(CPP)\n$(CHECK)\n$(MTUNE)","category":"page"},{"location":"appendix/make.html#LFLAGS","page":"make.inc","title":"LFLAGS","text":"","category":"section"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"Collection of linker options. Do not modify them unless you know what you are doing.","category":"page"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"Possible options:","category":"page"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"$(OMP)\n-Wl,-no_pie","category":"page"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"The '-Wl,-no_pie' option is useful when you are using the macOS system and want to traceback the code (the -traceback option is applied). If you are using the Linux system, you can skip it.","category":"page"},{"location":"appendix/make.html#LIBS","page":"make.inc","title":"LIBS","text":"","category":"section"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"Specify the external libraries. Now the this software package depends on LAPACK and BLAS heavily. To achieve good performance, the highly optimized LAPACK and BLAS implementations are essential.","category":"page"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"Possible options:","category":"page"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"-framework Accelerate\n-L/home/lihuang/lapack -llapack -lblas\n-L/opt/intel/mkl/lib -lmklcore -lmklsequential -lmkl_rt","category":"page"},{"location":"appendix/make.html","page":"make.inc","title":"make.inc","text":"Here we provide three typical choices. (1) In the macOS system, we can use the Apple Accelerate framework. (2) We use the home-built BLAS and LAPACK libraries. Please pay attention to the path. You have to modify it to meet your software environment. (3) We link our codes with the Intel MKL. Please pay attention to the path and the library's name. You have to modify them to meet your software environment. Please see the documentation about Intel MKL for more details.","category":"page"},{"location":"guide/m_sparse.html#Introduction","page":"Sparse matrix","title":"Introduction","text":"","category":"section"},{"location":"guide/m_sparse.html","page":"Sparse matrix","title":"Sparse matrix","text":"In this module, we implement some basic sparse matrix algebra. Now it supports both double precision real and complex numbers. The internal format of sparse matrix used in this module is CSR (compressed sparse row) format.","category":"page"},{"location":"guide/m_sparse.html#Type","page":"Sparse matrix","title":"Type","text":"","category":"section"},{"location":"guide/m_sparse.html","page":"Sparse matrix","title":"Sparse matrix","text":"module","category":"page"},{"location":"guide/m_sparse.html#Source","page":"Sparse matrix","title":"Source","text":"","category":"section"},{"location":"guide/m_sparse.html","page":"Sparse matrix","title":"Sparse matrix","text":"src/m_sparse.f90","category":"page"},{"location":"guide/m_sparse.html#Usage","page":"Sparse matrix","title":"Usage","text":"","category":"section"},{"location":"guide/m_sparse.html","page":"Sparse matrix","title":"Sparse matrix","text":"(1) Import sparse module support.","category":"page"},{"location":"guide/m_sparse.html","page":"Sparse matrix","title":"Sparse matrix","text":"use sparse","category":"page"},{"location":"guide/m_sparse.html","page":"Sparse matrix","title":"Sparse matrix","text":"(2) Convert normal matrix to sparse matrix.","category":"page"},{"location":"guide/m_sparse.html","page":"Sparse matrix","title":"Sparse matrix","text":"call sp_dns_to_csr(...)","category":"page"},{"location":"guide/m_sparse.html","page":"Sparse matrix","title":"Sparse matrix","text":"(3) Convert sparse matrix to normal matrix.","category":"page"},{"location":"guide/m_sparse.html","page":"Sparse matrix","title":"Sparse matrix","text":"call sp_csr_to_dns(...)","category":"page"},{"location":"guide/m_sparse.html","page":"Sparse matrix","title":"Sparse matrix","text":"(4) Perform sparse matrix - vector multiplication.","category":"page"},{"location":"guide/m_sparse.html","page":"Sparse matrix","title":"Sparse matrix","text":"call sp_csr_mv_vec(...)","category":"page"},{"location":"guide/m_sparse.html","page":"Sparse matrix","title":"Sparse matrix","text":"(5) Perform sparse matrix - matrix multiplication.","category":"page"},{"location":"guide/m_sparse.html","page":"Sparse matrix","title":"Sparse matrix","text":"call sp_csr_mm_csr(...)","category":"page"},{"location":"guide/m_sparse.html","page":"Sparse matrix","title":"Sparse matrix","text":"Specifically, if one of the matrix is diagonal matrix, then you can use","category":"page"},{"location":"guide/m_sparse.html","page":"Sparse matrix","title":"Sparse matrix","text":"call sp_dia_mm_csr(...)","category":"page"},{"location":"guide/m_sparse.html","page":"Sparse matrix","title":"Sparse matrix","text":"or","category":"page"},{"location":"guide/m_sparse.html","page":"Sparse matrix","title":"Sparse matrix","text":"call sp_csr_mm_dia(...)","category":"page"},{"location":"guide/m_sparse.html","page":"Sparse matrix","title":"Sparse matrix","text":"to accelerate the execution.","category":"page"},{"location":"guide/m_linkedlist.html#Introduction","page":"Linked list","title":"Introduction","text":"","category":"section"},{"location":"guide/m_linkedlist.html","page":"Linked list","title":"Linked list","text":"note: Note\nThis implementation of generic linked list in Fortran 90 was taken fromJason R. Blevins's code\njournal: ACM Fortran Forum 28(3), 2-7, 2009.\nwebsite: http://jblevins.org/research/generic-list.Of course, we have adapted the original code to fulfill our requirement.","category":"page"},{"location":"guide/m_linkedlist.html","page":"Linked list","title":"Linked list","text":"This linked list is capable of storing data of an any type by using the generic programming techniques.","category":"page"},{"location":"guide/m_linkedlist.html#Type","page":"Linked list","title":"Type","text":"","category":"section"},{"location":"guide/m_linkedlist.html","page":"Linked list","title":"Linked list","text":"module","category":"page"},{"location":"guide/m_linkedlist.html#Source","page":"Linked list","title":"Source","text":"","category":"section"},{"location":"guide/m_linkedlist.html","page":"Linked list","title":"Linked list","text":"src/m_linkedlist.f90","category":"page"},{"location":"guide/m_linkedlist.html#Usage","page":"Linked list","title":"Usage","text":"","category":"section"},{"location":"guide/m_linkedlist.html","page":"Linked list","title":"Linked list","text":"(1) Include linked list module support.","category":"page"},{"location":"guide/m_linkedlist.html","page":"Linked list","title":"Linked list","text":"use linkedlist","category":"page"},{"location":"guide/m_linkedlist.html","page":"Linked list","title":"Linked list","text":"(2) Define user own data type.","category":"page"},{"location":"guide/m_linkedlist.html","page":"Linked list","title":"Linked list","text":"type data_t\n     ! place your definition here\nend type data_t","category":"page"},{"location":"guide/m_linkedlist.html","page":"Linked list","title":"Linked list","text":"(3) Define pointer to data.","category":"page"},{"location":"guide/m_linkedlist.html","page":"Linked list","title":"Linked list","text":"type (data_t), pointer  :: data_ptr => null()","category":"page"},{"location":"guide/m_linkedlist.html","page":"Linked list","title":"Linked list","text":"(4) Define pointer to list.","category":"page"},{"location":"guide/m_linkedlist.html","page":"Linked list","title":"Linked list","text":"type (list_t), pointer  :: list_ptr => null()","category":"page"},{"location":"guide/m_linkedlist.html","page":"Linked list","title":"Linked list","text":"(5) Prepare data.","category":"page"},{"location":"guide/m_linkedlist.html","page":"Linked list","title":"Linked list","text":"allocate(data_ptr)\ndata_ptr%something = something","category":"page"},{"location":"guide/m_linkedlist.html","page":"Linked list","title":"Linked list","text":"(6) Create a linked list.","category":"page"},{"location":"guide/m_linkedlist.html","page":"Linked list","title":"Linked list","text":"call list_init(list_ptr, transfer(data_ptr, list_d))","category":"page"},{"location":"guide/m_linkedlist.html","page":"Linked list","title":"Linked list","text":"Here list_d is a public variable defined in linkedlist module.","category":"page"},{"location":"guide/m_linkedlist.html","page":"Linked list","title":"Linked list","text":"note: Note\nTo access the data stored in the nodes, we have to use the intrinsic transfer() subroutine.","category":"page"},{"location":"guide/m_linkedlist.html","page":"Linked list","title":"Linked list","text":"(7) Insert new node.","category":"page"},{"location":"guide/m_linkedlist.html","page":"Linked list","title":"Linked list","text":"call list_insert(list_ptr, transfer(data_ptr, list_d))","category":"page"},{"location":"guide/m_linkedlist.html","page":"Linked list","title":"Linked list","text":"list_insert() will always insert the new node after the given node, i.e., list_ptr. If you want to update the data for the given node, please use the following code:","category":"page"},{"location":"guide/m_linkedlist.html","page":"Linked list","title":"Linked list","text":"call list_put(list_ptr, transfer(data_ptr, list_d))","category":"page"},{"location":"guide/m_linkedlist.html","page":"Linked list","title":"Linked list","text":"(8) Visit next node.","category":"page"},{"location":"guide/m_linkedlist.html","page":"Linked list","title":"Linked list","text":"curr => list_next(curr)","category":"page"},{"location":"guide/m_linkedlist.html","page":"Linked list","title":"Linked list","text":"Here curr is a list_t type pointer.","category":"page"},{"location":"guide/m_linkedlist.html","page":"Linked list","title":"Linked list","text":"(9) Retrieve data stored in the node.","category":"page"},{"location":"guide/m_linkedlist.html","page":"Linked list","title":"Linked list","text":"data_ptr  = transfer(list_get(curr), data_ptr)\nsomething = data_ptr%something","category":"page"},{"location":"guide/m_linkedlist.html","page":"Linked list","title":"Linked list","text":"Here curr is a list_t type pointer, it points to the current node.","category":"page"},{"location":"guide/m_linkedlist.html","page":"Linked list","title":"Linked list","text":"(10) Free memory for this linked list.","category":"page"},{"location":"guide/m_linkedlist.html","page":"Linked list","title":"Linked list","text":"call list_free(list_ptr)","category":"page"},{"location":"usage.html","page":"Basic usage","title":"Basic usage","text":"It is quite easy to use the Flink library.","category":"page"},{"location":"usage.html","page":"Basic usage","title":"Basic usage","text":"Step 1","category":"page"},{"location":"usage.html","page":"Basic usage","title":"Basic usage","text":"At first, please look at the user's guide to learn how to call the Flink's subroutines and functions. Notice that some subroutines are encapsulated in various modules, while the others are not.","category":"page"},{"location":"usage.html","page":"Basic usage","title":"Basic usage","text":"Step 2","category":"page"},{"location":"usage.html","page":"Basic usage","title":"Basic usage","text":"Second, modify your source codes carefully.","category":"page"},{"location":"usage.html","page":"Basic usage","title":"Basic usage","text":"Step 3","category":"page"},{"location":"usage.html","page":"Basic usage","title":"Basic usage","text":"Third, if your codes are using some modules of the Flink library, please copy the corresponding *.mod files to your working directory. For example, if your codes need the module spring which is defined in the src/s_spring.f90 file, please copy the spring.mod file to your directory or add it to the INCLUDE_PATH.","category":"page"},{"location":"usage.html","page":"Basic usage","title":"Basic usage","text":"Step 4","category":"page"},{"location":"usage.html","page":"Basic usage","title":"Basic usage","text":"Fourth, modify your Makefile. Notify the linker to link libflink.a to your program. You can use the following syntax:","category":"page"},{"location":"usage.html","page":"Basic usage","title":"Basic usage","text":"$ ifort your_code.f90 -Lpath_to_libflink -lflink -o your_code.x","category":"page"},{"location":"guide/s_spline.html#Introduction","page":"Spline interpolation","title":"Introduction","text":"","category":"section"},{"location":"guide/s_spline.html","page":"Spline interpolation","title":"Spline interpolation","text":"These subroutines are used to perform spline interpolation.","category":"page"},{"location":"guide/s_spline.html#Type","page":"Spline interpolation","title":"Type","text":"","category":"section"},{"location":"guide/s_spline.html","page":"Spline interpolation","title":"Spline interpolation","text":"subroutines","category":"page"},{"location":"guide/s_spline.html#Source","page":"Spline interpolation","title":"Source","text":"","category":"section"},{"location":"guide/s_spline.html","page":"Spline interpolation","title":"Spline interpolation","text":"src/s_spline.f90","category":"page"},{"location":"guide/s_spline.html#Usage","page":"Spline interpolation","title":"Usage","text":"","category":"section"},{"location":"guide/s_spline.html","page":"Spline interpolation","title":"Spline interpolation","text":"(1) Calculate 1-order derivates for a given function.","category":"page"},{"location":"guide/s_spline.html","page":"Spline interpolation","title":"Spline interpolation","text":"subroutine s_spl_deriv1(ydim, xval, yval, d1y)","category":"page"},{"location":"guide/s_spline.html","page":"Spline interpolation","title":"Spline interpolation","text":"     ! dimension of xval and yval\n     integer, intent(in)   :: ydim\n\n     ! old knots\n     real(dp), intent(in)  :: xval(ydim)\n\n     ! old function values to be interpolated\n     real(dp), intent(in)  :: yval(ydim)\n\n     ! 1-order derivates\n     real(dp), intent(out) :: d1y(ydim)","category":"page"},{"location":"guide/s_spline.html","page":"Spline interpolation","title":"Spline interpolation","text":"(2) Calculate 2-order derivates for a given function.","category":"page"},{"location":"guide/s_spline.html","page":"Spline interpolation","title":"Spline interpolation","text":"subroutine s_spl_deriv2(ydim, xval, yval, startu, startd, d2y)","category":"page"},{"location":"guide/s_spline.html","page":"Spline interpolation","title":"Spline interpolation","text":"     ! dimension of xval and yval\n     integer, intent(in)   :: ydim\n\n     ! first-derivate at point 1\n     real(dp), intent(in)  :: startu\n\n     ! first-derivate at point ydim\n     real(dp), intent(in)  :: startd\n\n     ! old knots\n     real(dp), intent(in)  :: xval(ydim)\n\n     ! old function values to be interpolated\n     real(dp), intent(in)  :: yval(ydim)\n\n     ! 2-order derivates\n     real(dp), intent(out) :: d2y(ydim)","category":"page"},{"location":"guide/s_spline.html","page":"Spline interpolation","title":"Spline interpolation","text":"(3) Evaluate function value at a given point.","category":"page"},{"location":"guide/s_spline.html","page":"Spline interpolation","title":"Spline interpolation","text":"function s_spl_funct(xdim, xval, yval, d2y, x)","category":"page"},{"location":"guide/s_spline.html","page":"Spline interpolation","title":"Spline interpolation","text":"     ! dimension of xval and yval\n     integer, intent(in)  :: xdim\n\n     ! new mesh point\n     real(dp), intent(in) :: x\n\n     ! old mesh\n     real(dp), intent(in) :: xval(xdim)\n\n     ! old function value\n     real(dp), intent(in) :: yval(xdim)\n\n     ! 2-order derviates of old function\n     real(dp), intent(in) :: d2y(xdim)","category":"page"},{"location":"guide/m_parser.html#Introduction","page":"Configuration parser","title":"Introduction","text":"","category":"section"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"The original input file format for iQIST is not very good. We need a flexible, convenient, and powerful input file format, and corresponding file reader and parser. Thus, we redesign the input file format and implement this configuration parser.","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"note: Note\nThis module depends on the linkedlist module internally.","category":"page"},{"location":"guide/m_parser.html#Type","page":"Configuration parser","title":"Type","text":"","category":"section"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"module","category":"page"},{"location":"guide/m_parser.html#Source","page":"Configuration parser","title":"Source","text":"","category":"section"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"src/m_parser.f90","category":"page"},{"location":"guide/m_parser.html#Input-File-Format","page":"Configuration parser","title":"Input File Format","text":"","category":"section"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"(1) Anything after \"#\" and \"!\" character can be treated as comments and will be ignored completely.","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"Example:","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"   # this is a comment line\n   ! this is a comment line\n\n   nband = 4 # this is in line comment\n   norbs = 8 ! this is in line comment","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"(2) It is not case sensitive.","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"Example:","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"   Nband = 4\n   NORBS = 8\n   NspiN = 2","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"(3) The key and value pair is separated by \"=\" or \":\" character.","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"Example:","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"   nband = 4 ! you can use nband : 4\n   norbs : 8 ! you can use norbs = 8","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"(4) Any space will be ignored. Any blank lines will be skipped as well.","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"Example:","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"   n b a n d = 4 ! it is valid\n   no   rb s = 8 ! it is valid","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"(5) You can only use one line to define one key-value pair.","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"Example:","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"   nband = 4 norbs = 8  ! it is not valid\n   nband = 4, norbs = 8 ! it is not valid\n   nband = 4; norbs = 8 ! it is not valid\n   nband =              !\n   4                    ! it is not valid","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"(6) In the value part, now only integer, real(dp), logical, and character data type are support.","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"Example:","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"   nband = 4        ! integer type\n   mune  = 4.0      ! real(dp) type\n   isscf = .true.   ! logical type, you can also use .false., T, F\n   model = anderson ! character type, do not use \"\" or '' characters to quote it","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"(7) In the value part, a vector is also support. the items in the vector should be separated by \",\" character.","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"Example:","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"   nband = 1, 2, 3, 4                   ! 4 items\n   mune = 0.0, -1.0, 2.0                ! 3 items\n   isscf = .true., .true., F, T, .true. ! 5 items\n   model = anderson, hubbard            ! 2 items","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"(8) An empty input file is acceptable.","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"(9) If one key occurs in the input file for more than 1 times, only the last occurrence is recognized.","category":"page"},{"location":"guide/m_parser.html#Usage","page":"Configuration parser","title":"Usage","text":"","category":"section"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"(1) Import parser module support.","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"use parser","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"(2) Create instance for parser.","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"call p_create()","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"(3) Parse the input file.","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"call p_parse(file_name)","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"warning: Warning\nIn the mpi environment, only the master node can execute this command. You should broadcast the data manually.","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"(4) Extract parameters.","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"integer :: nband = 2            ! default value\nreal(dp) :: mune = 10.0_dp      ! default value\nlogical :: symm(2)              ! default value\nsymm(1) = .true.\nsymm(2) = .false.\ncall p_get('nband', nband)      ! get single value\ncall p_get('mune', mune)        ! get single value\ncall p_get_vec('symm', symm, 2) ! get array","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"note: Note\nThat if the desired parameter is not contained in the config file, then the default value will not be changed.In the mpi environment, only the master node can execute these commands.The parser DO NOT check the correctness (including number of values, key's name, and datatype of value) of the input file. So, please always monitor the output of ctqmc code which use this parser to parse the input file.","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"(5) Destroy parser.","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"call p_destroy()","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"(6) Broadcast the parameters read from input file.","category":"page"},{"location":"guide/m_parser.html","page":"Configuration parser","title":"Configuration parser","text":"Do not forget to broadcast all of the parameters from master node to children nodes.","category":"page"},{"location":"guide/m_constants.html#Introduction","page":"Constants","title":"Introduction","text":"","category":"section"},{"location":"guide/m_constants.html","page":"Constants","title":"Constants","text":"It is a common module which defines some common used numerical or physical constants. They are as follows:","category":"page"},{"location":"guide/m_constants.html","page":"Constants","title":"Constants","text":"Numerical precision: sp, dp\nFile units: mystd, myout, mytmp\nNumerical constants (real number): pi, zero, one, two, half\nNumerical constants (small number): eps6, eps8, epst, epss\nNumerical constants (complex number): czi, cone, czero\nPhysical constants: ev2k, ry2e, ha2e","category":"page"},{"location":"guide/m_constants.html","page":"Constants","title":"Constants","text":"We always need to import this module.","category":"page"},{"location":"guide/m_constants.html#Type","page":"Constants","title":"Type","text":"","category":"section"},{"location":"guide/m_constants.html","page":"Constants","title":"Constants","text":"module","category":"page"},{"location":"guide/m_constants.html#Source","page":"Constants","title":"Source","text":"","category":"section"},{"location":"guide/m_constants.html","page":"Constants","title":"Constants","text":"src/m_constants.f90","category":"page"},{"location":"guide/m_constants.html#Usage","page":"Constants","title":"Usage","text":"","category":"section"},{"location":"guide/m_constants.html","page":"Constants","title":"Constants","text":"(1) Import constants module completely.","category":"page"},{"location":"guide/m_constants.html","page":"Constants","title":"Constants","text":"program test\n    use constants\n\n    implicit none\n\n    real(dp) :: A\n    A = one\nend program test","category":"page"},{"location":"guide/m_constants.html","page":"Constants","title":"Constants","text":"(2) Import constants module partially.","category":"page"},{"location":"guide/m_constants.html","page":"Constants","title":"Constants","text":"program test\n    use constants, only : dp\n    use constants, only : one\n\n    implicit none\n\n    real(dp) :: A\n    A = one\nend program test","category":"page"},{"location":"index.html#Flink","page":"Home","title":"Flink","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"A collection of Fortran modules and subroutines for scientific computing.","category":"page"},{"location":"index.html#Reference-Manual-Outline","page":"Home","title":"Reference Manual Outline","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Introduction\nInstallation\nBasic usage\nUser's guide\nConstants\nLinked list\nMessage passing interface\nConfiguration parser\nSparse matrix\nPseudorandom number generator\nStack\nAnalytical tetrahedron algorithm\nError and exception\nFourier transformation\nSpecial functions\nIntegration\nMatrix\nSpline interpolation\nUtility\nVector\nAppendix\nmake.inc\nFAQ","category":"page"},{"location":"guide/m_stack.html#Introduction","page":"Stack","title":"Introduction","text":"","category":"section"},{"location":"guide/m_stack.html","page":"Stack","title":"Stack","text":"In this module, we implement two types of stack, istack and gstack. The istack type was designed to deal with integer numbers only. However, gstack is a generic type stack. More specifically, it supports the following four data types:","category":"page"},{"location":"guide/m_stack.html","page":"Stack","title":"Stack","text":"integer,\nlogical,\nreal(dp),\ncomplex(dp).","category":"page"},{"location":"guide/m_stack.html","page":"Stack","title":"Stack","text":"The usages and subroutine's parameters for these two stack types are almost identical. To implement the gstack type, we generally use the unlimited polymorphic features in Fortran 2003/2008 standard. Noted that not all Fortran compilers can support these features. This module was tested using Intel Fortran compiler only. We do not guarantee it can work/be compiled correctly for using the other Fortran compilers. So please use it carefully. In the iQIST project, so far we only use the istack type. However, in the future, we will turn to the gstack type.","category":"page"},{"location":"guide/m_stack.html#Type","page":"Stack","title":"Type","text":"","category":"section"},{"location":"guide/m_stack.html","page":"Stack","title":"Stack","text":"module","category":"page"},{"location":"guide/m_stack.html#Source","page":"Stack","title":"Source","text":"","category":"section"},{"location":"guide/m_stack.html","page":"Stack","title":"Stack","text":"src/m_stack.f90","category":"page"},{"location":"guide/m_stack.html#Usage","page":"Stack","title":"Usage","text":"","category":"section"},{"location":"guide/m_stack.html","page":"Stack","title":"Stack","text":"(1) Import stack module support.","category":"page"},{"location":"guide/m_stack.html","page":"Stack","title":"Stack","text":"use stack","category":"page"},{"location":"guide/m_stack.html","page":"Stack","title":"Stack","text":"(2) Declare stack type.","category":"page"},{"location":"guide/m_stack.html","page":"Stack","title":"Stack","text":"type (istack) :: is\ntype (gstack) :: gs","category":"page"},{"location":"guide/m_stack.html","page":"Stack","title":"Stack","text":"(3) Create stack struct.","category":"page"},{"location":"guide/m_stack.html","page":"Stack","title":"Stack","text":"call istack_create(is, 1024)\ncall gstack_create(gs, 1, 1024)                ! create stack to support integer\ncall gstack_create(gs, .true., 1024)           ! create stack to support logical\ncall gstack_create(gs, 1.0_dp, 1024)           ! create stack to support real(dp)\ncall gstack_create(gs, (1.0_dp, 1.0_dp), 1024) ! create stack to support complex(dp)","category":"page"},{"location":"guide/m_stack.html","page":"Stack","title":"Stack","text":"note: Note\nIn istack_create(), the second parameter is the capacity of the stack. However, in gstack_create(), the second parameter means the data type that gstack will manipulate, and the third parameter will be used to determine the capacity. It is an optional parameter.","category":"page"},{"location":"guide/m_stack.html","page":"Stack","title":"Stack","text":"(4) Push element into stack.","category":"page"},{"location":"guide/m_stack.html","page":"Stack","title":"Stack","text":"call istack_push(is, 1)\ncall gstack_push(gs, 1)\ncall gstack_push(gs, .true.)\ncall gstack_push(gs, 2.0_dp)\ncall gstack_push(gs, (1.0_dp, 1.0_dp))","category":"page"},{"location":"guide/m_stack.html","page":"Stack","title":"Stack","text":"(5) Pop element from stack.","category":"page"},{"location":"guide/m_stack.html","page":"Stack","title":"Stack","text":"call istack_pop(is, i) ! i is an integer\ncall gstack_pop(is, j) ! j can be integer, logical, real(dp), and complex(dp)","category":"page"},{"location":"guide/m_stack.html","page":"Stack","title":"Stack","text":"(6) Check status of stack.","category":"page"},{"location":"guide/m_stack.html","page":"Stack","title":"Stack","text":"print *, istack_isfull(is)\nprint *, istack_isempty(is)\nprint *, istack_getsize(is)\nprint *, istack_getrest(is)\n\nprint *, gstack_isfull(gs)\nprint *, gstack_isempty(gs)\nprint *, gstack_getsize(gs)\nprint *, gstack_getrest(gs)","category":"page"},{"location":"guide/m_stack.html","page":"Stack","title":"Stack","text":"The above three function calls will tell you whether the stack is full, whether it is empty, and its capacity.","category":"page"},{"location":"guide/m_stack.html","page":"Stack","title":"Stack","text":"(7) Clean the stack.","category":"page"},{"location":"guide/m_stack.html","page":"Stack","title":"Stack","text":"call istack_clean(is)\ncall gstack_clean(gs)","category":"page"},{"location":"guide/m_stack.html","page":"Stack","title":"Stack","text":"note: Note\nThis operation will reset the top position of the stack, instead of releasing the memory of it. So you can still use the stack after that.","category":"page"},{"location":"guide/m_stack.html","page":"Stack","title":"Stack","text":"(8) Destroy the stack.","category":"page"},{"location":"guide/m_stack.html","page":"Stack","title":"Stack","text":"call istack_destroy(is)\ncall gstack_destroy(gs)","category":"page"},{"location":"guide/m_stack.html","page":"Stack","title":"Stack","text":"note: Note\nWhen the stack was destroyed, you can not use it any more.","category":"page"}]
}

var documenterSearchIndex = {"docs":
[{"location":"ch04/p_js.html#Parameter:-Js","page":"Js","title":"Parameter: Js","text":"","category":"section"},{"location":"ch04/p_js.html","page":"Js","title":"Js","text":"Definition","category":"page"},{"location":"ch04/p_js.html","page":"Js","title":"Js","text":"Strength of the spin-flip term in the interaction term, J_s.","category":"page"},{"location":"ch04/p_js.html","page":"Js","title":"Js","text":"Type","category":"page"},{"location":"ch04/p_js.html","page":"Js","title":"Js","text":"Float, double precision","category":"page"},{"location":"ch04/p_js.html","page":"Js","title":"Js","text":"Default value","category":"page"},{"location":"ch04/p_js.html","page":"Js","title":"Js","text":"0.0","category":"page"},{"location":"ch04/p_js.html","page":"Js","title":"Js","text":"Component","category":"page"},{"location":"ch04/p_js.html","page":"Js","title":"Js","text":"ALL","category":"page"},{"location":"ch04/p_js.html","page":"Js","title":"Js","text":"Behavior","category":"page"},{"location":"ch04/p_js.html","page":"Js","title":"Js","text":"In principle, it is used to build the Coulomb interaction matrix.But the NARCISSUS component does not support general interaction. In other words, it does not support the J_s term in the local impurity Hamiltonian.As for the MANJUSHAKA component, the Coulomb interaction matrix is not built within the quantum impurity solvers. All of the information is encapsulated in the atom.cix file. So they don't need the J_s parameter as well.Therefore, in summary, we don't use this parameter actually. You can set it to any values as you wish. But we strongly suggest to set it to the actual value.","category":"page"},{"location":"ch04/p_js.html","page":"Js","title":"Js","text":"Comment","category":"page"},{"location":"ch04/p_js.html","page":"Js","title":"Js","text":"See also Jz and Jp for more details.","category":"page"},{"location":"ch05/p_jz.html#Parameter:-Jz","page":"Jz","title":"Parameter: Jz","text":"","category":"section"},{"location":"ch05/p_jz.html","page":"Jz","title":"Jz","text":"Definition","category":"page"},{"location":"ch05/p_jz.html","page":"Jz","title":"Jz","text":"Strength of Hund's exchange interaction in z-axis.","category":"page"},{"location":"ch05/p_jz.html","page":"Jz","title":"Jz","text":"Type","category":"page"},{"location":"ch05/p_jz.html","page":"Jz","title":"Jz","text":"Float, double precision","category":"page"},{"location":"ch05/p_jz.html","page":"Jz","title":"Jz","text":"Default value","category":"page"},{"location":"ch05/p_jz.html","page":"Jz","title":"Jz","text":"0.0","category":"page"},{"location":"ch05/p_jz.html","page":"Jz","title":"Jz","text":"Component","category":"page"},{"location":"ch05/p_jz.html","page":"Jz","title":"Jz","text":"Only for the JASMINE component.","category":"page"},{"location":"ch05/p_jz.html","page":"Jz","title":"Jz","text":"Behavior","category":"page"},{"location":"ch05/p_jz.html","page":"Jz","title":"Jz","text":"It is used to build the interaction term in the local Hamiltonian, only valid when icu = 1 or icu = 3.","category":"page"},{"location":"ch05/p_jz.html","page":"Jz","title":"Jz","text":"Comment","category":"page"},{"location":"ch05/p_jz.html","page":"Jz","title":"Jz","text":"See also Uc, Uv, Js, Jp, and icu parameters for more details.","category":"page"},{"location":"ch05/p_isoc.html#Parameter:-isoc","page":"isoc","title":"Parameter: isoc","text":"","category":"section"},{"location":"ch05/p_isoc.html","page":"isoc","title":"isoc","text":"Definition","category":"page"},{"location":"ch05/p_isoc.html","page":"isoc","title":"isoc","text":"Key control flag, to define the type of spin-orbit coupling.","category":"page"},{"location":"ch05/p_isoc.html","page":"isoc","title":"isoc","text":"Type","category":"page"},{"location":"ch05/p_isoc.html","page":"isoc","title":"isoc","text":"Integer","category":"page"},{"location":"ch05/p_isoc.html","page":"isoc","title":"isoc","text":"Default value","category":"page"},{"location":"ch05/p_isoc.html","page":"isoc","title":"isoc","text":"0","category":"page"},{"location":"ch05/p_isoc.html","page":"isoc","title":"isoc","text":"Component","category":"page"},{"location":"ch05/p_isoc.html","page":"isoc","title":"isoc","text":"Only for the JASMINE component.","category":"page"},{"location":"ch05/p_isoc.html","page":"isoc","title":"isoc","text":"Behavior","category":"page"},{"location":"ch05/p_isoc.html","page":"isoc","title":"isoc","text":"There are two possible values for the isoc parameter:isoc = 0, no spin-orbit coupling.\nisoc = 1, on-site atomic spin-orbit coupling.","category":"page"},{"location":"ch05/p_isoc.html","page":"isoc","title":"isoc","text":"Comment","category":"page"},{"location":"ch05/p_isoc.html","page":"isoc","title":"isoc","text":"See also the lambda parameter for more details.","category":"page"},{"location":"ch05/p_ud.html#Parameter:-Ud","page":"Ud","title":"Parameter: Ud","text":"","category":"section"},{"location":"ch05/p_ud.html","page":"Ud","title":"Ud","text":"Definition","category":"page"},{"location":"ch05/p_ud.html","page":"Ud","title":"Ud","text":"Coulomb interaction parameter.","category":"page"},{"location":"ch05/p_ud.html","page":"Ud","title":"Ud","text":"Type","category":"page"},{"location":"ch05/p_ud.html","page":"Ud","title":"Ud","text":"Float, double precision","category":"page"},{"location":"ch05/p_ud.html","page":"Ud","title":"Ud","text":"Default value","category":"page"},{"location":"ch05/p_ud.html","page":"Ud","title":"Ud","text":"2.0","category":"page"},{"location":"ch05/p_ud.html","page":"Ud","title":"Ud","text":"Component","category":"page"},{"location":"ch05/p_ud.html","page":"Ud","title":"Ud","text":"Only for the JASMINE component.","category":"page"},{"location":"ch05/p_ud.html","page":"Ud","title":"Ud","text":"Behavior","category":"page"},{"location":"ch05/p_ud.html","page":"Ud","title":"Ud","text":"It is useful when icu = 2. The Ud and Jh parameters are used to calculate the F_0, F_2, F_4, and F_6.","category":"page"},{"location":"ch05/p_ud.html","page":"Ud","title":"Ud","text":"Comment","category":"page"},{"location":"ch05/p_ud.html","page":"Ud","title":"Ud","text":"See also Jh and icu parameters for more details.","category":"page"},{"location":"ch08/hyb.html#Hybridization-expansion","page":"Hybridization expansion","title":"Hybridization expansion","text":"","category":"section"},{"location":"ch08/hyb.html","page":"Hybridization expansion","title":"Hybridization expansion","text":"In the hybridization expansion algorithm (CT-HYB), due to the fact that H_1 does not mix the impurity and bath states, the trace in omega(mathcalC_n) can be written as","category":"page"},{"location":"ch08/hyb.html","page":"Hybridization expansion","title":"Hybridization expansion","text":"beginequation\ntextTr = textTr_d textTr_c\nendequation","category":"page"},{"location":"ch08/hyb.html","page":"Hybridization expansion","title":"Hybridization expansion","text":"As a result, we can split the weight of each configuration as","category":"page"},{"location":"ch08/hyb.html","page":"Hybridization expansion","title":"Hybridization expansion","text":"beginequation\nomega(mathcalC_n) = omega_d(mathcalC_n) omega_c(mathcalC_n) prodlimits_i=1^n dtau_i\nendequation","category":"page"},{"location":"ch08/hyb.html","page":"Hybridization expansion","title":"Hybridization expansion","text":"omega_d(mathcalC_n) is the trace over impurity operators (textTr_d), omega_c(mathcalC_n) is the trace over bath operators (textTr_c). Further, since the Wick's theorem is applicable for the omega_c(mathcalC_n) part, we can represent it as a determinant of a matrix mathcalZ_textbathmathcalM^-1 with","category":"page"},{"location":"ch08/hyb.html","page":"Hybridization expansion","title":"Hybridization expansion","text":"beginequation\nmathcalZ_textbath=textTr_c e^-beta H_textbath\nendequation","category":"page"},{"location":"ch08/hyb.html","page":"Hybridization expansion","title":"Hybridization expansion","text":"and","category":"page"},{"location":"ch08/hyb.html","page":"Hybridization expansion","title":"Hybridization expansion","text":"beginequation\n(mathcalM^-1)_ij = Delta(tau_i - tau_j)\nendequation","category":"page"},{"location":"ch08/hyb.html","page":"Hybridization expansion","title":"Hybridization expansion","text":"The omega_d(mathcalC_n) part can be expressed using segment representation when n_alpha H_textloc = 0[1]. However, if this condition is not fulfilled, we have to calculate the trace explicitly, which is called the general matrix algorithm[2][3]. The explicit calculation of the trace for a large multi-orbital AIM with general interactions is computationally expensive. Many tricks and strategies have been implemented in the iQIST software package to address this challenge. Please refer to next section for more details.","category":"page"},{"location":"ch08/hyb.html","page":"Hybridization expansion","title":"Hybridization expansion","text":"In this package, we used importance sampling and the Metropolis algorithm to evaluate the partition function mathcalZ. The following four local update procedures, with which the ergodicity of Monte Carlo algorithm is guaranteed, are used to generate the Markov chain:","category":"page"},{"location":"ch08/hyb.html","page":"Hybridization expansion","title":"Hybridization expansion","text":"Insert a pair of creation and annihilation operators in the time interval 0beta).\nRemove a pair of creation and annihilation operators from the current configuration.\nSelect a creation operator randomly and shift its position on the imaginary time axis.\nSelect a annihilation operator randomly and shift its position on the imaginary time axis.","category":"page"},{"location":"ch08/hyb.html","page":"Hybridization expansion","title":"Hybridization expansion","text":"In the Monte Carlo simulations, sometimes the system can be trapped by some (for example symmetry-broken) state. In order to avoid unphysical trapping, we also consider the following two global updates:","category":"page"},{"location":"ch08/hyb.html","page":"Hybridization expansion","title":"Hybridization expansion","text":"Swap the operators of randomly selected spin up and spin down flavors.\nSwap the creation and annihilation operators globally.","category":"page"},{"location":"ch08/hyb.html","page":"Hybridization expansion","title":"Hybridization expansion","text":"Reference","category":"page"},{"location":"ch08/hyb.html","page":"Hybridization expansion","title":"Hybridization expansion","text":"[1]: Philipp Werner, Armin Comanac, Luca de’ Medici, Matthias Troyer, and Andrew J. Millis, Phys. Rev. Lett. 97, 076405 (2006)","category":"page"},{"location":"ch08/hyb.html","page":"Hybridization expansion","title":"Hybridization expansion","text":"[2]: Philipp Werner and Andrew J. Millis, Phys. Rev. B 74, 155107 (2006)","category":"page"},{"location":"ch08/hyb.html","page":"Hybridization expansion","title":"Hybridization expansion","text":"[3]: Kristjan Haule, Phys. Rev. B 75, 155113 (2007)","category":"page"},{"location":"ch04/out_green.html#solver.green.dat","page":"solver.green.dat","title":"solver.green.dat","text":"","category":"section"},{"location":"ch04/out_green.html","page":"solver.green.dat","title":"solver.green.dat","text":"Introduction","category":"page"},{"location":"ch04/out_green.html","page":"solver.green.dat","title":"solver.green.dat","text":"This file is used to store the imaginary-time Green's function G(tau). It will be output by the quantum impurity solvers when they are shut down.","category":"page"},{"location":"ch04/out_green.html","page":"solver.green.dat","title":"solver.green.dat","text":"Format","category":"page"},{"location":"ch04/out_green.html","page":"solver.green.dat","title":"solver.green.dat","text":"The solver.green.dat file contains norbs block. Each block is appended by two blank lines. The format of each block is as follows:","category":"page"},{"location":"ch04/out_green.html","page":"solver.green.dat","title":"solver.green.dat","text":"","category":"page"},{"location":"ch04/out_green.html","page":"solver.green.dat","title":"solver.green.dat","text":"column 1: orbital index i, integer","category":"page"},{"location":"ch04/out_green.html","page":"solver.green.dat","title":"solver.green.dat","text":"column 2: imaginary-time index j, integer","category":"page"},{"location":"ch04/out_green.html","page":"solver.green.dat","title":"solver.green.dat","text":"column 3: imaginary-time point, tau, double precision","category":"page"},{"location":"ch04/out_green.html","page":"solver.green.dat","title":"solver.green.dat","text":"column 4: imaginary-time Green's function, G(tau), double precision","category":"page"},{"location":"ch04/out_green.html","page":"solver.green.dat","title":"solver.green.dat","text":"column 5: error bar, delta G(tau), double precision","category":"page"},{"location":"ch04/out_green.html","page":"solver.green.dat","title":"solver.green.dat","text":"","category":"page"},{"location":"ch04/out_green.html","page":"solver.green.dat","title":"solver.green.dat","text":"note: Note\nIn the solver.green.dat file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch04/out_green.html","page":"solver.green.dat","title":"solver.green.dat","text":"Code","category":"page"},{"location":"ch04/out_green.html","page":"solver.green.dat","title":"solver.green.dat","text":"The corresponding Fortran code block for the writing of solver.green.dat file is as follows:","category":"page"},{"location":"ch04/out_green.html","page":"solver.green.dat","title":"solver.green.dat","text":"! open data file: solver.green.dat\nopen(mytmp, file='solver.green.dat', form='formatted', status='unknown')\n\n! write it\ndo i=1,norbs\n    do j=1,ntime\n        write(mytmp,'(2i6,3f12.6)') i, j, tmesh(j), gtau(j,i,i), gerr(j,i,i)\n    enddo ! over j={1,ntime} loop\n    write(mytmp,*) ! write empty lines\n    write(mytmp,*)\nenddo ! over i={1,norbs} loop\n\n! close data file\nclose(mytmp)","category":"page"},{"location":"ch04/out_green.html","page":"solver.green.dat","title":"solver.green.dat","text":"In the iQIST software package, we provide a Python module to read the output files of quantum impurity solvers. You can use it to read the solver.green.dat file. See [src/tools/u_reader.py] for more details.","category":"page"},{"location":"ch05/in_tmat.html#atom.tmat.in","page":"atom.tmat.in","title":"atom.tmat.in","text":"","category":"section"},{"location":"ch05/in_tmat.html","page":"atom.tmat.in","title":"atom.tmat.in","text":"Introduction","category":"page"},{"location":"ch05/in_tmat.html","page":"atom.tmat.in","title":"atom.tmat.in","text":"The purpose of the atom.tmat.in file is to supply the transformation matrix mathcalT_alphabeta, which transforms an operator from its original basis to the natural basis. Only when ibasis = 2, the atom.tmat.in file is used. See ibasis for more details.","category":"page"},{"location":"ch05/in_tmat.html","page":"atom.tmat.in","title":"atom.tmat.in","text":"Format","category":"page"},{"location":"ch05/in_tmat.html","page":"atom.tmat.in","title":"atom.tmat.in","text":"The format of the atom.tmat.in file is as follows:","category":"page"},{"location":"ch05/in_tmat.html","page":"atom.tmat.in","title":"atom.tmat.in","text":"","category":"page"},{"location":"ch05/in_tmat.html","page":"atom.tmat.in","title":"atom.tmat.in","text":"column 1: orbital index alpha, integer","category":"page"},{"location":"ch05/in_tmat.html","page":"atom.tmat.in","title":"atom.tmat.in","text":"column 2: orbital index beta, integer","category":"page"},{"location":"ch05/in_tmat.html","page":"atom.tmat.in","title":"atom.tmat.in","text":"column 3: elements of the transformation matrix mathcalT_alphabeta, double precision","category":"page"},{"location":"ch05/in_tmat.html","page":"atom.tmat.in","title":"atom.tmat.in","text":"","category":"page"},{"location":"ch05/in_tmat.html","page":"atom.tmat.in","title":"atom.tmat.in","text":"note: Note\nIn the atom.tmat.in file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch05/in_tmat.html","page":"atom.tmat.in","title":"atom.tmat.in","text":"Code","category":"page"},{"location":"ch05/in_tmat.html","page":"atom.tmat.in","title":"atom.tmat.in","text":"The corresponding Fortran code block for the reading of the atom.tmat.in file is as follows:","category":"page"},{"location":"ch05/in_tmat.html","page":"atom.tmat.in","title":"atom.tmat.in","text":"! open file atom.tmat.in\nopen(mytmp, file='atom.tmat.in', form='formatted', status='unknown')\n\n! read the data file\ndo i=1,norbs\n    do j=1,norbs\n        read(mytmp,*) i1, i2, raux\n        ! tmat is actually real\n        tmat(i,j) = dcmplx(raux, zero)\n    enddo ! over j={1,norbs} loop\nenddo ! over i={1,norbs} loop\n\n! close data file\nclose(mytmp)","category":"page"},{"location":"ch05/in_tmat.html","page":"atom.tmat.in","title":"atom.tmat.in","text":"In principle, the transformation matrix is complex. Here we think that its imaginary part is zero and only take the real part into consideration.","category":"page"},{"location":"ch01/feature.html#Features","page":"Features","title":"Features","text":"","category":"section"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"The main features of the core components (i.e., quantum impurity solvers) of the iQIST software package are summarized as follows:","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"Model\nDensity-density interaction\nGeneral interaction (Slater or Kanamori scheme)\nSpin-orbital coupling and crystal field splitting\nHubbard-Holstein model\nFrequency-dependent Coulomb interaction","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"Measurement tricks\nOrthogonal polynomial representation (Legendre polynomials)\nImproved estimator for self-energy function","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"Observables\nSingle-particle Green's function in imaginary time space\nSingle-particle Green's function in matsubara frequency space\nTwo-particle correlation function in matsubara frequency space (experimental)\nSelf-energy function in matsubara frequency space\nHistogram of perturbation expansion order\nKurtosis and skewness of perturbation expansion order\nKinetic and potential energies\nOrbital occupation numbers\nDouble occupation numbers\nMagnetic moment\nAtomic state probability\nSpin-spin correlation function in imaginary time space\nSpin-spin correlation function in matsubara frequency space\nOrbital-orbital correlation function in imaginary time space\nOrbital-orbital correlation function in matsubara frequency space\nFidelity susceptibility\nKinetic energy fluctuation langle k^2rangle - langle krangle^2 - langle krangle","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"Fast algorithms\nSegment algorithm for density-density interaction\nDivide-and-conquer algorithm\nSparse matrix multiplication\nGood quantum numbers (N S_z J_z, PS)\nLazy trace evaluation\nDynamical truncation approximation","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"Parallelism\nMPI\nOpenMP","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"Preprocessing\nAtomic eigenvalue problem solver","category":"page"},{"location":"ch08/platform.html#Development-platform","page":"Development platform","title":"Development platform","text":"","category":"section"},{"location":"ch08/platform.html","page":"Development platform","title":"Development platform","text":"Programming languages","category":"page"},{"location":"ch08/platform.html","page":"Development platform","title":"Development platform","text":"The main part of the iQIST software package was developed with the modern Fortran 90 language. We extensively used advanced language features in the Fortran 2003/2008 standard such as an object oriented programming style (polymorphic, inheritance, and module, etc.) to improve the readability and re-usability of the source codes. The compilers are fixed to the Intel Fortran compiler and GNU GCC gfortran. We can not guarantee that the iQIST can be compiled successfully with other Fortran compilers. Some auxiliary scripts, pre- and post-processing tools are written using the Python language and Bash shell scripts. These scripts and tools act like a glue. They are very flexible and very easily extended or adapted to deal with various problems. In order to avoid incompatibilities, our Python codes only run on the Python 2.x runtime environment.","category":"page"},{"location":"ch08/platform.html","page":"Development platform","title":"Development platform","text":"Version control system","category":"page"},{"location":"ch08/platform.html","page":"Development platform","title":"Development platform","text":"We use git as the version control tool, and the source codes are hosted in some remote servers. Many thanks to Bitbucket and Github for providing free code repository services. The developers pull the source codes from the server into their local machines, and then try to improve them. Once the development is done, the source codes can be pushed back to the server and merged with the master branch. Then the other developers can access them and use them immediately to start further developments. The members of our developer team and the other users can access the public code repository anywhere and anytime.","category":"page"},{"location":"ch08/platform.html","page":"Development platform","title":"Development platform","text":"The official code repositories are as follows:","category":"page"},{"location":"ch08/platform.html","page":"Development platform","title":"Development platform","text":"Github","category":"page"},{"location":"ch06/writer.html#u_writer.py","page":"u_writer.py","title":"u_writer.py","text":"","category":"section"},{"location":"ch06/writer.html","page":"u_writer.py","title":"u_writer.py","text":"Introduction","category":"page"},{"location":"ch06/writer.html","page":"u_writer.py","title":"u_writer.py","text":"The purpose of this script is provide an easy-to-use interface to write/dump necessary input files for the quantum impurity solver components.","category":"page"},{"location":"ch06/writer.html","page":"u_writer.py","title":"u_writer.py","text":"Type","category":"page"},{"location":"ch06/writer.html","page":"u_writer.py","title":"u_writer.py","text":"Python module","category":"page"},{"location":"ch06/writer.html","page":"u_writer.py","title":"u_writer.py","text":"APIs","category":"page"},{"location":"ch06/writer.html","page":"u_writer.py","title":"u_writer.py","text":"class iqistWriter(object):\n    \"\"\" This class provide a few static methods which are used to write\n        the necessary input data for the ctqmc impurity solvers and hfqmc\n        impurity solver.\n\n        Why do we need this class? Because sometimes it is not convenient\n        to call the Python API for iQIST directly. Using this class, we\n        can ensure the input file format is correct.\n    \"\"\"\n\n    @staticmethod\n    def out_hyb(norbs, mfreq, rmesh, hybf, fileName = None):\n        \"\"\" try to write the hybridization function to the solver.hyb.in\n            file, only suitable for the ctqmc impurity solver\n        \"\"\"\n\n    @staticmethod\n    def out_wss(norbs, mfreq, rmesh, wssf, fileName = None):\n        \"\"\" try to write the bath weiss's function to the solver.wss.in\n            file, only suitable for the hfqmc impurity solver\n        \"\"\"\n\n    @staticmethod\n    def out_eimp(norbs, symm, eimp, fileName = None):\n        \"\"\" try to write the impurity levels and symmetry vector to the\n            solver.eimp.in file\n        \"\"\"\n\n    @staticmethod\n    def out_umat(norbs, umat, fileName = None):\n        \"\"\" try to write the Coulomb matrix to the solver.umat.in file,\n            only suitable for the ctqmc impurity solver\n        \"\"\"\n\n    @staticmethod\n    def out_ktau(ntime, tmesh, ktau, ptau, fileName = None):\n        \"\"\" try to write the screening function K(\\tau) and its first\n            derivates to the solver.ktau.in file, only suitable for the\n            ctqmc impurity solver (narcissus)\n        \"\"\"","category":"page"},{"location":"ch06/writer.html","page":"u_writer.py","title":"u_writer.py","text":"Examples","category":"page"},{"location":"ch06/writer.html","page":"u_writer.py","title":"u_writer.py","text":"# import this module\nfrom u_writer import *\n\n# setup parameters\nnorbs = 2\nntime = 1024\nmfreq = 8193\n\n# build rmesh, hybf, wssf, symm, eimp, umat, tmesh, ktau and ptau\n...\n\n# write the data\niqistWriter.out_hyb(norbs, mfreq, rmesh, hybf)\niqistWriter.out_wss(norbs, mfreq, rmesh, wssf)\niqistWriter.out_eimp(norbs, symm, eimp)\niqistWriter.out_umat(norbs, umat)\niqistWriter.out_ktau(ntime, tmesh, ktau, ptau)","category":"page"},{"location":"ch06/writer.html","page":"u_writer.py","title":"u_writer.py","text":"note: Note\nYou can not execute u_writer.py in the terminal or Python environment directly, like this:$ python u_writer.py","category":"page"},{"location":"ch06/writer.html","page":"u_writer.py","title":"u_writer.py","text":"Comment","category":"page"},{"location":"ch06/writer.html","page":"u_writer.py","title":"u_writer.py","text":"N/A","category":"page"},{"location":"ch08/soc.html#Spin-orbit-coupling","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"","category":"section"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"Spin-orbit interaction Hamiltonian","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"The spin-orbit coupling (SOC) is implemented at atomic level,","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"beginequation\nhatH_textSOC=\nlambdasum_ihatl_i cdot hats_i\nendequation","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"where hatl is orbital angular momentum, and hats is spin angular momentum. In second quantization form,","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"beginequation\nhatH_textSOC=\nlambdasum_alphasigmabetasigma^prime\nleftlangle\nalphasigmaleft hatl cdot hats rightbetasigma^prime\nrightrangle\nhatf_alphasigma^daggerhatf_betasigma^prime\nendequation","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"where alpha is orbital index and sigma is spin index. We note that","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"beginequation\nhatl cdot hats =\nfrac12 hatl cdot hatsigma\nendequation","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"where hatsigma is the Pauli operator:","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"beginequation\nhatsigma = hatsigma_x hatx +\n               hatsigma_y haty +\n               sigma_z hatz\nendequation","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"beginequation\nhatsigma_x = left\nbeginarraycc\n0  1 \n1  0 \nendarray\nright\nhatsigma_y = left\nbeginarraycc\n0  -i \ni  0 \nendarray\nright\nhatsigma_z = left\nbeginarraycc\n1  0 \n0  -1 \nendarray\nright\nendequation","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"Now the question is how to write down the matrix elements for hatl cdot hatsigma.","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"beginequation\nhatl cdot hatsigma =\nhatl_xhatsigma_x+\nhatl_yhatsigma_y+\nhatl_zhatsigma_z\n= leftbeginarraycc\nhatl_z  hatl_-\nhatl_+  -hatl_z\nendarrayright\nendequation","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"where hatl_pm=hatl_xpmhatl_y. It is easy to prove that the above equation can be rewritten as","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"beginequation\nhatl cdot hatsigma =\nhatl_+hatsigma_-+\nhatl_-hatsigma_++\nhatl_zhatsigma_z\nendequation","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"where","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"beginequation\nhatsigma_+ = left\nbeginarraycc\n0  1 \n0  0 \nendarray\nright\nhatsigma_- = left\nbeginarraycc\n0  0 \n1  0 \nendarray\nright\nendequation","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"Spin-orbit interaction in the complex orbital basis","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"We just write down hatlcdothatsigma in the complex spherical harmonics basis. The following relations are used to derive the matrix elements of the spin-orbit interaction:","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"beginequation\nhatl_pmY_l^m=sqrt(lmp m)(lpm m+1)Y_l^mpm1\nendequation","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"beginequation\nhatsigma_+ uparrowrangle = 0\nhatsigma_+ downarrowrangle = uparrowrangle\nendequation","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"beginequation\nhatsigma_- uparrowrangle = downarrowrangle\nhatsigma_- downarrowrangle = 0\nendequation","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"beginequation\nhatsigma_z uparrowrangle = 1\nhatsigma_z downarrowrangle = -1\nendequation","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"For p system,","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"beginequation\nhatlcdothatsigma=\nleft\nbeginarraycccccc\n-1  0  0  0  sqrt2  0\n0  0  0  0  0  sqrt2\n0  0  1  0  0  0\nhline\n0  0  0  1  0  0\nsqrt2  0  0  0  0  0\n0  sqrt2  0  0  0  -1\nendarray\nright\nendequation","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"For d system,","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"beginequation\nhatlcdothatsigma=\nleft\nbeginarraycccccccccc\n-2  0  0  0  0  0  sqrt4  0  0  0\n0  -1  0  0  0  0  0  sqrt6  0  0\n0  0  0  0  0  0  0  0  sqrt6  0\n0  0  0  1  0  0  0  0  0  sqrt4\n0  0  0  0  2  0  0  0  0  0\nhline\n0  0  0  0  0  2  0  0  0  0\nsqrt4  0  0  0  0  0  1  0  0  0\n0  sqrt6  0  0  0  0  0  0  0  0\n0  0  sqrt6  0  0  0  0  0  -1  0\n0  0  0  sqrt4  0  0  0  0  0  -2\nendarray\nright\nendequation","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"For f system,","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"beginequation\nhatlcdothatsigma=\nleft\nbeginarraycccccccccccccc\n-3  0  0  0  0  0  0  0  sqrt6  0  0  0  0  0\n0  -2  0  0  0  0  0  0  0  sqrt10  0  0  0  0\n0  0  -1  0  0  0  0  0  0  0  sqrt12  0  0  0\n0  0  0  0  0  0  0  0  0  0  0  sqrt12  0  0\n0  0  0  0  1  0  0  0  0  0  0  0  sqrt10  0\n0  0  0  0  0  2  0  0  0  0  0  0  0  sqrt6\n0  0  0  0  0  0  3  0  0  0  0  0  0  0\nhline\n0  0  0  0  0  0  0  3  0  0  0  0  0  0\nsqrt6  0  0  0  0  0  0  0  2  0  0  0  0  0\n0  sqrt10  0  0  0  0  0  0  0  1  0  0  0  0\n0  0  sqrt12  0  0  0  0  0  0  0  0  0  0  0\n0  0  0  sqrt12  0  0  0  0  0  0  0  -1  0  0\n0  0  0  0  sqrt10  0  0  0  0  0  0  0  -2  0\n0  0  0  0  0  sqrt6  0  0  0  0  0  0  0  -3\nendarray\nright\nendequation","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"The following Julia's script can be used to generate the matrix elements for the spin-orbit interaction.","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"# To calculate the matrix representation of spin-orbit coupling in the\n# complex orbital basis.\nfunction calc_matrix(l::Int64)\n    println(\"Construct complex orbital basis for 𝑙 = $l\")\n    COB = [] # To save the complex orbital basis\n    # m = -l, -l+1, ..., l-1, l\n    mlist = collect(-l:1:l)\n    for s in (\"up\", \"down\")\n        for m in mlist\n            push!(COB, [m, s])\n        end\n    end\n    #\n    for i in eachindex(COB)\n        m = COB[i][1]\n        s = COB[i][2] == \"up\" ? \"↑\" : \"↓\"\n        println(\"$i -> | $l, $m, $s ⟩\")\n    end\n\n    println(\"Calculate matrix elements of spin-orbit coupling\")\n    for i in eachindex(COB)\n        lᵢ = l\n        mᵢ = COB[i][1]\n        sᵢ = COB[i][2]\n        for j in eachindex(COB)\n            lⱼ = l\n            mⱼ = COB[j][1]\n            sⱼ = COB[j][2]\n\n            # For l₊σ₋ term\n            T₁ = (lⱼ - mⱼ) * (lⱼ + mⱼ + 1)\n            m1ⱼ = mⱼ + 1\n            #\n            if sⱼ == \"up\"\n                s1ⱼ = \"down\"\n            else\n                s1ⱼ = \"null\"\n            end\n            #\n            if m1ⱼ == mᵢ && sᵢ == s1ⱼ\n                println(\"SOC($i, $j) = sqrt(\", T₁, \")\")\n            end\n\n            # For l₋σ₊ term\n            T₂ = (lⱼ + mⱼ)*(lⱼ - mⱼ + 1)\n            m2ⱼ = mⱼ - 1\n            #\n            if sⱼ == \"down\"\n                s2ⱼ = \"up\"\n            else\n                s2ⱼ = \"null\"\n            end\n            #\n            if m2ⱼ == mᵢ && sᵢ == s2ⱼ\n                println(\"SOC($i, $j) = sqrt(\", T₂, \")\")\n            end\n\n            # For lzσz term\n            T₃ = mⱼ * (sⱼ == \"up\" ? 1 : -1)\n            if mⱼ == mᵢ && sᵢ == sⱼ\n                println(\"SOC($i, $j) = \", T₃)\n            end\n        end\n    end\nend","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"Spin-orbit interaction in the hatj^2-hatj_z-hatl^2-hats^2 diagonal basis","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"Since","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"beginequation\nhatj = hatl + hats\nendequation","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"hatj^2 = hatl^2 + hats^2 + 2hatl cdot hats","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"hatl cdot hatsigma = 2 hatl cdot hats\n                           = hatj^2 - hatl^2 - hats^2","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"thus, in the hatj^2-hatj_z-hatl^2-hats^2 diagonal basis, the matrix of hatl cdot hatsigma is diagonal. The diagonal element reads j(j+1) - l(l+1) - s(s+1). Note that in this basis, j = l pm frac12 and s = frac12.","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"For p system,","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"beginequation\nhatlcdothatsigma=\nleft\nbeginarraycccccc\n-2  0  0  0  0  0\n0  -2  0  0  0  0\n0  0  1  0  0  0\nhline\n0  0  0  1  0  0\n0  0  0  0  1  0\n0  0  0  0  0  1\nendarray\nright\nendequation","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"For d system,","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"beginequation\nhatlcdothatsigma=\nleft\nbeginarraycccccccccc\n-3  0  0  0  0  0  0  0  0  0\n0  -3  0  0  0  0  0  0  0  0\n0  0  -3  0  0  0  0  0  0  0\n0  0  0  -3  0  0  0  0  0  0\n0  0  0  0  2  0  0  0  0  0\nhline\n0  0  0  0  0  2  0  0  0  0\n0  0  0  0  0  0  2  0  0  0\n0  0  0  0  0  0  0  2  0  0\n0  0  0  0  0  0  0  0  2  0\n0  0  0  0  0  0  0  0  0  2\nendarray\nright\nendequation","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"For f system,","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"beginequation\nhatlcdothatsigma=\nleft\nbeginarraycccccccccccccc\n-4  0  0  0  0  0  0  0  0  0  0  0  0  0\n0  -4  0  0  0  0  0  0  0  0  0  0  0  0\n0  0  -4  0  0  0  0  0  0  0  0  0  0  0\n0  0  0  -4  0  0  0  0  0  0  0  0  0  0\n0  0  0  0  -4  0  0  0  0  0  0  0  0  0\n0  0  0  0  0  -4  0  0  0  0  0  0  0  0\n0  0  0  0  0  0  3  0  0  0  0  0  0  0\nhline\n0  0  0  0  0  0  0  3  0  0  0  0  0  0\n0  0  0  0  0  0  0  0  3  0  0  0  0  0\n0  0  0  0  0  0  0  0  0  3  0  0  0  0\n0  0  0  0  0  0  0  0  0  0  3  0  0  0\n0  0  0  0  0  0  0  0  0  0  0  3  0  0\n0  0  0  0  0  0  0  0  0  0  0  0  3  0\n0  0  0  0  0  0  0  0  0  0  0  0  0  3\nendarray\nright\nendequation","category":"page"},{"location":"ch08/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"Next, it is easy to transform the above matrices from the hatj^2-hatj_z-hatl^2-hats^2 diagonal basis to complex orbital basis. See Single particle basis for the transformation matrix.","category":"page"},{"location":"ch06/ctqmc.html#script/u_ctqmc.py","page":"u_ctqmc.py","title":"script/u_ctqmc.py","text":"","category":"section"},{"location":"ch06/ctqmc.html","page":"u_ctqmc.py","title":"u_ctqmc.py","text":"Introduction","category":"page"},{"location":"ch06/ctqmc.html","page":"u_ctqmc.py","title":"u_ctqmc.py","text":"The purpose of this script is to generate essential input file (solver.ctqmc.in) for the quantum impurity solver components. Note that you can not use it to control these codes directly.","category":"page"},{"location":"ch06/ctqmc.html","page":"u_ctqmc.py","title":"u_ctqmc.py","text":"Type","category":"page"},{"location":"ch06/ctqmc.html","page":"u_ctqmc.py","title":"u_ctqmc.py","text":"Python module","category":"page"},{"location":"ch06/ctqmc.html","page":"u_ctqmc.py","title":"u_ctqmc.py","text":"APIs","category":"page"},{"location":"ch06/ctqmc.html","page":"u_ctqmc.py","title":"u_ctqmc.py","text":"class p_ctqmc_solver(object):\n    \"\"\" This class can be used to generate the config file for the quantum\n        impurity solver components.\n    \"\"\"\n\n    def __init__(self, solver):\n        \"\"\" define the class variables\n        \"\"\"\n\n    def setp(self, **kwargs):\n        \"\"\" setup the parameters using a series of key-value pairs\n        \"\"\"\n\n    def check(self):\n        \"\"\" check the correctness of input parameters\n        \"\"\"\n\n    def write(self):\n        \"\"\" write the parameters to the config file: solver.ctqmc.in\n        \"\"\"","category":"page"},{"location":"ch06/ctqmc.html","page":"u_ctqmc.py","title":"u_ctqmc.py","text":"Examples","category":"page"},{"location":"ch06/ctqmc.html","page":"u_ctqmc.py","title":"u_ctqmc.py","text":"# import this module\nfrom u_ctqmc import *\n\n# create an instance\np = p_ctqmc_solver('manjushaka')\n\n# setup the parameters\np.setp(isscf = 2, isort = 1, nsweep = 10000000)\np.setp(mune = 2.0, nmaxi = 10)\np.setp()\np.setp(isscf = 1)\n\n# verify the parameters\np.check()\n\n# generate the solver.ctqmc.in file\np.write()\n\n# destroy the instance\ndel p","category":"page"},{"location":"ch06/ctqmc.html","page":"u_ctqmc.py","title":"u_ctqmc.py","text":"note: Note\nYou can not execute u_ctqmc.py in the terminal or Python environment directly, like this:$ python u_ctqmc.py","category":"page"},{"location":"ch06/ctqmc.html","page":"u_ctqmc.py","title":"u_ctqmc.py","text":"Comment","category":"page"},{"location":"ch06/ctqmc.html","page":"u_ctqmc.py","title":"u_ctqmc.py","text":"N/A","category":"page"},{"location":"ch03/create.html#Prepare-input-files","page":"Prepare input files","title":"Prepare input files","text":"","category":"section"},{"location":"ch03/create.html","page":"Prepare input files","title":"Prepare input files","text":"There are two ways to generate the necessary inpute files for the quantum impurity solvers in the iQIST software package.","category":"page"},{"location":"ch03/create.html","page":"Prepare input files","title":"Prepare input files","text":"","category":"page"},{"location":"ch03/create.html","page":"Prepare input files","title":"Prepare input files","text":"Method 1:","category":"page"},{"location":"ch03/create.html","page":"Prepare input files","title":"Prepare input files","text":"One is to prepare the input files manually.","category":"page"},{"location":"ch03/create.html","page":"Prepare input files","title":"Prepare input files","text":"Usually, the necessary input file is solver.ctqmc.in. It is an ascii text file actually. You can use any text editor to create and edit it in principle. As for the file format of solver.ctqmc.in, please read:","category":"page"},{"location":"ch03/create.html","page":"Prepare input files","title":"Prepare input files","text":"solver.ctqmc.in // Configuration file for CT-QMC quantum impurity solvers.","category":"page"},{"location":"ch03/create.html","page":"Prepare input files","title":"Prepare input files","text":"Besides the solver.ctqmc.in file, some quantum impurity solvers also require the atom.cix file as input. You can use the JASMINE component to generate it. The necessary input file for the JASMINE component is atom.config.in. For more details about it, please read:","category":"page"},{"location":"ch03/create.html","page":"Prepare input files","title":"Prepare input files","text":"atom.config.in // Configuration file for the atomic eigenvalue problem solver.","category":"page"},{"location":"ch03/create.html","page":"Prepare input files","title":"Prepare input files","text":"","category":"page"},{"location":"ch03/create.html","page":"Prepare input files","title":"Prepare input files","text":"Method 2:","category":"page"},{"location":"ch03/create.html","page":"Prepare input files","title":"Prepare input files","text":"Another approach is to use the u_ctqmc.py and u_atomic.py to generate the solver.ctqmc.in and atom.config.in files, respectively. In this approach, you have to write some python scripts. Don't worry about it. It is a trivial task. Please see","category":"page"},{"location":"ch03/create.html","page":"Prepare input files","title":"Prepare input files","text":"[Scripts] // Python scripts.","category":"page"},{"location":"ch03/create.html","page":"Prepare input files","title":"Prepare input files","text":"for more details.","category":"page"},{"location":"ch03/create.html","page":"Prepare input files","title":"Prepare input files","text":"","category":"page"},{"location":"ch03/create.html","page":"Prepare input files","title":"Prepare input files","text":"As for the other input files not mentioned here, please try to generate them by yourself. The detailed format descriptions can be seen in the following sections:","category":"page"},{"location":"ch03/create.html","page":"Prepare input files","title":"Prepare input files","text":"Standard input files // Input stuffs for CT-HYB quantum impurity solvers.\n[Standard input files] // Input stuffs for atomic eigenvalue problem solver.","category":"page"},{"location":"ch04/in_anydos.html#solver.anydos.in","page":"solver.anydos.in","title":"solver.anydos.in","text":"","category":"section"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"Introduction","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"In the CT-QMC impurity solvers contained in the iQIST software package, we provide a mini dynamical mean-field theory engine. This engine implements a self-consistent condition for the bethe lattice which has a semi-circular density of states with bandwith 4t. Sometimes you may want to try the other models with arbitrary density of states.","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"Is it possible?","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"Yes, of course. You can define your density of states in the solver.anydos.in file. And then you have to hack the iqist/src/ctqmc_dmft.f90 file.","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"Change the following codes","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"......\n     use context, only : grnf\n......\n     ! apply the self-consistent condition. here we consider a Hubbard model\n     ! on a bethe lattice. of course you can replace it with your implements\n     call ctqmc_dmft_bethe(hybf, grnf)","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"to","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"......\n     use context, only : grnf, sig2\n......\n     ! calculate new hybridization function using self-consistent condition\n     call ctqmc_dmft_anydos(hybf, grnf, sig2)","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"You have to be very careful. Finally, recompiling the CT-QMC quantum impurity solvers is necessary.","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"note: Note\nDon't forget to set the isscf parameter to 2, or else the CT-QMC impurity solvers will skip the dynamical mean-field theory engine and perform one-shot calculation only.","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"Format","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"The format of the solver.anydos.in file is as follows:","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"column 1: frequency point, epsilon, double precision","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"column 2: density of states, rho(epsilon), double precision","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"note: Note\nWe assume that:The orbitals are degenerated.\nThe number of frequency points is 801.If you are not satisfied with these assumptions, you have to hack the corresponding ctqmc_dmft.f90 by yourself.","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"Code","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"The corresponding Fortran code block for the reading of solver.anydos.in file is as follows:","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"open(mytmp, file='solver.anydos.in', form='formatted', status='unknown')\ndo i=1,ngrid\n    read(mytmp,*) epsi(i), pdos(i,1)\n    do j=2,norbs\n        pdos(:,j) = pdos(:,1)\n    enddo ! over j={2,norbs} loop\nenddo ! over i={1,ngrid} loop\nclose(mytmp)","category":"page"},{"location":"ch05/in_atom.html#atom.config.in","page":"atom.config.in","title":"atom.config.in","text":"","category":"section"},{"location":"ch05/in_atom.html","page":"atom.config.in","title":"atom.config.in","text":"Introduction","category":"page"},{"location":"ch05/in_atom.html","page":"atom.config.in","title":"atom.config.in","text":"The main configuration file for the atomic eigenvalue problem solver in the iQIST software package is the atom.config.in file.","category":"page"},{"location":"ch05/in_atom.html","page":"atom.config.in","title":"atom.config.in","text":"Just like the CT-QMC quantum impurity solvers, since all of the input parameters have default values, the atomic eigenvalue problem solver can run without any input files. But if you want to use it to solve a specific problem, a well-prepared atom.config.in file is of course necessary.","category":"page"},{"location":"ch05/in_atom.html","page":"atom.config.in","title":"atom.config.in","text":"Format","category":"page"},{"location":"ch05/in_atom.html","page":"atom.config.in","title":"atom.config.in","text":"The atom.config.in file share the same format with the solver.ctqmc.in files. In other words, it adopts the simple \"key-value\" style. See solver.ctqmc.in for more details.","category":"page"},{"location":"ch05/in_atom.html","page":"atom.config.in","title":"atom.config.in","text":"Code","category":"page"},{"location":"ch05/in_atom.html","page":"atom.config.in","title":"atom.config.in","text":"N/A","category":"page"},{"location":"ch08/ct.html#Principles-of-continuous-time-quantum-Monte-Carlo-algorithm","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"","category":"section"},{"location":"ch08/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"Now we already have an impurity model Hamiltonian H_textimp, the question is how to solve it using the Monte Carlo algorithm?","category":"page"},{"location":"ch08/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"We first split the impurity Hamiltonian H_textimp into two separate parts,","category":"page"},{"location":"ch08/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"beginequation\nH_textimp = H_1 + H_2\nendequation","category":"page"},{"location":"ch08/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"then treat H_2 as a perturbation term, and expand the partition function mathcalZ in powers of H_2,","category":"page"},{"location":"ch08/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"beginequation\nmathcalZ =  textTr e^-beta H = sum_n=0^infty int_0^beta cdots int_tau_n-1^beta omega(mathcalC_n)\nendequation","category":"page"},{"location":"ch08/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"with","category":"page"},{"location":"ch08/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"beginequation\nomega(mathcalC_n)=dtau_1 cdots dtau_n textTrleft e^-beta H_1-H_2(tau_n)cdots -H_2(tau_1)right\nendequation","category":"page"},{"location":"ch08/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"where H_2(tau) is defined in the interaction picture with","category":"page"},{"location":"ch08/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"beginequation\nH_2(tau) = e^tau H_1 H_2 e^-tau H_1\nendequation","category":"page"},{"location":"ch08/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"Each term in the right side of the second equation can be regarded as a diagram or configuration (labeled by mathcalC), and omega(mathcalC_n) is the diagrammatic weight of a specific order-n configuration. Next we use a stochastic Monte Carlo algorithm to sample the terms of this series. This is the core spirit of the continuous-time quantum Monte Carlo impurity solver. The idea is very simple, but the realization is not.","category":"page"},{"location":"ch08/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"Depending on the different choices of H_2 term, there are multiple variations for the continuous-time quantum Monte Carlo impurity solver. According to our knowledge, the variations at least include","category":"page"},{"location":"ch08/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"CT-INT\nCT-HYB\nCT-J\nCT-AUX","category":"page"},{"location":"ch08/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"In the CT-INT and CT-AUX quantum impurity solvers[1][2], the interaction term is the perturbation term, namely, H_2 = H_textint, while H_2 = H_texthyb is chosen for the CT-HYB quantum impurity solver[3]. The CT-J quantum impurity solver is designed for the Kondo lattice model only[4]. We won't discuss it at here. In the intermediate and strong interaction region, CT-HYB is much more efficient than CT-INT and CT-AUX. We could even say that it is the most powerful and efficient quantum impurity solver so far. This is also the main reason that we only implemented the CT-HYB quantum impurity solvers in the iQIST software package.","category":"page"},{"location":"ch08/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"Reference","category":"page"},{"location":"ch08/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"[1]: A. N. Rubtsov, V. V. Savkin, and A. I. Lichtenstein, Phys. Rev. B 72, 035122 (2005)","category":"page"},{"location":"ch08/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"[2]: Emanuel Gull, Philipp Werner, Olivier Parcollet, Matthias Troyer, EPL 82, 57003 (2008)","category":"page"},{"location":"ch08/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"[3]: Philipp Werner, Armin Comanac, Luca de’ Medici, Matthias Troyer, and Andrew J. Millis, Phys. Rev. Lett. 97, 076405 (2006)","category":"page"},{"location":"ch08/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"[4]: Junya Otsuki, Hiroaki Kusunose, Philipp Werner, and Yoshio Kuramoto, J. Phys. Soc. Jpn. 76, 114707 (2007)","category":"page"},{"location":"ch02/multi.html#Contents","page":"Contents","title":"Contents","text":"","category":"section"},{"location":"ch02/multi.html","page":"Contents","title":"Contents","text":"Well, maybe you don't like to compile the whole iQIST at one step. You want more controls about the compiling procedure, or you just don't want to waste time on compiling the components, or you even don't indend to compile/have. OK, the compiling system of iQIST provide an alternative way to meet your requirements.","category":"page"},{"location":"ch02/multi.html","page":"Contents","title":"Contents","text":"Anyway, the compiling procedure can be split into three successive steps:","category":"page"},{"location":"ch02/multi.html","page":"Contents","title":"Contents","text":"Build quantum impurity solvers\nBuild atomic eigenvalues solver\nBuild documentation","category":"page"},{"location":"ch02/multi.html","page":"Contents","title":"Contents","text":"These steps are optional. You can do the above jobs in sequence or in a random manner.","category":"page"},{"location":"ch08/basic.html#Outline","page":"Outline","title":"Outline","text":"","category":"section"},{"location":"ch08/basic.html","page":"Outline","title":"Outline","text":"In this section, you will learn the basic principles of continuous-time quantum Monte Carlo impurity solver. Especially, the powerful hybridization expansion version is emphasized.","category":"page"},{"location":"ch08/basic.html","page":"Outline","title":"Outline","text":"Quantum impurity model // Anderson impurity model.\nPrinciples of continuous-time quantum Monte Carlo algorithm // Diagrammatic Monte Carlo.\nHybridization expansion // Core spirit of it.","category":"page"},{"location":"ch04/in_ctqmc.html#solver.ctqmc.in","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"","category":"section"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"Introduction","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"The solver.ctqmc.in file is the only configuration file for the continuous-time quantum Monte Carlo impurity solver. You can setup the parameters for the quantum impurity solvers in it. Besides the Fortran API, this is the only way to setup the parameters for the quantum impurity solvers. But we have to emphasize that this file is optional. In other words, the CT-QMC impurity solvers can run without it.","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"There are many input parameters for the CT-QMC impurity solvers. But all of parameters have default values. If the solver.ctqmc.in file is absent, the quantum impurity solvers will use the default values. If the solver.ctqmc.in file is present, the quantum impurity solvers will read it, parse it, and apply the settings in it to initialize the quantum impurity solvers. The default values for the parameters are designed for a single-band Hubbard model. Thus in most cases, you need a solver.ctqmc.in file to override the default settings.","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"Format","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"All of the CT-QMC impurity solvers in the iQIST software package share the same solver.ctqmc.in file. In other words, you can exchange solver.ctqmc.in files between different CT-QMC quantum impurity solvers. The format of the solver.ctqmc.in file adopts the simple \"key-value\" style. The detailed rules are as follows:","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"(1) Anything after \"#\" and \"!\" character will be treated as comments and will be ignored completely.","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"example:\n# this is a comment line\n! this is a comment line\nnband = 4 # this is in line comment\nnorbs = 8 ! this in line comment","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"(2) It is not case sensitive.","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"example:\nNband = 4\nNORBS = 8\nNspiN = 2","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"(3) The key and value pair is separated by \"=\" or \":\" character.","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"example:\nnband = 4 ! you can use nband : 4\nnorbs : 8 ! you can use norbs = 8","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"(4) Any space will be ignored. Any blank lines will be skipped as well.","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"example:\nn b a n d = 4 ! it is valid\nno   rb s = 8 ! it is valid","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"(5) You can only use one line to define one key-value pair.","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"example\nnband = 4 norbs = 8  ! it is not valid\nnband = 4, norbs = 8 ! it is not valid\nnband = 4; norbs = 8 ! it is not valid\nnband =              !\n4                    ! it is not valid","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"(6) In the value part, now only integer, real(dp), logical, and character data type are supported.","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"example:\nnband = 4        ! integer type\nmune  = 4.0      ! real(dp) type\nisscf = .true.   ! logical type, you can also use .false., T, F\nmodel = anderson ! character type, do not use \"\" or '' characters to quote it","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"(7) In the value part, a vector is also support. The items in the vector  should be separated by \",\" character.","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"example:\nnband = 1, 2, 3, 4                   ! 4 items\nmune = 0.0, -1.0, 2.0                ! 3 items\nisscf = .true., .true., F, T, .true. ! 5 items\nmodel = anderson, hubbard            ! 2 items","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"(8) An empty input file is acceptable.","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"(9) If one key occurs in the input file for more than 1 times, only the last occurrence is recognized.","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"warning: Warning\nWe mention that the quantum impurity solvers will not check whether the settings in the solver.ctqmc.in file are reasonable and correct. It is the user's responsibility.","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"Code","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"N/A","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"tip: Tip\nIn the Flink library, we implement a parser to parse the solver.ctqmc.in file.","category":"page"},{"location":"glossary.html#Glossary","page":"Glossary","title":"Glossary","text":"","category":"section"},{"location":"glossary.html","page":"Glossary","title":"Glossary","text":"Teerminology Explanation\nQMC Quantum Monte Carlo\nSOC Spin-Orbit Coupling\nBLAS Basic Linear Algebra Subprograms\nLAPACK Linear Algebra Package\nFFT Fast Fourier transform\nMEM Maximum Entropy Method\nSAC Stochastic Analytical Continuation\nOpenMP Open Multi-Processing\nMPI Message Passing Interface\nDFT Density Functional Theory\nDF Dual Fermions\nDMFT Dynamical Mean-Field Theory\nQIM Quantum Impurity Models\nAIM Anderson Impurity Models\nCT-QMC Continuous-Time Quantum Monte Carlo impurity solvers\nCT-HYB Hybridization expansion version CT-QMC\nCT-INT Interaction expansion version CT-QMC\nHF-QMC Hirsch-Fye Quantum Monte Carlo impurity solvers","category":"page"},{"location":"ch04/p_ntherm.html#Parameter:-ntherm","page":"ntherm","title":"Parameter: ntherm","text":"","category":"section"},{"location":"ch04/p_ntherm.html","page":"ntherm","title":"ntherm","text":"Definition","category":"page"},{"location":"ch04/p_ntherm.html","page":"ntherm","title":"ntherm","text":"Maximum number of Monte Carlo thermalization steps.","category":"page"},{"location":"ch04/p_ntherm.html","page":"ntherm","title":"ntherm","text":"Type","category":"page"},{"location":"ch04/p_ntherm.html","page":"ntherm","title":"ntherm","text":"Integer","category":"page"},{"location":"ch04/p_ntherm.html","page":"ntherm","title":"ntherm","text":"Default value","category":"page"},{"location":"ch04/p_ntherm.html","page":"ntherm","title":"ntherm","text":"200000 for CT-HYB impurity solvers","category":"page"},{"location":"ch04/p_ntherm.html","page":"ntherm","title":"ntherm","text":"Component","category":"page"},{"location":"ch04/p_ntherm.html","page":"ntherm","title":"ntherm","text":"ALL","category":"page"},{"location":"ch04/p_ntherm.html","page":"ntherm","title":"ntherm","text":"Behavior","category":"page"},{"location":"ch04/p_ntherm.html","page":"ntherm","title":"ntherm","text":"Before starting to measure the physical observables, we have to ensure the system has reached thermal equilibrium state. So during the first ntherm Monte Carlo steps, the quantum impurity solvers just update the diagrammatic configuration, but don't record the physical quantities.","category":"page"},{"location":"ch04/p_ntherm.html","page":"ntherm","title":"ntherm","text":"Comment","category":"page"},{"location":"ch04/p_ntherm.html","page":"ntherm","title":"ntherm","text":"According to our experience, the optimal value for ntherm can be one tenth of the value of nsweep. See nsweep parameter for more details.","category":"page"},{"location":"ch04/p_nwrite.html#Parameter:-nwrite","page":"nwrite","title":"Parameter: nwrite","text":"","category":"section"},{"location":"ch04/p_nwrite.html","page":"nwrite","title":"nwrite","text":"Definition","category":"page"},{"location":"ch04/p_nwrite.html","page":"nwrite","title":"nwrite","text":"Output period for the quantum impurity solvers.","category":"page"},{"location":"ch04/p_nwrite.html","page":"nwrite","title":"nwrite","text":"Type","category":"page"},{"location":"ch04/p_nwrite.html","page":"nwrite","title":"nwrite","text":"Integer","category":"page"},{"location":"ch04/p_nwrite.html","page":"nwrite","title":"nwrite","text":"Default value","category":"page"},{"location":"ch04/p_nwrite.html","page":"nwrite","title":"nwrite","text":"2000000","category":"page"},{"location":"ch04/p_nwrite.html","page":"nwrite","title":"nwrite","text":"Component","category":"page"},{"location":"ch04/p_nwrite.html","page":"nwrite","title":"nwrite","text":"ALL","category":"page"},{"location":"ch04/p_nwrite.html","page":"nwrite","title":"nwrite","text":"Behavior","category":"page"},{"location":"ch04/p_nwrite.html","page":"nwrite","title":"nwrite","text":"This parameter controls the output frequency of the quantum impurity solvers. The quantum impurity solvers will output the intermediate results to disk files and run-time information to the terminal for every nwrite Monte Carlo sampling step. As for the continuous-time quantum Monte Carlo impurity solvers, the so-called intermediate results mean the histogram for the perturbation expansion series.Especially, the CT-HYB quantum impurity solvers will save the current diagram configurations to the solver.diag.dat file every nwrite Monte Carlo sampling step. Then, you can use the u_movie.py script to make an animation movie.","category":"page"},{"location":"ch04/p_nwrite.html","page":"nwrite","title":"nwrite","text":"Comment","category":"page"},{"location":"ch04/p_nwrite.html","page":"nwrite","title":"nwrite","text":"See also the nsweep parameter, solver.diag.dat file, script/u_movie.py tool for more details.","category":"page"},{"location":"ch01/components.html#Components","page":"Components","title":"Components","text":"","category":"section"},{"location":"ch01/components.html","page":"Components","title":"Components","text":"The iQIST software package is much more complex and powerful than what you can imagine. It contains several components which can be used to solve various impurity problems, prepare the input files, post-process the calculated results, etc. According to their abilities and functions, the components of the iQIST software package can be classified into the following catalogues:","category":"page"},{"location":"ch01/components.html","page":"Components","title":"Components","text":"","category":"page"},{"location":"ch01/components.html","page":"Components","title":"Components","text":"Continuous-time quantum impurity solvers","category":"page"},{"location":"ch01/components.html","page":"Components","title":"Components","text":"NARCISSUS component\nMANJUSHAKA component","category":"page"},{"location":"ch01/components.html","page":"Components","title":"Components","text":"For the details of these quantum impurity solvers, please see the chapter Quantum impurity solvers.","category":"page"},{"location":"ch01/components.html","page":"Components","title":"Components","text":"","category":"page"},{"location":"ch01/components.html","page":"Components","title":"Components","text":"Atomic eigenvalue problem solver","category":"page"},{"location":"ch01/components.html","page":"Components","title":"Components","text":"JASMINE component","category":"page"},{"location":"ch01/components.html","page":"Components","title":"Components","text":"For the details of these tools, please see the chapters [Atomic eigenvalue problem solver].","category":"page"},{"location":"ch01/components.html","page":"Components","title":"Components","text":"","category":"page"},{"location":"ch01/components.html","page":"Components","title":"Components","text":"Miscellanies","category":"page"},{"location":"ch01/components.html","page":"Components","title":"Components","text":"Besides the above components, the iQIST software package also includes many useful and interesting things, such as:","category":"page"},{"location":"ch01/components.html","page":"Components","title":"Components","text":"The Reference Manual (It is me!)\nTutorials\nMany testings\nUseful tools","category":"page"},{"location":"ch08/atomic.html#Atomic-eigenvalue-solver","page":"Atomic eigenvalue solver","title":"Atomic eigenvalue solver","text":"","category":"section"},{"location":"ch08/atomic.html","page":"Atomic eigenvalue solver","title":"Atomic eigenvalue solver","text":"The JASMINE component of iQIST software package is used to solve a local atomic Hamiltonian defined as,","category":"page"},{"location":"ch08/atomic.html","page":"Atomic eigenvalue solver","title":"Atomic eigenvalue solver","text":"beginequation\nhatH_textatom=hatH_0+hatH_textCoulomb\nendequation","category":"page"},{"location":"ch08/atomic.html","page":"Atomic eigenvalue solver","title":"Atomic eigenvalue solver","text":"where, hatH_0 is the on-site term, and hatH_textCoulomb is the Coulomb interaction term.","category":"page"},{"location":"ch08/atomic.html","page":"Atomic eigenvalue solver","title":"Atomic eigenvalue solver","text":"The hatH_0 term includes the crystal field (CF) splitting term hatH_textCF, spin-orbit coupling (SOC) term hatH_textSOC, and other terms such as a Zeeman term in case of the presence of external magnetic field,","category":"page"},{"location":"ch08/atomic.html","page":"Atomic eigenvalue solver","title":"Atomic eigenvalue solver","text":"beginequation\nhatH_0=hatH_textCF+hatH_textSOC+textother on-site terms\nendequation","category":"page"},{"location":"ch08/atomic.html","page":"Atomic eigenvalue solver","title":"Atomic eigenvalue solver","text":"We can re-write the hatH_textatom in second quantization form,","category":"page"},{"location":"ch08/atomic.html","page":"Atomic eigenvalue solver","title":"Atomic eigenvalue solver","text":"beginequation\nhatH_textatom=sum_alphabetaE_alphabetahatf_alpha^daggerhatf_beta\n                     +sum_alphabetagammadeltaU_alphabetagammadeltahatf_alpha^dagger\n                     hatf_beta^daggerhatf_deltahatf_gamma\nendequation","category":"page"},{"location":"ch08/atomic.html","page":"Atomic eigenvalue solver","title":"Atomic eigenvalue solver","text":"where, alphabetagammadelta is the single particle orbital-spin index, the first term is the on-site term, the second one is the Coulomb interaction term.","category":"page"},{"location":"ch02/full.html#Build-iQIST-at-one-step","page":"Build iQIST at one step","title":"Build iQIST at one step","text":"","category":"section"},{"location":"ch02/full.html","page":"Build iQIST at one step","title":"Build iQIST at one step","text":"When the system is ready and the compiling environment is configured correctly, you can try to compile the iQIST software package right now. Let's start now.","category":"page"},{"location":"ch02/full.html","page":"Build iQIST at one step","title":"Build iQIST at one step","text":"$ cd iqist/build\n$ editor make.inc\n$ make all","category":"page"},{"location":"ch02/full.html","page":"Build iQIST at one step","title":"Build iQIST at one step","text":"note: Note\nHere editor means any ascii text editor you prefer. The vim is our favorite.","category":"page"},{"location":"ch02/full.html","page":"Build iQIST at one step","title":"Build iQIST at one step","text":"After a few minutes (it depends on the performance of your system), if everything is OK you will find some executable programs in the iqist/src/ directory, which means the compiling is completed. Now all of the components of the iQIST software package are successfully built. Congratulations! You can start to enjoy using iQIST and begin with your great research!","category":"page"},{"location":"ch02/full.html","page":"Build iQIST at one step","title":"Build iQIST at one step","text":"However, don't get frustrated once the compiling fails. It is wise for you to type the following command in the terminal:","category":"page"},{"location":"ch02/full.html","page":"Build iQIST at one step","title":"Build iQIST at one step","text":"$ make clean","category":"page"},{"location":"ch02/full.html","page":"Build iQIST at one step","title":"Build iQIST at one step","text":"Then you go to check and correct the make.inc file, fix the other system-related issues, and repeat the above procedures. We are sure that you will solve this problem successfully.","category":"page"},{"location":"ch02/full.html","page":"Build iQIST at one step","title":"Build iQIST at one step","text":"Do you expect a more controllable compiling procedure? Some other great ideas are given in the next section.","category":"page"},{"location":"ch01/what.html#What's-iQIST?","page":"What's iQIST?","title":"What's iQIST?","text":"","category":"section"},{"location":"ch01/what.html","page":"What's iQIST?","title":"What's iQIST?","text":"The Interacting Quantum Impurity Solver Toolkit (dubbed iQIST) is an open source software package aiming to provide a full, reliable, flexible, and powerful tool chain for various quantum impurity models. The major objective of iQIST is to be the core (computational) engine of the dynamical mean-field theory and its extensions.","category":"page"},{"location":"ch01/what.html","page":"What's iQIST?","title":"What's iQIST?","text":"The iQIST software package offers a few continuous-time quantum Monte Carlo impurity solvers (hybridization expansion version), and some prep-processed and post-processed tools. It is an all-in-one software package. With it you can solve quantum impurity models and analyze the calculated results easily and efficiently. Of course, you can extend it or build complicated programs with it to fit your special requirements.","category":"page"},{"location":"ch01/what.html","page":"What's iQIST?","title":"What's iQIST?","text":"(Image: logo image)","category":"page"},{"location":"ch01/what.html","page":"What's iQIST?","title":"What's iQIST?","text":"Figure | The logo of the iQIST software package.","category":"page"},{"location":"ch04/index.html#Contents","page":"Contents","title":"Contents","text":"","category":"section"},{"location":"ch04/index.html","page":"Contents","title":"Contents","text":"It is time to look inside the quantum impurity solvers implemented in the iQIST software package. In this chapter, we will explain the essential information about how to setup the quantum impurity solvers components. This is the most important chapter in this manual. Even if you are already an expert of the iQIST software package, this chapter is still helpful.","category":"page"},{"location":"ch04/index.html","page":"Contents","title":"Contents","text":"The contents in this chapter are related with the following components:","category":"page"},{"location":"ch04/index.html","page":"Contents","title":"Contents","text":"NARCISSUS\nMANJUSHAKA","category":"page"},{"location":"ch04/index.html","page":"Contents","title":"Contents","text":"The main topics are as follows:","category":"page"},{"location":"ch04/index.html","page":"Contents","title":"Contents","text":"How to choose suitable quantum impurity solvers? // So many CT-HYB quantum impurity solvers!?\nStandard input files // Input stuffs.\nStandard output files // Output stuffs.\nParameters // Really a reference manual.","category":"page"},{"location":"ch04/index.html","page":"Contents","title":"Contents","text":"Maybe you are interested in the following related topics:","category":"page"},{"location":"ch04/index.html","page":"Contents","title":"Contents","text":"Getting started // To teach you how to setup and use the iQIST software package.\n[Atomic eigenvalue problem solver] // Another reference manual.\n[Auxiliary tools] // The companion of quantum impurity solvers.\n[iQIST in action] // Some lightweight tutorials.\n[Inside iQIST] // Unleashing the secrets inside the iQIST.","category":"page"},{"location":"ch04/index.html","page":"Contents","title":"Contents","text":"See also:","category":"page"},{"location":"ch04/index.html","page":"Contents","title":"Contents","text":"Besides the above links, you can find many useful examples/cases under the iqist/test/ and iqist/tutor directories.","category":"page"},{"location":"ch05/p_icf.html#Parameter:-icf","page":"icf","title":"Parameter: icf","text":"","category":"section"},{"location":"ch05/p_icf.html","page":"icf","title":"icf","text":"Definition","category":"page"},{"location":"ch05/p_icf.html","page":"icf","title":"icf","text":"Key control flag, to define the type of crystal field splitting.","category":"page"},{"location":"ch05/p_icf.html","page":"icf","title":"icf","text":"Type","category":"page"},{"location":"ch05/p_icf.html","page":"icf","title":"icf","text":"Integer","category":"page"},{"location":"ch05/p_icf.html","page":"icf","title":"icf","text":"Default value","category":"page"},{"location":"ch05/p_icf.html","page":"icf","title":"icf","text":"0","category":"page"},{"location":"ch05/p_icf.html","page":"icf","title":"icf","text":"Component","category":"page"},{"location":"ch05/p_icf.html","page":"icf","title":"icf","text":"Only for the JASMINE component.","category":"page"},{"location":"ch05/p_icf.html","page":"icf","title":"icf","text":"Behavior","category":"page"},{"location":"ch05/p_icf.html","page":"icf","title":"icf","text":"There are three possible values for the icf parameter:icf = 0, no crystal field splitting.\nicf = 1, diagonal crystal field splitting.\nicf = 2, non-diagonal crystal field splitting.","category":"page"},{"location":"ch05/p_icf.html","page":"icf","title":"icf","text":"Comment","category":"page"},{"location":"ch05/p_icf.html","page":"icf","title":"icf","text":"The crystal field splitting can be read from the atom.cmat.in file. See also atom.cmat.in for more details.","category":"page"},{"location":"ch04/p_alpha.html#Parameter:-alpha","page":"alpha","title":"Parameter: alpha","text":"","category":"section"},{"location":"ch04/p_alpha.html","page":"alpha","title":"alpha","text":"Definition","category":"page"},{"location":"ch04/p_alpha.html","page":"alpha","title":"alpha","text":"Mixing parameter alpha for dynamical mean-field theory self-consistent engine.","category":"page"},{"location":"ch04/p_alpha.html","page":"alpha","title":"alpha","text":"Type","category":"page"},{"location":"ch04/p_alpha.html","page":"alpha","title":"alpha","text":"Float, double precision","category":"page"},{"location":"ch04/p_alpha.html","page":"alpha","title":"alpha","text":"Default value","category":"page"},{"location":"ch04/p_alpha.html","page":"alpha","title":"alpha","text":"0.7","category":"page"},{"location":"ch04/p_alpha.html","page":"alpha","title":"alpha","text":"Component","category":"page"},{"location":"ch04/p_alpha.html","page":"alpha","title":"alpha","text":"ALL","category":"page"},{"location":"ch04/p_alpha.html","page":"alpha","title":"alpha","text":"Behavior","category":"page"},{"location":"ch04/p_alpha.html","page":"alpha","title":"alpha","text":"In the dynamical mean-field theory self-consistent engine, the new hybridization function and self-energy function are mixed using the following equations.beginequation\nDelta_textnew leftarrow Delta_textold(1-alpha) + alpha Delta_textnew\nendequationbeginequation\nSigma_textnew leftarrow Sigma_textold(1-alpha) + alpha Sigma_textnew\nendequationHere, Delta_textold and Sigma_textold are obtained in the previous iteration, while Delta_textnew and Sigma_textnew are derived in the current iteration.","category":"page"},{"location":"ch04/p_alpha.html","page":"alpha","title":"alpha","text":"Comment","category":"page"},{"location":"ch04/p_alpha.html","page":"alpha","title":"alpha","text":"If you have trouble in achieving convergence, you can decrease it to 0.5 or even 0.2. If you are doing one-shot calculation (isscf = 1), this parameter is useless. It is useful only when isscf = 2.See also isscf parameter for more details.","category":"page"},{"location":"ch05/p_nspin.html#Parameter:-nspin","page":"nspin","title":"Parameter: nspin","text":"","category":"section"},{"location":"ch05/p_nspin.html","page":"nspin","title":"nspin","text":"warning: Warning\nPlease DO NOT modify it.","category":"page"},{"location":"ch05/p_nspin.html","page":"nspin","title":"nspin","text":"Definition:","category":"page"},{"location":"ch05/p_nspin.html","page":"nspin","title":"nspin","text":"Number of spin projection.","category":"page"},{"location":"ch05/p_nspin.html","page":"nspin","title":"nspin","text":"Type","category":"page"},{"location":"ch05/p_nspin.html","page":"nspin","title":"nspin","text":"Integer","category":"page"},{"location":"ch05/p_nspin.html","page":"nspin","title":"nspin","text":"Default value","category":"page"},{"location":"ch05/p_nspin.html","page":"nspin","title":"nspin","text":"2","category":"page"},{"location":"ch05/p_nspin.html","page":"nspin","title":"nspin","text":"Component","category":"page"},{"location":"ch05/p_nspin.html","page":"nspin","title":"nspin","text":"Only for the JASMINE component.","category":"page"},{"location":"ch05/p_nspin.html","page":"nspin","title":"nspin","text":"Behavior","category":"page"},{"location":"ch05/p_nspin.html","page":"nspin","title":"nspin","text":"Determine the size of involved arrays.","category":"page"},{"location":"ch05/p_nspin.html","page":"nspin","title":"nspin","text":"Comment","category":"page"},{"location":"ch05/p_nspin.html","page":"nspin","title":"nspin","text":"See nband, norbs, and ncfgs parameters for more details.","category":"page"},{"location":"thanks.html#Acknowledgements","page":"Acknowledgements","title":"Acknowledgements","text":"","category":"section"},{"location":"thanks.html","page":"Acknowledgements","title":"Acknowledgements","text":"tip: FUNDINGS\nThis project has been financed by the following fundings:DARPA Grant No. D13AP00052 (LD)\nSwiss National Science Foundation, Grant No. 200021_140648 (PW, LH)\nNational Science Foundation of China, No. 2011CBA00108 (XD, YLW)\nNational Science Foundation of China, No. 11504340, 12274380, 11934020 (LH)","category":"page"},{"location":"ch05/p_ictqmc.html#Parameter:-ictqmc","page":"ictqmc","title":"Parameter: ictqmc","text":"","category":"section"},{"location":"ch05/p_ictqmc.html","page":"ictqmc","title":"ictqmc","text":"Definition","category":"page"},{"location":"ch05/p_ictqmc.html","page":"ictqmc","title":"ictqmc","text":"Key control flag, define which algorithm is used to diagonalize the atomic Hamiltonian matrix.","category":"page"},{"location":"ch05/p_ictqmc.html","page":"ictqmc","title":"ictqmc","text":"Type","category":"page"},{"location":"ch05/p_ictqmc.html","page":"ictqmc","title":"ictqmc","text":"Integer","category":"page"},{"location":"ch05/p_ictqmc.html","page":"ictqmc","title":"ictqmc","text":"Default value","category":"page"},{"location":"ch05/p_ictqmc.html","page":"ictqmc","title":"ictqmc","text":"1","category":"page"},{"location":"ch05/p_ictqmc.html","page":"ictqmc","title":"ictqmc","text":"Component","category":"page"},{"location":"ch05/p_ictqmc.html","page":"ictqmc","title":"ictqmc","text":"Only for the JASMINE component.","category":"page"},{"location":"ch05/p_ictqmc.html","page":"ictqmc","title":"ictqmc","text":"Behavior","category":"page"},{"location":"ch05/p_ictqmc.html","page":"ictqmc","title":"ictqmc","text":"There are five possible values for the ictqmc parameter:ictqmc = 1, direct diagonalization in full Hilbert space. The generated atom.cix file is only suitable for the LAVENDER code. actually, the LAVENDER code has been deprecated, so we keep this option only for reference.\nictqmc = 2, subspace diagonalization using good quantum number N. The generated atom.cix file is only suitable for the MANJUSHAKA code.\nictqmc = 3, subspace diagonalization using good quantum numbers N, S_z. The generated atom.cix file is only suitable for the MANJUSHAKA code.\nictqmc = 4, subspace diagonalization using good quantum numbers N, S_z, PS. The generated atom.cix file is only suitable for the MANJUSHAKA code.\nictqmc = 5, subspace diagonalization using good quantum numbers N, J_z. The generated atom.cix file is only suitable for the MANJUSHAKA code.When ictqmc = 4, it is not compatible with icu = 2.","category":"page"},{"location":"ch05/p_ictqmc.html","page":"ictqmc","title":"ictqmc","text":"Comment","category":"page"},{"location":"ch05/p_ictqmc.html","page":"ictqmc","title":"ictqmc","text":"See also icu for more details.","category":"page"},{"location":"ch05/p_lambda.html#Parameter:-lambda","page":"lambda","title":"Parameter: lambda","text":"","category":"section"},{"location":"ch05/p_lambda.html","page":"lambda","title":"lambda","text":"Definition","category":"page"},{"location":"ch05/p_lambda.html","page":"lambda","title":"lambda","text":"Strength of the spin-orbit coupling lambda.","category":"page"},{"location":"ch05/p_lambda.html","page":"lambda","title":"lambda","text":"Type","category":"page"},{"location":"ch05/p_lambda.html","page":"lambda","title":"lambda","text":"Float, double precision","category":"page"},{"location":"ch05/p_lambda.html","page":"lambda","title":"lambda","text":"Default value","category":"page"},{"location":"ch05/p_lambda.html","page":"lambda","title":"lambda","text":"0.0","category":"page"},{"location":"ch05/p_lambda.html","page":"lambda","title":"lambda","text":"Component","category":"page"},{"location":"ch05/p_lambda.html","page":"lambda","title":"lambda","text":"Only for the JASMINE component.","category":"page"},{"location":"ch05/p_lambda.html","page":"lambda","title":"lambda","text":"Behavior","category":"page"},{"location":"ch05/p_lambda.html","page":"lambda","title":"lambda","text":"This parameter is used to build the spin-orbit coupling term of the local interaction Hamiltonian. It is valid only when isoc = 1.hatH_textSOC = lambda hattextbfl cdot hattextbfs","category":"page"},{"location":"ch05/p_lambda.html","page":"lambda","title":"lambda","text":"Comment","category":"page"},{"location":"ch05/p_lambda.html","page":"lambda","title":"lambda","text":"See also isoc parameter for more details.","category":"page"},{"location":"ch04/p_isspn.html#Parameter:-isspn","page":"isspn","title":"Parameter: isspn","text":"","category":"section"},{"location":"ch04/p_isspn.html","page":"isspn","title":"isspn","text":"Definition","category":"page"},{"location":"ch04/p_isspn.html","page":"isspn","title":"isspn","text":"Key control flag, determine the symmetry of spin orientation freedom of degree.","category":"page"},{"location":"ch04/p_isspn.html","page":"isspn","title":"isspn","text":"Type","category":"page"},{"location":"ch04/p_isspn.html","page":"isspn","title":"isspn","text":"Integer","category":"page"},{"location":"ch04/p_isspn.html","page":"isspn","title":"isspn","text":"Default value","category":"page"},{"location":"ch04/p_isspn.html","page":"isspn","title":"isspn","text":"1","category":"page"},{"location":"ch04/p_isspn.html","page":"isspn","title":"isspn","text":"Component","category":"page"},{"location":"ch04/p_isspn.html","page":"isspn","title":"isspn","text":"ALL","category":"page"},{"location":"ch04/p_isspn.html","page":"isspn","title":"isspn","text":"Behavior","category":"page"},{"location":"ch04/p_isspn.html","page":"isspn","title":"isspn","text":"There are two possible values for the isspn parameter so far:isspn = 1, let spin up and spin down states evolve independently.\nisspn = 2, enforce spin up = spin down.The quantum impurity solvers will symmetrize the relevant physical quantities according to the isspn parameter.","category":"page"},{"location":"ch04/p_isspn.html","page":"isspn","title":"isspn","text":"Comment","category":"page"},{"location":"ch04/p_isspn.html","page":"isspn","title":"isspn","text":"Usually, the isspn and isbnd are used at the same time to setup the magnetic order of the system. For example, if you want to simulate a model with anti-ferromagnetic order, then isspn should be 1, and isbnd can be 1 or 2 (a solver.eimp.in file must be available for the latter case).See isbnd parameter for more details.","category":"page"},{"location":"team.html#The-iQIST-Developer-Team","page":"Team","title":"The iQIST Developer Team","text":"","category":"section"},{"location":"team.html","page":"Team","title":"Team","text":"Current Maintainer:","category":"page"},{"location":"team.html","page":"Team","title":"Team","text":"Li Huang^dagger","category":"page"},{"location":"team.html","page":"Team","title":"Team","text":"Core Developers:","category":"page"},{"location":"team.html","page":"Team","title":"Team","text":"Li Huang^dagger and Yilin Wang^ddagger","category":"page"},{"location":"team.html","page":"Team","title":"Team","text":"Key Contributors:","category":"page"},{"location":"team.html","page":"Team","title":"Team","text":"Liang Du^rceil","category":"page"},{"location":"team.html","page":"Team","title":"Team","text":"Directors and Supervisors:","category":"page"},{"location":"team.html","page":"Team","title":"Team","text":"Philipp Werner^ and Xi Dai^lceil","category":"page"},{"location":"team.html","page":"Team","title":"Team","text":"","category":"page"},{"location":"team.html","page":"Team","title":"Team","text":"^dagger Institute of Materials, China Academy of Engineering Physics, Jiangyou 621900, China","category":"page"},{"location":"team.html","page":"Team","title":"Team","text":"^ddagger School of Emerging Technology and Department of Physics, University of Science and Technology of China, Hefei 230026, China","category":"page"},{"location":"team.html","page":"Team","title":"Team","text":"^rceil College of Physics and Technology, Guangxi Normal University, Guilin 541004, China","category":"page"},{"location":"team.html","page":"Team","title":"Team","text":"^ Department of Physics, University of Fribourg, 1700 Fribourg, Switzerland","category":"page"},{"location":"team.html","page":"Team","title":"Team","text":"^lceil Department of Physics, The Hongkong University of Science and Technology, Clear Water Bay, Kowloon 999077, Hong Kong, China","category":"page"},{"location":"ch01/policy.html#Policy","page":"Policy","title":"Policy","text":"","category":"section"},{"location":"ch01/policy.html#License","page":"Policy","title":"License","text":"","category":"section"},{"location":"ch01/policy.html","page":"Policy","title":"Policy","text":"The iQIST software package is released under the General Public Licence 3.0 (GPL) or later version.","category":"page"},{"location":"ch01/policy.html#Technical-support","page":"Policy","title":"Technical support","text":"","category":"section"},{"location":"ch01/policy.html","page":"Policy","title":"Policy","text":"We are sorry. We DO NOT provide any technical supports now. If you meet some problems when you are using the iQIST. You can write a letter to us or create an issue via github. But we can not guarantee that we will reply you on time.","category":"page"},{"location":"ch01/policy.html#Feedback","page":"Policy","title":"Feedback","text":"","category":"section"},{"location":"ch01/policy.html","page":"Policy","title":"Policy","text":"If you have any suggestions, comments, successful stories, or criticisms, welcome! Please write a letter to us or create an issue via github.","category":"page"},{"location":"ch01/policy.html#Contribution","page":"Policy","title":"Contribution","text":"","category":"section"},{"location":"ch01/policy.html","page":"Policy","title":"Policy","text":"If you find a bug, want to patch it, or want to contribute your codes to the iQIST, great! Please write a letter to us as soon as possible or create a pull request via github.","category":"page"},{"location":"ch01/policy.html#Contact","page":"Policy","title":"Contact","text":"","category":"section"},{"location":"ch01/policy.html","page":"Policy","title":"Policy","text":"Dr. Li HuangAffiliation: Institute of Materials, China Academy of Engineering Physics, Sichuan Jiangyou, PRCEmail: huangli at caep.cn","category":"page"},{"location":"ch01/policy.html#Citation","page":"Policy","title":"Citation","text":"","category":"section"},{"location":"ch01/policy.html","page":"Policy","title":"Policy","text":"It is really appreciated if you can cite the following paper when you would like to publish your great works by using the iQIST software package. It is really important for us. But, of course, it is also not obligated.","category":"page"},{"location":"ch01/policy.html","page":"Policy","title":"Policy","text":"iQIST: An open source continuous-time quantum Monte Carlo impurity solver toolkitLi Huang, Yilin Wang, Zi Yang Meng, Liang Du, Philipp Werner and Xi DaiComputer Physics Communications 195, 140 (2015)","category":"page"},{"location":"ch01/policy.html","page":"Policy","title":"Policy","text":"iQIST v0.7: An open source continuous-time quantum Monte Carlo impurity solver toolkitLi HuangComputer Physics Communications 221, 423 (2017)","category":"page"},{"location":"ch04/p_u.html#Parameter:-U","page":"U","title":"Parameter: U","text":"","category":"section"},{"location":"ch04/p_u.html","page":"U","title":"U","text":"Definition","category":"page"},{"location":"ch04/p_u.html","page":"U","title":"U","text":"Averaged Coulomb interaction U.","category":"page"},{"location":"ch04/p_u.html","page":"U","title":"U","text":"Type","category":"page"},{"location":"ch04/p_u.html","page":"U","title":"U","text":"Float, double precision","category":"page"},{"location":"ch04/p_u.html","page":"U","title":"U","text":"Default value","category":"page"},{"location":"ch04/p_u.html","page":"U","title":"U","text":"4.0","category":"page"},{"location":"ch04/p_u.html","page":"U","title":"U","text":"Component","category":"page"},{"location":"ch04/p_u.html","page":"U","title":"U","text":"ALL","category":"page"},{"location":"ch04/p_u.html","page":"U","title":"U","text":"Behavior","category":"page"},{"location":"ch04/p_u.html","page":"U","title":"U","text":"Actually, it is not used by the quantum impurity solvers to build the Coulomb interaction matrix. It will be output by the impurity solver as a reference. You can set it to any values. I forgot why I had designed this parameter.","category":"page"},{"location":"ch04/p_u.html","page":"U","title":"U","text":"Comment","category":"page"},{"location":"ch04/p_u.html","page":"U","title":"U","text":"See also Uc, Uv, Jz, Js and Jp parameters for more details.","category":"page"},{"location":"ch04/p_u.html","page":"U","title":"U","text":"warning: Warning\nIn the future, perhaps we will remove this parameter.","category":"page"},{"location":"ch08/basis.html#Single-particle-basis","page":"Single particle basis","title":"Single particle basis","text":"","category":"section"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"In this section, we define some single particle basis used in the JASMINE component to write down the atomic Hamiltonian hatH_textatom. We set hbar=1 in this note.","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"Spherical harmonics","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"The complex spherical harmonics Y_l^m(thetaphi) are the eigenstates of operators hatl^2 and hatl_z,","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nhatl^2Y_l^m=l(l+1)Y_l^m\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nhatl_zY_l^m=mY_l^m\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"where l is the azimuthal quantum number (l = 012cdotsn-1), and m is the magnetic quantum number (m=-l-l+1cdotsl)[1][2]. They are defined as follows:","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nY^m_l(thetaphi) = sqrtfrac2l+14pifrac(l-m)(l+m)\nP^m_l(costheta) e^imphi\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"where theta is taken as the polar (colatitudinal) coordinate with theta in 0pi, and phi as the azimuthal (longitudinal) coordinate with phi in 02pi, and P^m_l(z) is an associated Legendre polynomial.","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"The spherical harmonics are orthonormal","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nint^pi_theta = 0 int^2pi_phi = 0\nY^m_l(thetaphi) Y^m*_l(thetaphi)dOmega = delta_ll delta_mm\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"where delta_ij is the Kronecker delta and dOmega = sin(theta) dphi dtheta.","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"Real Spherical Harmonics","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"The real spherical harmonics Y_lm are defined as[3]","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"begingather\nY_lm=begincases\n  fracisqrt2left(Y_l^-m-(-1)^mY_l^mright)  textif m0\n  Y_l^0  textif m=0\n  frac1sqrt2left(Y_l^-m+(-1)^mY_l^mright)  textif m0\nendcases\nendgather","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"The corresponding inverse equations defining the complex spherical harmonics Y^m_l in terms of the real spherical harmonics Y_lm read:","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"begingather\nY_l^m=begincases\n  frac1sqrt2left(Y_lm-iY_l-mright)  textif m0\n  Y_l0  textif m=0\n  frac(-1)^msqrt2left(Y_lm+iY_l-mright)  textif m0\nendcases\nendgather","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"The real spherical harmonics Y_lm are sometimes known as tesseral spherical harmonics. These functions have the same orthonormality properties as the complex ones Y_l^m.","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"Spinor spherical harmonics","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"The spinor spherical harmonics Omega^l_jm_j(thetaphi) are eigenstates of the operators hatj^2, hatj_z, hatl^2, and hats^2,","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nhatj^2 Omega^l_jm_j = j (j + 1) Omega^l_jm_j\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nhatj_z Omega^l_jm_j = m_j Omega^l_jm_j\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nhatl^2 Omega^l_jm_j = l (l + 1) Omega^l_jm_j\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nhats^2 Omega^l_jm_j = s(s+1) Omega^l_jm_j\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"For given j only two values of l are possible, l = j pm frac12, while m_j assumes 2j + 1 values (m_j = -j-j + 1cdotsj - 1j) [1][2].","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"For j = l + frac12, m_j = m + frac12,","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nOmega^l_jm_j = sqrtfracl+m+12l+1 Y^m_l chi_uparrow\n                + sqrtfracl-m2l+1 Y^m+1_l chi_downarrow\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"For j = l - frac12 (l neq 0), m_j = m + frac12,","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nOmega^l_jm_j = -sqrtfracl-m2l+1 Y^m_l chi_uparrow\n                + sqrtfracl+m+12l+1 Y^m+1_l chi_downarrow\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"Real orbital basis","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"The basis functions are the real spherical harmonics Y_lm(thetaphi).","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"For p system, the basis order is[4]","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nbeginsplit\n\np_y uparrow rangle\np_z uparrow rangle\np_x uparrow rangle\n\np_y downarrow rangle\np_z downarrow rangle\np_x downarrow rangle\nendsplit\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\np_yrangle = Y_1-1=fracisqrt2left(Y_1^-1+Y_1^1right)\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\np_zrangle =  Y_10=Y_1^0\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\np_xrangle  =  Y_11=frac1sqrt2left(Y_1^-1-Y_1^1right)\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"For d system, the basis order is[4]","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nbeginsplit\n\nd_xy uparrow rangle\nd_yz uparrow rangle\nd_z^2 uparrow rangle\nd_xz uparrow rangle\nd_x^2-y^2 uparrow rangle\n\nd_xy downarrow rangle\nd_yz downarrow rangle\nd_z^2 downarrow rangle\nd_xz downarrow rangle\nd_x^2-y^2 downarrow rangle\nendsplit\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nd_xy = Y_2-2=fracisqrt2left(Y_2^-2-Y_2^2right)\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nd_yz = Y_2-1=fracisqrt2left(Y_2^-1+Y_2^1right)\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nd_z^2 = Y_20=Y_2^0\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nd_xz = Y_21=frac1sqrt2left(Y_2^-1-Y_2^1right)\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nd_x^2-y^2 = Y_22=frac1sqrt2left(Y_2^-2+Y_2^2right)\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"For f system, the basis order is[4]","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nbeginsplit\n\nf_y(3x^2-y^2) uparrow rangle\nf_xyz uparrow rangle\nf_yz^2 uparrow rangle\nf_z^3 uparrow rangle\nf_xz^2 uparrow rangle\nf_z(x^2-y^2) uparrow rangle\nf_x(x^2-3y^2) uparrow rangle\n\nf_y(3x^2-y^2) downarrow rangle\nf_xyz downarrow rangle\nf_yz^2 downarrow rangle\nf_z^3 downarrow rangle\nf_xz^2 downarrow rangle\nf_z(x^2-y^2) downarrow rangle\nf_x(x^2-3y^2) downarrow rangle\nendsplit\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nf_y(3x^2-y^2) = Y_3-3=fracisqrt2left(Y_3^-3+Y_3^3right)\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nf_xyz = Y_3-2=fracisqrt2left(Y_3^-2-Y_3^2right)\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nf_yz^2 = Y_3-1=fracisqrt2left(Y_3^-1+Y_3^1right)\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nf_z^3 = Y_30=Y_3^0\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nf_xz^2 = Y_31=frac1sqrt2left(Y_3^-1-Y_3^1right)\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nf_z(x^2-y^2) = Y_32=frac1sqrt2left(Y_3^-2+Y_3^2right)\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nf_x(x^2-3y^2) = Y_33=frac1sqrt2left(Y_3^-3-Y_3^3right)\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"For t_2g system, we have a T-P equivalence,","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nd_xz rightarrow p_y=fracisqrt2left(Y_1^-1+Y_1^1right)\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nd_xy rightarrow p_z=Y_1^0\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nd_yz rightarrow p_x=frac1sqrt2left(Y_1^-1-Y_1^1right)\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"Complex orbital basis","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"It is also called the l^2l_zrangle basis. The basis functions are the complex spherical harmonics Y^m_l(thetaphi). We just use l and m to label the basis functions lmrangle.","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"For p system (l = 1m = pm 10), the basis order is","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nbeginsplit\n 1   -1 uparrow rangle \n 1 0 uparrow rangle \n 1 1 uparrow rangle \n 1   -1 downarrow rangle \n 1 0 downarrow rangle \n 1 1 downarrow rangle\nendsplit\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"For d system (l = 2m = pm 2pm 10), the basis order is","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nbeginsplit\n 2   -2 uparrow rangle \n 2   -1 uparrow rangle \n 2 0 uparrow rangle \n 2 1 uparrow rangle \n 2 2 uparrow rangle \n 2   -2 downarrow rangle \n 2   -1 downarrow rangle \n 2 0 downarrow rangle \n 2 1 downarrow rangle \n 2 2 downarrow rangle\nendsplit\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"For f system (l = 3m = pm 3pm 2pm 10), the basis order is","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nbeginsplit\n 3   -3 uparrow rangle \n 3   -2 uparrow rangle \n 3   -1 uparrow rangle \n 3 0 uparrow rangle \n 3 1 uparrow rangle \n 3 2 uparrow rangle \n 3 3 uparrow rangle \n 3   -3 downarrow rangle \n 3   -2 downarrow rangle \n 3   -1 downarrow rangle \n 3 0 downarrow rangle \n 3 1 downarrow rangle \n 3 2 downarrow rangle \n 3 3 downarrow rangle\nendsplit\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"hatj^2-hatj_z-hatl^2-hats^2 diagonal basis","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"We just use j and m_j to label the eigenfunctions j m_jrangle, which are just the spinor spherical harmonics Omega^l_jm_j(thetaphi).","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"For p system, l = 1, j = frac12 or frac32, the basis order is","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nbeginsplit\nleftfrac12 -frac12rightrangle   = -sqrtfrac23Y^-1_1chi_uparrow + sqrtfrac13Y^ 0_1chi_downarrow \nleftfrac12 frac12rightrangle = -sqrtfrac13Y^ 0_1chi_uparrow + sqrtfrac23Y^ 1_1chi_downarrow \nleftfrac32 -frac32rightrangle   =  sqrtfrac03Y^-2_1chi_uparrow + sqrtfrac33Y^-1_1chi_downarrow = Y^-1_1 chi_downarrow \nleftfrac32 -frac12rightrangle   =  sqrtfrac13Y^-1_1chi_uparrow + sqrtfrac23Y^ 0_1chi_downarrow \nleftfrac32 frac12rightrangle =  sqrtfrac23Y^ 0_1chi_uparrow + sqrtfrac13Y^ 1_1chi_downarrow \nleftfrac32 frac32rightrangle =  sqrtfrac33Y^ 1_1chi_uparrow + sqrtfrac03Y^ 2_1chi_downarrow = Y^1_1chi_uparrow\nendsplit\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"For d system, l = 2, j = frac32 or frac52, the basis order is","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nbeginsplit\nleftfrac32 -frac32rightrangle   = -sqrtfrac45Y^-2_2chi_uparrow + sqrtfrac15Y^-1_2chi_downarrow \nleftfrac32 -frac12rightrangle   = -sqrtfrac35Y^-1_2chi_uparrow + sqrtfrac25Y^ 0_2chi_downarrow \nleftfrac32 frac12rightrangle = -sqrtfrac25Y^ 0_2chi_uparrow + sqrtfrac35Y^ 1_2chi_downarrow \nleftfrac32 frac32rightrangle = -sqrtfrac15Y^ 1_2chi_uparrow + sqrtfrac45Y^ 2_2chi_downarrow \nleftfrac52 -frac52rightrangle   =  sqrtfrac05Y^-3_2chi_uparrow + sqrtfrac55Y^-2_2chi_downarrow = Y^-2_2chi_downarrow \nleftfrac52 -frac32rightrangle   =  sqrtfrac15Y^-2_2chi_uparrow + sqrtfrac45Y^-1_2chi_downarrow \nleftfrac52 -frac12rightrangle   =  sqrtfrac25Y^-1_2chi_uparrow + sqrtfrac35Y^ 0_2chi_downarrow \nleftfrac52 frac12rightrangle =  sqrtfrac35Y^ 0_2chi_uparrow + sqrtfrac25Y^ 1_2chi_downarrow \nleftfrac52 frac32rightrangle =  sqrtfrac45Y^ 1_2chi_uparrow + sqrtfrac15Y^ 2_2chi_downarrow \nleftfrac52 frac52rightrangle =  sqrtfrac55Y^ 2_2chi_uparrow + sqrtfrac05Y^ 3_2chi_downarrow = Y^2_2chi_uparrow\nendsplit\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"For f system, l = 3, j = frac52 or frac72, the basis order is","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nbeginsplit\nleftfrac52 -frac52rightrangle   = -sqrtfrac67Y^-3_3chi_uparrow + sqrtfrac17Y^-2_3chi_downarrow \nleftfrac52 -frac32rightrangle   = -sqrtfrac57Y^-2_3chi_uparrow + sqrtfrac27Y^-1_3chi_downarrow \nleftfrac52 -frac12rightrangle   = -sqrtfrac47Y^-1_3chi_uparrow + sqrtfrac37Y^ 0_3chi_downarrow \nleftfrac52 frac12rightrangle = -sqrtfrac37Y^ 0_3chi_uparrow + sqrtfrac47Y^ 1_3chi_downarrow \nleftfrac52 frac32rightrangle = -sqrtfrac27Y^ 1_3chi_uparrow + sqrtfrac57Y^ 2_3chi_downarrow \nleftfrac52 frac52rightrangle = -sqrtfrac17Y^ 2_3chi_uparrow + sqrtfrac67Y^ 3_3chi_downarrow \nleftfrac72 -frac72rightrangle   =  sqrtfrac07Y^-4_3chi_uparrow + sqrtfrac77Y^-3_3chi_downarrow = Y^-3_3chi_downarrow \nleftfrac72 -frac52rightrangle   =  sqrtfrac17Y^-3_3chi_uparrow + sqrtfrac67Y^-2_3chi_downarrow \nleftfrac72 -frac32rightrangle   =  sqrtfrac27Y^-2_3chi_uparrow + sqrtfrac57Y^-1_3chi_downarrow \nleftfrac72 -frac12rightrangle   =  sqrtfrac37Y^-1_3chi_uparrow + sqrtfrac47Y^ 0_3chi_downarrow \nleftfrac72 frac12rightrangle =  sqrtfrac47Y^ 0_3chi_uparrow + sqrtfrac37Y^ 1_3chi_downarrow \nleftfrac72 frac32rightrangle =  sqrtfrac57Y^ 1_3chi_uparrow + sqrtfrac27Y^ 2_3chi_downarrow \nleftfrac72 frac52rightrangle =  sqrtfrac67Y^ 2_3chi_uparrow + sqrtfrac17Y^ 3_3chi_downarrow \nleftfrac72 frac72rightrangle =  sqrtfrac77Y^ 3_3chi_uparrow + sqrtfrac07Y^ 4_3chi_downarrow = Y^3_3chi_uparrow \nendsplit\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"Natural basis","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"The natural basis is defined as the diagonal basis of on-site term E_alphabeta.","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"Transformation matrix from complex orbital basis to real orbital basis","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"For p system, the transformation matrix reads","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nT = left\nbeginarraycccccc\nfracisqrt2  0  frac1sqrt2  0  0  0 \n0  1  0  0  0  0 \nfracisqrt2  0  -frac1sqrt2  0  0  0 \nhline\n0  0  0  fracisqrt2  0  frac1sqrt2 \n0  0  0  0  1  0 \n0  0  0  fracisqrt2  0  -frac1sqrt2 \nendarray\nright\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"For d system, the transformation matrix reads","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"T = left\nbeginarraycccccccccc\nfracisqrt2  0  0  0  frac1sqrt2  0  0  0  0  0 \n0  fracisqrt2  0  frac1sqrt2  0  0  0  0  0  0 \n0  0  1  0  0  0  0  0  0  0 \n0  fracisqrt2  0  -frac1sqrt2  0  0  0  0  0  0 \n-fracisqrt2  0  0  0  frac1sqrt2  0  0  0  0  0 \nhline\n0  0  0  0  0  fracisqrt2  0  0  0  frac1sqrt2 \n0  0  0  0  0  0  fracisqrt2  0  frac1sqrt2  0 \n0  0  0  0  0  0  0  1  0  0 \n0  0  0  0  0  0  fracisqrt2  0  -frac1sqrt2  0 \n0  0  0  0  0  -fracisqrt2  0  0  0  frac1sqrt2 \nendarray\nright","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"For f system, the transformation matrix reads","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"T= left\nbeginarraycccccccccccccc\nfracisqrt2  0  0  0  0  0  frac1sqrt2      0  0  0  0  0  0  0 \n0  fracisqrt2  0  0  0  frac1sqrt2  0      0  0  0  0  0  0  0 \n0  0  fracisqrt2  0  frac1sqrt2  0  0      0  0  0  0  0  0  0 \n0  0  0  1  0  0  0      0  0  0  0  0  0  0 \n0  0  fracisqrt2  0  -frac1sqrt2  0  0      0  0  0  0  0  0  0 \n0  -fracisqrt2  0  0  0  frac1sqrt2  0      0  0  0  0  0  0  0 \nfracisqrt2  0  0  0  0  0  -frac1sqrt2      0  0  0  0  0  0  0 \nhline\n0  0  0  0  0  0  0      fracisqrt2  0  0  0  0  0  frac1sqrt2 \n0  0  0  0  0  0  0      0  fracisqrt2  0  0  0  frac1sqrt2  0 \n0  0  0  0  0  0  0      0  0  fracisqrt2  0  frac1sqrt2  0  0 \n0  0  0  0  0  0  0      0  0  0  1  0  0  0 \n0  0  0  0  0  0  0      0  0  fracisqrt2  0  -frac1sqrt2  0  0 \n0  0  0  0  0  0  0      0  -fracisqrt2  0  0  0  frac1sqrt2  0 \n0  0  0  0  0  0  0      fracisqrt2  0  0  0  0  0  -frac1sqrt2 \nendarray\nright","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"The following Julia script is used to construct the complex orbital basis and the real orbital basis, and the transformation matrix between them.","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"# To calculate the transformation matrix from the complex orbital basis\n# to the real orbital basis.\nfunction calc_matrix(l::Int64)\n    println(\"Construct complex orbital basis for 𝑙 = $l\")\n    COB = [] # To save the complex orbital basis\n    # m = -l, -l+1, ..., l-1, l\n    mlist = collect(-l:1:l)\n    for s in (\"up\", \"down\")\n        for m in mlist\n            push!(COB, [m, s])\n        end\n    end\n    #\n    for i in eachindex(COB)\n        m = COB[i][1]\n        s = COB[i][2] == \"up\" ? \"↑\" : \"↓\"\n        println(\"$i -> | $l, $m, $s ⟩\")\n    end\n\n    println(\"Construct real orbital basis for 𝑙 = $l\")\n    RO = [] # To save the real orbital basis basis\n    ROB = [] # To save the detailed expressions for the real orbital basis\n    for s in (\"up\", \"down\")\n        for m in mlist\n            if m < 0\n                b = [\"i/sqrt(2)\", -abs(m), -(-1)^m, abs(m)]\n            elseif m == 0\n                b = [0]\n            elseif m > 0\n                b = [\"1/sqrt(2)\", -abs(m),  (-1)^m, abs(m)]\n            end\n            push!(RO, [m,s])\n            push!(ROB, b)\n        end\n    end\n    #\n    for i in eachindex(RO)\n        m = RO[i][1]\n        s = RO[i][2] == \"up\" ? \"↑\" : \"↓\"\n        println(\"$i -> Y_{$l,$m} χ$s\")        \n    end\n\n    println(\"Evaluate transformation matrix for 𝑙 = $l\")\n    for m in eachindex(COB)\n        for n in eachindex(RO)\n            if COB[m][2] == RO[n][2] # their spins are the same\n                # for Y_{l0} case\n                if length(ROB[n]) == 1\n                    if COB[m][1] == ROB[n][1]\n                        println(\"T($m,$n) -> 1\")\n                    end\n                # for Y_{lm} case where m /= 0\n                else\n                    if COB[m][1] == ROB[n][2]\n                        println(\"T($m,$n) -> \", ROB[n][1])\n                    end\n                    if COB[m][1] == ROB[n][4]\n                        s = ROB[n][3] < 0 ? \"-\" : \"\"\n                        println(\"T($m,$n) -> $s\", ROB[n][1])\n                    end\n                end\n            end\n        end\n    end\nend","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"Transformation matrix from complex orbital basis to hatj^2-hatj_z-hatl^2-hats^2 diagonal basis","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"For p system, the transformation matrix reads","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nT = left\nbeginarraycccccc\n-sqrtfrac23  0  0  sqrtfrac13  0  0 \n0  -sqrtfrac13  0  0  sqrtfrac23  0 \n0  0  0  0  0  10 \nhline\n0  0  10  0  0  0 \nsqrtfrac13  0  0  sqrtfrac23  0  0 \n0  sqrtfrac23  0  0  sqrtfrac13  0 \nendarray\nright\nendequation","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"For d system, the transformation matrix reads","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"T = left\nbeginarraycccccccccc\n-sqrtfrac45  0  0  0  0  sqrtfrac15  0  0  0  0 \n0  -sqrtfrac35  0  0  0  0  sqrtfrac25  0  0  0 \n0  0  -sqrtfrac25  0  0  0  0  sqrtfrac35  0  0 \n0  0  0  -sqrtfrac15  0  0  0  0  sqrtfrac45  0 \n0  0  0  0  0  0  0  0  0  10 \nhline\n0  0  0  0  10  0  0  0  0  0 \nsqrtfrac15  0  0  0  0  sqrtfrac45  0  0  0  0 \n0  sqrtfrac25  0  0  0  0  sqrtfrac35  0  0  0 \n0  0  sqrtfrac35  0  0  0  0  sqrtfrac25  0  0 \n0  0  0  sqrtfrac45  0  0  0  0  sqrtfrac15  0 \nendarray\nright","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"For f system, the transformation matrix reads","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"T = left\nbeginarraycccccccccccccc\n-sqrtfrac67  0  0  0  0  0  0  sqrtfrac17  0  0  0  0  0  0 \n0  -sqrtfrac57  0  0  0  0  0  0  sqrtfrac27  0  0  0  0  0 \n0  0  -sqrtfrac47  0  0  0  0  0  0  sqrtfrac37  0  0  0  0 \n0  0  0  -sqrtfrac37  0  0  0  0  0  0  sqrtfrac47  0  0  0 \n0  0  0  0  -sqrtfrac27  0  0  0  0  0  0  sqrtfrac57  0  0 \n0  0  0  0  0  -sqrtfrac17  0  0  0  0  0  0  sqrtfrac67  0 \n0  0  0  0  0  0  0  0  0  0  0  0  0  10 \nhline\n0  0  0  0  0  0  10  0  0  0  0  0  0  0 \nsqrtfrac17  0  0  0  0  0  0  sqrtfrac67  0  0  0  0  0  0 \n0  sqrtfrac27  0  0  0  0  0  0  sqrtfrac57  0  0  0  0  0 \n0  0  sqrtfrac37  0  0  0  0  0  0  sqrtfrac47  0  0  0  0 \n0  0  0  sqrtfrac47  0  0  0  0  0  0  sqrtfrac37  0  0  0 \n0  0  0  0  sqrtfrac57  0  0  0  0  0  0  sqrtfrac27  0  0 \n0  0  0  0  0  sqrtfrac67  0  0  0  0  0  0  sqrtfrac17  0 \nendarray\nright","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"The following Julia script is used to construct the complex orbital basis and the j^2-j_z basis, and the transformation matrix between them.","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"# To calculate the transformation matrix from the complex orbital basis\n# to the j²-jz basis.\nfunction calc_matrix(l::Int64)\n    println(\"Construct complex orbital basis for 𝑙 = $l\")\n    COB = [] # To save the complex orbital basis\n    # m = -l, -l+1, ..., l-1, l\n    mlist = collect(-l:1:l)\n    for s in (\"up\", \"down\")\n        for m in mlist\n            push!(COB, [m, s])\n        end\n    end\n    #\n    for i in eachindex(COB)\n        m = COB[i][1]\n        s = COB[i][2] == \"up\" ? \"↑\" : \"↓\"\n        println(\"$i -> | $l, $m, $s ⟩\")\n    end\n\n    println(\"Construct j²-jz basis for 𝑙 = $l\")\n    JJ = []  # To save the j²-jz basis\n    JJB = [] # To save the detailed expressions for the j²-jz basis\n    jlist = [l-1//2, l+1//2]\n    for j in jlist\n        # mⱼ = -j, -j+1, ..., j-1, j\n        mⱼlist = collect(-j:2//2:j)\n        for mⱼ in mⱼlist\n            push!(JJ, [j, mⱼ])\n            m = mⱼ-1//2\n            if j == l-1//2 # For j = l-1/2\n                jj = [\"-\", (l-m)/(2*l+1), Int(m), (l+m+1)/(2*l+1), Int(m+1)]\n            else           # For j = l+1/2\n                jj = [\"\" , (l+m+1)/(2*l+1), Int(m), (l-m)/(2*l+1), Int(m+1)]\n            end\n            push!(JJB, jj)\n        end\n    end\n    #\n    for i in eachindex(JJ)\n        j = JJ[i][1]\n        mⱼ = JJ[i][2]\n        print(\"$i -> | $j, $mⱼ ⟩ = \")\n\n        jj = JJB[i]\n        print(jj[1])\n        print(\"sqrt(\", jj[2], \")Y^{\", jj[3],\"}_{$l}χ↑ + \")\n        print(\"sqrt(\", jj[4], \")Y^{\", jj[5],\"}_{$l}χ↓\\n\")\n    end\n\n    println(\"Evaluate transformation matrix for 𝑙 = $l\")\n    for m in eachindex(COB)\n        for n in eachindex(JJ)\n            if COB[m][2] == \"up\"\n                if COB[m][1] == JJB[n][3]\n                    println(\"T($m,$n) -> \", JJB[n][1], \"sqrt(\", JJB[n][2],\")\")\n                end\n            else\n                if COB[m][1] == JJB[n][5]\n                    println(\"T($m,$n) -> \", \"sqrt(\", JJB[n][4],\")\")\n                end\n            end\n        end\n    end\nend","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"Reference","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"[1]: 曾谨言, 量子力学（卷1, 第四版）， 科学出版社， 2007。","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"[2]: D. A. Varshalovich, A. N. Moskalev, and V. K. Khersonskii, Quantum Theory of Angular Momentum, World Scientific, 1988.","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"[3]: See https://handwiki.org/wiki/Physics:Spherical_harmonics.","category":"page"},{"location":"ch08/basis.html","page":"Single particle basis","title":"Single particle basis","text":"[4]: The orbital orders are consistent with the definition of local basis used by VASP (see https://www.vasp.at/wiki/index.php/LOCPROJ), and the definition in HandWiki (see https://handwiki.org/wiki/Table_of_spherical_harmonics).","category":"page"},{"location":"ch04/p_ntime.html#Parameter:-ntime","page":"ntime","title":"Parameter: ntime","text":"","category":"section"},{"location":"ch04/p_ntime.html","page":"ntime","title":"ntime","text":"Definition","category":"page"},{"location":"ch04/p_ntime.html","page":"ntime","title":"ntime","text":"Number of imaginary time slices sampling by continuous time or Hirsch-Fye quantum Monte Carlo quantum impurity solver.In the iQIST software package, the imaginary time mesh is calculated as follows:tau_i = fracbeta (i-1)n-1where i in 1n and tau_i in 0beta. So, the value of n is just ntime.","category":"page"},{"location":"ch04/p_ntime.html","page":"ntime","title":"ntime","text":"Type","category":"page"},{"location":"ch04/p_ntime.html","page":"ntime","title":"ntime","text":"Integer","category":"page"},{"location":"ch04/p_ntime.html","page":"ntime","title":"ntime","text":"Default value","category":"page"},{"location":"ch04/p_ntime.html","page":"ntime","title":"ntime","text":"1024 (for CT-HYB impurity solvers)","category":"page"},{"location":"ch04/p_ntime.html","page":"ntime","title":"ntime","text":"Component","category":"page"},{"location":"ch04/p_ntime.html","page":"ntime","title":"ntime","text":"ALL","category":"page"},{"location":"ch04/p_ntime.html","page":"ntime","title":"ntime","text":"Behavior","category":"page"},{"location":"ch04/p_ntime.html","page":"ntime","title":"ntime","text":"Determine the size of involved arrays, such as the imaginary-time Green's function G(tau), the hybridization function Delta(tau), the auxiliary correlation function F(tau), the spin-spin correlation function langle S_z(0) S_z(tau) rangle, etc.","category":"page"},{"location":"ch04/p_ntime.html","page":"ntime","title":"ntime","text":"Comment","category":"page"},{"location":"ch04/p_ntime.html","page":"ntime","title":"ntime","text":"The ntime = 1024 is an optimal value for most cases. But if the system temperature is too low, it is useful to increase ntime to obtain higher accurate. For example, if beta = 100, it is better to let ntime = 2048 or 4096.See mfreq and nfreq parameters for more details.","category":"page"},{"location":"ch04/out_diag.html#solver.diag.dat","page":"solver.diag.dat","title":"solver.diag.dat","text":"","category":"section"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":"Introduction","category":"page"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":"The solver.diag.dat file is used to store the diagram configurations of the perturbation expansion series. Owing to the limitation of disk capacity and computational efficiency, it is impossible to save all of the visited diagram configurations. Consequently we only save the current diagram configurations every nwrite Monte Carlo step. Namely, the frequency for writing diagram configurations is controlled by the nwrite parameter. See also nwrite for more details.","category":"page"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":"Format","category":"page"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":"The solver.diag.dat file consists many blocks. The blocks are separated by two blank lines. A typical block looks like as follows:","category":"page"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":">> cur_iter:   1 tot_iter:  20\n>> cur_diag:   4 tot_diag:1000\n# flvr:   1 rank:   2\n   1      6.49617550      0.35585709\n   1      7.30348648      7.28301304\n# flvr:   2 rank:   1\n   2      0.43805150      6.89040598","category":"page"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":"Here cur_iter means current iteration number, tot_iter the total iteration number, cur_diag the index of the current diagram configuration, tot_diag the total number of diagram configurations. Actually, we have","category":"page"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":"texttot_diag = fractextnsweeptextnwrite","category":"page"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":"Next, the positions for creator/destroy operators are given for all orbitals (flavors).","category":"page"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":"","category":"page"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":"column 1: the index of orbitals.","category":"page"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":"column 2: tau_s, the imaginary-time points for creator operators","category":"page"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":"column 3: tau_e, the imaginary-time points for destroy operators","category":"page"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":"","category":"page"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":"We can utilize the data in the solver.diag.dat file to produce animation movie. A block can be used to generate one frame in the movie.","category":"page"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":"Code","category":"page"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":"The corresponding Fortran code block for the writing of solver.diag.dat file is as follows:","category":"page"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":"! write the snapshot\n! open data file: solver.diag.dat\n     open(mytmp, file='solver.diag.dat', form='formatted', status='unknown', position='append')\n\n! write diagram info\n     write(mytmp,'(2(a,i4))') '>> cur_iter:', iter, ' tot_iter:', niter\n     write(mytmp,'(2(a,i4))') '>> cur_diag:', cstep/nwrite, ' tot_diag:', nsweep/nwrite\n\n! write the position of operators\n     do i=1,norbs\n         write(mytmp,'(2(a,i4))') '# flvr:', i, ' rank:', rank(i)\n         do j=1,rank(i)\n             write(mytmp,'(i4,2f16.8)') i, time_s( index_s(j, i), i ), time_e( index_e(j, i), i )\n         enddo ! over j={1,rank(i)} loop\n     enddo ! over i={1,norbs} loop\n\n! write two blank lines\n     write(mytmp,*)\n     write(mytmp,*)\n\n! close data file\n     close(mytmp)","category":"page"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":"You can use the u_movie.py script to visualize the diagram configurations in the solver.diag.dat file. See also script/u_movie.py for more details.","category":"page"},{"location":"ch04/p_jz.html#Parameter:-Jz","page":"Jz","title":"Parameter: Jz","text":"","category":"section"},{"location":"ch04/p_jz.html","page":"Jz","title":"Jz","text":"Definition","category":"page"},{"location":"ch04/p_jz.html","page":"Jz","title":"Jz","text":"Coupling constant for the Hund's exchange interaction in z axis, J_z.","category":"page"},{"location":"ch04/p_jz.html","page":"Jz","title":"Jz","text":"Type:","category":"page"},{"location":"ch04/p_jz.html","page":"Jz","title":"Jz","text":"Float, double precision","category":"page"},{"location":"ch04/p_jz.html","page":"Jz","title":"Jz","text":"Default value","category":"page"},{"location":"ch04/p_jz.html","page":"Jz","title":"Jz","text":"0.0","category":"page"},{"location":"ch04/p_jz.html","page":"Jz","title":"Jz","text":"Component","category":"page"},{"location":"ch04/p_jz.html","page":"Jz","title":"Jz","text":"ALL","category":"page"},{"location":"ch04/p_jz.html","page":"Jz","title":"Jz","text":"Behavior","category":"page"},{"location":"ch04/p_jz.html","page":"Jz","title":"Jz","text":"It is used to determine the Coulomb interaction matrix.","category":"page"},{"location":"ch04/p_jz.html","page":"Jz","title":"Jz","text":"Comment","category":"page"},{"location":"ch04/p_jz.html","page":"Jz","title":"Jz","text":"Actually, only the NARCISSUS component needs it. For the other quantum impurity solvers components (such as the MANJUSHAKA component), the information about the Coulomb interaction matrix is imported via the atom.cix file. So you can set it to any values for the MANJUSHAKA component.Usually, the U_c, U_v and J_z should satisfy the following relation:beginequation\nU_c = U_v - 2J_z\nendequationSee also Uc, Uv parameters for more details.Usually, J_z = J_s = J_p = J. As for a single-band model, they are zero. See also Js, Jp parameters for more details.","category":"page"},{"location":"ch04/p_jz.html","page":"Jz","title":"Jz","text":"note: Note\nFor the NARCISSUS component, the Coulomb interaction matrix can be imported via the solver.umat.in file which has the highest priority. See solver.umat.in for more details.","category":"page"},{"location":"ch04/p_ncarlo.html#Parameter:-ncarlo","page":"ncarlo","title":"Parameter: ncarlo","text":"","category":"section"},{"location":"ch04/p_ncarlo.html","page":"ncarlo","title":"ncarlo","text":"Definition","category":"page"},{"location":"ch04/p_ncarlo.html","page":"ncarlo","title":"ncarlo","text":"How often to measure the physical observables.","category":"page"},{"location":"ch04/p_ncarlo.html","page":"ncarlo","title":"ncarlo","text":"Type","category":"page"},{"location":"ch04/p_ncarlo.html","page":"ncarlo","title":"ncarlo","text":"Integer","category":"page"},{"location":"ch04/p_ncarlo.html","page":"ncarlo","title":"ncarlo","text":"Default value","category":"page"},{"location":"ch04/p_ncarlo.html","page":"ncarlo","title":"ncarlo","text":"10","category":"page"},{"location":"ch04/p_ncarlo.html","page":"ncarlo","title":"ncarlo","text":"Component","category":"page"},{"location":"ch04/p_ncarlo.html","page":"ncarlo","title":"ncarlo","text":"All","category":"page"},{"location":"ch04/p_ncarlo.html","page":"ncarlo","title":"ncarlo","text":"Behavior","category":"page"},{"location":"ch04/p_ncarlo.html","page":"ncarlo","title":"ncarlo","text":"Every ncarlo Monte Carlo sampling steps, the quantum impurity solvers try to measure the physical observables. The affected physical observables are as follows:Atomic state probability, P_Gamma,\nImaginary-time Green's function, G(tau),\nAuxiliary imaginary-time correlation function, F(tau).The measuring period for the other physical observables are controlled by the nmonte parameter. See also nmonte parameter for more details.","category":"page"},{"location":"ch04/p_ncarlo.html","page":"ncarlo","title":"ncarlo","text":"note: Note\nThe histogram for the perturbation expansion series is measured in each Monte Carlo sampling step.","category":"page"},{"location":"ch04/p_ncarlo.html","page":"ncarlo","title":"ncarlo","text":"Comment","category":"page"},{"location":"ch04/p_ncarlo.html","page":"ncarlo","title":"ncarlo","text":"You can increase ncarlo to relieve the auto-correlation of physical observables > between two successive measurements. However, large ncarlo will waste the CPU times. What's the best choices? We guess a good ncarlo should satisfy the following relation:textncarlo * textP_textinsert = 10Here, textP_textinsert means the accepted ratio for the insert update actions.","category":"page"},{"location":"ch05/in_cmat.html#atom.cmat.in","page":"atom.cmat.in","title":"atom.cmat.in","text":"","category":"section"},{"location":"ch05/in_cmat.html","page":"atom.cmat.in","title":"atom.cmat.in","text":"Introduction","category":"page"},{"location":"ch05/in_cmat.html","page":"atom.cmat.in","title":"atom.cmat.in","text":"The purpose of the atom.cmat.in file is to define the crystal field splitting of the atomic Hamiltonian. The JASMINE component supports both diagonal and non-diagonal crystal field matrix. Only when ibasis = 1, the atom.cmat.in file is read. See ibasis parameter for more details.","category":"page"},{"location":"ch05/in_cmat.html","page":"atom.cmat.in","title":"atom.cmat.in","text":"Format","category":"page"},{"location":"ch05/in_cmat.html","page":"atom.cmat.in","title":"atom.cmat.in","text":"The format of the atom.cmat.in file is as follows:","category":"page"},{"location":"ch05/in_cmat.html","page":"atom.cmat.in","title":"atom.cmat.in","text":"","category":"page"},{"location":"ch05/in_cmat.html","page":"atom.cmat.in","title":"atom.cmat.in","text":"column 1: orbital index alpha, integer","category":"page"},{"location":"ch05/in_cmat.html","page":"atom.cmat.in","title":"atom.cmat.in","text":"column 2: orbital index beta, integer","category":"page"},{"location":"ch05/in_cmat.html","page":"atom.cmat.in","title":"atom.cmat.in","text":"column 3: crystal field splitting matrix element Delta_alphabeta, double precision","category":"page"},{"location":"ch05/in_cmat.html","page":"atom.cmat.in","title":"atom.cmat.in","text":"","category":"page"},{"location":"ch05/in_cmat.html","page":"atom.cmat.in","title":"atom.cmat.in","text":"note: Note\nIn the atom.cmat.in file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch05/in_cmat.html","page":"atom.cmat.in","title":"atom.cmat.in","text":"Code","category":"page"},{"location":"ch05/in_cmat.html","page":"atom.cmat.in","title":"atom.cmat.in","text":"The corresponding Fortran code block for the reading of the atom.cmat.in file is as follows:","category":"page"},{"location":"ch05/in_cmat.html","page":"atom.cmat.in","title":"atom.cmat.in","text":"! open file atom.cmat.in\nopen(mytmp, file='atom.cmat.in', form='formatted', status='unknown')\n\n! read the data until EOF\ndo\n    read(mytmp,*,iostat = ierr) i1, i2, raux\n    if ( ierr == iostat_end ) EXIT\n    !\n    ! crystal field splitting is actually real\n    call s_assert( i1 <= norbs .and. i2 <= norbs )\n    cmat(i1,i2) = dcmplx(raux, zero)\nenddo ! over do while loop\n\n! close data file\nclose(mytmp)","category":"page"},{"location":"ch05/p_ncfgs.html#Parameter:-ncfgs","page":"ncfgs","title":"Parameter: ncfgs","text":"","category":"section"},{"location":"ch05/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Definition","category":"page"},{"location":"ch05/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Number of atomic states or many-body configurations, the dimension of Hilbert space.","category":"page"},{"location":"ch05/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Type","category":"page"},{"location":"ch05/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Integer","category":"page"},{"location":"ch05/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Default value","category":"page"},{"location":"ch05/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"4","category":"page"},{"location":"ch05/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Component","category":"page"},{"location":"ch05/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Only for the JASMINE component.","category":"page"},{"location":"ch05/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Behavior","category":"page"},{"location":"ch05/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Determine the size of involved arrays.","category":"page"},{"location":"ch05/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Comment","category":"page"},{"location":"ch05/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"The following relations always hold:textnorbs = textnpsin * textnbandtextncfgs = 2^textnorbsYou have to ensure the value of ncfgs is compatible with nband, nspin and norbs. The JASMINE component will not check and correct them automatically. See also nspin, nband, and norbs parameters for more details.","category":"page"},{"location":"ch05/p_nband.html#Parameter:-nband","page":"nband","title":"Parameter: nband","text":"","category":"section"},{"location":"ch05/p_nband.html","page":"nband","title":"nband","text":"Definition","category":"page"},{"location":"ch05/p_nband.html","page":"nband","title":"nband","text":"Number of correlated bands.","category":"page"},{"location":"ch05/p_nband.html","page":"nband","title":"nband","text":"Type","category":"page"},{"location":"ch05/p_nband.html","page":"nband","title":"nband","text":"Integer","category":"page"},{"location":"ch05/p_nband.html","page":"nband","title":"nband","text":"Default value","category":"page"},{"location":"ch05/p_nband.html","page":"nband","title":"nband","text":"1","category":"page"},{"location":"ch05/p_nband.html","page":"nband","title":"nband","text":"Component","category":"page"},{"location":"ch05/p_nband.html","page":"nband","title":"nband","text":"Only for the JASMINE component.","category":"page"},{"location":"ch05/p_nband.html","page":"nband","title":"nband","text":"Behavior","category":"page"},{"location":"ch05/p_nband.html","page":"nband","title":"nband","text":"Determine the size of involved arrays.","category":"page"},{"location":"ch05/p_nband.html","page":"nband","title":"nband","text":"Comment","category":"page"},{"location":"ch05/p_nband.html","page":"nband","title":"nband","text":"In the iQIST software package, when we say nband, we always do not consider the spin degree of freedom. So for d−electron system, it should be a five-band model (nband = 5), while for f−electron, it should be a seven-band model (nband = 7).","category":"page"},{"location":"ch05/p_nband.html","page":"nband","title":"nband","text":"See nspin, norbs, and ncfgs parameters for more details.","category":"page"},{"location":"ch04/p_uv.html#Parameter:-Uv","page":"Uv","title":"Parameter: Uv","text":"","category":"section"},{"location":"ch04/p_uv.html","page":"Uv","title":"Uv","text":"Definition","category":"page"},{"location":"ch04/p_uv.html","page":"Uv","title":"Uv","text":"Inter-orbital Coulomb interaction U_v.","category":"page"},{"location":"ch04/p_uv.html","page":"Uv","title":"Uv","text":"Type","category":"page"},{"location":"ch04/p_uv.html","page":"Uv","title":"Uv","text":"Float, double precision","category":"page"},{"location":"ch04/p_uv.html","page":"Uv","title":"Uv","text":"Default value","category":"page"},{"location":"ch04/p_uv.html","page":"Uv","title":"Uv","text":"4.0","category":"page"},{"location":"ch04/p_uv.html","page":"Uv","title":"Uv","text":"Component","category":"page"},{"location":"ch04/p_uv.html","page":"Uv","title":"Uv","text":"ALL","category":"page"},{"location":"ch04/p_uv.html","page":"Uv","title":"Uv","text":"Behavior","category":"page"},{"location":"ch04/p_uv.html","page":"Uv","title":"Uv","text":"It is used to determine the Coulomb interaction matrix.","category":"page"},{"location":"ch04/p_uv.html","page":"Uv","title":"Uv","text":"Comment","category":"page"},{"location":"ch04/p_uv.html","page":"Uv","title":"Uv","text":"Actually, only the NARCISSUS component need it. For the other quantum impurity solvers components (such as the MANJUSHAKA component), the information about the Coulomb interaction matrix is imported via the atom.cix file. So you can set it to any values for the MANJUSHAKA component.Usually, the U_c, U_v and J_z should satisfy the following relation:beginequation\nU_c = U_v - 2J_z\nendequationSee also Uc, Jz parameters for more details.","category":"page"},{"location":"ch04/p_uv.html","page":"Uv","title":"Uv","text":"note: Note\nFor the NARCISSUS component, the Coulomb interaction matrix can be imported via the solver.umat.in file which has the highest priority. See solver.umat.in for more details.","category":"page"},{"location":"ch04/p_uc.html#Parameter:-Uc","page":"Uc","title":"Parameter: Uc","text":"","category":"section"},{"location":"ch04/p_uc.html","page":"Uc","title":"Uc","text":"Definition","category":"page"},{"location":"ch04/p_uc.html","page":"Uc","title":"Uc","text":"Intra-orbital Coulomb interaction U_c.","category":"page"},{"location":"ch04/p_uc.html","page":"Uc","title":"Uc","text":"Type","category":"page"},{"location":"ch04/p_uc.html","page":"Uc","title":"Uc","text":"Float, double precision","category":"page"},{"location":"ch04/p_uc.html","page":"Uc","title":"Uc","text":"Default value","category":"page"},{"location":"ch04/p_uc.html","page":"Uc","title":"Uc","text":"4.0","category":"page"},{"location":"ch04/p_uc.html","page":"Uc","title":"Uc","text":"Component","category":"page"},{"location":"ch04/p_uc.html","page":"Uc","title":"Uc","text":"ALL","category":"page"},{"location":"ch04/p_uc.html","page":"Uc","title":"Uc","text":"Behavior","category":"page"},{"location":"ch04/p_uc.html","page":"Uc","title":"Uc","text":"It is used to determine the Coulomb interaction matrix.","category":"page"},{"location":"ch04/p_uc.html","page":"Uc","title":"Uc","text":"Comment","category":"page"},{"location":"ch04/p_uc.html","page":"Uc","title":"Uc","text":"Actually, only the NARCISSUS component needs it. For the other quantum impurity solvers components (such as the MANJUSHAKA component), the information about the Coulomb interaction matrix is imported via the atom.cix file. So you can set it to any values for the MANJUSHAKA component.Usually, the U_c, U_v and J_z should meet the following relation:beginequation\nU_c = U_v - 2J_z\nendequationSee also Uv, Jz parameters for more details.","category":"page"},{"location":"ch04/p_uc.html","page":"Uc","title":"Uc","text":"note: Note\nFor the NARCISSUS component, the Coulomb interaction matrix can be imported via the solver.umat.in file which has the highest priority. See solver.umat.in for more details.","category":"page"},{"location":"ch05/p_nmaxi.html#Parameter:-nmaxi","page":"nmaxi","title":"Parameter: nmaxi","text":"","category":"section"},{"location":"ch05/p_nmaxi.html","page":"nmaxi","title":"nmaxi","text":"Definition","category":"page"},{"location":"ch05/p_nmaxi.html","page":"nmaxi","title":"nmaxi","text":"The maximal total occupancy N which will be kept in the construction of atomic eigenstates.","category":"page"},{"location":"ch05/p_nmaxi.html","page":"nmaxi","title":"nmaxi","text":"Type","category":"page"},{"location":"ch05/p_nmaxi.html","page":"nmaxi","title":"nmaxi","text":"Integer","category":"page"},{"location":"ch05/p_nmaxi.html","page":"nmaxi","title":"nmaxi","text":"Default value","category":"page"},{"location":"ch05/p_nmaxi.html","page":"nmaxi","title":"nmaxi","text":"2","category":"page"},{"location":"ch05/p_nmaxi.html","page":"nmaxi","title":"nmaxi","text":"Component","category":"page"},{"location":"ch05/p_nmaxi.html","page":"nmaxi","title":"nmaxi","text":"Only for the JASMINE component.","category":"page"},{"location":"ch05/p_nmaxi.html","page":"nmaxi","title":"nmaxi","text":"Behavior","category":"page"},{"location":"ch05/p_nmaxi.html","page":"nmaxi","title":"nmaxi","text":"Those atomic eigenstates in which the total occupancy N in textnmini textnmaxi will be kept. The other atomic eigenstates will be discarded. It is an aggressive truncation and may led to significant derivations.","category":"page"},{"location":"ch05/p_nmaxi.html","page":"nmaxi","title":"nmaxi","text":"Comment","category":"page"},{"location":"ch05/p_nmaxi.html","page":"nmaxi","title":"nmaxi","text":"See also nmini parameter for more details.","category":"page"},{"location":"ch04/out_grn.html#solver.grn.dat","page":"solver.grn.dat","title":"solver.grn.dat","text":"","category":"section"},{"location":"ch04/out_grn.html","page":"solver.grn.dat","title":"solver.grn.dat","text":"Introduction","category":"page"},{"location":"ch04/out_grn.html","page":"solver.grn.dat","title":"solver.grn.dat","text":"This file is used to store the Matsubara Green's function G(iomega_n). It will be output by the quantum impurity solvers when they are shut down.","category":"page"},{"location":"ch04/out_grn.html","page":"solver.grn.dat","title":"solver.grn.dat","text":"Format","category":"page"},{"location":"ch04/out_grn.html","page":"solver.grn.dat","title":"solver.grn.dat","text":"The solver.grn.dat file contains norbs block. Each block is appended by two blank lines. The format of each block is as follows:","category":"page"},{"location":"ch04/out_grn.html","page":"solver.grn.dat","title":"solver.grn.dat","text":"","category":"page"},{"location":"ch04/out_grn.html","page":"solver.grn.dat","title":"solver.grn.dat","text":"column 1: orbital index i, integer","category":"page"},{"location":"ch04/out_grn.html","page":"solver.grn.dat","title":"solver.grn.dat","text":"column 2: Matsubara frequency point, omega_n, double precision","category":"page"},{"location":"ch04/out_grn.html","page":"solver.grn.dat","title":"solver.grn.dat","text":"column 3: Matsubara Green's function, Re G(iomega_n), double precision","category":"page"},{"location":"ch04/out_grn.html","page":"solver.grn.dat","title":"solver.grn.dat","text":"column 4: Matsubara Green's function, Im G(iomega_n), double precision","category":"page"},{"location":"ch04/out_grn.html","page":"solver.grn.dat","title":"solver.grn.dat","text":"column 5: error bar, Re delta G(iomega_n), double precision","category":"page"},{"location":"ch04/out_grn.html","page":"solver.grn.dat","title":"solver.grn.dat","text":"column 6: error bar, Im delta G(iomega_n), double precision","category":"page"},{"location":"ch04/out_grn.html","page":"solver.grn.dat","title":"solver.grn.dat","text":"","category":"page"},{"location":"ch04/out_grn.html","page":"solver.grn.dat","title":"solver.grn.dat","text":"note: Note\nIn the solver.grn.dat file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch04/out_grn.html","page":"solver.grn.dat","title":"solver.grn.dat","text":"Code","category":"page"},{"location":"ch04/out_grn.html","page":"solver.grn.dat","title":"solver.grn.dat","text":"The corresponding Fortran code block for the writing of solver.grn.dat file is as follows:","category":"page"},{"location":"ch04/out_grn.html","page":"solver.grn.dat","title":"solver.grn.dat","text":"! open data file: solver.grn.dat\nopen(mytmp, file='solver.grn.dat', form='formatted', status='unknown')\n\n! write it\ndo i=1,norbs\n    do j=1,mfreq\n        write(mytmp,'(i6,5f16.8)') i, rmesh(j), grnf(j,i,i), gerr(j,i,i)\n    enddo ! over j={1,mfreq} loop\n    write(mytmp,*) ! write empty lines\n    write(mytmp,*)\nenddo ! over i={1,norbs} loop\n\n! close data file\nclose(mytmp)","category":"page"},{"location":"ch04/out_grn.html","page":"solver.grn.dat","title":"solver.grn.dat","text":"In the iQIST software package, we provide a Python module to read the output files of quantum impurity solvers. You can use it to read the solver.grn.dat file. See [src/tools/u_reader.py] for more details.","category":"page"},{"location":"ch04/p_jp.html#Parameter:-Jp","page":"Jp","title":"Parameter: Jp","text":"","category":"section"},{"location":"ch04/p_jp.html","page":"Jp","title":"Jp","text":"Definition","category":"page"},{"location":"ch04/p_jp.html","page":"Jp","title":"Jp","text":"Strength of the pair-hopping term in the interaction term, J_p.","category":"page"},{"location":"ch04/p_jp.html","page":"Jp","title":"Jp","text":"Type","category":"page"},{"location":"ch04/p_jp.html","page":"Jp","title":"Jp","text":"Float, double precision","category":"page"},{"location":"ch04/p_jp.html","page":"Jp","title":"Jp","text":"Default value","category":"page"},{"location":"ch04/p_jp.html","page":"Jp","title":"Jp","text":"0.0","category":"page"},{"location":"ch04/p_jp.html","page":"Jp","title":"Jp","text":"Component","category":"page"},{"location":"ch04/p_jp.html","page":"Jp","title":"Jp","text":"ALL","category":"page"},{"location":"ch04/p_jp.html","page":"Jp","title":"Jp","text":"Behavior","category":"page"},{"location":"ch04/p_jp.html","page":"Jp","title":"Jp","text":"In principle, it is used to build the Coulomb interaction matrix.But the NARCISSUS component does not support general interaction. In other words, it does not support the J_p term in the local impurity Hamiltonian.As for the MANJUSHAKA component, the Coulomb interaction matrix is not built within the quantum impurity solvers. All of the information is encapsulated in the atom.cix file. So they don't need the J_p parameter as well.So, in summary, we don't use this parameter actually. You can set it to any values as you wish. But we strongly suggest to set it to the exact value.","category":"page"},{"location":"ch04/p_jp.html","page":"Jp","title":"Jp","text":"Comment","category":"page"},{"location":"ch04/p_jp.html","page":"Jp","title":"Jp","text":"See also Jz and Js for more details.","category":"page"},{"location":"ch04/p_beta.html#Parameter:-beta","page":"beta","title":"Parameter: beta","text":"","category":"section"},{"location":"ch04/p_beta.html","page":"beta","title":"beta","text":"Definition","category":"page"},{"location":"ch04/p_beta.html","page":"beta","title":"beta","text":"Inversion of temperature beta (equiv 1T).","category":"page"},{"location":"ch04/p_beta.html","page":"beta","title":"beta","text":"Type","category":"page"},{"location":"ch04/p_beta.html","page":"beta","title":"beta","text":"Float, double precision","category":"page"},{"location":"ch04/p_beta.html","page":"beta","title":"beta","text":"Default value","category":"page"},{"location":"ch04/p_beta.html","page":"beta","title":"beta","text":"8.0","category":"page"},{"location":"ch04/p_beta.html","page":"beta","title":"beta","text":"Component","category":"page"},{"location":"ch04/p_beta.html","page":"beta","title":"beta","text":"ALL","category":"page"},{"location":"ch04/p_beta.html","page":"beta","title":"beta","text":"Behavior","category":"page"},{"location":"ch04/p_beta.html","page":"beta","title":"beta","text":"It is used to determine the system temperature. The larger beta is, the slower computation is.","category":"page"},{"location":"ch04/p_beta.html","page":"beta","title":"beta","text":"Comment","category":"page"},{"location":"ch04/p_beta.html","page":"beta","title":"beta","text":"To convert beta to real temperature, you can use the following formula:T = 11604505008098  betaThe unit is Kelvin (K). For beta = 400, the corresponding temperature (290.11262520245 K) is roughly the room temperature.","category":"page"},{"location":"ch05/parameters.html#Parameters","page":"README","title":"Parameters","text":"","category":"section"},{"location":"ch05/parameters.html","page":"README","title":"README","text":"In this section, we will introduce all of the parameters which can be used in the atom.config.in file. The JASMINE component will parse this file and use the setting in it to override the default ones.","category":"page"},{"location":"ch05/parameters.html#Classification-of-the-parameters:","page":"README","title":"Classification of the parameters:","text":"","category":"section"},{"location":"ch05/parameters.html","page":"README","title":"README","text":"Diagonalization algorithms\nibasis\nictqmc\nnmini\nnmaxi\nHilbert space\nnband\nnspin\nnorbs\nncfgs\nCoulomb interaction\nicu\nUc\nUv\nJz\nJs\nJp\nUd\nJh\nSpin-orbit coupling\nisoc\nlambda\nCrystal field splitting\nicf\nmune","category":"page"},{"location":"ch01/index.html#Contents","page":"Contents","title":"Contents","text":"","category":"section"},{"location":"ch01/index.html","page":"Contents","title":"Contents","text":"Hi, welcome to the world of continuous-time quantum impurity solvers.","category":"page"},{"location":"ch01/index.html","page":"Contents","title":"Contents","text":"This is the official user manual for the iQIST software package which implements several state-of-the-art continuous-time quantum impurity solvers. In this chapter, you will learn something you have to know about the continuous-time quantum impurity solvers, and of course the iQIST software package.","category":"page"},{"location":"ch01/index.html","page":"Contents","title":"Contents","text":"Are you ready? Let's go!","category":"page"},{"location":"ch01/index.html","page":"Contents","title":"Contents","text":"What's iQIST? // Is it a food or an animal?\nMotivation // Why do we need the iQIST software package?\nComponents // What does the iQIST software package include?\nSoftware architecture // A bird's eye view of the iQIST software package.\nFeatures // What can we do by using the iQIST software package?\nPolicy // Some basic rules and tips.","category":"page"},{"location":"ch01/index.html","page":"Contents","title":"Contents","text":"If you are already familiar with the iQIST software package, perhaps you will be interested in the following advanced topics:","category":"page"},{"location":"ch01/index.html","page":"Contents","title":"Contents","text":"Quantum impurity solvers // A comprehensive reference about the impurity solvers.\n[Atomic eigenvalue problem solver] // A comprehensive reference about the atomic eigenvalue solver.\n[Auxiliary tools] // Full descriptions about the auxiliary toolbox.\n[iQIST in action] // Successful stories about the iQIST software package.","category":"page"},{"location":"ch01/index.html","page":"Contents","title":"Contents","text":"If you want to learn the secrets of the iQIST software package, then diving into","category":"page"},{"location":"ch01/index.html","page":"Contents","title":"Contents","text":"[Inside iQIST] // The principles, tricks, formulations, algorithms that are implemented in iQIST.","category":"page"},{"location":"ch01/index.html","page":"Contents","title":"Contents","text":"may be the best choices.","category":"page"},{"location":"ch01/motivation.html#Motivation","page":"Motivation","title":"Motivation","text":"","category":"section"},{"location":"ch01/motivation.html","page":"Motivation","title":"Motivation","text":"DMFT","category":"page"},{"location":"ch01/motivation.html","page":"Motivation","title":"Motivation","text":"Dynamical mean-field theory (DMFT) and its extensions play a very important role in contemporary studies of correlated electron systems. The broad applications of this technique range from the study of Mott transitions, unconventional superconductivity in Cu- and Fe-based superconductors, and non-Fermi liquid behaviors, to the investigation of anomalous transport properties of transition metal oxides. For many of these applications, DMFT is the currently most powerful and reliable (sometimes the only) technique available and has in many cases produced new physical insights. Furthermore, the combination of ab initio calculation method (such as density functional theory) with DMFT allows to compute the subtle electronic properties of realistic correlated materials, including partially filled 3d- and 4d-electron transition metal oxides, where lattice, spin and orbital degrees of freedom all coupled.","category":"page"},{"location":"ch01/motivation.html","page":"Motivation","title":"Motivation","text":"(Image: dmft image)","category":"page"},{"location":"ch01/motivation.html","page":"Motivation","title":"Motivation","text":"Figure | The hierarchical structure of DMFT and its extensions. The iQIST software package can be used as a computational engine of them.","category":"page"},{"location":"ch01/motivation.html","page":"Motivation","title":"Motivation","text":"(Image: dft_dmft_type image)","category":"page"},{"location":"ch01/motivation.html","page":"Motivation","title":"Motivation","text":"Figure | The hierarchical structure of DFT + DMFT and its extensions. The iQIST software package can be used as a computational engine of them.","category":"page"},{"location":"ch01/motivation.html","page":"Motivation","title":"Motivation","text":"","category":"page"},{"location":"ch01/motivation.html","page":"Motivation","title":"Motivation","text":"Quantum impurity solvers","category":"page"},{"location":"ch01/motivation.html","page":"Motivation","title":"Motivation","text":"The key idea of DMFT is to map the original correlated lattice model into a quantum impurity model whose mean-field bath is determined self-consistently. Thus, the central task of a DMFT simulation becomes the numerical solution of the quantum impurity problem. During the past several decades, many methods have been tested as impurity solvers, including the exact diagonalization (ED), equation of motion (EOM), Hubbard-I approximation (HIA), iterative perturbation theory (IPT), non-crossing approximation (NCA), fluctuation-exchange approximation (FLEX), and quantum Monte Carlo (QMC). Among the methods listed above, the QMC method has several very important advantages, which makes it so far the most flexible and widely used impurity solver. First, it is based on the imaginary time action, in which the infinite bath has been integrated out. Second, it can treat arbitrary couplings, and can thus be applied to all kinds of phases including the metallic phase, insulating state, and phases with spontaneous symmetry breaking. Third, the QMC method is numerically exact with a controllable numerical error. In other words, by increasing the computational effort the numerical error of the QMC simulation can be systematically reduced. For these reasons, the QMC algorithm is considered as the method of choice for many applications.","category":"page"},{"location":"ch01/motivation.html","page":"Motivation","title":"Motivation","text":"(Image: lattice image)","category":"page"},{"location":"ch01/motivation.html","page":"Motivation","title":"Motivation","text":"Figure | A schematic diagram of the key idea of DMFT.","category":"page"},{"location":"ch01/motivation.html","page":"Motivation","title":"Motivation","text":"(Image: scf_dmft image)","category":"page"},{"location":"ch01/motivation.html","page":"Motivation","title":"Motivation","text":"Figure | A schematic diagram of the self-consistent iteration of DMFT. Actually, the role played by the iQIST software package is the quantum impurity solver.","category":"page"},{"location":"ch01/motivation.html","page":"Motivation","title":"Motivation","text":"","category":"page"},{"location":"ch01/motivation.html","page":"Motivation","title":"Motivation","text":"CT-QMC impurity solvers","category":"page"},{"location":"ch01/motivation.html","page":"Motivation","title":"Motivation","text":"Several QMC impurity solvers have been developed in the past three decades. An important innovation was the Hirsch-Fye QMC (HF-QMC) impurity solver, in which the time axis is divided into small time steps and the interaction term in the Hamiltonian is decoupled on each time step by means of a discrete Hubbard-Stratonovich auxiliary field. HF-QMC has been widely used in the early studies of DMFT, but is limited by the discretization on the time axis and also by the form of the electronic interactions (usually only density-density interactions can be treated). Recently, a new class of more powerful and versatile QMC impurity solvers, continuous-time quantum Monte Carlo (CT-QMC) algorithms, have been invented. In the CT-QMC impurity solvers, the partition function of the quantum impurity problem is diagrammatically expanded, and then the diagrammatic expansion series is evaluated by stochastic Monte Carlo sampling. The continuous-time nature of the algorithm means that operators can be placed at any arbitrary position on the imaginary time interval, so that time discretization errors can be completely avoided. Depending on how the diagrammatic expansion is performed, the CT-QMC approach can be further divided into interaction expansion (or weak coupling) CT-QMC (CT-INT), auxiliary field CT-QMC (CT-AUX), and hybridization expansion (or strong coupling) CT-QMC (CT-HYB).","category":"page"},{"location":"ch01/motivation.html","page":"Motivation","title":"Motivation","text":"","category":"page"},{"location":"ch01/motivation.html","page":"Motivation","title":"Motivation","text":"CT-HYB impurity solvers","category":"page"},{"location":"ch01/motivation.html","page":"Motivation","title":"Motivation","text":"At present, the CT-HYB is the most popular and powerful impurity solver, since it can be used to solve multi-orbital impurity model with general interactions at low temperature. In single-site DMFT calculations, the computational efficiency of CT-HYB is much higher than that of CT-INT and HF-QMC, especially when the interactions are strong. However, in order to solve more complicated quantum impurity models (for example, five-band or seven-band impurity model with general interactions and spin-orbital coupling) efficiently, further improvements of the CT-HYB impurity solvers are needed. In recent years many tricks and algorithms have been developed to increase the efficiency and accuracy of original CT-HYB impurity solver, such as the truncation approximation, Krylov subspace iteration, orthogonal polynomial representation, PS quantum number, lazy trace evaluation, and skip listing method, and matrix product state implementation, etc.","category":"page"},{"location":"ch01/motivation.html","page":"Motivation","title":"Motivation","text":"","category":"page"},{"location":"ch01/motivation.html","page":"Motivation","title":"Motivation","text":"The iQIST software package","category":"page"},{"location":"ch01/motivation.html","page":"Motivation","title":"Motivation","text":"As the state-of-the-art CT-HYB impurity solvers become more and more sophisticated and specialized, it is not easy anymore to master all their facets and build ones implementations from scratch. Hence, we believe that it is a good time to provide a CT-HYB software package for the DMFT community such that researchers can focus more on the physical questions, instead of spending much time on (re-)implementing efficient codes. In fact, there are some valuable efforts in this direction, such as TRIQS, ALPS, ALPSCore, comsuite, w2dynamics, Haule's eDMFT codes, etc. However, a flexible, extensible, and highly efficient CT-HYB impurity solver is still lacking. The purpose of this reference manual is to present our solution – the open source software package iQIST – which contains several well-implemented and thoroughly tested modern CT-HYB impurity solvers, and the corresponding pre- and post-processing tools. Originally the iQIST software package was internally used in our group. Now we release it publicly and hope that the whole community will benefit from it.","category":"page"},{"location":"ch02/directory.html#Directory-structures","page":"Directory structures","title":"Directory structures","text":"","category":"section"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"The uncompressed iQIST software package is somewhat complicated, but have a rich content. We think that it is helpful to introduce the detailed directory structure of it. As has been explained before, in the following, we always use the term iqist to denote the top folder which contains the uncompressed iQIST software package.","category":"page"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"(Image: dir image)","category":"page"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"Figure | The directory structures of the iQIST software package.","category":"page"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"Where is the compling system?","category":"page"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"iqist/build","category":"page"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"Where are the source codes?","category":"page"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"iqist/src","category":"page"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"Where are the quantum impurity solvers?","category":"page"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"For CT-QMC quantum impurity solvers","category":"page"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"iqist/src/ctseg\niqist/src/cthyb","category":"page"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"Where is the atomic eigenvalue problem solver?","category":"page"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"iqist/src/atomic","category":"page"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"Where are the auxiliary tools?","category":"page"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"iqist/src/tools","category":"page"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"Where are the documentations?","category":"page"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"iqist/docs","category":"page"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"Where are the tutorials?","category":"page"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"iqist/tutor","category":"page"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"Where are the benchmark cases?","category":"page"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"iqist/test","category":"page"},{"location":"ch08/rng.html#Random-number-generators","page":"Random number generator","title":"Random number generators","text":"","category":"section"},{"location":"ch08/rng.html","page":"Random number generator","title":"Random number generator","text":"Fast, reliable, and long period pseudo-random number generators are a key factor for any Monte Carlo simulations. Currently, the most popular random number generator is the Mersenne Twister which was developed in 1998 by Matsumoto and Nishimura[1]. Its name derives from the fact that its period length is chosen to be a Mersenne prime. In the iQIST software package, we implemented the commonly used version of Mersenne Twister, MT19937. It has a very long period of 2^19937-1. Of course, if we choose different parameter sets, its period can be shorter or longer.","category":"page"},{"location":"ch08/rng.html","page":"Random number generator","title":"Random number generator","text":"The Mersenne Twister is a bit slow by today's standards. So in 2006, a variant of Mersenne Twister, the SIMD-oriented Fast Mersenne Twister (SFMT)[2] was introduced. It was designed to be fast when it runs on 128-bit SIMD. It is almost twice as fast as the original Mersenne Twister and has better statistics properties. We also implemented it in the iQIST software package, and use it as the default random number generator.","category":"page"},{"location":"ch08/rng.html","page":"Random number generator","title":"Random number generator","text":"Reference","category":"page"},{"location":"ch08/rng.html","page":"Random number generator","title":"Random number generator","text":"[1]: M. Matsumoto, T. Nishimura, ACM Transactions on Modeling and Computer Simulation 8 3 (1998)","category":"page"},{"location":"ch08/rng.html","page":"Random number generator","title":"Random number generator","text":"[2]: Mutsuo Saito and Makoto Matsumoto, Monte Carlo and Quasi-Monte Carlo Methods, Springer, 607 – 622 (2008)","category":"page"},{"location":"ch06/reader.html#u_reader.py","page":"u_reader.py","title":"u_reader.py","text":"","category":"section"},{"location":"ch06/reader.html","page":"u_reader.py","title":"u_reader.py","text":"Introduction","category":"page"},{"location":"ch06/reader.html","page":"u_reader.py","title":"u_reader.py","text":"The purpose of this script is provide an easy-to-use interface to read in and analyze the output data of the quantum impurity solver components.","category":"page"},{"location":"ch06/reader.html","page":"u_reader.py","title":"u_reader.py","text":"Type","category":"page"},{"location":"ch06/reader.html","page":"u_reader.py","title":"u_reader.py","text":"Python module","category":"page"},{"location":"ch06/reader.html","page":"u_reader.py","title":"u_reader.py","text":"APIs","category":"page"},{"location":"ch06/reader.html","page":"u_reader.py","title":"u_reader.py","text":"class iqistReader(object):\n    \"\"\" This class provide a few static methods which are used to extract\n        the data from the ouput files of ctqmc impurity solvers and hfqmc\n        impurity solver.\n    \"\"\"\n\n    @staticmethod\n    def get_green(norbs, ntime, fileName = None):\n        \"\"\" try to read the solver.green.dat or solver.green.bin.nnn file\n            to return the imaginary time Green's function G(\\tau) data\n        \"\"\"\n\n    @staticmethod\n    def get_grn(norbs, mfreq, fileName = None):\n        \"\"\" try to read the solver.grn.dat file to return the matsubara\n            Green's function G(i\\omega) data\n        \"\"\"\n\n    @staticmethod\n    def get_weiss(norbs, ntime, fileName = None):\n        \"\"\" try to read the solver.weiss.dat file to return the imaginary\n            time Weiss's function \\mathcal{G}(\\tau) data\n        \"\"\"\n\n    @staticmethod\n    def get_wss(norbs, mfreq, fileName = None):\n        \"\"\" try to read the solver.wss.dat file to return the matsubara\n            Weiss's function \\mathcal{G}(i\\omega) data\n        \"\"\"\n\n    @staticmethod\n    def get_hybri(norbs, ntime, fileName = None):\n        \"\"\" try to read the solver.hybri.dat file to return the imaginary\n            time hybridization function \\Delta(\\tau) data\n        \"\"\"\n\n    @staticmethod\n    def get_hyb(norbs, mfreq, fileName = None):\n        \"\"\" try to read the solver.hyb.dat file to return the matsubara\n            hybridization function \\Delta(i\\omega) data\n        \"\"\"\n\n    @staticmethod\n    def get_sgm(norbs, mfreq, fileName = None):\n        \"\"\" try to read the solver.sgm.dat file to return the matsubara\n            self-energy function \\Sigma(i\\omega) data\n        \"\"\"\n\n    @staticmethod\n    def get_hub(norbs, mfreq, fileName = None):\n        \"\"\" try to read the solver.hub.dat file to return the matsubara\n            Hubbard-I self-energy function \\Sigma_{hub}(i\\omega) data and\n            Green's function data\n        \"\"\"\n\n    @staticmethod\n    def get_hist(mkink, fileName = None):\n        \"\"\" try to read the solver.hist.dat file to return the histogram\n            data for diagrammatic perturbation expansion\n        \"\"\"\n\n    @staticmethod\n    def get_prob(ncfgs, nsect = 0, fileName = None):\n        \"\"\" try to read the solver.prob.dat file to return the atomic\n            state probability P_{\\Gamma} data\n        \"\"\"\n\n    @staticmethod\n    def get_nmat(norbs, fileName = None):\n        \"\"\" try to read the solver.nmat.dat file to return the occupation\n            number < N_i > and double occupation number < N_i N_j > data\n        \"\"\"\n\n    @staticmethod\n    def get_kmat(norbs, fileName = None):\n        \"\"\" try to read the solver.kmat.dat file to return the required\n            perturbation order data: < k > and < k^2 >\n        \"\"\"\n\n    @staticmethod\n    def get_lmat(norbs, fileName = None):\n        \"\"\" try to read the solver.lmat.dat file to return the fidelity\n            susceptibility data: < k_l >, < k_r >, and < k_l k_r >\n        \"\"\"\n\n    @staticmethod\n    def get_schi(nband, ntime, fileName = None):\n        \"\"\" try to read the solver.schi.dat file to return the spin-spin\n            correlation function < S_z(0) S_z(\\tau) > data\n        \"\"\"\n\n    @staticmethod\n    def get_sfom(nband, nbfrq, fileName = None):\n        \"\"\" try to read the solver.sfom.dat file to return the spin-spin\n            correlation function data\n        \"\"\"\n\n    @staticmethod\n    def get_ochi(norbs, ntime, fileName = None):\n        \"\"\" try to read the solver.ochi.dat file to return the orbital-\n            orbital correlation function < N_i(0) N_j(\\tau) > data\n        \"\"\"\n\n    @staticmethod\n    def get_ofom(norbs, nbfrq, fileName = None):\n        \"\"\" try to read the solver.ofom.dat file to return the orbital-\n            orbital correlation function data\n        \"\"\"\n\n    @staticmethod\n    def get_twop(norbs, nffrq, nbfrq, fileName = None):\n        \"\"\" try to read the solver.twop.dat file to return the two-particle\n            Green's function data\n        \"\"\"\n\n    @staticmethod\n    def get_vrtx(norbs, nffrq, nbfrq, fileName = None):\n        \"\"\" try to read the solver.vrtx.dat file to return the two-particle\n            Green's function data\n        \"\"\"\n\n    @staticmethod\n    def get_pair(norbs, nffrq, nbfrq, fileName = None):\n        \"\"\" try to read the solver.pair.dat file to return the pair\n            susceptibility data\n        \"\"\"\n\n    @staticmethod\n    def get_kernel(ntime, fileName = None):\n        \"\"\" try to read the solver.kernel.dat file to return the screening\n            function K(\\tau) and its first derivates\n        \"\"\"","category":"page"},{"location":"ch06/reader.html","page":"u_reader.py","title":"u_reader.py","text":"Examples","category":"page"},{"location":"ch06/reader.html","page":"u_reader.py","title":"u_reader.py","text":"# import this module\nfrom u_reader import *\n\n# setup parameters\nnorbs = 2\nntime = 1024\nmfreq = 8193\n\n# read the data\n(tmesh, gtau) = iqistReader.get_green(norbs, ntime)\n(tmesh, gbin) = iqistReader.get_green(norbs, ntime, \"solver.green.bin.10\")\n(rmesh, grnf) = iqistReader.get_grn(norbs, mfreq)","category":"page"},{"location":"ch06/reader.html","page":"u_reader.py","title":"u_reader.py","text":"note: Note\nYou can not execute u_reader.py in the terminal or Python environment directly, like this:$ python u_reader.py","category":"page"},{"location":"ch06/reader.html","page":"u_reader.py","title":"u_reader.py","text":"Comment","category":"page"},{"location":"ch06/reader.html","page":"u_reader.py","title":"u_reader.py","text":"N/A","category":"page"},{"location":"ch05/p_nmini.html#Parameter:-nmini","page":"nmini","title":"Parameter: nmini","text":"","category":"section"},{"location":"ch05/p_nmini.html","page":"nmini","title":"nmini","text":"Definition","category":"page"},{"location":"ch05/p_nmini.html","page":"nmini","title":"nmini","text":"The minimal total occupancy N which will be kept in the construction of atomic eigenstates.","category":"page"},{"location":"ch05/p_nmini.html","page":"nmini","title":"nmini","text":"Type","category":"page"},{"location":"ch05/p_nmini.html","page":"nmini","title":"nmini","text":"Integer","category":"page"},{"location":"ch05/p_nmini.html","page":"nmini","title":"nmini","text":"Default value","category":"page"},{"location":"ch05/p_nmini.html","page":"nmini","title":"nmini","text":"0","category":"page"},{"location":"ch05/p_nmini.html","page":"nmini","title":"nmini","text":"Component","category":"page"},{"location":"ch05/p_nmini.html","page":"nmini","title":"nmini","text":"Only for the JASMINE component.","category":"page"},{"location":"ch05/p_nmini.html","page":"nmini","title":"nmini","text":"Behavior","category":"page"},{"location":"ch05/p_nmini.html","page":"nmini","title":"nmini","text":"Those atomic eigenstates in which the total occupancy N in textnmini textnmaxi will be kept. The other atomic eigenstates will be discarded. It is an aggressive truncation and may led to significant derivations.","category":"page"},{"location":"ch05/p_nmini.html","page":"nmini","title":"nmini","text":"Comment","category":"page"},{"location":"ch05/p_nmini.html","page":"nmini","title":"nmini","text":"See also nmaxi parameter for more details.","category":"page"},{"location":"ch04/p_nspin.html#Parameter:-nspin","page":"nspin","title":"Parameter: nspin","text":"","category":"section"},{"location":"ch04/p_nspin.html","page":"nspin","title":"nspin","text":"Definition","category":"page"},{"location":"ch04/p_nspin.html","page":"nspin","title":"nspin","text":"Number of spin projection considered in the calculations.","category":"page"},{"location":"ch04/p_nspin.html","page":"nspin","title":"nspin","text":"Type","category":"page"},{"location":"ch04/p_nspin.html","page":"nspin","title":"nspin","text":"Integer","category":"page"},{"location":"ch04/p_nspin.html","page":"nspin","title":"nspin","text":"Default value","category":"page"},{"location":"ch04/p_nspin.html","page":"nspin","title":"nspin","text":"2","category":"page"},{"location":"ch04/p_nspin.html","page":"nspin","title":"nspin","text":"Component","category":"page"},{"location":"ch04/p_nspin.html","page":"nspin","title":"nspin","text":"ALL","category":"page"},{"location":"ch04/p_nspin.html","page":"nspin","title":"nspin","text":"Behavior","category":"page"},{"location":"ch04/p_nspin.html","page":"nspin","title":"nspin","text":"Determine the size of involved arrays.","category":"page"},{"location":"ch04/p_nspin.html","page":"nspin","title":"nspin","text":"Comment","category":"page"},{"location":"ch04/p_nspin.html","page":"nspin","title":"nspin","text":"See also nband, norbs, and ncfgs parameters for more details.","category":"page"},{"location":"ch04/p_nspin.html","page":"nspin","title":"nspin","text":"warning: Warning\nPlease DO NOT modify it. Now the quantum impurity solvers in the iQIST software package don't support nspin = 1.","category":"page"},{"location":"ch03/config.html#Configure-your-system","page":"Configure your system","title":"Configure your system","text":"","category":"section"},{"location":"ch03/config.html","page":"Configure your system","title":"Configure your system","text":"Please add the directory which includes the executable programs of iQIST software package to your system path. Usually, you can modify the .bashrc file in your home directory to reach this goal:","category":"page"},{"location":"ch03/config.html","page":"Configure your system","title":"Configure your system","text":"export PATH=iqist/build:$PATH","category":"page"},{"location":"ch03/config.html","page":"Configure your system","title":"Configure your system","text":"If you don't know how to modify the system environment variables, please consult your system administrator at first.","category":"page"},{"location":"ch04/in_eimp.html#solver.eimp.in","page":"solver.eimp.in","title":"solver.eimp.in","text":"","category":"section"},{"location":"ch04/in_eimp.html","page":"solver.eimp.in","title":"solver.eimp.in","text":"Introduction","category":"page"},{"location":"ch04/in_eimp.html","page":"solver.eimp.in","title":"solver.eimp.in","text":"The solver.eimp.in file is used to define impurity level matrix E_alphabeta and symmetry matrix symm(alpha,beta). Unfortunately, now only the diagonal elements of the two matrices are supported.","category":"page"},{"location":"ch04/in_eimp.html","page":"solver.eimp.in","title":"solver.eimp.in","text":"If the orbitals are degenerated, the impurity levels should be a constant and can be absorbed into the chemical potential mu. If the isbnd parameter is set to 2, the orbital-resolved observables are then symmetrized according the symmetry matrix. See isbnd for more details.","category":"page"},{"location":"ch04/in_eimp.html","page":"solver.eimp.in","title":"solver.eimp.in","text":"Format","category":"page"},{"location":"ch04/in_eimp.html","page":"solver.eimp.in","title":"solver.eimp.in","text":"The format of the solver.eimp.in file is as follows:","category":"page"},{"location":"ch04/in_eimp.html","page":"solver.eimp.in","title":"solver.eimp.in","text":"","category":"page"},{"location":"ch04/in_eimp.html","page":"solver.eimp.in","title":"solver.eimp.in","text":"column 1: orbital index, alpha, integer","category":"page"},{"location":"ch04/in_eimp.html","page":"solver.eimp.in","title":"solver.eimp.in","text":"column 2: diagonal element of the impurity level, E_alphaalpha, double precision","category":"page"},{"location":"ch04/in_eimp.html","page":"solver.eimp.in","title":"solver.eimp.in","text":"column 3: symmetry vector, symm(alpha), integer","category":"page"},{"location":"ch04/in_eimp.html","page":"solver.eimp.in","title":"solver.eimp.in","text":"","category":"page"},{"location":"ch04/in_eimp.html","page":"solver.eimp.in","title":"solver.eimp.in","text":"tip: Tip\nIn the solver.eimp.in file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch04/in_eimp.html","page":"solver.eimp.in","title":"solver.eimp.in","text":"Code","category":"page"},{"location":"ch04/in_eimp.html","page":"solver.eimp.in","title":"solver.eimp.in","text":"The corresponding Fortran code block for the reading of solver.eimp.in file is as follows:","category":"page"},{"location":"ch04/in_eimp.html","page":"solver.eimp.in","title":"solver.eimp.in","text":"open(mytmp, file='solver.eimp.in', form='formatted', status='unknown')\ndo i=1,norbs\n    read(mytmp,*) k, eimp(i), symm(i)\nenddo ! over i={1,norbs} loop\nclose(mytmp)","category":"page"},{"location":"ch04/in_eimp.html","page":"solver.eimp.in","title":"solver.eimp.in","text":"Usually, you have to edit the solver.eimp.in file by yourself.","category":"page"},{"location":"ch04/p_nfreq.html#Parameter:-nfreq","page":"nfreq","title":"Parameter: nfreq","text":"","category":"section"},{"location":"ch04/p_nfreq.html","page":"nfreq","title":"nfreq","text":"Definition","category":"page"},{"location":"ch04/p_nfreq.html","page":"nfreq","title":"nfreq","text":"Number of Matsubara frequency points sampling by continuous-time quantum Monte Carlo quantum impurity solver.","category":"page"},{"location":"ch04/p_nfreq.html","page":"nfreq","title":"nfreq","text":"Type","category":"page"},{"location":"ch04/p_nfreq.html","page":"nfreq","title":"nfreq","text":"Integer","category":"page"},{"location":"ch04/p_nfreq.html","page":"nfreq","title":"nfreq","text":"Default value","category":"page"},{"location":"ch04/p_nfreq.html","page":"nfreq","title":"nfreq","text":"128","category":"page"},{"location":"ch04/p_nfreq.html","page":"nfreq","title":"nfreq","text":"Component","category":"page"},{"location":"ch04/p_nfreq.html","page":"nfreq","title":"nfreq","text":"ALL","category":"page"},{"location":"ch04/p_nfreq.html","page":"nfreq","title":"nfreq","text":"Behavior","category":"page"},{"location":"ch04/p_nfreq.html","page":"nfreq","title":"nfreq","text":"Determine the size of involved arrays. The larger nfreq, the more computational time is needed.","category":"page"},{"location":"ch04/p_nfreq.html","page":"nfreq","title":"nfreq","text":"Comment","category":"page"},{"location":"ch04/p_nfreq.html","page":"nfreq","title":"nfreq","text":"There are mfreq matsubara frequency points in total. The physical observables on the first nfreq points are sampled directly by the Monte Carlo algorithm, however, the rest (mfreq - nfreq + 1 points) values are evaluated by using Hubbard-I approximation or the other algorithm.","category":"page"},{"location":"ch02/index.html#Contents","page":"Contents","title":"Contents","text":"","category":"section"},{"location":"ch02/index.html","page":"Contents","title":"Contents","text":"Are you interested in the iQIST software package?","category":"page"},{"location":"ch02/index.html","page":"Contents","title":"Contents","text":"Yes? Do you have passion for iQIST and want to have a try?","category":"page"},{"location":"ch02/index.html","page":"Contents","title":"Contents","text":"Yes? Great!","category":"page"},{"location":"ch02/index.html","page":"Contents","title":"Contents","text":"In this chapter, we will guide you to compile and install the iQIST software package step by step. Supposing that you have installed the iQIST software package successfully, you can skip this chapter and go to the next one.","category":"page"},{"location":"ch02/index.html","page":"Contents","title":"Contents","text":"Basic recipes:","category":"page"},{"location":"ch02/index.html","page":"Contents","title":"Contents","text":"Obtain // How to get the source codes?\nUncompress // Hmm, un-tar it.\nDirectory structures // Where are the quantum impurity solvers?\nCompiling environment // Fortran compiler and math library.\nCompiling system // How to make it?\nBuild iQIST at one step // Quickly build.","category":"page"},{"location":"ch02/index.html","page":"Contents","title":"Contents","text":"Advanced recipes:","category":"page"},{"location":"ch02/index.html","page":"Contents","title":"Contents","text":"Build quantum impurity solvers // Core components.\nBuild atomic eigenvalues solver // Companion of the quantum impurity solvers.\nBuild documentation // User manual.","category":"page"},{"location":"ch02/index.html","page":"Contents","title":"Contents","text":"note: Note\nWe assume that you are familiar with the basic terminal commands/operations of Linux system.\nWe assume that the root directory of the iQIST software package is just iqist in the manual, except stated explicitly. For example, if the iQIST software package was installed at /home/lihuang/iqist2025, then we just use iqist to denote this directory.","category":"page"},{"location":"ch02/system.html#Compiling-system","page":"Compiling system","title":"Compiling system","text":"","category":"section"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"In this section, we will illustrate the compiling system of the iQIST software package. In fact, it is completely based on the well-known GNU GCC tool-chain.","category":"page"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"The compiling system is in the iqist/build directory which includes the following files/folders:","category":"page"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"Makefile\nmake.inc","category":"page"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"Next, we will explain them in detail.","category":"page"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"","category":"page"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"Makefile","category":"page"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"It is the central file of the compiling system. Usually, when you type \"make target\" command in the terminal, the make utility will parse this file and then apply the rules defined in it to build the target. Now suppose that you are in the iqist/build directory, you can execute","category":"page"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"$ make help","category":"page"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"to see the available targets, and input","category":"page"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"$ make help-more","category":"page"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"for more details.","category":"page"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"warning: Warning\nDO NOT touch this file by yourself even you are very familiar with the iQIST software package.","category":"page"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"","category":"page"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"make.inc","category":"page"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"We design this file to configure the compiling system. In this file, we have to specify the Fortran compiler, the parallel environment, the linear algebra library, and the target hardware architecture, etc.","category":"page"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"warning: Warning\nThe make.inc file is system-dependent, i.e., you have to modify it to fit your systems. Or else, the compiling will fail definitely.","category":"page"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"We strongly recommend the users go through the make.inc file carefully and check whether the settings are correct before they start to compile the iQIST.","category":"page"},{"location":"ch04/p_nffrq.html#Parameter:-nffrq","page":"nffrq","title":"Parameter: nffrq","text":"","category":"section"},{"location":"ch04/p_nffrq.html","page":"nffrq","title":"nffrq","text":"Definition","category":"page"},{"location":"ch04/p_nffrq.html","page":"nffrq","title":"nffrq","text":"Number of fermionic Matsubara frequency points for the two-particle green's function.The two-particle Green's function chi(iomega_n iomega_n inu_n) and vertex function mathcalF(iomega_n iomega_n inu_n) have three frequency indices where omega_n and omega_n are fermionic frequencies, and nu_n bosonic frequency:nu_n = frac2npibetaomega_n = frac(2n+1)pibetaThe nbfrq parameter is used to define and generate the bosonic mesh nu_n. The corresponding fermionic mesh omega_n is defined by the nffrq parameter.","category":"page"},{"location":"ch04/p_nffrq.html","page":"nffrq","title":"nffrq","text":"Type","category":"page"},{"location":"ch04/p_nffrq.html","page":"nffrq","title":"nffrq","text":"Integer","category":"page"},{"location":"ch04/p_nffrq.html","page":"nffrq","title":"nffrq","text":"Default value","category":"page"},{"location":"ch04/p_nffrq.html","page":"nffrq","title":"nffrq","text":"32","category":"page"},{"location":"ch04/p_nffrq.html","page":"nffrq","title":"nffrq","text":"Component","category":"page"},{"location":"ch04/p_nffrq.html","page":"nffrq","title":"nffrq","text":"ALL","category":"page"},{"location":"ch04/p_nffrq.html","page":"nffrq","title":"nffrq","text":"Behavior","category":"page"},{"location":"ch04/p_nffrq.html","page":"nffrq","title":"nffrq","text":"Determine the size of involved arrays. Only useful when we need to compute the two-particle quantities.","category":"page"},{"location":"ch04/p_nffrq.html","page":"nffrq","title":"nffrq","text":"Comment","category":"page"},{"location":"ch04/p_nffrq.html","page":"nffrq","title":"nffrq","text":"If the nffrq is too large, the computational time is not bearable. So we suggest to set nffrq  128. The computation of two-particle quantities is extremely time-consuming, though we have tried our best optimizing it.See nbfrq and nfreq for more details.","category":"page"},{"location":"ch04/p_nffrq.html","page":"nffrq","title":"nffrq","text":"tip: Tip\nThe computation of two-particle quantities has been optimized using the OpenMP multi-thread technology. You can enable this feature in the compiling procedure. See also Compiling environment for more details.","category":"page"},{"location":"ch03/profile.html#Profile-the-codes","page":"Profile the codes","title":"Profile the codes","text":"","category":"section"},{"location":"ch03/profile.html","page":"Profile the codes","title":"Profile the codes","text":"note: Note\nTrust me, if you don't want to get involved into the tedious development of the iQIST software package, you can skip this section.","category":"page"},{"location":"ch03/profile.html","page":"Profile the codes","title":"Profile the codes","text":"Are you satisfying with the efficiency of the iQIST's quantum impurity solvers? Though we have spent a lot of time in improving the efficiency of the iQIST, there are still a lot of codes/algorithms to be optimized.","category":"page"},{"location":"ch03/profile.html","page":"Profile the codes","title":"Profile the codes","text":"Well, how to optimize the iQIST software package is not a trivial task. But, it is very important to figure out the hot-spots of the code at first. Usually, we use the following approach to analyze the computational efficiency of iQIST.","category":"page"},{"location":"ch03/profile.html","page":"Profile the codes","title":"Profile the codes","text":"Modify iqist/build/make.inc. Active the \"-pg\" compiler opinion\nRerun the codes.\nAfter the execution is finished, you will find a gmon.out file in the working directory. Here, we assume that you are running the iQIST codes in a Linux system. If you are using the MacOS system, the situation may be a bit different.\nThen you can use the GNU gprof tool to analyze the gmon.out file. You have to ensure the execute program is in the same directory. As for the usage of the gprof tool, please google or 'man' it by yourself.\nOf course, you can use any other advanced GUI tools to do this job. But it is far beyond the scopes of this reference manual.","category":"page"},{"location":"ch04/in_umat.html#solver.umat.in","page":"solver.umat.in","title":"solver.umat.in","text":"","category":"section"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"Introduction","category":"page"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"The quantum impurity solvers will automatically generate the Coulomb interaction matrix using the U and J parameters provided by you. But sometimes you may want to customize the Coulomb interaction matrix by yourself.","category":"page"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"Is it possible within the iQIST code?","category":"page"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"Yes, of course.","category":"page"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"You can define your Coulomb interaction matrix in the solver.umat.in file. And the iQIST codes will read data from it if it is available. Then the default Coulomb interaction matrix will be replaced with the new one. That's all.","category":"page"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"warning: Warning\nThe continuous-time quantum Monte Carlo impurity solvers in the general matrix representation, i.e., the MANJUSHAKA, component does not support this file/feature as well. All the information about the interaction matrix is already encapsulated in the atom.cix file.","category":"page"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"Format","category":"page"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"The format of the solver.umat.in file is as follows:","category":"page"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"","category":"page"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"column 1: orbital index i, integer","category":"page"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"column 2: orbital index j, integer","category":"page"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"column 3: Coulomb interaction matrix element U(ij), double precision","category":"page"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"","category":"page"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"tip: Tip\nIn the solver.umat.in file, we employed the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots Namely, we put the spin up part before the spin down part.","category":"page"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"Code","category":"page"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"The corresponding Fortran code block for the reading of solver.umat.in file is as follows:","category":"page"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"open(mytmp, file='solver.umat.in', form='formatted', status='unknown')\ndo i=1,norbs\n    do j=1,norbs\n        read(mytmp,*) k, l, rtmp\n        uumat(k,l) = rtmp\n    enddo ! over j={1,norbs} loop\nenddo ! over i={1,norbs} loop\nclose(mytmp)","category":"page"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"Usually, you have to edit the solver.umat.in file by yourself.","category":"page"},{"location":"ch06/movie.html#u_movie.py","page":"u_movie.py","title":"u_movie.py","text":"","category":"section"},{"location":"ch06/movie.html","page":"u_movie.py","title":"u_movie.py","text":"Introduction","category":"page"},{"location":"ch06/movie.html","page":"u_movie.py","title":"u_movie.py","text":"The purpose of this script is to generate the animation movie using the data contained in the solver.diag.dat file.","category":"page"},{"location":"ch06/movie.html","page":"u_movie.py","title":"u_movie.py","text":"Type","category":"page"},{"location":"ch06/movie.html","page":"u_movie.py","title":"u_movie.py","text":"Python script","category":"page"},{"location":"ch06/movie.html","page":"u_movie.py","title":"u_movie.py","text":"Usage","category":"page"},{"location":"ch06/movie.html","page":"u_movie.py","title":"u_movie.py","text":"First, please edit the configuration parameters (such as inverse temperature beta, number of orbitals norbs, number of frames nsweep/nwrite, etc) in the script carefully, and then execute it in the terminal:","category":"page"},{"location":"ch06/movie.html","page":"u_movie.py","title":"u_movie.py","text":"$ ./u_movie.py movie.mp4","category":"page"},{"location":"ch06/movie.html","page":"u_movie.py","title":"u_movie.py","text":"Here movie.mp4 is the output file. We can use the VLC to play it. If you don't supply any valid filename, the default output should be diag.mp4.","category":"page"},{"location":"ch06/movie.html","page":"u_movie.py","title":"u_movie.py","text":"note: Note\nUsually, the default setting in this script is not good. You have to adjust them again and again to obtain a good mp4 video.","category":"page"},{"location":"ch06/movie.html","page":"u_movie.py","title":"u_movie.py","text":"Input","category":"page"},{"location":"ch06/movie.html","page":"u_movie.py","title":"u_movie.py","text":"solver.diag.dat","category":"page"},{"location":"ch06/movie.html","page":"u_movie.py","title":"u_movie.py","text":"All of the CT-HYB quantum impurity solvers in the iQIST software package can output the solver.diag.dat file if the nwrite parameter is correctly set.","category":"page"},{"location":"ch06/movie.html","page":"u_movie.py","title":"u_movie.py","text":"Output","category":"page"},{"location":"ch06/movie.html","page":"u_movie.py","title":"u_movie.py","text":"movie.mp4","category":"page"},{"location":"ch06/movie.html","page":"u_movie.py","title":"u_movie.py","text":"You can specify the output filename by yourself. The suffix must be mp4.","category":"page"},{"location":"ch06/movie.html","page":"u_movie.py","title":"u_movie.py","text":"Comment","category":"page"},{"location":"ch06/movie.html","page":"u_movie.py","title":"u_movie.py","text":"The generated animation movie can be played using the VLC video tool. Sometimes the Quicktime player in the Mac OS X can not play it correctly.","category":"page"},{"location":"ch02/envir.html#Compiling-environment","page":"Compiling environment","title":"Compiling environment","text":"","category":"section"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"note: Note\nThe URLs/links provided in this page may be broken sometimes. If you meet the broken links, please contact us.","category":"page"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"In order to compile/execute the iQIST software package successfully, please confirm whether the following software/libraries are correctly installed and configured in your system.","category":"page"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"Fortran Compiler","category":"page"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"A modern Fortran compiler supporting ISO Fortran 2003 standard is necessary. We strongly advise you to choose the newest version of Intel Fortran Compiler (ifort) or GNU Fortran Compiler (gfortran). During the development of the iQIST software package, these two compilers are extensively used.","category":"page"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"Check the following websites for more details:","category":"page"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"Intel Fortran compiler\nGNU Fortran compiler","category":"page"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"note: Note\nBesides ifort and gfortran, in principle the iQIST software package can be compiled by any other Fortran 90 compilers, but we can not guarantee it.","category":"page"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"Parallel environment","category":"page"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"We use the message passing interface (MPI) to implement the parallelism in the iQIST software package. Therefore, in order to accelerate the quantum impurity solvers, you have to install a MPI implementation in your system, and setup it to work with the Fortran compiler you choose correctly. There are many MPI implementations in the market provided by various vendors. But we recommend to use the newest versions of MPICH or Openmpi.","category":"page"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"Check the following websites for more details:","category":"page"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"Message passing interface standard\nMPICH\nOpenmpi","category":"page"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"Some features in the iQIST software package have been optimized using the OpenMP multi-thread technology. The chosen Fortran compilers should support the OpenMP standard version 3.0 or later version.","category":"page"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"Check the following websites for more details:","category":"page"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"OpenMP\nOpenMP support in GNU GCC\nOpenMP support in Intel compilers","category":"page"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"Linear algebra library","category":"page"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"The iQIST software package depends on the BLAS and LAPACK libraries heavily. Then you have to ensure that a compatible math library is installed in your system. We recommend to use the Intel Math Kernel Library (Intel MKL). If you are using the MacOS system, the Accelerate Framework may be an alternate choice. Keep in mind that the running efficiency of iQIST is always benefited from the highly optimized linear algebra library.","category":"page"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"Check the following websites for more details:","category":"page"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"BLAS\nLAPACK\nIntel MKL\nOpenBLAS\nAccelerate Framework","category":"page"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"Python environment","category":"page"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"There are a few python scripts in the iQIST software package. In order to run them, you need a Python interpreter. We recommend to install Python 3.8+, and the numpy, scipy, matplotlib packages must be installed as well.","category":"page"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"Check the following websites for more details:","category":"page"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"Python\nnumpy\nscipy\nmatplotlib","category":"page"},{"location":"ch04/output.html#Contents","page":"Contents","title":"Contents","text":"","category":"section"},{"location":"ch04/output.html","page":"Contents","title":"Contents","text":"The quantum impurity solvers will generate a lot of data files at run time. In this section, we will depict their formats and usages in detail.","category":"page"},{"location":"ch04/output.html","page":"Contents","title":"Contents","text":"The data files could be classified as the following kinds:","category":"page"},{"location":"ch04/output.html","page":"Contents","title":"Contents","text":"Direct output\n[Terminal output] // Many useful stuffs in it\nGreen's function data\nsolver.green.dat // G(tau)\nsolver.weiss.dat // G_0(tau)\nsolver.grn.dat // G(iomega_n)\nsolver.wss.dat // G_0(iomega_n)\nHybridization function data\nsolver.hybri.dat // Delta(tau)\nsolver.hyb.dat // Delta(iomega_n)\nSelf-energy function data\nsolver.sgm.dat // Sigma(iomega_n)\n[solver.hub.dat] // Sigma_textatomic(iomega_n) and G_textatomic(iomega_n)\nTwo-particle Green's function data\n[solver.twop.dat] // Two-particle Green's function and vertex function\n[solver.vrtx.dat] // Two-particle Green's function and vertex function\n[solver.pair.dat] // Pairing susceptibility\nSusceptibility data\n[solver.schi.dat] // Spin-spin correlation function in tau space\n[solver.sfom.dat] // Spin-spin correlation function in Matsubara frequency space\n[solver.ochi.dat] // Orbital-orbital correlation in tau space\n[solver.ofom.dat] // Orbital-orbital correlation in Matsubara frequency space\nPhysical observables data\nsolver.hist.dat // Histogram for perturbation expansion order\nsolver.prob.dat // Atomic state probability\nsolver.nmat.dat // Occupation number\n[solver.kmat.dat] // langle k rangle and langle k^2 rangle\n[solver.lmat.dat] // langle k_L rangle and langle k_R rangle\nMiscellaneous data\n[solver.kernel.dat] // Frequency-dependent interaction\nsolver.status.dat // Status of the quantum impurity solvers\nsolver.diag.dat // Snapshot of the current configuration for diagrammatic perturbation expansion","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"<div align=\"center\">\n<img src=\"assets/logo.png\"/>\n<h1>\nReference Manual\n<font face = 'times'><i>for</i></font><br/>\n<font color = 'purple'>I</font>nteracting\n<font color = 'orange'>Q</font>uantum\n<font color = 'orange'>I</font>mpurity\n<font color = 'orange'>S</font>olver\n<font color = 'orange'>T</font>oolkit\n</h1>\n\nDraft Version: Jan 27, 2025 (in progress)\n</div>\n<br/>\n<br/>","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Obi-Wan Kenobi:\n\n    1. Use the Manual, Luke! (To Luke Skywalker)\n\n    2. May the Manual be with you. (To Anakin Skywalker)","category":"page"},{"location":"ch04/out_nmat.html#solver.nmat.dat","page":"solver.nmat.dat","title":"solver.nmat.dat","text":"","category":"section"},{"location":"ch04/out_nmat.html","page":"solver.nmat.dat","title":"solver.nmat.dat","text":"Introduction","category":"page"},{"location":"ch04/out_nmat.html","page":"solver.nmat.dat","title":"solver.nmat.dat","text":"The solver.nmat.dat file is used to memory the impurity occupancy and double occupancy matrix. It will be output by the quantum impurity solvers when they stop working.","category":"page"},{"location":"ch04/out_nmat.html","page":"solver.nmat.dat","title":"solver.nmat.dat","text":"Format","category":"page"},{"location":"ch04/out_nmat.html","page":"solver.nmat.dat","title":"solver.nmat.dat","text":"The solver.nmat.dat file contains two blocks. One is for the impurity occupancy langle n_irangle, and another one is for the double occupancy matrix langle n_i n_jrangle. In each block, the error bar data are always shown in the rightmost column.","category":"page"},{"location":"ch04/out_nmat.html","page":"solver.nmat.dat","title":"solver.nmat.dat","text":"note: Note\nIn the solver.nmat.dat file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch04/out_nmat.html","page":"solver.nmat.dat","title":"solver.nmat.dat","text":"Code","category":"page"},{"location":"ch04/out_nmat.html","page":"solver.nmat.dat","title":"solver.nmat.dat","text":"The corresponding Fortran code block for the writing of solver.nmat.dat file is as follows:","category":"page"},{"location":"ch04/out_nmat.html","page":"solver.nmat.dat","title":"solver.nmat.dat","text":"! open data file: solver.nmat.dat\n     open(mytmp, file='solver.nmat.dat', form='formatted', status='unknown')\n\n! write it\n     write(mytmp,'(a)') '#   < n_i >   data:'\n     do i=1,norbs\n         write(mytmp,'(i6,2f12.6)') i, nmat(i), nerr(i)\n     enddo ! over i={1,norbs} loop\n     write(mytmp,'(a6,2f12.6)') 'sup', sum( nmat(1:nband) ), sum( nerr(1:nband) )\n     write(mytmp,'(a6,2f12.6)') 'sdn', sum( nmat(nband+1:norbs) ), sum( nerr(nband+1:norbs) )\n     write(mytmp,'(a6,2f12.6)') 'sum', sum( nmat(1:norbs) ), sum( nerr(1:norbs) )\n\n     write(mytmp,'(a)') '# < n_i n_j > data:'\n     do i=1,norbs\n         do j=1,norbs\n             write(mytmp,'(2i6,2f12.6)') i, j, nnmat(i,j), nnerr(i,j)\n         enddo ! over j={1,norbs} loop\n     enddo ! over i={1,norbs} loop\n\n! close data file\n     close(mytmp)","category":"page"},{"location":"ch04/out_nmat.html","page":"solver.nmat.dat","title":"solver.nmat.dat","text":"Now we provide a Python module to read the output files of quantum impurity solvers. You can use it to read the solver.nmat.dat file. See script/u_reader.py for more details.","category":"page"},{"location":"ch04/out_sgm.html#solver.sgm.dat","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"","category":"section"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"Introduction","category":"page"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"This file is used to store the Matsubara self-energy function Sigma(iomega_n). It will be output by the quantum impurity solvers when they are shut down.","category":"page"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"Format","category":"page"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"The solver.sgm.dat file contains norbs block. Each block is appended by two blank lines. The format of each block is as follows:","category":"page"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"","category":"page"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"column 1: orbital index i, integer","category":"page"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"column 2: Matsubara frequency point, omega_n, double precision","category":"page"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"column 3: Matsubara self-energy function, Re Sigma(iomega_n), double precision","category":"page"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"column 4: Matsubara self-energy function, Im Sigma(iomega_n), double precision","category":"page"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"column 5: error bar, Re delta Sigma(iomega_n), double precision","category":"page"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"column 6: error bar, Im delta Sigma(iomega_n), double precision","category":"page"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"","category":"page"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"note: Note\nIn the solver.sgm.dat file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"Code","category":"page"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"The corresponding Fortran code block for the writing of solver.sgm.dat file is as follows:","category":"page"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"! open data file: solver.sgm.dat\nopen(mytmp, file='solver.sgm.dat', form='formatted', status='unknown')\n\n! write it\ndo i=1,norbs\n    do j=1,mfreq\n        write(mytmp,'(i6,5f16.8)') i, rmesh(j), sig2(j,i,i), serr(j,i,i)\n    enddo ! over j={1,mfreq} loop\n    write(mytmp,*) ! write empty lines\n    write(mytmp,*)\nenddo ! over i={1,norbs} loop\n\n! close data file\nclose(mytmp)","category":"page"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"note: Note\nThe columns for the error bar are always zero in this file.","category":"page"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"In the iQIST software package, we provide a Python module to read the output files of quantum impurity solvers. You can use it to read the solver.sgm.dat file. See [src/tools/u_reader.py] for more details.","category":"page"},{"location":"ch04/p_mfreq.html#Parameter:-mfreq","page":"mfreq","title":"Parameter: mfreq","text":"","category":"section"},{"location":"ch04/p_mfreq.html","page":"mfreq","title":"mfreq","text":"Definition","category":"page"},{"location":"ch04/p_mfreq.html","page":"mfreq","title":"mfreq","text":"Maximum number of Matsubara frequency points n_textmax. The Matsubara frequency mesh for fermions is defined as follows:omega_n = frac(2n + 1)pibetawhere n = 0, 1, 2, 3, cdots, n_textmax.","category":"page"},{"location":"ch04/p_mfreq.html","page":"mfreq","title":"mfreq","text":"Type","category":"page"},{"location":"ch04/p_mfreq.html","page":"mfreq","title":"mfreq","text":"Integer","category":"page"},{"location":"ch04/p_mfreq.html","page":"mfreq","title":"mfreq","text":"Default value","category":"page"},{"location":"ch04/p_mfreq.html","page":"mfreq","title":"mfreq","text":"8193 (equiv 2^13+1)","category":"page"},{"location":"ch04/p_mfreq.html","page":"mfreq","title":"mfreq","text":"Component","category":"page"},{"location":"ch04/p_mfreq.html","page":"mfreq","title":"mfreq","text":"ALL","category":"page"},{"location":"ch04/p_mfreq.html","page":"mfreq","title":"mfreq","text":"Behavior","category":"page"},{"location":"ch04/p_mfreq.html","page":"mfreq","title":"mfreq","text":"Determine the size of involved arrays, such as G(iomega_n), G_0(iomega_n), Sigma(iomega_n), and Delta(iomega_n) etc.","category":"page"},{"location":"ch04/p_mfreq.html","page":"mfreq","title":"mfreq","text":"Comment","category":"page"},{"location":"ch04/p_mfreq.html","page":"mfreq","title":"mfreq","text":"mfreq = 8193 is a safe setting. We don't recommend to change it.","category":"page"},{"location":"ch04/out_hist.html#solver.hist.dat","page":"solver.hist.dat","title":"solver.hist.dat","text":"","category":"section"},{"location":"ch04/out_hist.html","page":"solver.hist.dat","title":"solver.hist.dat","text":"Introduction","category":"page"},{"location":"ch04/out_hist.html","page":"solver.hist.dat","title":"solver.hist.dat","text":"The solver.hist.dat file is used to store the histogram for the perturbation expansion orders of the continuous-time quantum Monte Carlo impurity solvers. It will be output by the quantum impurity solvers periodically (every nwrite Monte Carlo sampling steps, see nwrite for more details).","category":"page"},{"location":"ch04/out_hist.html","page":"solver.hist.dat","title":"solver.hist.dat","text":"Format","category":"page"},{"location":"ch04/out_hist.html","page":"solver.hist.dat","title":"solver.hist.dat","text":"The solver.hist.dat file only contains one block. The format of the block is as follows:","category":"page"},{"location":"ch04/out_hist.html","page":"solver.hist.dat","title":"solver.hist.dat","text":"","category":"page"},{"location":"ch04/out_hist.html","page":"solver.hist.dat","title":"solver.hist.dat","text":"column 1: index of perturbation expansion order, integer","category":"page"},{"location":"ch04/out_hist.html","page":"solver.hist.dat","title":"solver.hist.dat","text":"column 2: count of the perturbation expansion order, integer","category":"page"},{"location":"ch04/out_hist.html","page":"solver.hist.dat","title":"solver.hist.dat","text":"column 3: percent of the perturbation expansion order, double precision","category":"page"},{"location":"ch04/out_hist.html","page":"solver.hist.dat","title":"solver.hist.dat","text":"column 4: error bar of the histogram","category":"page"},{"location":"ch04/out_hist.html","page":"solver.hist.dat","title":"solver.hist.dat","text":"","category":"page"},{"location":"ch04/out_hist.html","page":"solver.hist.dat","title":"solver.hist.dat","text":"Code","category":"page"},{"location":"ch04/out_hist.html","page":"solver.hist.dat","title":"solver.hist.dat","text":"The corresponding Fortran code block for the writing of solver.hist.dat file is as follows:","category":"page"},{"location":"ch04/out_hist.html","page":"solver.hist.dat","title":"solver.hist.dat","text":"! open data file: solver.hist.dat\n     open(mytmp, file='solver.hist.dat', form='formatted', status='unknown')\n\n! write it\n     write(mytmp,'(a)') '# histogram: order | count | percent'\n     do i=1,mkink\n         write(mytmp,'(i6,i12,2f12.6)') i-1, int( hint(i) ), haux(i), htmp(i)\n     enddo ! over i={1,mkink} loop\n\n! close data file\n     close(mytmp)","category":"page"},{"location":"ch04/out_hist.html","page":"solver.hist.dat","title":"solver.hist.dat","text":"Now we provide a Python module to read the output files of quantum impurity solvers. You can use it to read the solver.hist.dat file. See script/u_reader.py for more details.","category":"page"},{"location":"copy.html","page":"Copyright","title":"Copyright","text":"   o         o__ __o       __o__     o__ __o    ____o__ __o____\n _<|>_      /v     v\\        |      /v     v\\    /   \\   /   \\\n           />       <\\      / \\    />       <\\        \\o/\n   o     o/           \\o    \\o/   _\\o____              |\n  <|>   <|             |>    |         \\_\\__o__       < >\n  / \\    \\\\           //    < >              \\         |\n  \\o/      \\       \\o/       |     \\         /         o\n   |        o       |        o      o       o         <|\n  / \\       <\\__   / \\     __|>_    <\\__ __/>         / \\","category":"page"},{"location":"copy.html","page":"Copyright","title":"Copyright","text":"Copyright 2025 by The iQIST Developer Team","category":"page"},{"location":"copy.html","page":"Copyright","title":"Copyright","text":"Permission is granted to copy, distribute and/or modify the documentation under the terms of the GNU Free Documentation License, Version 1.2 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.","category":"page"},{"location":"copy.html","page":"Copyright","title":"Copyright","text":"Permission is granted to copy, distribute and/or modify the code of the package under the terms of the GNU Public License, Version 2 or any later version published by the Free Software Foundation.","category":"page"},{"location":"ch04/in_atom.html#atom.cix","page":"atom.cix","title":"atom.cix","text":"","category":"section"},{"location":"ch04/in_atom.html","page":"atom.cix","title":"atom.cix","text":"Introduction","category":"page"},{"location":"ch04/in_atom.html","page":"atom.cix","title":"atom.cix","text":"We use the atom.cix file to store the eigensystem of the local interaction Hamiltonian. It is necessary for the general matrix version of the CT-QMC impurity solvers.","category":"page"},{"location":"ch04/in_atom.html","page":"atom.cix","title":"atom.cix","text":"warning: Warning\nThe iQIST won't provide a default atom.cix file. Without this file, the general matrix version of the CT-QMC impurity solvers won't be started correctly.","category":"page"},{"location":"ch04/in_atom.html","page":"atom.cix","title":"atom.cix","text":"Format","category":"page"},{"location":"ch04/in_atom.html","page":"atom.cix","title":"atom.cix","text":"The atom.cix file is always generated by the JASMINE component. You should not modify it by yourself. Please see [Atomic eigenvalue problem solver] for more details about the JASMINE component.","category":"page"},{"location":"ch04/in_atom.html","page":"atom.cix","title":"atom.cix","text":"Now the JASMINE component can generate three kinds of atom.cix files.","category":"page"},{"location":"ch04/in_atom.html","page":"atom.cix","title":"atom.cix","text":"TYPE 0, only valid for the CAMELLIA component.\nTYPE 1, only valid for the BEGONIA and LAVENDER components.\nTYPE 2, only valid for the MANJUSHAKA and PANSY components.","category":"page"},{"location":"ch04/in_atom.html","page":"atom.cix","title":"atom.cix","text":"warning: Warning\nThe format of the atom.cix file may be modified in the near future. So we don't describe its format here.","category":"page"},{"location":"ch04/in_atom.html","page":"atom.cix","title":"atom.cix","text":"Code","category":"page"},{"location":"ch04/in_atom.html","page":"atom.cix","title":"atom.cix","text":"N/A","category":"page"},{"location":"ch02/obtain.html#Obtain","page":"Obtain","title":"Obtain","text":"","category":"section"},{"location":"ch02/obtain.html","page":"Obtain","title":"Obtain","text":"The first rule of thumb is to get the newest version of iQIST. Unfortunately, the release period for the iQIST software package is not fixed. In other words, it is very difficult to predict that when the new generation of iQIST will be released. There are two ways to get the newest release of iQIST software package.","category":"page"},{"location":"ch02/obtain.html","page":"Obtain","title":"Obtain","text":"","category":"page"},{"location":"ch02/obtain.html","page":"Obtain","title":"Obtain","text":"Method 1:","category":"page"},{"location":"ch02/obtain.html","page":"Obtain","title":"Obtain","text":"Download it directly from the online repository. Now we ONLY maintain one repository:","category":"page"},{"location":"ch02/obtain.html","page":"Obtain","title":"Obtain","text":"Github","category":"page"},{"location":"ch02/obtain.html","page":"Obtain","title":"Obtain","text":"The newest release of iQIST software package is v0.8.2-devel.230706.","category":"page"},{"location":"ch02/obtain.html","page":"Obtain","title":"Obtain","text":"note: Note\nSometimes the latest commit will not be compiled correctly. So, please download the released version of iQIST which has an unique version tag.","category":"page"},{"location":"ch02/obtain.html","page":"Obtain","title":"Obtain","text":"","category":"page"},{"location":"ch02/obtain.html","page":"Obtain","title":"Obtain","text":"Method 2:","category":"page"},{"location":"ch02/obtain.html","page":"Obtain","title":"Obtain","text":"Write a letter to one of the core members of the iQIST Developer Team (iQDT), i.e.,","category":"page"},{"location":"ch02/obtain.html","page":"Obtain","title":"Obtain","text":"Dr. Li HUANG (email: huangli at caep.cn)","category":"page"},{"location":"ch02/obtain.html","page":"Obtain","title":"Obtain","text":"and","category":"page"},{"location":"ch02/obtain.html","page":"Obtain","title":"Obtain","text":"Dr. Yilin WANG","category":"page"},{"location":"ch02/obtain.html","page":"Obtain","title":"Obtain","text":"As for the relevant contact information, please see Policy.","category":"page"},{"location":"ch04/p_norbs.html#Parameter:-norbs","page":"norbs","title":"Parameter: norbs","text":"","category":"section"},{"location":"ch04/p_norbs.html","page":"norbs","title":"norbs","text":"Definition","category":"page"},{"location":"ch04/p_norbs.html","page":"norbs","title":"norbs","text":"Number of correlated orbitals considered in the calculations.","category":"page"},{"location":"ch04/p_norbs.html","page":"norbs","title":"norbs","text":"Type","category":"page"},{"location":"ch04/p_norbs.html","page":"norbs","title":"norbs","text":"Integer","category":"page"},{"location":"ch04/p_norbs.html","page":"norbs","title":"norbs","text":"Default value","category":"page"},{"location":"ch04/p_norbs.html","page":"norbs","title":"norbs","text":"2","category":"page"},{"location":"ch04/p_norbs.html","page":"norbs","title":"norbs","text":"Component","category":"page"},{"location":"ch04/p_norbs.html","page":"norbs","title":"norbs","text":"ALL","category":"page"},{"location":"ch04/p_norbs.html","page":"norbs","title":"norbs","text":"Behavior","category":"page"},{"location":"ch04/p_norbs.html","page":"norbs","title":"norbs","text":"Determine the size of involved arrays.","category":"page"},{"location":"ch04/p_norbs.html","page":"norbs","title":"norbs","text":"Comment","category":"page"},{"location":"ch04/p_norbs.html","page":"norbs","title":"norbs","text":"The following relations always hold.textnorbs = textnpsin * textnbandtextncfgs = 2^textnorbsYou have to ensure the value of norbs is compatible with nband, nspin and ncfgs. The quantum impurity solvers will not check and correct them automatically. So you have to setup them in the solver.ctqmc.in and solver.hfqmc.in files explicitly.See also nspin, nband, and ncfgs parameters for more details.","category":"page"},{"location":"ch04/out_prob.html#solver.prob.dat","page":"solver.prob.dat","title":"solver.prob.dat","text":"","category":"section"},{"location":"ch04/out_prob.html","page":"solver.prob.dat","title":"solver.prob.dat","text":"Introduction","category":"page"},{"location":"ch04/out_prob.html","page":"solver.prob.dat","title":"solver.prob.dat","text":"The solver.prob.dat file is used to store the atomic state probability and related information about the quantum impurity solvers. It will be output by the quantum impurity solvers when they are shut down. We can use the data in it to analyze the valence fluctuation.","category":"page"},{"location":"ch04/out_prob.html","page":"solver.prob.dat","title":"solver.prob.dat","text":"Format","category":"page"},{"location":"ch04/out_prob.html","page":"solver.prob.dat","title":"solver.prob.dat","text":"The format of the solver.prob.dat file is somewhat complex. It contains three blocks. They show the probabilities for atomic states, orbitals, and spins, respectively. In the first block, the fifth column is used to represent the error bar.","category":"page"},{"location":"ch04/out_prob.html","page":"solver.prob.dat","title":"solver.prob.dat","text":"note: Note\nFor the MANJUSHAKA component, there is an additional block for showing the probabilities for sectors/superstates.","category":"page"},{"location":"ch04/out_prob.html","page":"solver.prob.dat","title":"solver.prob.dat","text":"Code","category":"page"},{"location":"ch04/out_prob.html","page":"solver.prob.dat","title":"solver.prob.dat","text":"The corresponding Fortran code block for the writing of solver.prob.dat file is as follows:","category":"page"},{"location":"ch04/out_prob.html","page":"solver.prob.dat","title":"solver.prob.dat","text":"! open data file: solver.prob.dat\nopen(mytmp, file='solver.prob.dat', form='formatted', status='unknown')\n\n! write it\nwrite(mytmp,'(a)') '# state probability: index | prob | occupy | spin'\ndo i=1,ncfgs\n    write(mytmp,'(i6,4f12.6)') i, prob(i), noccs(i), soccs(i) * half, perr(i)\nenddo ! over i={1,ncfgs} loop\n\nwrite(mytmp,'(a)') '# orbital probability: index | occupy | prob'\ndo i=0,norbs\n    write(mytmp,'(i6,3f12.6)') i + 1, real(i), oprob(i), operr(i)\nenddo ! over i={0,norbs} loop\nwrite(mytmp,'(a6,12X,f12.6)') 'sum', sum(oprob)\n\nwrite(mytmp,'(a)') '# spin probability: index | spin | prob'\ndo i=-nband,nband\n    write(mytmp,'(i6,3f12.6)') i + nband + 1, i * half, sprob(i), sperr(i)\nenddo ! over i={-nband,nband} loop\nwrite(mytmp,'(a6,12X,f12.6)') 'sum', sum(sprob)\n\n! close data file\nclose(mytmp)","category":"page"},{"location":"ch04/out_prob.html","page":"solver.prob.dat","title":"solver.prob.dat","text":"Now we provide a Python module to read the output files of quantum impurity solvers. You can use it to read the solver.prob.dat file. See script/u_reader.py for more details.","category":"page"},{"location":"ch04/p_nsweep.html#Parameter:-nsweep","page":"nsweep","title":"Parameter: nsweep","text":"","category":"section"},{"location":"ch04/p_nsweep.html","page":"nsweep","title":"nsweep","text":"Definition","category":"page"},{"location":"ch04/p_nsweep.html","page":"nsweep","title":"nsweep","text":"Maximum number of quantum Monte Carlo sampling steps.","category":"page"},{"location":"ch04/p_nsweep.html","page":"nsweep","title":"nsweep","text":"Type","category":"page"},{"location":"ch04/p_nsweep.html","page":"nsweep","title":"nsweep","text":"Integer","category":"page"},{"location":"ch04/p_nsweep.html","page":"nsweep","title":"nsweep","text":"Default value","category":"page"},{"location":"ch04/p_nsweep.html","page":"nsweep","title":"nsweep","text":"20000000 for CT-HYB impurity solvers","category":"page"},{"location":"ch04/p_nsweep.html","page":"nsweep","title":"nsweep","text":"Component","category":"page"},{"location":"ch04/p_nsweep.html","page":"nsweep","title":"nsweep","text":"ALL","category":"page"},{"location":"ch04/p_nsweep.html","page":"nsweep","title":"nsweep","text":"Behavior","category":"page"},{"location":"ch04/p_nsweep.html","page":"nsweep","title":"nsweep","text":"This is the number of Monte Carlo sampling steps conducted by the current process. If you run the quantum impurity solvers parallelly with N_textprocs processes, then the total number of Monte Carlo sampling steps in the calculation isN_textprocs times textnsweepLarger the nsweep is, more accurate and more time-consuming the calculation is. If you conduct the quantum impurity solver on many cores, you can decrease nsweep. But the minimal value of it should not be less than its default value.","category":"page"},{"location":"ch04/p_nsweep.html","page":"nsweep","title":"nsweep","text":"Comment","category":"page"},{"location":"ch04/p_nsweep.html","page":"nsweep","title":"nsweep","text":"In order to improve the numerical quality and suppress the numerical noise, the most direct and practicable route is to increase nsweep.If the data binning mode is activated, nsweep should not be larger than 200000000.nsweep should be always larger than ntherm, nwrite, nmonte, and ncarlo.","category":"page"},{"location":"ch04/p_nsweep.html","page":"nsweep","title":"nsweep","text":"See also ntherm, nwrite, nmonte, ncarlo parameters for more details.","category":"page"},{"location":"ch01/architecture.html#Software-architecture","page":"Software architecture","title":"Software architecture","text":"","category":"section"},{"location":"ch01/architecture.html","page":"Software architecture","title":"Software architecture","text":"To solve a quantum impurity model is not a straightforward job. Besides the necessary quantum impurity solvers, we need several auxiliary programs or tools. The iQIST is an all-in-one software package, which can be used to solve a broad range of quantum impurity problems. Thus, it is not surprising that iQIST is a collection of various codes and scripts. The core components contain about 50000 lines of code.","category":"page"},{"location":"ch01/architecture.html","page":"Software architecture","title":"Software architecture","text":"The software architecture of iQIST is slightly involved. We just use a layer model to illustrate it. Next, we will explain these layers one by one.","category":"page"},{"location":"ch01/architecture.html","page":"Software architecture","title":"Software architecture","text":"","category":"page"},{"location":"ch01/architecture.html#Operating-system-layer","page":"Software architecture","title":"Operating system layer","text":"","category":"section"},{"location":"ch01/architecture.html","page":"Software architecture","title":"Software architecture","text":"The bottom layer is the operating system (OS). In principle, the iQIST is OS-independent. It can run properly on top of Unix/Linux, Mac OS X, FreeBSD, and Windows.","category":"page"},{"location":"ch01/architecture.html#System-layer","page":"Software architecture","title":"System layer","text":"","category":"section"},{"location":"ch01/architecture.html","page":"Software architecture","title":"Software architecture","text":"The second layer is the system layer, which contains highly optimized linear algebra math libraries (such as BLAS and LAPACK) and parallelism supports (such as MPI and OpenMP).","category":"page"},{"location":"ch01/architecture.html#Service-layer","page":"Software architecture","title":"Service layer","text":"","category":"section"},{"location":"ch01/architecture.html","page":"Software architecture","title":"Software architecture","text":"The third layer is the service layer. In this layer, we implemented some commonly used modules and subroutines. They are provided in a separate library, namely Flink. The Flink library provides an useful interface between the system layer and the component layer and facilitate the development of core components. The features of the Flink library include basic data structures (stack and linked list), random number generators, spare matrix manipulations, linear algebra operations, string processing, linear interpolation, numerical integration, and fast Fourier transformation (FFT), etc.","category":"page"},{"location":"ch01/architecture.html#Component-layer","page":"Software architecture","title":"Component layer","text":"","category":"section"},{"location":"ch01/architecture.html","page":"Software architecture","title":"Software architecture","text":"The core part of iQIST software package is in the fourth layer – the component layer – which contains various quantum impurity solvers as shown before. At present, iQIST contains three different components, including","category":"page"},{"location":"ch01/architecture.html","page":"Software architecture","title":"Software architecture","text":"NARCISSUS\nMANJUSHAKA\nJASMINE","category":"page"},{"location":"ch01/architecture.html","page":"Software architecture","title":"Software architecture","text":"Here, NARCISSUS and MANJUSHAKA are CT-HYB quantum impurity solvers, and JASMINE is an atomic eigenvalue solver. For more details about these components, please consult the following chapters.","category":"page"},{"location":"ch08/qim.html#Quantum-impurity-model","page":"Quantum impurity model","title":"Quantum impurity model","text":"","category":"section"},{"location":"ch08/qim.html","page":"Quantum impurity model","title":"Quantum impurity model","text":"The main goal of the iQIST software package is to provide a comprehensive tool for solving the quantum impurity models, especially the Anderson impurity model. Generally speaking, the multi-orbital Anderson impurity model (AIM) can be written as","category":"page"},{"location":"ch08/qim.html","page":"Quantum impurity model","title":"Quantum impurity model","text":"beginequation\nH_textimp = H_textloc + H_textbath + H_texthyb\nendequation","category":"page"},{"location":"ch08/qim.html","page":"Quantum impurity model","title":"Quantum impurity model","text":"where","category":"page"},{"location":"ch08/qim.html","page":"Quantum impurity model","title":"Quantum impurity model","text":"beginequation\nH_textloc = sum_alphabeta E_alphabeta d_alpha^dagger d_beta+sum_alphabetagammadelta U_alphabetagammadelta\n    d^dagger_alphad^dagger_beta d_gamma d_delta\nendequation","category":"page"},{"location":"ch08/qim.html","page":"Quantum impurity model","title":"Quantum impurity model","text":"beginequation\nH_texthyb = sum_textbfkalphabeta V^alphabeta_textbfk c_textbfkalpha^dagger d_beta + hc\nendequation","category":"page"},{"location":"ch08/qim.html","page":"Quantum impurity model","title":"Quantum impurity model","text":"beginequation\nH_textbath = sum_textbfkalpha epsilon_textbfkalpha c_textbfkalpha^dagger c_textbfkalpha\nendequation","category":"page"},{"location":"ch08/qim.html","page":"Quantum impurity model","title":"Quantum impurity model","text":"In these equations, Greek letters in the subscripts denote a combined spin-orbital index, the fermion operator d_alpha^dagger (d_alpha) is creating (annihilating) an electron with index alpha on the impurity site, while c_textbfkalpha^dagger (c_textbfkalpha) is the creation (annihilation) operator for conduction band (bath) electron with spin-orbital index alpha and momentum textbfk.","category":"page"},{"location":"ch08/qim.html","page":"Quantum impurity model","title":"Quantum impurity model","text":"The first term in H_textloc is the general form of the impurity single particle term with energy level splitting and inter-orbital hybridization. This term can be generated by crystal field (CF) splitting or spin-orbit coupling (SOC), etc. The second term in H_textloc is the Coulomb interaction term which can be parameterized by intra(inter)-band Coulomb interactions U (U) and Hund's rule coupling J or Slater integral parameters F^k. The hybridization term H_texthyb describes the process of electrons hopping from the impurity site to the environment and back. H_textbath describes the non-interacting bath. This Anderson impurity model is usually solved self-consistently in the DMFT calculations.","category":"page"},{"location":"ch04/choose.html#How-to-choose-suitable-quantum-impurity-solvers?","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"","category":"section"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"At a first glance, you may feel puzzled why there are so many continuous-time quantum impurity solvers in the iQIST software package. What are the differences between them? Do we really need them? How to choose a suitable quantum impurity solvers for a given strongly correlated electron problem?","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"Relax! In the following we will uncover the secrets.","category":"page"},{"location":"ch04/choose.html#How-many-quantum-Monte-Carlo-impurity-solvers-are-there?","page":"How to choose suitable quantum impurity solvers?","title":"How many quantum Monte Carlo impurity solvers are there?","text":"","category":"section"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"Hmm, let me think. Two. Now the answer is two. These are the newest data. We are not sure whether there is new quantum impurity solver in the future.","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"The two CT-HYB quantum impurity solvers are as follows:","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"NARCISSUS\nMANJUSHAKA","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"You probably have found that we always used the flowers to name the quantum impurity solvers (and the other projects). Well, so many flowers. I think at least you will like one of them.","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"(Image: narcissus image)","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"Figure | Narcissus (source: internet).","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"(Image: manjushaka image)","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"Figure | Manjushaka (source: internet).","category":"page"},{"location":"ch04/choose.html#Do-we-really-need-these-quantum-impurity-solvers?","page":"How to choose suitable quantum impurity solvers?","title":"Do we really need these quantum impurity solvers?","text":"","category":"section"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"This problem is a bit complicated and equivalent to why we had designed and implemented so many quantum impurity solvers in the iQIST software package.","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"The answer is \"Yes\".","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"First, the state-of-the-art continuous-time quantum impurity solvers become more and more complex. In order to achieve high performance, many tricky algorithms, numerical methods are invented. Some of them conflict with each other. It is almost impossible to implement all of them in a single program. Second, the quantum impurity models in strongly correlated systems are extremely complicated and polytropic. It is also impossible to design such a perfect impurity solver which can solve all of the impurity problems. Third, each quantum impurity solver in the iQIST software package is designed for a specific impurity problem. These quantum impurity solvers share similar computational kernel, but they are highly optimized for the given impurity model.","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"The price for maintaining nine quantum impurity solvers is high, but it is worth it.","category":"page"},{"location":"ch04/choose.html#What-are-the-differences-between-these-quantum-impurity-solvers?","page":"How to choose suitable quantum impurity solvers?","title":"What are the differences between these quantum impurity solvers?","text":"","category":"section"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"NARCISSUS component","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"Model: Density-density interaction, retarded interaction, no SOC.\nAlgorithm: Segment representation.\nFeature: Full-fledged.\nScenario: Used in real research, especially in E-DMFT calculations.","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"MANJUSHAKA component","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"Model: General interaction, SOC.\nAlgorithm: General matrix representation + subspace + divide-and-conquer algorithm + Lazy trace evaluation + dynamical truncation + skip listing algorithm.\nFeature: Full-fledged.\nScenario: Used in real research.","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"See also:","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"Features // Exact features for the quantum impurity solvers.","category":"page"},{"location":"ch04/choose.html#How-to-choose-suitable-quantum-impurity-solvers-for-a-given-impurity-problem?","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers for a given impurity problem?","text":"","category":"section"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"OK, now let's return to the original problem. How to choose a suitable quantum impurity solver? It depends on the problems what you face. In the following, we will provide some guidelines.","category":"page"},{"location":"ch05/in_emat.html#atom.emat.in","page":"atom.emat.in","title":"atom.emat.in","text":"","category":"section"},{"location":"ch05/in_emat.html","page":"atom.emat.in","title":"atom.emat.in","text":"Introduction","category":"page"},{"location":"ch05/in_emat.html","page":"atom.emat.in","title":"atom.emat.in","text":"The purpose of the atom.emat.in file is to supply the on-site impurity energy level E_alphabeta, which is in fact the CFS + SOC. It is a diagonal matrix in the natural basis. Only when ibasis = 2, the atom.emat.in file is used. See ibasis for more details.","category":"page"},{"location":"ch05/in_emat.html","page":"atom.emat.in","title":"atom.emat.in","text":"note: Note\nThe so-called natural basis is the eigenstates of CFS + SOC matrix.\nOnly the diagonal elements of E_alphabeta are included in the atom.emat.in file.","category":"page"},{"location":"ch05/in_emat.html","page":"atom.emat.in","title":"atom.emat.in","text":"Format","category":"page"},{"location":"ch05/in_emat.html","page":"atom.emat.in","title":"atom.emat.in","text":"The format of the atom.emat.in file is as follows:","category":"page"},{"location":"ch05/in_emat.html","page":"atom.emat.in","title":"atom.emat.in","text":"","category":"page"},{"location":"ch05/in_emat.html","page":"atom.emat.in","title":"atom.emat.in","text":"column 1: orbital index alpha, integer","category":"page"},{"location":"ch05/in_emat.html","page":"atom.emat.in","title":"atom.emat.in","text":"column 2: orbital index beta, integer","category":"page"},{"location":"ch05/in_emat.html","page":"atom.emat.in","title":"atom.emat.in","text":"column 3: on-site impurity energy level E_alphabeta, double precision","category":"page"},{"location":"ch05/in_emat.html","page":"atom.emat.in","title":"atom.emat.in","text":"","category":"page"},{"location":"ch05/in_emat.html","page":"atom.emat.in","title":"atom.emat.in","text":"note: Note\nIn the atom.emat.in file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch05/in_emat.html","page":"atom.emat.in","title":"atom.emat.in","text":"Code","category":"page"},{"location":"ch05/in_emat.html","page":"atom.emat.in","title":"atom.emat.in","text":"The corresponding Fortran code block for the reading of the atom.emat.in file is as follows:","category":"page"},{"location":"ch05/in_emat.html","page":"atom.emat.in","title":"atom.emat.in","text":"! open file atom.emat.in\nopen(mytmp, file='atom.emat.in', form='formatted', status='unknown')\n\n! read the data file\ndo i=1,norbs\n    read(mytmp,*) i1, i2, raux\n    ! emat is actually real and diagonal in natural basis\n    emat(i,i) = dcmplx(raux, zero)\nenddo ! over i={1,norbs} loop\n\n! close data file\nclose(mytmp)","category":"page"},{"location":"ch03/index.html#Contents","page":"Contents","title":"Contents","text":"","category":"section"},{"location":"ch03/index.html","page":"Contents","title":"Contents","text":"Well, I guesss that you have compiled and installed the iQIST software package on your system successfully. And you cannot wait trying it now. But wait, there is still a lot of stuffs you have to keep in mind before you submit the iQIST-related jobs in your queue system.","category":"page"},{"location":"ch03/index.html","page":"Contents","title":"Contents","text":"Configure your system // Environment variables.\niQIST recipes // The basic workflow for cooking with iQIST.\nPrepare input files // Are you ready?\nExecute the codes // MPI vs. OpenMP, paralleled or serial.\nMonitor the codes // What's the status of the code?\nProfile the codes // Is it possible to accelerate the code further?","category":"page"},{"location":"ch03/index.html","page":"Contents","title":"Contents","text":"OK, if you are already familiar with the basic usage of the iQIST software package, then you can read the following advanced topics.","category":"page"},{"location":"ch03/index.html","page":"Contents","title":"Contents","text":"Quantum impurity solvers // A comprehensive reference about the quantum impurity solvers.\n[Atomic eigenvalue problem solver] // A comprehensive reference about the atomic eigenvalue problem solver.\n[Auxiliary tools] // Full descriptions about the auxiliary toolbox.\n[Inside iQIST] // The principles, tricks, formulations, algorithms that implemented in iQIST.","category":"page"},{"location":"ch05/input.html#Standard-input-files","page":"README","title":"Standard input files","text":"","category":"section"},{"location":"ch05/input.html","page":"README","title":"README","text":"The atomic eigenvalue problem solver, i.e., the JASMINE component, is designed to diagonalize the atomic Hamiltonian and generate the necessary atom.cix file for the CT-HYB quantum impurity solvers. Since the atomic Hamiltonian is a bit complex, which may include the chemical potential term, onsite Coulomb interaction matrix term, crystal field splitting term, and spin-orbit coupling term, and so on. Some of them are in matrix-form, and the others are vectors. So in order to define the atomic Hamiltonian conveniently, it is essential to introduce multiple input files.","category":"page"},{"location":"ch05/input.html","page":"README","title":"README","text":"The standard input files supported by the atomic eigenvalue problem solver are as follows:","category":"page"},{"location":"ch05/input.html","page":"README","title":"README","text":"atom.config.in // Primary configuration file for the JASMINE component.\natom.cmat.in // Crystal field splitting.\natom.emat.in // On-site impurity energy level.\natom.tmat.in // Transformation matrix.","category":"page"},{"location":"ch04/out_stat.html#solver.status.dat","page":"solver.status.dat","title":"solver.status.dat","text":"","category":"section"},{"location":"ch04/out_stat.html","page":"solver.status.dat","title":"solver.status.dat","text":"Introduction","category":"page"},{"location":"ch04/out_stat.html","page":"solver.status.dat","title":"solver.status.dat","text":"The solver.status.dat is used to store the current diagram configuration. In other words, we can treat it as a snapshot of the CT-QMC impurity solvers.","category":"page"},{"location":"ch04/out_stat.html","page":"solver.status.dat","title":"solver.status.dat","text":"Usually, the quantum impurity solvers will output solver.status.dat file periodically. In the next run, they can reload it in order to reach thermal equilibrium state as soon as possible. In addition, when they meet fatal errors/exceptions, a solver.status.dat will be generated as well. It is very useful for us to diagnose where the bug is.","category":"page"},{"location":"ch04/out_stat.html","page":"solver.status.dat","title":"solver.status.dat","text":"danger: Danger\nThe solver.status.dat is always generated by the quantum impurity solvers. DO NOT try to modify it by yourself. It is EXTREMELY DANGEROUS.","category":"page"},{"location":"ch04/out_stat.html","page":"solver.status.dat","title":"solver.status.dat","text":"Format","category":"page"},{"location":"ch04/out_stat.html","page":"solver.status.dat","title":"solver.status.dat","text":"The solver.status.dat files generated by various quantum impurity solvers are quite different. In principle you can not mix them. For example, the solver.status.dat generated by the NARCISSUS component can not be recognized by the MANJUSHAKA component, and vice versa.","category":"page"},{"location":"ch04/out_stat.html","page":"solver.status.dat","title":"solver.status.dat","text":"Code","category":"page"},{"location":"ch04/out_stat.html","page":"solver.status.dat","title":"solver.status.dat","text":"N/A","category":"page"},{"location":"ch04/p_isbnd.html#Parameter:-isbnd","page":"isbnd","title":"Parameter: isbnd","text":"","category":"section"},{"location":"ch04/p_isbnd.html","page":"isbnd","title":"isbnd","text":"Definition","category":"page"},{"location":"ch04/p_isbnd.html","page":"isbnd","title":"isbnd","text":"Key control flag, it is used to determine the symmetry of bands/orbitals.","category":"page"},{"location":"ch04/p_isbnd.html","page":"isbnd","title":"isbnd","text":"Type","category":"page"},{"location":"ch04/p_isbnd.html","page":"isbnd","title":"isbnd","text":"Integer","category":"page"},{"location":"ch04/p_isbnd.html","page":"isbnd","title":"isbnd","text":"Default value","category":"page"},{"location":"ch04/p_isbnd.html","page":"isbnd","title":"isbnd","text":"1","category":"page"},{"location":"ch04/p_isbnd.html","page":"isbnd","title":"isbnd","text":"Component","category":"page"},{"location":"ch04/p_isbnd.html","page":"isbnd","title":"isbnd","text":"ALL","category":"page"},{"location":"ch04/p_isbnd.html","page":"isbnd","title":"isbnd","text":"Behavior","category":"page"},{"location":"ch04/p_isbnd.html","page":"isbnd","title":"isbnd","text":"There are two possible values for the isbnd parameter so far:isbnd = 1, the bands are not symmetrized.\nisbnd = 2, the bands are symmetrized according to symmetry matrix symm.The quantum impurity solvers will symmetrize the relevant physical quantities according to the isbnd parameter.","category":"page"},{"location":"ch04/p_isbnd.html","page":"isbnd","title":"isbnd","text":"Comment","category":"page"},{"location":"ch04/p_isbnd.html","page":"isbnd","title":"isbnd","text":"There is still one question. What's the symmetry matrix and where is it?In fact, we should call it symmetry vector, instead of symmetry matrix. It is an integer vector whose size is exact norbs. The quantum impurity solvers will use it to perform symmetrization. Let's suppose this vector is called symm. For example, there is a 5-band model, the symmetry vector is as follows:symm(01) = 1\nsymm(02) = 2\nsymm(03) = 3\nsymm(04) = 4\nsymm(05) = 4\nsymm(06) = 4\nsymm(07) = 5\nsymm(08) = 5\nsymm(09) = 5\nsymm(10) = 1Guess which orbitals are degenerated?ehh, the orbitals 1 and 10, since symm(01) and symm(10) are all 1. Similarly, the orbitals 4, 5, and 6 are degenerated. The orbitals 7, 8, and 9 are degenerated as well.Yes, you are right. The quantum impurity solvers will consider that those orbitals which have the same symmetry number (the element of symm) are degenerated.By default, the elements in symm vector are 1. In other words, if isbnd = 2, all of the orbitals are degenerated. If you want to re-assign the degenerated orbitals, you can edit the solver.eimp.in file. See solver.eimp.in for more details.","category":"page"},{"location":"ch04/p_nclean.html#Parameter:-nclean","page":"nclean","title":"Parameter: nclean","text":"","category":"section"},{"location":"ch04/p_nclean.html","page":"nclean","title":"nclean","text":"Definition","category":"page"},{"location":"ch04/p_nclean.html","page":"nclean","title":"nclean","text":"Clean update period for quantum impurity solvers.","category":"page"},{"location":"ch04/p_nclean.html","page":"nclean","title":"nclean","text":"Type","category":"page"},{"location":"ch04/p_nclean.html","page":"nclean","title":"nclean","text":"Integer","category":"page"},{"location":"ch04/p_nclean.html","page":"nclean","title":"nclean","text":"Default value","category":"page"},{"location":"ch04/p_nclean.html","page":"nclean","title":"nclean","text":"100000 (for CT-HYB impurity solvers)","category":"page"},{"location":"ch04/p_nclean.html","page":"nclean","title":"nclean","text":"Component","category":"page"},{"location":"ch04/p_nclean.html","page":"nclean","title":"nclean","text":"ALL","category":"page"},{"location":"ch04/p_nclean.html","page":"nclean","title":"nclean","text":"Behavior","category":"page"},{"location":"ch04/p_nclean.html","page":"nclean","title":"nclean","text":"After a few Monte Carlo sampling steps, the numerical accuracy may be deteriorated. In order to retain the numerical accuracy, the quantum impurity solvers will conduct a clean update (in other words, recalculate everything from scratch) every nclean Monte Carlo sampling step.","category":"page"},{"location":"ch04/p_nclean.html","page":"nclean","title":"nclean","text":"Comment","category":"page"},{"location":"ch04/p_nclean.html","page":"nclean","title":"nclean","text":"nclean = 100000 (for CT-HYB) is an optimal setting. Do not modify it casually.","category":"page"},{"location":"ch05/p_jp.html#Parameter:-Jp","page":"Jp","title":"Parameter: Jp","text":"","category":"section"},{"location":"ch05/p_jp.html","page":"Jp","title":"Jp","text":"Definition","category":"page"},{"location":"ch05/p_jp.html","page":"Jp","title":"Jp","text":"Strength of pair-hopping interaction.","category":"page"},{"location":"ch05/p_jp.html","page":"Jp","title":"Jp","text":"Type","category":"page"},{"location":"ch05/p_jp.html","page":"Jp","title":"Jp","text":"Float, double precision","category":"page"},{"location":"ch05/p_jp.html","page":"Jp","title":"Jp","text":"Default value","category":"page"},{"location":"ch05/p_jp.html","page":"Jp","title":"Jp","text":"0.0","category":"page"},{"location":"ch05/p_jp.html","page":"Jp","title":"Jp","text":"Component","category":"page"},{"location":"ch05/p_jp.html","page":"Jp","title":"Jp","text":"Only for the JASMINE component.","category":"page"},{"location":"ch05/p_jp.html","page":"Jp","title":"Jp","text":"Behavior","category":"page"},{"location":"ch05/p_jp.html","page":"Jp","title":"Jp","text":"It is used to build the interaction term in the local Hamiltonian, only valid when icu = 1 or icu = 3.","category":"page"},{"location":"ch05/p_jp.html","page":"Jp","title":"Jp","text":"Comment","category":"page"},{"location":"ch05/p_jp.html","page":"Jp","title":"Jp","text":"See also Uc, Uv, Jz, Js, and icu parameters for more details.","category":"page"},{"location":"ch08/coulomb.html#Coulomb-interaction","page":"Coulomb interaction matrix","title":"Coulomb interaction","text":"","category":"section"},{"location":"ch08/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"The standard form of Coulomb interaction in second quantization form is:","category":"page"},{"location":"ch08/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"beginequation\nhatH_textCoulomb=\nfrac12sum_sigmasigma^primesum_abcd\nleftlangle asigmabsigma^primeleft\nfrac1r_12\nrightcsigmadsigma^primerightrangle\nhatf_asigma^dagger\nhatf_bsigma^prime^dagger\nhatf_dsigma^prime\nhatf_csigma\nendequation","category":"page"},{"location":"ch08/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"where frac1r_12 is the Coulomb interaction, r_12=vecr_1-vecr_2, abcd is orbital index and sigmasigma^prime=uparrowdownarrow is spin index.","category":"page"},{"location":"ch08/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"","category":"page"},{"location":"ch08/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"Slater Type Interaction","category":"page"},{"location":"ch08/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"In this single particle basis, the Coulomb interaction Hamiltonian is:","category":"page"},{"location":"ch08/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"beginequation\nhatH_U=frac12sum_m_1m_2m_1^primem_2^primesigmasigma^primeleftlangle m_1sigmam_2sigma^primeleftfrac1r_12rightm_1^primesigmam_2^primesigma^primerightrangle hatf_m_1sigma^daggerhatf_m_2sigma^prime^daggerhatf_m_2^primesigma^primehatf_m_1^primesigma\nendequation","category":"page"},{"location":"ch08/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"Set","category":"page"},{"location":"ch08/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"alpha=m_1sigma beta=m_2sigma^prime gamma=m_1^primesigma delta=m_2^primesigma^prime","category":"page"},{"location":"ch08/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"thus the Coulomb U-tensor (UMAT) in the JASMINE component reads:","category":"page"},{"location":"ch08/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"beginequation\ntextbfUMAT(alphabetadeltagamma)=frac12delta(m_1+m_2m_1^prime+m_2^prime)sum_kc_l^k(m_1m_1^prime)c_l^k(m_2^primem_2)F_nl^k\nendequation","category":"page"},{"location":"ch08/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"Here, F_nl^k is the Slater integrals:","category":"page"},{"location":"ch08/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"beginequation\nF_nl^k=int_0^inftyr_1^2dr_1int_0^inftyr_2^2dr_2R_nl^2(r_1)R_nl^2(r_2)fracr_^kr_^k+1\nendequation","category":"page"},{"location":"ch08/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"c_l^k(m^primem^primeprime) is related to the Gaunt coefficient for fixed l. It is defined as:","category":"page"},{"location":"ch08/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"beginequation\nc_l^k(m^primem^primeprime) =\nsqrtfrac4pi2k+1\nint dphi dthetasin(theta)\nY_l^m^prime*(thetaphi)\nY_k^m^prime-m^primeprime(thetaphi)\nY_l^m^primeprime(thetaphi)\nendequation","category":"page"},{"location":"ch08/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"Note that the Gaunt coefficient is defined as the integral over three spherical harmonics:","category":"page"},{"location":"ch08/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"beginaligned\noperatornameGaunt(l_1l_2l_3m_1m_2m_3)\n=int Y_l_1m_1(Omega)\n       Y_l_2m_2(Omega)\n       Y_l_3m_3(Omega) dOmega \n=sqrtfrac(2l_1+1)(2l_2+1)(2l_3+1)4pi\n      operatornameWigner3j(l_1l_2l_3000)\n      operatornameWigner3j(l_1l_2l_3m_1m_2m_3)\nendaligned","category":"page"},{"location":"ch08/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"We adopted the following Python script to generate c_l^k(m^primem^primeprime):","category":"page"},{"location":"ch08/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"from sympy import *\nfrom sympy.physics.wigner import gaunt\n\ndef get_gaunt(l1, l2):\n    for k in range(l1 + l2 + 1):\n        if not ((l1 + l2 + k) % 2 == 0 and abs(l1 - l2) <= k <= l1 + l2):\n            continue\n        for i1, m1 in enumerate(range(-l1, l1 + 1)):\n            for i2, m2 in enumerate(range(-l2, l2 + 1)):\n                x = symbols('x')\n                f1 = sqrt(4*pi / (2*x + 1)) * gaunt(l1, k, l2, -m1, m1 - m2, m2)\n                f2 = f1.subs(x, k)\n                f3 = (-1.0)**m1\n                if f2 == 0:\n                    continue\n                print('gaunt(', i1-l1, ',', i2-l2, ', ', k, ') = ', f2, '* (', f3, ')')\n","category":"page"},{"location":"ch08/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"For d-electron system, we use get_gaunt(2,2). As for f-electron system, we use get_gaunt(3,3).","category":"page"},{"location":"ch08/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"","category":"page"},{"location":"ch08/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"Kanamori Type Interaction","category":"page"},{"location":"ch08/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"The Kanomori type of Coulomb interaction Hamiltonian in the JASMINE component is defined as:","category":"page"},{"location":"ch08/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"beginalign\nhatH_U\n  =  U^primesum_atextbsigmahatf_asigma^daggerhatf_asigmahatf_b-sigma^daggerhatf_b-sigma\n  + (U^prime-J_z)sum_absigmahatf_asigma^daggerhatf_asigmahatf_bsigma^daggerhatf_bsigma \n  -  J_ssum_absigmahatf_asigma^daggerhatf_a-sigmahatf_b-sigma^daggerhatf_bsigma\n  +  J_psum_aneq bhatf_auparrow^daggerhatf_adownarrow^daggerhatf_bdownarrowhatf_buparrow\nendalign","category":"page"},{"location":"ch08/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"where, ab is orbital index, and sigma=uparrowdownarrow is spin index.","category":"page"},{"location":"ch05/p_norbs.html#Parameter:-norbs","page":"norbs","title":"Parameter: norbs","text":"","category":"section"},{"location":"ch05/p_norbs.html","page":"norbs","title":"norbs","text":"Definition","category":"page"},{"location":"ch05/p_norbs.html","page":"norbs","title":"norbs","text":"Number of correlated orbitals.","category":"page"},{"location":"ch05/p_norbs.html","page":"norbs","title":"norbs","text":"Type","category":"page"},{"location":"ch05/p_norbs.html","page":"norbs","title":"norbs","text":"Integer","category":"page"},{"location":"ch05/p_norbs.html","page":"norbs","title":"norbs","text":"Default value","category":"page"},{"location":"ch05/p_norbs.html","page":"norbs","title":"norbs","text":"2","category":"page"},{"location":"ch05/p_norbs.html","page":"norbs","title":"norbs","text":"Component","category":"page"},{"location":"ch05/p_norbs.html","page":"norbs","title":"norbs","text":"Only for the JASMINE component.","category":"page"},{"location":"ch05/p_norbs.html","page":"norbs","title":"norbs","text":"Behavior","category":"page"},{"location":"ch05/p_norbs.html","page":"norbs","title":"norbs","text":"Determine the size of involved arrays.","category":"page"},{"location":"ch05/p_norbs.html","page":"norbs","title":"norbs","text":"Comment:","category":"page"},{"location":"ch05/p_norbs.html","page":"norbs","title":"norbs","text":"The following relations always hold:textnorbs = textnpsin * textnbandtextncfgs = 2^textnorbsYou have to ensure the value of norbs is compatible with nband, nspin and ncfgs. The JASMINE component will not check and correct them automatically. See also nspin, nband, and ncfgs parameters for more details.","category":"page"},{"location":"ch04/in_hyb.html#solver.hyb.in","page":"solver.hyb.in","title":"solver.hyb.in","text":"","category":"section"},{"location":"ch04/in_hyb.html","page":"solver.hyb.in","title":"solver.hyb.in","text":"Introduction","category":"page"},{"location":"ch04/in_hyb.html","page":"solver.hyb.in","title":"solver.hyb.in","text":"The solver.hyb.in file is an optional input file for iQIST software package. It is defined to initialize the Matsubara hybridization function Delta(iomega_n). This file is usually not generated by hand, but directly rename the output file of iQIST software package solver.hyb.dat as solver.hyb.in. The non-interacting hybridization function will be used as an input file on the condition that the user doesn't provide the initial solver.hyb.in file. However, the system will read in the parameters from the solver.hyb.in file given by the user to replace the default values.","category":"page"},{"location":"ch04/in_hyb.html","page":"solver.hyb.in","title":"solver.hyb.in","text":"Format","category":"page"},{"location":"ch04/in_hyb.html","page":"solver.hyb.in","title":"solver.hyb.in","text":"The solver.hyb.in file contains norbs block. Each block is appended by two blank lines. The format of each block is as follows:","category":"page"},{"location":"ch04/in_hyb.html","page":"solver.hyb.in","title":"solver.hyb.in","text":"","category":"page"},{"location":"ch04/in_hyb.html","page":"solver.hyb.in","title":"solver.hyb.in","text":"column 1: orbital index i, integer","category":"page"},{"location":"ch04/in_hyb.html","page":"solver.hyb.in","title":"solver.hyb.in","text":"column 2: Matsubara frequency point, omega_n, double precision","category":"page"},{"location":"ch04/in_hyb.html","page":"solver.hyb.in","title":"solver.hyb.in","text":"column 3: Matsubara hybridization function, Re Delta(iomega_n), double precision","category":"page"},{"location":"ch04/in_hyb.html","page":"solver.hyb.in","title":"solver.hyb.in","text":"column 4: Matsubara hybridization function, Im Delta(iomega_n), double precision","category":"page"},{"location":"ch04/in_hyb.html","page":"solver.hyb.in","title":"solver.hyb.in","text":"column 5: error bar, Re delta Delta(iomega_n), double precision","category":"page"},{"location":"ch04/in_hyb.html","page":"solver.hyb.in","title":"solver.hyb.in","text":"column 6: error bar, Im delta Delta(iomega_n), double precision","category":"page"},{"location":"ch04/in_hyb.html","page":"solver.hyb.in","title":"solver.hyb.in","text":"","category":"page"},{"location":"ch04/in_hyb.html","page":"solver.hyb.in","title":"solver.hyb.in","text":"note: Note\nIn the solver.hyb.in file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch04/in_hyb.html","page":"solver.hyb.in","title":"solver.hyb.in","text":"Code","category":"page"},{"location":"ch04/in_hyb.html","page":"solver.hyb.in","title":"solver.hyb.in","text":"The corresponding Fortran code block for the reading of solver.hyb.in file is as follows:","category":"page"},{"location":"ch04/in_hyb.html","page":"solver.hyb.in","title":"solver.hyb.in","text":"if ( myid == master ) then ! only master node can do it\n    exists = .false.\n\n    ! inquire about file's existence\n    inquire (file = 'solver.hyb.in', exist = exists)\n\n    ! find input file: solver.hyb.in, read it\n    if ( exists .eqv. .true. ) then\n\n        hybf = czero ! reset it to zero\n\n        ! read in hybridization function from solver.hyb.in\n        open(mytmp, file='solver.hyb.in', form='formatted', status='unknown')\n        do i=1,norbs\n            do j=1,mfreq\n                read(mytmp,*) k, rtmp, r1, i1, r2, i2\n                hybf(j,i,i) = dcmplx(r1,i1)\n            enddo ! over j={1,mfreq} loop\n            read(mytmp,*) ! skip two lines\n            read(mytmp,*)\n        enddo ! over i={1,norbs} loop\n        close(mytmp)\n\n    endif ! back if ( exists .eqv. .true. ) block\nendif ! back if ( myid == master ) block","category":"page"},{"location":"ch04/in_hyb.html","page":"solver.hyb.in","title":"solver.hyb.in","text":"Generally, you should not edit the solver.hyb.in file by yourself.","category":"page"},{"location":"ch04/p_nmonte.html#Parameter:-nmonte","page":"nmonte","title":"Parameter: nmonte","text":"","category":"section"},{"location":"ch04/p_nmonte.html","page":"nmonte","title":"nmonte","text":"Definition","category":"page"},{"location":"ch04/p_nmonte.html","page":"nmonte","title":"nmonte","text":"How often to measure the physical observables.","category":"page"},{"location":"ch04/p_nmonte.html","page":"nmonte","title":"nmonte","text":"Type","category":"page"},{"location":"ch04/p_nmonte.html","page":"nmonte","title":"nmonte","text":"Integer","category":"page"},{"location":"ch04/p_nmonte.html","page":"nmonte","title":"nmonte","text":"Default value","category":"page"},{"location":"ch04/p_nmonte.html","page":"nmonte","title":"nmonte","text":"10","category":"page"},{"location":"ch04/p_nmonte.html","page":"nmonte","title":"nmonte","text":"Component","category":"page"},{"location":"ch04/p_nmonte.html","page":"nmonte","title":"nmonte","text":"ALL","category":"page"},{"location":"ch04/p_nmonte.html","page":"nmonte","title":"nmonte","text":"Behavior","category":"page"},{"location":"ch04/p_nmonte.html","page":"nmonte","title":"nmonte","text":"Every nmonte Monte Carlo sampling steps, the quantum impurity solvers try to measure the physical observables. The affected physical observables are as follows:Impurity occupancy, langle n_alpha rangle, langle n_alphan_beta rangle,\nImpurity Matsubara Green's function, G(iomega_n),\nSpin-spin correlation function, langle S_z(0) S_z(tau) rangle, chi_textsp(inu_n),\nOrbital-orbital correlation function, langle n_alpha(0) n_beta(tau)rangle, chi_textch(inu_n),\nMomentum of kinetic energy, langle k^2 rangle - langle k rangle^2,\nFidelity susceptibility, langle k_L k_R rangle - langle k_L rangle langle k_R rangle,\nTwo-particle Green's function, chi(iomega_niomega_ninu_n),\nTwo-particle vertex function, mathcalF(iomega_niomega_ninu_n),\nPairing susceptibility, Gamma(iomega_niomega_ninu_n),.The measuring period for the other physical observables are controlled by the ncarlo parameter. See also ncarlo parameter for more details.","category":"page"},{"location":"ch04/p_nmonte.html","page":"nmonte","title":"nmonte","text":"note: Note\nThe histogram for the perturbation expansion series is measured in each Monte Carlo sampling step.","category":"page"},{"location":"ch04/p_nmonte.html","page":"nmonte","title":"nmonte","text":"Comment","category":"page"},{"location":"ch04/p_nmonte.html","page":"nmonte","title":"nmonte","text":"You can increase nmonte to relieve the auto-correlation of physical observables between two successive measurements. However, large nmonte will waste the CPU times. It is recommended that a good nmonte should satisfy the following relation:textnmonte * textP_textinsert = 10Here, textP_textinsert means the accepted ratio for the insert update actions.","category":"page"},{"location":"ch04/p_part.html#Parameter:-part","page":"part","title":"Parameter: part","text":"","category":"section"},{"location":"ch04/p_part.html","page":"part","title":"part","text":"Definition","category":"page"},{"location":"ch04/p_part.html","page":"part","title":"part","text":"Hopping (or coupling) parameter t for Hubbard model.","category":"page"},{"location":"ch04/p_part.html","page":"part","title":"part","text":"Type","category":"page"},{"location":"ch04/p_part.html","page":"part","title":"part","text":"Float, double precision","category":"page"},{"location":"ch04/p_part.html","page":"part","title":"part","text":"Default value","category":"page"},{"location":"ch04/p_part.html","page":"part","title":"part","text":"0.5","category":"page"},{"location":"ch04/p_part.html","page":"part","title":"part","text":"Component","category":"page"},{"location":"ch04/p_part.html","page":"part","title":"part","text":"ALL","category":"page"},{"location":"ch04/p_part.html","page":"part","title":"part","text":"Behavior","category":"page"},{"location":"ch04/p_part.html","page":"part","title":"part","text":"It is used to initialize the default hybridization function Delta(iomega_n), and in the implementation of the dynamical mean-field theory self-consistent equation for the Bethe lattice.Para-magnetic phase:beginequation\nG_alphasigma(iomega_n) = t^2 Delta_alphasigma(iomega_n)\nendequationAnti-ferromagnetic phase:beginequation\nG_alphabarsigma(iomega_n) = t^2 Delta_alphabarsigma(iomega_n)\nendequation","category":"page"},{"location":"ch04/p_part.html","page":"part","title":"part","text":"Comment","category":"page"},{"location":"ch04/p_part.html","page":"part","title":"part","text":"It is useful only when isscf = 2. See also isscf parameter for more details.","category":"page"},{"location":"ch04/input.html#Contents","page":"Contents","title":"Contents","text":"","category":"section"},{"location":"ch04/input.html","page":"Contents","title":"Contents","text":"The quantum impurity solvers requires a few input files to setup the impurity models, configure the impurity solvers, and control the DMFT iterations, etc. In principle, the quantum impurity solvers can run without any input files. But if the input files are available, the parameters read from the input files will override the default ones.","category":"page"},{"location":"ch04/input.html","page":"Contents","title":"Contents","text":"The standard input files supported by the CT-HYB quantum impurity solvers are as follows:","category":"page"},{"location":"ch04/input.html","page":"Contents","title":"Contents","text":"solver.ctqmc.in // Configuration file for CT-QMC quantum impurity solvers.\nsolver.umat.in // Coulomb interaction matrix.\nsolver.eimp.in // Impurity level and crystal-field splitting.\nsolver.anydos.in // Density of states from various lattice or tight-binding models.\nsolver.ktau.in // Screening interaction.\natom.cix // Atomic eigenstates data.","category":"page"},{"location":"ch05/p_icu.html#Parameter:-icu","page":"icu","title":"Parameter: icu","text":"","category":"section"},{"location":"ch05/p_icu.html","page":"icu","title":"icu","text":"Definition","category":"page"},{"location":"ch05/p_icu.html","page":"icu","title":"icu","text":"Key control flag, determine the scheme to build the Coulomb interaction matrix.","category":"page"},{"location":"ch05/p_icu.html","page":"icu","title":"icu","text":"Type","category":"page"},{"location":"ch05/p_icu.html","page":"icu","title":"icu","text":"Integer","category":"page"},{"location":"ch05/p_icu.html","page":"icu","title":"icu","text":"Default value","category":"page"},{"location":"ch05/p_icu.html","page":"icu","title":"icu","text":"1","category":"page"},{"location":"ch05/p_icu.html","page":"icu","title":"icu","text":"Component","category":"page"},{"location":"ch05/p_icu.html","page":"icu","title":"icu","text":"Only for the JASMINE component.","category":"page"},{"location":"ch05/p_icu.html","page":"icu","title":"icu","text":"Behavior","category":"page"},{"location":"ch05/p_icu.html","page":"icu","title":"icu","text":"There are three possible values for the icu parameter.icu = 1, Kanamori scheme, using U_c, U_v, J_z, J_s, J_p parameters, isotropic Hund's rule coupling.\nicu = 2, Slater-Cordon scheme, using U_d, J_h parameters to build F_0, F_2, F_4, F_6.\nicu = 3, Kanamori scheme, using U_c, U_v, J_z, J_s, J_p parameters, anisotropic Hund's rule coupling.When icu = 2, it is not compatible with ictqmc = 4.","category":"page"},{"location":"ch05/p_icu.html","page":"icu","title":"icu","text":"Comment","category":"page"},{"location":"ch05/p_icu.html","page":"icu","title":"icu","text":"See Uc, Uv, Jz, Js, and Jp parameters for more details.","category":"page"},{"location":"ch05/p_jh.html#Parameter:-Jh","page":"Jh","title":"Parameter: Jh","text":"","category":"section"},{"location":"ch05/p_jh.html","page":"Jh","title":"Jh","text":"Definition","category":"page"},{"location":"ch05/p_jh.html","page":"Jh","title":"Jh","text":"Hund's exchange interaction parameter.","category":"page"},{"location":"ch05/p_jh.html","page":"Jh","title":"Jh","text":"Type","category":"page"},{"location":"ch05/p_jh.html","page":"Jh","title":"Jh","text":"Float, double precision","category":"page"},{"location":"ch05/p_jh.html","page":"Jh","title":"Jh","text":"Default value","category":"page"},{"location":"ch05/p_jh.html","page":"Jh","title":"Jh","text":"0.0","category":"page"},{"location":"ch05/p_jh.html","page":"Jh","title":"Jh","text":"Component","category":"page"},{"location":"ch05/p_jh.html","page":"Jh","title":"Jh","text":"Only for the JASMINE component.","category":"page"},{"location":"ch05/p_jh.html","page":"Jh","title":"Jh","text":"Behavior","category":"page"},{"location":"ch05/p_jh.html","page":"Jh","title":"Jh","text":"It is used to define the interaction term in the local Hamiltonian, only valid when icu = 2.","category":"page"},{"location":"ch05/p_jh.html","page":"Jh","title":"Jh","text":"Comment","category":"page"},{"location":"ch05/p_jh.html","page":"Jh","title":"Jh","text":"See also Ud and icu parameters for more details.","category":"page"},{"location":"ch08/truncation.html#Truncation-approximation","page":"Truncation approximation","title":"Truncation approximation","text":"","category":"section"},{"location":"ch08/truncation.html","page":"Truncation approximation","title":"Truncation approximation","text":"As discussed in previous section, although we have used GQNs to split the full Hilbert space with very large dimension into blocks with smaller dimensions [for cases such as 7-band systems with GQNs (N, J_z) and 5-band systems with GQN (N)], the dimensions of some blocks are still too large and the numbers of blocks are too much so that it is still very expensive to evaluate the local trace. Haule proposed to discard some high-energy states because they are rarely visited[1]. For example, for 7-band system with only 1 electron (like Ce metal), only states with occupancy N=0, 1, 2 will be frequently visited, and states with occupancy N2 can be truncated completely to reduce the large Hilbert space to a very small one. Of course, this truncation approximation may cause some bias because a frequently visited state may be accessed via an infrequently visited state. Therefore, one should be cautious when adopting the truncation approximation, and for example run some convergence tests.","category":"page"},{"location":"ch08/truncation.html","page":"Truncation approximation","title":"Truncation approximation","text":"Currently, we adopted two truncation schemes in our codes. The first scheme relies on the occupation number. We just keep those states whose occupation numbers are close to the nominal valence and skip the other states, as shown in the above example. This scheme is quite robust if the charge fluctuations are small enough, such as in the case of a Mott insulating phase. Another scheme is to dynamically truncate the states with very low probability based on statistics which is recorded during the Monte Carlo sampling. This scheme is not very stable, so one needs to use it with caution.","category":"page"},{"location":"ch08/truncation.html","page":"Truncation approximation","title":"Truncation approximation","text":"Reference","category":"page"},{"location":"ch08/truncation.html","page":"Truncation approximation","title":"Truncation approximation","text":"[1]: Kristjan Haule, Phys. Rev. B 75, 155113 (2007)","category":"page"},{"location":"ch07/story.html#Successful-stories","page":"Successful stories","title":"Successful stories","text":"","category":"section"},{"location":"ch05/p_uv.html#Parameter:-Uv","page":"Uv","title":"Parameter: Uv","text":"","category":"section"},{"location":"ch05/p_uv.html","page":"Uv","title":"Uv","text":"Definition","category":"page"},{"location":"ch05/p_uv.html","page":"Uv","title":"Uv","text":"Inter-orbital Coulomb interaction.","category":"page"},{"location":"ch05/p_uv.html","page":"Uv","title":"Uv","text":"Type","category":"page"},{"location":"ch05/p_uv.html","page":"Uv","title":"Uv","text":"Float, double precision","category":"page"},{"location":"ch05/p_uv.html","page":"Uv","title":"Uv","text":"Default value","category":"page"},{"location":"ch05/p_uv.html","page":"Uv","title":"Uv","text":"2.0","category":"page"},{"location":"ch05/p_uv.html","page":"Uv","title":"Uv","text":"Component","category":"page"},{"location":"ch05/p_uv.html","page":"Uv","title":"Uv","text":"Only for the JASMINE component.","category":"page"},{"location":"ch05/p_uv.html","page":"Uv","title":"Uv","text":"Behavior","category":"page"},{"location":"ch05/p_uv.html","page":"Uv","title":"Uv","text":"It is used to build the interaction term in the local Hamiltonian, only valid when icu = 1 or icu = 3.","category":"page"},{"location":"ch05/p_uv.html","page":"Uv","title":"Uv","text":"Comment","category":"page"},{"location":"ch05/p_uv.html","page":"Uv","title":"Uv","text":"See also Uc, Jz, Js, Jp, and icu parameters for more details.","category":"page"},{"location":"ch05/p_js.html#Parameter:-Js","page":"Js","title":"Parameter: Js","text":"","category":"section"},{"location":"ch05/p_js.html","page":"Js","title":"Js","text":"Definition","category":"page"},{"location":"ch05/p_js.html","page":"Js","title":"Js","text":"Strength of spin-flip interaction.","category":"page"},{"location":"ch05/p_js.html","page":"Js","title":"Js","text":"Type","category":"page"},{"location":"ch05/p_js.html","page":"Js","title":"Js","text":"Float, double precision","category":"page"},{"location":"ch05/p_js.html","page":"Js","title":"Js","text":"Default value","category":"page"},{"location":"ch05/p_js.html","page":"Js","title":"Js","text":"0.0","category":"page"},{"location":"ch05/p_js.html","page":"Js","title":"Js","text":"Component","category":"page"},{"location":"ch05/p_js.html","page":"Js","title":"Js","text":"Only for the JASMINE component.","category":"page"},{"location":"ch05/p_js.html","page":"Js","title":"Js","text":"Behavior","category":"page"},{"location":"ch05/p_js.html","page":"Js","title":"Js","text":"It is used to build the interaction term in the local Hamiltonian, only valid when icu = 1 or icu = 3.","category":"page"},{"location":"ch05/p_js.html","page":"Js","title":"Js","text":"Comment","category":"page"},{"location":"ch05/p_js.html","page":"Js","title":"Js","text":"See also Uc, Uv, Jz, Jp, and icu parameters for more details.","category":"page"},{"location":"ch04/in_ktau.html#solver.ktau.in","page":"solver.ktau.in","title":"solver.ktau.in","text":"","category":"section"},{"location":"ch04/in_ktau.html","page":"solver.ktau.in","title":"solver.ktau.in","text":"Introduction","category":"page"},{"location":"ch04/in_ktau.html","page":"solver.ktau.in","title":"solver.ktau.in","text":"The solver.ktau.in is used to store the screening function K(tau) and its derivates K(tau) in imaginary-time space. It is only useful for the NARCISSUS component.","category":"page"},{"location":"ch04/in_ktau.html","page":"solver.ktau.in","title":"solver.ktau.in","text":"note: Note\nOnly when isscr = 4, the solver.ktau.in is essential for the NARCISSUS component. See [isscr] for more details.","category":"page"},{"location":"ch04/in_ktau.html","page":"solver.ktau.in","title":"solver.ktau.in","text":"Format","category":"page"},{"location":"ch04/in_ktau.html","page":"solver.ktau.in","title":"solver.ktau.in","text":"The format of the solver.ktau.in file is as follows:","category":"page"},{"location":"ch04/in_ktau.html","page":"solver.ktau.in","title":"solver.ktau.in","text":"","category":"page"},{"location":"ch04/in_ktau.html","page":"solver.ktau.in","title":"solver.ktau.in","text":"column 1: imaginary-time point, tau, double precision","category":"page"},{"location":"ch04/in_ktau.html","page":"solver.ktau.in","title":"solver.ktau.in","text":"column 2: screening function, K(tau), double precision","category":"page"},{"location":"ch04/in_ktau.html","page":"solver.ktau.in","title":"solver.ktau.in","text":"column 3: the first derivates of screening function, K(tau), double precision","category":"page"},{"location":"ch04/in_ktau.html","page":"solver.ktau.in","title":"solver.ktau.in","text":"","category":"page"},{"location":"ch04/in_ktau.html","page":"solver.ktau.in","title":"solver.ktau.in","text":"In principle, K(tau) and K(tau) should be orbital-dependent. However in the NARCISSUS component, for the sake of simplicity, we treat them as orbital-independent vectors.","category":"page"},{"location":"ch04/in_ktau.html","page":"solver.ktau.in","title":"solver.ktau.in","text":"Code","category":"page"},{"location":"ch04/in_ktau.html","page":"solver.ktau.in","title":"solver.ktau.in","text":"The corresponding Fortran code block for the reading of solver.ktau.in file is as follows:","category":"page"},{"location":"ch04/in_ktau.html","page":"solver.ktau.in","title":"solver.ktau.in","text":"open(mytmp, file='solver.ktau.in', form='formatted', status='unknown')\nread(mytmp,*) ! skip one line\ndo i=1,ntime\n    read(mytmp,*) rtmp, ktau(i), ptau(i)\nenddo ! over i={1,ntime} loop\nclose(mytmp)","category":"page"},{"location":"ch05/p_uc.html#Parameter:-Uc","page":"Uc","title":"Parameter: Uc","text":"","category":"section"},{"location":"ch05/p_uc.html","page":"Uc","title":"Uc","text":"Definition","category":"page"},{"location":"ch05/p_uc.html","page":"Uc","title":"Uc","text":"Intra-orbital Coulomb interaction.","category":"page"},{"location":"ch05/p_uc.html","page":"Uc","title":"Uc","text":"Type","category":"page"},{"location":"ch05/p_uc.html","page":"Uc","title":"Uc","text":"Float, double precision","category":"page"},{"location":"ch05/p_uc.html","page":"Uc","title":"Uc","text":"Default value","category":"page"},{"location":"ch05/p_uc.html","page":"Uc","title":"Uc","text":"2.0","category":"page"},{"location":"ch05/p_uc.html","page":"Uc","title":"Uc","text":"Component","category":"page"},{"location":"ch05/p_uc.html","page":"Uc","title":"Uc","text":"Only for the JASMINE component.","category":"page"},{"location":"ch05/p_uc.html","page":"Uc","title":"Uc","text":"Behavior","category":"page"},{"location":"ch05/p_uc.html","page":"Uc","title":"Uc","text":"It is used to build the interaction term in the local Hamiltonian, only valid when icu = 1 or icu = 3.","category":"page"},{"location":"ch05/p_uc.html","page":"Uc","title":"Uc","text":"Comment","category":"page"},{"location":"ch05/p_uc.html","page":"Uc","title":"Uc","text":"See also Uv, Jz, Js, Jp, and icu parameters for more details.","category":"page"},{"location":"ch06/atomic.html#u_atomic.py","page":"u_atomic.py","title":"u_atomic.py","text":"","category":"section"},{"location":"ch06/atomic.html","page":"u_atomic.py","title":"u_atomic.py","text":"Introduction","category":"page"},{"location":"ch06/atomic.html","page":"u_atomic.py","title":"u_atomic.py","text":"The purpose of this script is to generate essential input file (atom.config.in) for the JASMINE code. Note that you can not use it to control the JASMINE code directly.","category":"page"},{"location":"ch06/atomic.html","page":"u_atomic.py","title":"u_atomic.py","text":"Type","category":"page"},{"location":"ch06/atomic.html","page":"u_atomic.py","title":"u_atomic.py","text":"Python module","category":"page"},{"location":"ch06/atomic.html","page":"u_atomic.py","title":"u_atomic.py","text":"APIs","category":"page"},{"location":"ch06/atomic.html","page":"u_atomic.py","title":"u_atomic.py","text":"class p_atomic_solver(object):\n    \"\"\" This class can be used to generate the config file for the jasmine.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\" define the class variables\n        \"\"\"\n\n    def setp(self, **kwargs):\n        \"\"\" setup the parameters using a series of key-value pairs\n        \"\"\"\n\n    def check(self):\n        \"\"\" check the correctness of input parameters\n        \"\"\"\n\n    def write(self):\n        \"\"\" write the parameters to the config file: atom.config.in\n        \"\"\"","category":"page"},{"location":"ch06/atomic.html","page":"u_atomic.py","title":"u_atomic.py","text":"Examples","category":"page"},{"location":"ch06/atomic.html","page":"u_atomic.py","title":"u_atomic.py","text":"# import this module\nfrom u_atomic import *\n\n# create an instance\np = p_atomic_solver()\n\n# setup the parameters\np.setp(ibasis = 2, Uv = 2.0)\np.setp(icu = 30) # invalid parameter\np.setp(icu = 1)\np.setp()\n\n# verify the parameters\np.check()\n\n# generate the atom.config.in file\np.write()\n\n# destroy the instance\ndel p","category":"page"},{"location":"ch06/atomic.html","page":"u_atomic.py","title":"u_atomic.py","text":"note: Note\nYou can not execute u_atomic.py in the terminal or Python environment directly, like this:$ python u_atomic.py","category":"page"},{"location":"ch06/atomic.html","page":"u_atomic.py","title":"u_atomic.py","text":"Comment","category":"page"},{"location":"ch06/atomic.html","page":"u_atomic.py","title":"u_atomic.py","text":"N/A","category":"page"},{"location":"ch04/out_weiss.html#solver.weiss.dat","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"","category":"section"},{"location":"ch04/out_weiss.html","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"Introduction","category":"page"},{"location":"ch04/out_weiss.html","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"This file is used to store the imaginary-time Weiss's function G_0(tau). It will be output by the quantum impurity solvers when they are shut down.","category":"page"},{"location":"ch04/out_weiss.html","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"Format","category":"page"},{"location":"ch04/out_weiss.html","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"The solver.weiss.dat file contains norbs block. Each block is appended by two blank lines. The format of each block is as follows:","category":"page"},{"location":"ch04/out_weiss.html","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"","category":"page"},{"location":"ch04/out_weiss.html","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"column 1: orbital index i, integer","category":"page"},{"location":"ch04/out_weiss.html","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"column 2: imaginary-time index j, integer","category":"page"},{"location":"ch04/out_weiss.html","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"column 3: imaginary-time point, tau, double precision","category":"page"},{"location":"ch04/out_weiss.html","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"column 4: imaginary-time Weiss's function, G_0(tau), double precision","category":"page"},{"location":"ch04/out_weiss.html","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"column 5: error bar, delta G_0(tau), double precision","category":"page"},{"location":"ch04/out_weiss.html","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"","category":"page"},{"location":"ch04/out_weiss.html","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"note: Note\nIn the solver.weiss.dat file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch04/out_weiss.html","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"Code","category":"page"},{"location":"ch04/out_weiss.html","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"The corresponding Fortran code block for the writing of solver.weiss.dat file is as follows:","category":"page"},{"location":"ch04/out_weiss.html","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"! open data file: solver.weiss.dat\nopen(mytmp, file='solver.weiss.dat', form='formatted', status='unknown')\n\n! write it\ndo i=1,norbs\n    do j=1,ntime\n        write(mytmp,'(2i6,3f12.6)') i, j, tmesh(j), wtau(j,i,i), zero\n    enddo ! over j={1,ntime} loop\n    write(mytmp,*) ! write empty lines\n    write(mytmp,*)\nenddo ! over i={1,norbs} loop\n\n! close data file\nclose(mytmp)","category":"page"},{"location":"ch04/out_weiss.html","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"note: Note\nThe column for the error bar is always zero in this file.","category":"page"},{"location":"ch04/out_weiss.html","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"In the iQIST software package, we provide a Python module to read the output files of quantum impurity solvers. You can use it to read the solver.weiss.dat file. See [script/u_reader.py] for more details.","category":"page"},{"location":"ch05/p_ibasis.html#Parameter:-ibasis","page":"ibasis","title":"Parameter: ibasis","text":"","category":"section"},{"location":"ch05/p_ibasis.html","page":"ibasis","title":"ibasis","text":"Definition","category":"page"},{"location":"ch05/p_ibasis.html","page":"ibasis","title":"ibasis","text":"Key control flag, it is used to specify the source for natural basis which is the eigenstate of crystal field splitting plus spin-orbit coupling.","category":"page"},{"location":"ch05/p_ibasis.html","page":"ibasis","title":"ibasis","text":"Type","category":"page"},{"location":"ch05/p_ibasis.html","page":"ibasis","title":"ibasis","text":"Integer","category":"page"},{"location":"ch05/p_ibasis.html","page":"ibasis","title":"ibasis","text":"Default value","category":"page"},{"location":"ch05/p_ibasis.html","page":"ibasis","title":"ibasis","text":"1","category":"page"},{"location":"ch05/p_ibasis.html","page":"ibasis","title":"ibasis","text":"Component","category":"page"},{"location":"ch05/p_ibasis.html","page":"ibasis","title":"ibasis","text":"Only for the JASMINE component.","category":"page"},{"location":"ch05/p_ibasis.html","page":"ibasis","title":"ibasis","text":"Behavior","category":"page"},{"location":"ch05/p_ibasis.html","page":"ibasis","title":"ibasis","text":"Now there are two possible values for the ibasis parameter:ibasis = 1, make natural basis inside of this program. The code will build crystal field splitting Delta_alphabeta and spin-orbit coupling terms Delta_textSOC at first, and then use them to generate the transformation matrix mathcalT_alphabeta and on-site impurity level E_alphabeta.\nibasis = 2, make natural basis outside of this program. The code will read the on-site impurity level E_alphabeta (in the atom.emat.in file) and transformation matrix mathcalT_alphabeta (in the atom.tmat.in file) from external files directly. See also atom.emat.in and atom.tmat.in for more details.","category":"page"},{"location":"ch05/p_ibasis.html","page":"ibasis","title":"ibasis","text":"Comment","category":"page"},{"location":"ch05/p_ibasis.html","page":"ibasis","title":"ibasis","text":"See also isoc and lambda parameters for more details.","category":"page"},{"location":"ch04/out_hybri.html#solver.hybri.dat","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"","category":"section"},{"location":"ch04/out_hybri.html","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"Introduction","category":"page"},{"location":"ch04/out_hybri.html","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"This file is used to store the imaginary-time hybridization function Delta(tau). It will be output by the quantum impurity solvers when they are shut down.","category":"page"},{"location":"ch04/out_hybri.html","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"Format","category":"page"},{"location":"ch04/out_hybri.html","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"The solver.hybri.dat file contains norbs block. Each block is appended by two blank lines. The format of each block is as follows:","category":"page"},{"location":"ch04/out_hybri.html","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"","category":"page"},{"location":"ch04/out_hybri.html","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"column 1: orbital index i, integer","category":"page"},{"location":"ch04/out_hybri.html","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"column 2: imaginary-time index j, integer","category":"page"},{"location":"ch04/out_hybri.html","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"column 3: imaginary-time point, tau, double precision","category":"page"},{"location":"ch04/out_hybri.html","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"column 4: imaginary-time hybridization function, Delta(tau), double precision","category":"page"},{"location":"ch04/out_hybri.html","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"column 5: error bar, delta Delta(tau), double precision","category":"page"},{"location":"ch04/out_hybri.html","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"","category":"page"},{"location":"ch04/out_hybri.html","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"note: Note\nIn the solver.hybri.dat file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch04/out_hybri.html","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"Code","category":"page"},{"location":"ch04/out_hybri.html","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"The corresponding Fortran code block for the writing of solver.hybri.dat file is as follows:","category":"page"},{"location":"ch04/out_hybri.html","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"! open data file: solver.hybri.dat\nopen(mytmp, file='solver.hybri.dat', form='formatted', status='unknown')\n\n! write it\ndo i=1,norbs\n    do j=1,ntime\n        write(mytmp,'(2i6,3f12.6)') i, j, tmesh(j), htau(j,i,i), zero\n    enddo ! over j={1,ntime} loop\n    write(mytmp,*) ! write empty lines\n    write(mytmp,*)\nenddo ! over i={1,norbs} loop\n\n! close data file\nclose(mytmp)","category":"page"},{"location":"ch04/out_hybri.html","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"note: Note\nThe column for the error bar is always zero in this file.","category":"page"},{"location":"ch04/out_hybri.html","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"In the iQIST software package, we provide a Python module to read the output files of quantum impurity solvers. You can use it to read the solver.hybri.dat file. See [script/u_reader.py] for more details.","category":"page"},{"location":"ch04/p_nflip.html#Parameter:-nflip","page":"nflip","title":"Parameter: nflip","text":"","category":"section"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"Definition","category":"page"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"Flip period for spin up and spin down states.","category":"page"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"Type","category":"page"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"Integer","category":"page"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"Default value","category":"page"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"20000","category":"page"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"Component","category":"page"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"ALL","category":"page"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"Behavior","category":"page"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"Care must be taken to prevent the system from being trapped in a state which breaks a symmetry of local Hamiltonian when it should not be. To avoid un-physical trapping, we introduce \"flip\" moves, which exchange the operators corresponding, for example, to up and down spins in a given band.","category":"page"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"In this code, nowadays the following flip schemes are supported:","category":"page"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"cflip = 1, flip intra-orbital spins one by one,\ncflip = 2, flip intra-orbital spins globally.","category":"page"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"Here cflip is an internal variable, instead of an input parameters, you can not setup it in the solver.ctqmc.in file.","category":"page"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"So the question is: how to control cflip via the nflip parameter?","category":"page"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"Now we use the sign of nflip to control flip schemes","category":"page"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"nflip = 0, means infinite long period to do flip\nnflip > 0, flip intra-orbital spins one by one (90%) and globally (10%)\nnflip < 0, flip intra-orbital spins globally (90%) and one by one (10%)","category":"page"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"Comment","category":"page"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"If nflip /= 0, the absolute value of nflip is the flip period.","category":"page"},{"location":"ch04/p_isscf.html#Parameter:-isscf","page":"isscf","title":"Parameter: isscf","text":"","category":"section"},{"location":"ch04/p_isscf.html","page":"isscf","title":"isscf","text":"Definition","category":"page"},{"location":"ch04/p_isscf.html","page":"isscf","title":"isscf","text":"It is the most important control flag, which is used to control the running mode of the quantum impurity solvers. As mentioned before, the quantum impurity solvers in the iQIST software package contain a mini dynamical mean-field theory self-consistent engine, concerning the Hubbard model on a Bethe lattice. You can use the isscf parameter to control whether to active this self-consistent engine or not.","category":"page"},{"location":"ch04/p_isscf.html","page":"isscf","title":"isscf","text":"Type","category":"page"},{"location":"ch04/p_isscf.html","page":"isscf","title":"isscf","text":"Integer","category":"page"},{"location":"ch04/p_isscf.html","page":"isscf","title":"isscf","text":"Default value","category":"page"},{"location":"ch04/p_isscf.html","page":"isscf","title":"isscf","text":"1","category":"page"},{"location":"ch04/p_isscf.html","page":"isscf","title":"isscf","text":"Component","category":"page"},{"location":"ch04/p_isscf.html","page":"isscf","title":"isscf","text":"ALL","category":"page"},{"location":"ch04/p_isscf.html","page":"isscf","title":"isscf","text":"Behavior","category":"page"},{"location":"ch04/p_isscf.html","page":"isscf","title":"isscf","text":"There are two possible values for the isscf parameter so far:isscf = 1, one-shot non-self-consistent scheme, usually used in local density approximation plus dynamical mean-field theory scenario. The internal dynamical mean-field theory self-consistent is disabled.\nisscf = 2, self-consistent scheme, used in standard Hubbard model (on Bethe lattice) plus dynamical mean-field theory scenario. The internal dynamical mean-field theory self-consistent engine is used.","category":"page"},{"location":"ch04/p_isscf.html","page":"isscf","title":"isscf","text":"Comment","category":"page"},{"location":"ch04/p_isscf.html","page":"isscf","title":"isscf","text":"The internal dynamical mean-field theory self-consistent engine is implemented in the ctqmc_dmft.f90. The experienced users can customize their own versions of it.","category":"page"},{"location":"ch04/parameters.html#Contents","page":"Contents","title":"Contents","text":"","category":"section"},{"location":"ch04/parameters.html","page":"Contents","title":"Contents","text":"In this section, we will introduce all of the valid parameters which can be used in the solver.ctqmc.in (for NARCISSUS and MANJUSHAKA components) file. For more information, the users can also refer to the comments in corresponding ctqmc_control.f90 file.","category":"page"},{"location":"ch04/parameters.html#Classification-of-the-parameters","page":"Contents","title":"Classification of the parameters","text":"","category":"section"},{"location":"ch04/parameters.html","page":"Contents","title":"Contents","text":"Parameters for the dynamical mean-field theory engine\nisscf\nniter\nalpha\nParameters for the strongly correlated models\n[issun]\nisspn\n[isscr]\nnband\nnspin\nnorbs\nncfgs\n[nzero]\nU\nUc\nUv\nJz\nJs\nJp\n[lc]\n[wc]\nmune\nbeta\npart\nParameters for the quantum impurity solvers\n[ifast]\n[itrun]\nmkink\nmfreq\nntime\n[npart]\nnflip\nntherm\nnsweep\nnwrite\nnclean\nncarlo\nnmonte\nParameters for the Monte Carlo sampling\n[isort]\n[issus]\n[isvrt]\n[lemax]\n[legrd]\nnffrq\nnbfrq\nnfreq","category":"page"},{"location":"ch04/parameters.html","page":"Contents","title":"Contents","text":"","category":"page"},{"location":"ch04/parameters.html#Concerning-the-speed","page":"Contents","title":"Concerning the speed","text":"","category":"section"},{"location":"ch04/parameters.html","page":"Contents","title":"Contents","text":"The following parameters have big influences on the computational efficiency of the quantum impurity solvers.","category":"page"},{"location":"ch04/parameters.html","page":"Contents","title":"Contents","text":"[ifast]\n[itrun]\n[npart]","category":"page"},{"location":"ch04/parameters.html","page":"Contents","title":"Contents","text":"","category":"page"},{"location":"ch04/parameters.html#Concerning-the-accuracy","page":"Contents","title":"Concerning the accuracy","text":"","category":"section"},{"location":"ch04/parameters.html","page":"Contents","title":"Contents","text":"The following parameters will affect the computational accuracy.","category":"page"},{"location":"ch04/parameters.html","page":"Contents","title":"Contents","text":"[ifast]\n[itrun]\nntime\nntherm\nnsweep\nnclean\nncarlo\nnmonte\n[isort]\n[isvrt]\n[lemax]\n[legrd]","category":"page"},{"location":"ch04/parameters.html","page":"Contents","title":"Contents","text":"","category":"page"},{"location":"ch04/parameters.html","page":"Contents","title":"Contents","text":"tip: Tip\nAll of the parameters are case-insensitive.\nAll of the parameters have default values. You can override them via the solver.ctqmc.in and solver.hfqmc.in files.\nThe quantum impurity solvers won't check the correctness, rationality of the parameters. They won't adjust the parameters automatically. For example, if you setup nband = 2 in the solver.ctqmc.in, you have to setup norbs, ncfgs parameters by yourself at the same time. The quantum impurity solvers won't do that.","category":"page"},{"location":"ch04/parameters.html","page":"Contents","title":"Contents","text":"See also:","category":"page"},{"location":"ch04/parameters.html","page":"Contents","title":"Contents","text":"solver.ctqmc.in // File format for solver.ctqmc.in","category":"page"},{"location":"ch08/sig.html#Improved-estimator-for-the-self-energy-function","page":"Improved estimator for the self-energy function","title":"Improved estimator for the self-energy function","text":"","category":"section"},{"location":"ch08/sig.html","page":"Improved estimator for the self-energy function","title":"Improved estimator for the self-energy function","text":"Recently, Hafermann et al. proposed efficient measurement procedures for the self-energy and vertex functions within the CT-HYB algorithm[^1,2]. In their method, some higher-order correlation functions (related to the quantities being sought through the equation of motion) are measured. For the case of interactions of density-density type, the segment algorithm is available[3]. Thus, the additional correlators can be obtained essentially at no additional computational cost. When the calculations are completed, the required self-energy function and vertex function can be evaluated analytically.","category":"page"},{"location":"ch08/sig.html","page":"Improved estimator for the self-energy function","title":"Improved estimator for the self-energy function","text":"The improved estimator for the self-energy function can be expressed in the following form:","category":"page"},{"location":"ch08/sig.html","page":"Improved estimator for the self-energy function","title":"Improved estimator for the self-energy function","text":"beginequation\nSigma_ab(iomega_n) = frac12\nsum_ij G^-1_ai(iomega_n) (U_jb + U_bj) F^j_ib(iomega_n)\nendequation","category":"page"},{"location":"ch08/sig.html","page":"Improved estimator for the self-energy function","title":"Improved estimator for the self-energy function","text":"where U_ab is the Coulomb interaction matrix element. The expression for the new two-particle correlator F^j_ab(tau - tau) reads","category":"page"},{"location":"ch08/sig.html","page":"Improved estimator for the self-energy function","title":"Improved estimator for the self-energy function","text":"beginequation\nF^j_ab(tau-tau)\n= -langle mathcalT d_a(tau) d^dagger_b(tau) n_j(tau) rangle\nendequation","category":"page"},{"location":"ch08/sig.html","page":"Improved estimator for the self-energy function","title":"Improved estimator for the self-energy function","text":"and F^j_ab(iomega_n) is its Fourier transform. The actual measurement formula is","category":"page"},{"location":"ch08/sig.html","page":"Improved estimator for the self-energy function","title":"Improved estimator for the self-energy function","text":"beginequation\nF^j_ab(tau - tau) =\n-frac1beta\nleftlangle\nsum_alphabeta = 1^k\nmathcalM_betaalphadelta^-(tau-tau tau^e_alpha - tau^s_beta)\nn_j(tau^s_beta)delta_aalphadelta_bbeta\nrightrangle\nendequation","category":"page"},{"location":"ch08/sig.html","page":"Improved estimator for the self-energy function","title":"Improved estimator for the self-energy function","text":"As one can see, this equation looks quite similar to the one for imaginary-time Green's function. Thus we use the same method to measure F^j_ab(tau - tau) and finally get the self-energy function via the first equation. Here, the matrix element n_j(tau^s_beta) (one or zero) denotes whether or not flavor j is occupied (whether or not a segment is present) at time tau^s_beta.","category":"page"},{"location":"ch08/sig.html","page":"Improved estimator for the self-energy function","title":"Improved estimator for the self-energy function","text":"This method can be combined with the orthogonal polynomial representation[4] as introduced in the previous subsection to suppress fluctuations and filter out the Monte Carlo noise. Using this technique, we can obtain the self-energy and vertex functions with unprecedented accuracy, which leads to an enhanced stability in the analytical continuations of those quantities[2]. In the iQIST software package, we only implemented the improved estimator for the self-energy function. Note that when the interaction matrix is frequency-dependent, the first equation should be modified slightly[1].","category":"page"},{"location":"ch08/sig.html","page":"Improved estimator for the self-energy function","title":"Improved estimator for the self-energy function","text":"Reference","category":"page"},{"location":"ch08/sig.html","page":"Improved estimator for the self-energy function","title":"Improved estimator for the self-energy function","text":"[1]: Hartmut Hafermann, Phys. Rev. B 89, 235128 (2014)","category":"page"},{"location":"ch08/sig.html","page":"Improved estimator for the self-energy function","title":"Improved estimator for the self-energy function","text":"[2]: Hartmut Hafermann, Kelly R. Patton, and Philipp Werner, Phys. Rev. B 85, 205106 (2012)","category":"page"},{"location":"ch08/sig.html","page":"Improved estimator for the self-energy function","title":"Improved estimator for the self-energy function","text":"[3]: Philipp Werner, Armin Comanac, Luca de’ Medici, Matthias Troyer, and Andrew J. Millis, Phys. Rev. Lett. 97, 076405 (2006)","category":"page"},{"location":"ch08/sig.html","page":"Improved estimator for the self-energy function","title":"Improved estimator for the self-energy function","text":"[4]: Lewin Boehnke, Hartmut Hafermann, Michel Ferrero, Frank Lechermann, and Olivier Parcollet, Phys. Rev. B 84, 075145 (2011)","category":"page"},{"location":"ch04/p_nbfrq.html#Parameter:-nbfrq","page":"nbfrq","title":"Parameter: nbfrq","text":"","category":"section"},{"location":"ch04/p_nbfrq.html","page":"nbfrq","title":"nbfrq","text":"Definition","category":"page"},{"location":"ch04/p_nbfrq.html","page":"nbfrq","title":"nbfrq","text":"Number of bosonic Matsubara frequency points for the two-particle green's function.The two-particle Green's function chi(iomega_n iomega_n inu_n) and vertex function mathcalF(iomega_n iomega_n inu_n) have three frequency indices where omega_n and omega_n are fermionic frequencies, and nu_n bosonic frequency:nu_n = frac2npibetaomega_n = frac(2n+1)pibetaThe nbfrq parameter is used to define and generate the bosonic mesh nu_n. The corresponding fermionic mesh omega_n is defined by the nffrq parameter.","category":"page"},{"location":"ch04/p_nbfrq.html","page":"nbfrq","title":"nbfrq","text":"Type","category":"page"},{"location":"ch04/p_nbfrq.html","page":"nbfrq","title":"nbfrq","text":"Integer","category":"page"},{"location":"ch04/p_nbfrq.html","page":"nbfrq","title":"nbfrq","text":"Default value","category":"page"},{"location":"ch04/p_nbfrq.html","page":"nbfrq","title":"nbfrq","text":"8","category":"page"},{"location":"ch04/p_nbfrq.html","page":"nbfrq","title":"nbfrq","text":"Component","category":"page"},{"location":"ch04/p_nbfrq.html","page":"nbfrq","title":"nbfrq","text":"ALL","category":"page"},{"location":"ch04/p_nbfrq.html","page":"nbfrq","title":"nbfrq","text":"Behavior","category":"page"},{"location":"ch04/p_nbfrq.html","page":"nbfrq","title":"nbfrq","text":"Determine the size of involved arrays. Only useful when we need to compute the two-particle quantities.","category":"page"},{"location":"ch04/p_nbfrq.html","page":"nbfrq","title":"nbfrq","text":"Comment","category":"page"},{"location":"ch04/p_nbfrq.html","page":"nbfrq","title":"nbfrq","text":"If the nbfrq is too large, the computational time is not bearable. So we recommend to set nbfrq leq 32 The computation of two-particle quantities is extremely time-consuming, though we have tried our best optimizing it.See nffrq and nfreq for more details.","category":"page"},{"location":"ch04/p_nbfrq.html","page":"nbfrq","title":"nbfrq","text":"tip: Tip\nThe computation of two-particle quantities has been optimized using the OpenMP multi-thread technology. You can enable this feature in the compiling procedure. See also Compiling environment for more details.","category":"page"},{"location":"ch08/lazy.html#Lazy-trace-evaluation","page":"Lazy trace evaluation","title":"Lazy trace evaluation","text":"","category":"section"},{"location":"ch08/lazy.html","page":"Lazy trace evaluation","title":"Lazy trace evaluation","text":"The diagrammatic Monte Carlo sampling algorithm consists of the following steps: (1) Propose an update for the current diagrammatic configuration. (2) Calculate the acceptance probability p according to the Metropolis-Hasting algorithm,","category":"page"},{"location":"ch08/lazy.html","page":"Lazy trace evaluation","title":"Lazy trace evaluation","text":"beginequation\np = textmin (1 fracA^primeA left fracomega_comega_c^primeright\n     leftfracomega_domega_d^prime right)\nendequation","category":"page"},{"location":"ch08/lazy.html","page":"Lazy trace evaluation","title":"Lazy trace evaluation","text":"where, A is the proposal probability for the current update and A^prime for the inverse update, omega_c and omega_c^prime are the determinants for the new and old configurations, respectively, and omega_d and omega_d^prime are the local traces for the new and old configurations, respectively. (3) Generate a random number r. If pr, the proposed update is accepted, otherwise it is rejected. (4) Update the current diagrammatic configuration if the proposed update is accepted. It turns out that for CT-HYB, p is usually low (1 sim 20), especially in the low temperature region. On the other hand, the calculation of p involves a costly local trace evaluation. To avoid wasting computation time when the acceptance probability is very low, in the subspace algorithm, we implemented the so-called lazy trace evaluation proposed in Reference[1].","category":"page"},{"location":"ch08/lazy.html","page":"Lazy trace evaluation","title":"Lazy trace evaluation","text":"The basic idea of the lazy trace evaluation is simple. For the proposed Monte Carlo move, we first generate a random number r. Then, instead of calculating the local trace from scratch to determine p, we calculate bounds for lefttextTr_textlocright,","category":"page"},{"location":"ch08/lazy.html","page":"Lazy trace evaluation","title":"Lazy trace evaluation","text":"beginequation\nleftomega_dright = lefttextTr_textlocright leq sum_i lefttextTr_iright leq sum_i B_i\nendequation","category":"page"},{"location":"ch08/lazy.html","page":"Lazy trace evaluation","title":"Lazy trace evaluation","text":"where B_i geq lefttextTr_iright. B_i is a product of some chosen matrix norms of T and F matrices:","category":"page"},{"location":"ch08/lazy.html","page":"Lazy trace evaluation","title":"Lazy trace evaluation","text":"beginequation\nB_i = C  left T_2k+1\nright left F_2k right cdots left F_2 right left T_2 right\nleft F_1 right left T_1 right geq\nlefttextTr(T_2k+1F_2k cdots F_2T_2F_1T_1)right\nendequation","category":"page"},{"location":"ch08/lazy.html","page":"Lazy trace evaluation","title":"Lazy trace evaluation","text":"where C is a parameter depending on the specific type of matrix norm, and left cdot right denotes a matrix norm. If textTr_i^prime denotes the exact trace of some subspaces, then we have","category":"page"},{"location":"ch08/lazy.html","page":"Lazy trace evaluation","title":"Lazy trace evaluation","text":"beginequation\nleft lefttextTr_textlocright - sum_i^primelefttextTr_i^primeright right\nleq sum_i neq i^prime B_i\nendequation","category":"page"},{"location":"ch08/lazy.html","page":"Lazy trace evaluation","title":"Lazy trace evaluation","text":"Thus, we can determine the upper p_textmax and lower p_textmin bounds of p as","category":"page"},{"location":"ch08/lazy.html","page":"Lazy trace evaluation","title":"Lazy trace evaluation","text":"beginequation\nbeginaligned\np_textmax=R left(sum_i^primelefttextTr_i^primeright + sum_i neq i^prime B_iright)\np_textmin=R left(sum_i^primelefttextTr_i^primeright - sum_i neq i^prime B_iright)\nendaligned\nendequation","category":"page"},{"location":"ch08/lazy.html","page":"Lazy trace evaluation","title":"Lazy trace evaluation","text":"where R=fracA^primeA left fracomega_comega_c^primeright leftfrac1omega_d^prime right.","category":"page"},{"location":"ch08/lazy.html","page":"Lazy trace evaluation","title":"Lazy trace evaluation","text":"If rp_textmax, we reject this move immediately. If rp_textmin, we accept the move and calculate the determinant and local trace from scratch. If p_textmin  r  p_textmax, we refine the bounds by calculating the local trace of one more subspace textTr_i until we can reject or accept the move. The calculation of these bounds involves only simple linear algebra calculations of matrix norms which cost little computation time, and one refining operation involves only one subspace trace evaluation. On average, it saves a lot of computation time, as confirmed by our benchmarks.","category":"page"},{"location":"ch08/lazy.html","page":"Lazy trace evaluation","title":"Lazy trace evaluation","text":"Reference","category":"page"},{"location":"ch08/lazy.html","page":"Lazy trace evaluation","title":"Lazy trace evaluation","text":"[1]: P. Sémon, Chuck-Hou Yee, Kristjan Haule, and A.-M. S. Tremblay, Phys. Rev. B 90, 075149","category":"page"},{"location":"ch02/inc.html#Explanation-of-make.inc","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"","category":"section"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"The make.inc file is the key component of the building system. You have to modify it to fulfill your requirements. If it is not configured correctly, the building system won't work correctly as well. So in the following we would like to provide a detailed explanations for it.","category":"page"},{"location":"ch02/inc.html#F90","page":"Explanation of make.inc","title":"F90","text":"","category":"section"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"The Fortran compiler. Both the parallel and sequential fortran compilers are supported. Note that only the Intel fortran compiler was extensively tested. And we recommend to use the very latest version of Intel fortran compiler (i.e, Intel Parallel Studio 2017).","category":"page"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"Possible options:","category":"page"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"mpif90\nmpifort\nmpiifort\nifort","category":"page"},{"location":"ch02/inc.html#LINKER","page":"Explanation of make.inc","title":"LINKER","text":"","category":"section"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"Linker. Here it should be the same with the fortran compiler. Do not change it.","category":"page"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"Possible options:","category":"page"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"$(F90)","category":"page"},{"location":"ch02/inc.html#ARCHIVER","page":"Explanation of make.inc","title":"ARCHIVER","text":"","category":"section"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"Archiver. It is used to pack the binary objects into a library. Do not modify it for ever.","category":"page"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"Possible options:","category":"page"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"ar -ruv","category":"page"},{"location":"ch02/inc.html#MPI","page":"Explanation of make.inc","title":"MPI","text":"","category":"section"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"Specify whether MPI is enable. If you want to compile a sequential code, please comment it out with '#' symbol and then setup F90 to 'ifort'. We strongly suggest to compile the MPI parallelized codes.","category":"page"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"Possible options:","category":"page"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"-DMPI","category":"page"},{"location":"ch02/inc.html#OMP","page":"Explanation of make.inc","title":"OMP","text":"","category":"section"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"Specify whether OpenMP is enable. If you want to disable it, please comment it out. In default it is disabled. So far the OpenMP was used to speedup the measurements of some selected two-particle quantities.","category":"page"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"Possible options:","category":"page"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"-qopenmp","category":"page"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"If you are using old version Intel fortran compiler, this option may be '-openmp'.","category":"page"},{"location":"ch02/inc.html#FPP","page":"Explanation of make.inc","title":"FPP","text":"","category":"section"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"Specify whether the fortran preprocessor (FPP) is used. It has to be enabled or else the iQIST can not be compiled correctly.","category":"page"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"Possible options:","category":"page"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"-fpp","category":"page"},{"location":"ch02/inc.html#CPP","page":"Explanation of make.inc","title":"CPP","text":"","category":"section"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"Collection of preprocessor directives. Do not modify it unless you are an expert of iQIST.","category":"page"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"Possible options:","category":"page"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"$(FPP)\n$(MPI)\n$(OMP)","category":"page"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"Please make sure that the '$(FPP)' option is always present.","category":"page"},{"location":"ch02/inc.html#CHECK","page":"Explanation of make.inc","title":"CHECK","text":"","category":"section"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"Used to specify what types of check should be done.","category":"page"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"Possible options:","category":"page"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"-nogen-interfaces\n-warn all\n-check all\n-traceback\n-g","category":"page"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"The '-nogen-interfaces' option ask the compiler to do not generate an interface block for each routine defined in the source file. The '-warn all' option means the check is done in compiling. The '-check all' option means the check will be done in running. The '-traceback' option enables us to track the exact position (line number and file name) where an error occurs. The '-g' option enables the compiler to generate debug information and embed them into the final program. Note that all of the '-check all', '-traceback', and '-g' options will decrease the efficiency greatly.","category":"page"},{"location":"ch02/inc.html#MTUNE","page":"Explanation of make.inc","title":"MTUNE","text":"","category":"section"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"Collection of optimization options.","category":"page"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"Possible options:","category":"page"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"-O3\n-xHost","category":"page"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"The '-O3' option means the highest optimization. The '-xHost' option enables the compiler to try to generate the most suitable code for the current computer architecture.","category":"page"},{"location":"ch02/inc.html#FFLAGS","page":"Explanation of make.inc","title":"FFLAGS","text":"","category":"section"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"Collection of Fortran compiler options. Do not modify them for ever.","category":"page"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"Possible options:","category":"page"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"-c\n$(CPP)\n$(CHECK)\n$(MTUNE)","category":"page"},{"location":"ch02/inc.html#LFLAGS","page":"Explanation of make.inc","title":"LFLAGS","text":"","category":"section"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"Collection of linker options. Do not modify them unless you know what you are doing.","category":"page"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"Possible options:","category":"page"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"$(OMP)\n-Wl,-no_pie","category":"page"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"The '-Wl,-no_pie' option is useful when you are using the macOS system and want to traceback the code (the -traceback option is applied). If you are using the Linux system, you can skip it.","category":"page"},{"location":"ch02/inc.html#LIBS","page":"Explanation of make.inc","title":"LIBS","text":"","category":"section"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"Specify the external libraries. Now the iQIST software package depends on LAPACK and BLAS heavily. To achieve good performance, the highly optimized LAPACK and BLAS implementations are essential.","category":"page"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"Possible options:","category":"page"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"-framework Accelerate\n-L/home/lihuang/lapack -llapack -lblas\n-L/opt/intel/mkl/lib -lmklcore -lmklsequential -lmkl_rt","category":"page"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"Here we provide three typical choices. (1) In the macOS system, we can use the Apple Accelerate framework. (2) We use the home-built BLAS and LAPACK libraries. Please pay attention to the path. You have to modify it to meet your software environment. (3) We link the iQIST code with the Intel MKL. Please pay attention to the path and the library's name. You have to modify them to meet your software environment. Please see the documentation about Intel MKL for more details.","category":"page"},{"location":"ch02/inc.html#FLINK","page":"Explanation of make.inc","title":"FLINK","text":"","category":"section"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"Specify where the Flink is. Now the iQIST software package depends on Flink heavily.","category":"page"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"Possible options:","category":"page"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"/Users/lihuang/Working/dmft/flink/src","category":"page"},{"location":"ch02/inc.html","page":"Explanation of make.inc","title":"Explanation of make.inc","text":"Please download the latest version of Flink. And then install it on your favourite directory.","category":"page"},{"location":"ch04/p_niter.html#Parameter:-niter","page":"niter","title":"Parameter: niter","text":"","category":"section"},{"location":"ch04/p_niter.html","page":"niter","title":"niter","text":"Definition","category":"page"},{"location":"ch04/p_niter.html","page":"niter","title":"niter","text":"Maximum number of continuous time quantum Monte Carlo quantum impurity solver plus dynamical mean field theory self-consistent iterations.","category":"page"},{"location":"ch04/p_niter.html","page":"niter","title":"niter","text":"Type","category":"page"},{"location":"ch04/p_niter.html","page":"niter","title":"niter","text":"Integer","category":"page"},{"location":"ch04/p_niter.html","page":"niter","title":"niter","text":"Default value","category":"page"},{"location":"ch04/p_niter.html","page":"niter","title":"niter","text":"20","category":"page"},{"location":"ch04/p_niter.html","page":"niter","title":"niter","text":"Component","category":"page"},{"location":"ch04/p_niter.html","page":"niter","title":"niter","text":"ALL","category":"page"},{"location":"ch04/p_niter.html","page":"niter","title":"niter","text":"Behavior","category":"page"},{"location":"ch04/p_niter.html","page":"niter","title":"niter","text":"To terminate the quantum impurity solvers when the niter DMFT iteration is reached.If isscf = 1, the niter becomes meaningless. The self-consistent iteration won't be carried out which is equivalent to niter = 1.","category":"page"},{"location":"ch04/p_niter.html","page":"niter","title":"niter","text":"Comment","category":"page"},{"location":"ch04/p_niter.html","page":"niter","title":"niter","text":"See also isscf and alpha parameters for more details.","category":"page"},{"location":"ch04/p_niter.html","page":"niter","title":"niter","text":"note: Note\nIf the convergence is obtained and the minimal iteration number is reached (the default value is 16, you can modify it in the ctqmc_dmft.f90), the quantum impurity solvers will exit as well.","category":"page"},{"location":"ch02/docs.html#Build-documentation","page":"Build documentation","title":"Build documentation","text":"","category":"section"},{"location":"ch02/docs.html","page":"Build documentation","title":"Build documentation","text":"The documentations for the iQIST software package are written by using the Markdown language and the Julia's Documenter.jl package. You can type the following command in the terminal to build the documentations:","category":"page"},{"location":"ch02/docs.html","page":"Build documentation","title":"Build documentation","text":"$ cd iqist/docs\n$ rm -fr build\n$ julia make.jl","category":"page"},{"location":"ch02/docs.html","page":"Build documentation","title":"Build documentation","text":"Then the HTML-version documentation is generated in the iqist/docs/build directory. Or you can read the official reference manual in the following website:","category":"page"},{"location":"ch02/docs.html","page":"Build documentation","title":"Build documentation","text":"https://huangli712.github.io/projects/iqist/index.html","category":"page"},{"location":"ch04/out_wss.html#solver.wss.dat","page":"solver.wss.dat","title":"solver.wss.dat","text":"","category":"section"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"Introduction","category":"page"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"This file is used to store the Matsubara Weiss's function G_0(iomega_n). It will be output by the quantum impurity solvers when they are shut down.","category":"page"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"Format","category":"page"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"The solver.wss.dat file contains norbs block. Each block is appended by two blank lines. The format of each block is as follows:","category":"page"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"","category":"page"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"column 1: orbital index i, integer","category":"page"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"column 2: Matsubara frequency point, omega_n, double precision","category":"page"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"column 3: Matsubara Weiss's function, Re G_0(iomega_n), double precision","category":"page"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"column 4: Matsubara Weiss's function, Im G_0(iomega_n), double precision","category":"page"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"column 5: error bar, Re delta G_0(iomega_n), double precision","category":"page"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"column 6: error bar, Im delta G_0(iomega_n), double precision","category":"page"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"","category":"page"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"note: Note\nIn the solver.wss.dat file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"Code","category":"page"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"The corresponding Fortran code block for the writing of solver.wss.dat file is as follows:","category":"page"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"! open data file: solver.wss.dat\nopen(mytmp, file='solver.wss.dat', form='formatted', status='unknown')\n\n! write it\ndo i=1,norbs\n    do j=1,mfreq\n        write(mytmp,'(i6,5f16.8)') i, rmesh(j), wssf(j,i,i), czero\n    enddo ! over j={1,mfreq} loop\n    write(mytmp,*) ! write empty lines\n    write(mytmp,*)\nenddo ! over i={1,norbs} loop\n\n! close data file\nclose(mytmp)","category":"page"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"note: Note\nThe columns for the error bar are always zero in this file.","category":"page"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"In the iQIST software package, we provide a Python module to read the output files of quantum impurity solvers. You can use it to read the solver.wss.dat file. See [src/tools/u_reader.py] for more details.","category":"page"},{"location":"ch03/execute.html#Execute-codes","page":"Execute the codes","title":"Execute codes","text":"","category":"section"},{"location":"ch03/execute.html","page":"Execute the codes","title":"Execute the codes","text":"There are also several ways to execute the quantum impurity solvers in the iQIST software package.","category":"page"},{"location":"ch03/execute.html","page":"Execute the codes","title":"Execute the codes","text":"Parallelism mode","category":"page"},{"location":"ch03/execute.html","page":"Execute the codes","title":"Execute the codes","text":"$ mpiexec -n num_of_cores iqist/src/ctseg/ctqmc","category":"page"},{"location":"ch03/execute.html","page":"Execute the codes","title":"Execute the codes","text":"$ mpiexec -n num_of_cores iqist/src/cthyb/ctqmc","category":"page"},{"location":"ch03/execute.html","page":"Execute the codes","title":"Execute the codes","text":"Sequential mode","category":"page"},{"location":"ch03/execute.html","page":"Execute the codes","title":"Execute the codes","text":"$ ./iqist/src/ctseg/ctqmc","category":"page"},{"location":"ch03/execute.html","page":"Execute the codes","title":"Execute the codes","text":"$ ./iqist/src/cthyb/ctqmc","category":"page"},{"location":"ch03/execute.html","page":"Execute the codes","title":"Execute the codes","text":"tip: Tip\nBe sure all of the input files are ready and in correct position. Sometimes the quantum impurity solvers can run without any inputs, but the results may be completely wrong.\nBe sure the message passing interface works properly. If not, please solve it immediately.\nIf you are using a queue system to manage the computational jobs, please edit the submit script by yourself. We could not provide further help.\nSometimes, you want to use the multi-thread technology (OpenMP) to accelerate the quantum impurity solvers in the share memory architecture, it is wise to setup the number of threads in advance. For example:$ export OMP_NUM_THREADS=number_of_cpu_cores_per_node","category":"page"},{"location":"ch03/execute.html","page":"Execute the codes","title":"Execute the codes","text":"note: Note\nEven the iQIST is compiled as a paralleled program, it still can run in a sequential mode.","category":"page"},{"location":"ch02/uncompress.html#Uncompress","page":"Uncompress","title":"Uncompress","text":"","category":"section"},{"location":"ch02/uncompress.html","page":"Uncompress","title":"Uncompress","text":"Usually, the iQIST software package is released as a compressed file. Please use the following commands to uncompress the iQIST software package:","category":"page"},{"location":"ch02/uncompress.html","page":"Uncompress","title":"Uncompress","text":"tar.gz style","category":"page"},{"location":"ch02/uncompress.html","page":"Uncompress","title":"Uncompress","text":"$ tar xvfz iqist.tar.gz","category":"page"},{"location":"ch02/uncompress.html","page":"Uncompress","title":"Uncompress","text":"zip style","category":"page"},{"location":"ch02/uncompress.html","page":"Uncompress","title":"Uncompress","text":"$ unzip iqist.tar.gz","category":"page"},{"location":"ch02/uncompress.html","page":"Uncompress","title":"Uncompress","text":"tar.bz2 style","category":"page"},{"location":"ch02/uncompress.html","page":"Uncompress","title":"Uncompress","text":"$ tar xvfz iqist.tar.bz2","category":"page"},{"location":"ch02/uncompress.html","page":"Uncompress","title":"Uncompress","text":"or","category":"page"},{"location":"ch02/uncompress.html","page":"Uncompress","title":"Uncompress","text":"$ bzip2 -d iqist.tar.bz2\n$ tar xvf iqist.tar","category":"page"},{"location":"ch02/uncompress.html","page":"Uncompress","title":"Uncompress","text":"note: Note\nThe tar, unzip, bzip2 are all Linux terminal commands. Please consult your system administrator for more details.","category":"page"},{"location":"ch04/out_hyb.html#solver.hyb.dat","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"","category":"section"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"Introduction","category":"page"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"This file is used to store the Matsubara hybridization function Delta(iomega_n). It will be output by the quantum impurity solvers when they are shut down.","category":"page"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"Format","category":"page"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"The solver.hyb.dat file contains norbs block. Each block is appended by two blank lines. The format of each block is as follows:","category":"page"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"","category":"page"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"column 1: orbital index i, integer","category":"page"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"column 2: Matsubara frequency point, omega_n, double precision","category":"page"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"column 3: Matsubara hybridization function, Re Delta(iomega_n), double precision","category":"page"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"column 4: Matsubara hybridization function, Im Delta(iomega_n), double precision","category":"page"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"column 5: error bar, Re delta Delta(iomega_n), double precision","category":"page"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"column 6: error bar, Im delta Delta(iomega_n), double precision","category":"page"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"","category":"page"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"note: Note\nIn the solver.hyb.dat file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"Code","category":"page"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"The corresponding Fortran code block for the writing of solver.hyb.dat file is as follows:","category":"page"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"! open data file: solver.hyb.dat\nopen(mytmp, file='solver.hyb.dat', form='formatted', status='unknown')\n\n! write it\ndo i=1,norbs\n    do j=1,mfreq\n        write(mytmp,'(i6,5f16.8)') i, rmesh(j), hybf(j,i,i), czero\n    enddo ! over j={1,mfreq} loop\n    write(mytmp,*) ! write empty lines\n    write(mytmp,*)\nenddo ! over i={1,norbs} loop\n\n! close data file\nclose(mytmp)","category":"page"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"note: Note\nThe columns for the error bar are always zero in this file.","category":"page"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"In the iQIST software package, we provide a Python module to read the output files of quantum impurity solvers. You can use it to read the solver.hyb.dat file. See [src/tools/u_reader.py] for more details.","category":"page"},{"location":"ch02/solvers.html#Build-quantum-impurity-solvers:-integrally","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers: integrally","text":"","category":"section"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"ehh...","category":"page"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"I want to compile all of the components of quantum impurity solvers. Is it possible?","category":"page"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"Of course. It is just a piece of cake. Please follow the following guidelines.","category":"page"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"Method:","category":"page"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"$ cd iqist/build\n$ editor make.inc\n$ make solver","category":"page"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"note: Note\nHere editor means any ascii text editor you prefer.","category":"page"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"Finally, you will see a lot of executable programs, such as ctqmc, etc., in the iqist/src directory. They are the CT-HYB quantum impurity solvers. You can execute them in the terminal directly.","category":"page"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"","category":"page"},{"location":"ch02/solvers.html#Build-quantum-impurity-solvers:-individually","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers: individually","text":"","category":"section"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"Sometimes you only need to use some of the quantum impurity solver components of iQIST and you don't want to compile the whole iQIST software package. Are there any tricks to do? Yes! You will not be disappointed with iQIST.","category":"page"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"Supposed that what you need is the NARCISSUS component:","category":"page"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"Method 1:","category":"page"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"$ cd iqist/build\n$ editor make.inc\n$ make ctseg","category":"page"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"note: Note\nHere editor means any ascii text editor you prefer.\nIf the user want to compile the MANJUSHAKA component, please execute$ make cthyb","category":"page"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"After a few minutes, you will find an ctqmc file in the iqist/src/ctseg directory. That is what you need, the executable program for the NARCISSUS component. Then you can add it to the system path, and do your great research.","category":"page"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"","category":"page"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"Method 2:","category":"page"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"In this approach, we go to the directory of the NARCISSUS component at first. Then 'make' it as usual.","category":"page"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"$ cd iqist/src/ctseg\n$ make","category":"page"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"Here, we assume that the compiling system was correctly configured.","category":"page"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"note: Note\nNow the executable programs will not be copied into the iqist/build directory automatically.","category":"page"},{"location":"ch04/p_ncfgs.html#Parameter:-ncfgs","page":"ncfgs","title":"Parameter: ncfgs","text":"","category":"section"},{"location":"ch04/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Definition","category":"page"},{"location":"ch04/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Number of atomic states considered in the calculations.","category":"page"},{"location":"ch04/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Type","category":"page"},{"location":"ch04/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Integer","category":"page"},{"location":"ch04/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Default value","category":"page"},{"location":"ch04/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"4","category":"page"},{"location":"ch04/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Component","category":"page"},{"location":"ch04/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"ALL","category":"page"},{"location":"ch04/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Behavior","category":"page"},{"location":"ch04/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Determine the size of involved arrays.","category":"page"},{"location":"ch04/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Comment","category":"page"},{"location":"ch04/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"The following relations always hold.textnorbs = textnpsin * textnbandtextncfgs = 2^textnorbsYou have to ensure the value of norbs is compatible with nband, nspin and ncfgs. The quantum impurity solvers will not check and correct them automatically. So you have to setup them in the solver.ctqmc.in file explicitly.See also nspin, nband, and norbs parameters for more details.","category":"page"},{"location":"ch03/monitor.html#Monitor-the-codes","page":"Monitor the codes","title":"Monitor the codes","text":"","category":"section"},{"location":"ch03/monitor.html","page":"Monitor the codes","title":"Monitor the codes","text":"The quantum impurity solvers in the iQIST software package will generate a lot of terminal output and data files (such as solver.hist.dat, solver.status.dat, solver.nmat.dat, etc.) at run time. Through them you can judge the status of the quantum impurity solvers.","category":"page"},{"location":"ch03/monitor.html","page":"Monitor the codes","title":"Monitor the codes","text":"See","category":"page"},{"location":"ch03/monitor.html","page":"Monitor the codes","title":"Monitor the codes","text":"Standard output files // Output stuffs for CT-HYB quantum impurity solvers.","category":"page"},{"location":"ch03/monitor.html","page":"Monitor the codes","title":"Monitor the codes","text":"for more details.","category":"page"},{"location":"ch03/recipes.html#iQIST-recipes","page":"iQIST recipes","title":"iQIST recipes","text":"","category":"section"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"Using the iQIST software package is quite easy. Next we will show you the standard workflow for using the iQIST software package.","category":"page"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"","category":"page"},{"location":"ch03/recipes.html#Choose-suitable-component","page":"iQIST recipes","title":"Choose suitable component","text":"","category":"section"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"At first, there are several CT-HYB quantum impurity solvers in the package. Their features and efficiency are somewhat different. Thus, it is the user's responsibility to choose suitable CT-HYB components to deal with the quantum impurity problem at hand.","category":"page"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"See also:","category":"page"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"Components // What does the iQIST software package include?\nFeatures // Is the required feature supported by the selected component?\n[How to choose suitable quantum impurity solvers?] // A guideline.","category":"page"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"","category":"page"},{"location":"ch03/recipes.html#Design-the-programs-and-scripts","page":"iQIST recipes","title":"Design the programs and scripts","text":"","category":"section"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"Second, the iQIST software package is in essence a computational engine, so users have to write scripts or programs to execute the selected CT-HYB quantum impurity solver. For example, if the users want to conduct CT-HYB/DMFT calculations, in principle they must implement the DMFT self-consistent equation by themselves.","category":"page"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"There is a bonus. When the users want to study the Hubbard model on bethe lattice using the single-site dynamical mean-field theory, or solve the Anderson impurity models in one-shot mode, it is possible to execute the quantum impurity solvers directly without any additional scripts or programs.","category":"page"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"","category":"page"},{"location":"ch03/recipes.html#Prepare-the-input-files","page":"iQIST recipes","title":"Prepare the input files","text":"","category":"section"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"Third, an important task is to prepare proper input data for the selected CT-HYB quantum impurity solver. The optional inputs for the CT-HYB quantum impurity solver are the hybridization function [Delta(iomega_n)], impurity energy level (E_alphabeta), interaction parameters (U, J, lambda, and mu), etc. If users do not provide them to the quantum impurity solver, it will use the default settings automatically. Specifically, if the Coulomb interaction matrix is general or the spin-orbit coupling is considered, users should use the JASMINE component to solve the local atomic Hamiltonian problem at first to generate the necessary eigenvalues and eigenvectors.","category":"page"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"See also:","category":"page"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"Prepare input files // Are you ready?\nStandard input files // Input stuffs for CT-HYB quantum impurity solvers.\nStandard input files // Input stuffs for atomic eigenvalue problem solver.","category":"page"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"","category":"page"},{"location":"ch03/recipes.html#Let's-go.","page":"iQIST recipes","title":"Let's go.","text":"","category":"section"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"Fourth, execute the CT-HYB quantum impurity solver directly or via some external scripts/programs.","category":"page"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"See also:","category":"page"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"Execute the codes // MPI vs. OpenMP, paralleled or sequential.\nMonitor the codes // What's the status of the code?","category":"page"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"","category":"page"},{"location":"ch03/recipes.html#Post-processing","page":"iQIST recipes","title":"Post-processing","text":"","category":"section"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"Finally, when the calculations are finished, users can use the tools contained in the iqist/src/tools directory to post-process the output data, such as the imaginary-time Green's function G(tau), Matsubara self-energy function Sigma(iomega_n), and other physical observables.","category":"page"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"See also:","category":"page"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"[Auxiliary tools] // Full descriptions about the auxiliary tools.","category":"page"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"Good luck to you.","category":"page"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"tip: Tip\nA full-fledged analytic continuation toolkit, namely ACFlow, has been developed to deal with the imaginary-time or Matsubara Green's functions to extract the corresponding spectral functions.","category":"page"},{"location":"ch04/p_mune.html#Parameter:-mune","page":"mune","title":"Parameter: mune","text":"","category":"section"},{"location":"ch04/p_mune.html","page":"mune","title":"mune","text":"Definition","category":"page"},{"location":"ch04/p_mune.html","page":"mune","title":"mune","text":"It means chemical potential mu or fermi level E_F.","category":"page"},{"location":"ch04/p_mune.html","page":"mune","title":"mune","text":"Type","category":"page"},{"location":"ch04/p_mune.html","page":"mune","title":"mune","text":"Float, double precision","category":"page"},{"location":"ch04/p_mune.html","page":"mune","title":"mune","text":"Default value","category":"page"},{"location":"ch04/p_mune.html","page":"mune","title":"mune","text":"2.0","category":"page"},{"location":"ch04/p_mune.html","page":"mune","title":"mune","text":"Component","category":"page"},{"location":"ch04/p_mune.html","page":"mune","title":"mune","text":"ALL","category":"page"},{"location":"ch04/p_mune.html","page":"mune","title":"mune","text":"Behavior","category":"page"},{"location":"ch04/p_mune.html","page":"mune","title":"mune","text":"It is a model parameter and can be used to determine the impurity occupancy.","category":"page"},{"location":"ch04/p_mune.html","page":"mune","title":"mune","text":"Comment","category":"page"},{"location":"ch04/p_mune.html","page":"mune","title":"mune","text":"For single-band model, the half-filling condition is mu = U2.","category":"page"},{"location":"ch05/p_mune.html#Parameter:-mune","page":"mune","title":"Parameter: mune","text":"","category":"section"},{"location":"ch05/p_mune.html","page":"mune","title":"mune","text":"Definition","category":"page"},{"location":"ch05/p_mune.html","page":"mune","title":"mune","text":"Chemical potential or fermi level mu.","category":"page"},{"location":"ch05/p_mune.html","page":"mune","title":"mune","text":"Type","category":"page"},{"location":"ch05/p_mune.html","page":"mune","title":"mune","text":"Float, double precision","category":"page"},{"location":"ch05/p_mune.html","page":"mune","title":"mune","text":"Default value","category":"page"},{"location":"ch05/p_mune.html","page":"mune","title":"mune","text":"0.0","category":"page"},{"location":"ch05/p_mune.html","page":"mune","title":"mune","text":"Component","category":"page"},{"location":"ch05/p_mune.html","page":"mune","title":"mune","text":"Only for the JASMINE component.","category":"page"},{"location":"ch05/p_mune.html","page":"mune","title":"mune","text":"Behavior","category":"page"},{"location":"ch05/p_mune.html","page":"mune","title":"mune","text":"It is used to shift energy level, only useful for model calculations.","category":"page"},{"location":"ch05/p_mune.html","page":"mune","title":"mune","text":"Comment","category":"page"},{"location":"ch05/p_mune.html","page":"mune","title":"mune","text":"N/A","category":"page"},{"location":"ch04/p_nband.html#Parameter:-nband","page":"nband","title":"Parameter: nband","text":"","category":"section"},{"location":"ch04/p_nband.html","page":"nband","title":"nband","text":"Definition","category":"page"},{"location":"ch04/p_nband.html","page":"nband","title":"nband","text":"Number of correlated bands in the model Hamiltonian.","category":"page"},{"location":"ch04/p_nband.html","page":"nband","title":"nband","text":"Type","category":"page"},{"location":"ch04/p_nband.html","page":"nband","title":"nband","text":"Integer","category":"page"},{"location":"ch04/p_nband.html","page":"nband","title":"nband","text":"Default value","category":"page"},{"location":"ch04/p_nband.html","page":"nband","title":"nband","text":"1","category":"page"},{"location":"ch04/p_nband.html","page":"nband","title":"nband","text":"Component","category":"page"},{"location":"ch04/p_nband.html","page":"nband","title":"nband","text":"ALL","category":"page"},{"location":"ch04/p_nband.html","page":"nband","title":"nband","text":"Behavior","category":"page"},{"location":"ch04/p_nband.html","page":"nband","title":"nband","text":"Determine the size of involved arrays.","category":"page"},{"location":"ch04/p_nband.html","page":"nband","title":"nband","text":"Comment","category":"page"},{"location":"ch04/p_nband.html","page":"nband","title":"nband","text":"In the iQIST software package, when we say nband, we always do not consider the spin degree of freedom. So for d−electron system, it should be a five-band model (nband = 5), while for f−electron, it should be a seven-band model (nband = 7).When you try to setup the nband parameter in the solver.ctqmc.in file, the corresponding norbs and ncfgs parameters must be set as well.See nspin, norbs, and ncfgs parameters for more details.","category":"page"},{"location":"ch04/p_mkink.html#Parameter:-mkink","page":"mkink","title":"Parameter: mkink","text":"","category":"section"},{"location":"ch04/p_mkink.html","page":"mkink","title":"mkink","text":"Definition","category":"page"},{"location":"ch04/p_mkink.html","page":"mkink","title":"mkink","text":"Maximum allowable diagrammatic perturbation order in the continuous-time quantum Monte Carlo algorithm.","category":"page"},{"location":"ch04/p_mkink.html","page":"mkink","title":"mkink","text":"Type","category":"page"},{"location":"ch04/p_mkink.html","page":"mkink","title":"mkink","text":"Integer","category":"page"},{"location":"ch04/p_mkink.html","page":"mkink","title":"mkink","text":"Default value","category":"page"},{"location":"ch04/p_mkink.html","page":"mkink","title":"mkink","text":"1024","category":"page"},{"location":"ch04/p_mkink.html","page":"mkink","title":"mkink","text":"Component","category":"page"},{"location":"ch04/p_mkink.html","page":"mkink","title":"mkink","text":"ALL","category":"page"},{"location":"ch04/p_mkink.html","page":"mkink","title":"mkink","text":"Behavior","category":"page"},{"location":"ch04/p_mkink.html","page":"mkink","title":"mkink","text":"Determine the size of involved arrays. If the perturbation expansion order exceeds mkink, fatal error/exceptions will happen.","category":"page"},{"location":"ch04/p_mkink.html","page":"mkink","title":"mkink","text":"Comment","category":"page"},{"location":"ch04/p_mkink.html","page":"mkink","title":"mkink","text":"mkink = 1024 is a safe setting on the condition that the temperature (controlled by the beta parameter) is not too low, the interaction (controlled by the Uc, Uv, Jz, etc,  parameters) is not too weak, the number of orbitals (controlled by the nband parameter) is not too large.","category":"page"},{"location":"ch02/atomic.html#Build-atomic-eigenvalue-problem-solver","page":"Build atomic eigenvalue problem solver","title":"Build atomic eigenvalue problem solver","text":"","category":"section"},{"location":"ch02/atomic.html","page":"Build atomic eigenvalue problem solver","title":"Build atomic eigenvalue problem solver","text":"The JASMINE component is the built-in atomic eigenvalues solver. If you want to use the MANJUSHAKA component, the JASMINE component is the necessary pre-processing tool. You can employ the following commands to compile it.","category":"page"},{"location":"ch02/atomic.html","page":"Build atomic eigenvalue problem solver","title":"Build atomic eigenvalue problem solver","text":"","category":"page"},{"location":"ch02/atomic.html","page":"Build atomic eigenvalue problem solver","title":"Build atomic eigenvalue problem solver","text":"Method 1:","category":"page"},{"location":"ch02/atomic.html","page":"Build atomic eigenvalue problem solver","title":"Build atomic eigenvalue problem solver","text":"$ cd iqist/build\n$ editor make.inc\n$ make atomic","category":"page"},{"location":"ch02/atomic.html","page":"Build atomic eigenvalue problem solver","title":"Build atomic eigenvalue problem solver","text":"note: Note\nHere editor means any ascii text editor you prefer.","category":"page"},{"location":"ch02/atomic.html","page":"Build atomic eigenvalue problem solver","title":"Build atomic eigenvalue problem solver","text":"This is the most common and direct method. After a few minutes, you will find a atomic file in the iqist/src/atomic directory. That is what you need, the executable program for the JASMINE component. After that you can add it to the system path, and do some tests.","category":"page"},{"location":"ch02/atomic.html","page":"Build atomic eigenvalue problem solver","title":"Build atomic eigenvalue problem solver","text":"","category":"page"},{"location":"ch02/atomic.html","page":"Build atomic eigenvalue problem solver","title":"Build atomic eigenvalue problem solver","text":"Method 2:","category":"page"},{"location":"ch02/atomic.html","page":"Build atomic eigenvalue problem solver","title":"Build atomic eigenvalue problem solver","text":"In this approach, we go to the directory of the JASMINE component at first. Then 'make' it as usual.","category":"page"},{"location":"ch02/atomic.html","page":"Build atomic eigenvalue problem solver","title":"Build atomic eigenvalue problem solver","text":"$ cd iqist/src/atomic\n$ make","category":"page"},{"location":"ch02/atomic.html","page":"Build atomic eigenvalue problem solver","title":"Build atomic eigenvalue problem solver","text":"Here, we assume that the compiling system was correctly configured.","category":"page"},{"location":"ch02/atomic.html","page":"Build atomic eigenvalue problem solver","title":"Build atomic eigenvalue problem solver","text":"note: Note\nNow the executable program will not be copied into the iqist/build directory automatically.","category":"page"}]
}

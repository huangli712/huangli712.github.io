var documenterSearchIndex = {"docs":
[{"location":"ch06/p_isoc.html#Parameter:-isoc","page":"isoc","title":"Parameter: isoc","text":"","category":"section"},{"location":"ch06/p_isoc.html","page":"isoc","title":"isoc","text":"Definition","category":"page"},{"location":"ch06/p_isoc.html","page":"isoc","title":"isoc","text":"Key control flag, to define the type of spin-orbit coupling.","category":"page"},{"location":"ch06/p_isoc.html","page":"isoc","title":"isoc","text":"Type","category":"page"},{"location":"ch06/p_isoc.html","page":"isoc","title":"isoc","text":"Integer","category":"page"},{"location":"ch06/p_isoc.html","page":"isoc","title":"isoc","text":"Default value","category":"page"},{"location":"ch06/p_isoc.html","page":"isoc","title":"isoc","text":"0","category":"page"},{"location":"ch06/p_isoc.html","page":"isoc","title":"isoc","text":"Component","category":"page"},{"location":"ch06/p_isoc.html","page":"isoc","title":"isoc","text":"Only for the JASMINE component.","category":"page"},{"location":"ch06/p_isoc.html","page":"isoc","title":"isoc","text":"Behavior","category":"page"},{"location":"ch06/p_isoc.html","page":"isoc","title":"isoc","text":"There are two possible values for the isoc parameter:","category":"page"},{"location":"ch06/p_isoc.html","page":"isoc","title":"isoc","text":"isoc = 0, no spin-orbit coupling.\nisoc = 1, on-site atomic spin-orbit coupling.","category":"page"},{"location":"ch06/p_isoc.html","page":"isoc","title":"isoc","text":"Comment","category":"page"},{"location":"ch06/p_isoc.html","page":"isoc","title":"isoc","text":"See also the lambda parameter for more details.","category":"page"},{"location":"ch09/code.html#Codes","page":"README","title":"Codes","text":"","category":"section"},{"location":"ch08/soc.html#Spin-orbital-coupling","page":"Spin-orbital coupling","title":"Spin-orbital coupling","text":"","category":"section"},{"location":"ch03/create.html#Prepare-input-files","page":"Prepare input files","title":"Prepare input files","text":"","category":"section"},{"location":"ch03/create.html","page":"Prepare input files","title":"Prepare input files","text":"There are two ways to generate the necessary inpute files for the quantum impurity solvers in the iQIST software package. ","category":"page"},{"location":"ch03/create.html","page":"Prepare input files","title":"Prepare input files","text":"Method 1:","category":"page"},{"location":"ch03/create.html","page":"Prepare input files","title":"Prepare input files","text":"One is to prepare the input files manually. ","category":"page"},{"location":"ch03/create.html","page":"Prepare input files","title":"Prepare input files","text":"Usually, the necessary input file is solver.ctqmc.in. It is an ascii text file actually. You can use any text editor to create and edit it in principle. As for the file format of solver.ctqmc.in, please read:","category":"page"},{"location":"ch03/create.html","page":"Prepare input files","title":"Prepare input files","text":"solver.ctqmc.in // Configuration file for CT-QMC impurity solvers.\nsolver.hfqmc.in // Configuration file for HF-QMC impurity solvers.","category":"page"},{"location":"ch03/create.html","page":"Prepare input files","title":"Prepare input files","text":"Besides the solver.ctqmc.in file, some quantum impurity solvers also require the atom.cix file as input. You can use the JASMINE component to generate it. The necessary input file for the JASMINE component is atom.config.in. For more details about it, please read:","category":"page"},{"location":"ch03/create.html","page":"Prepare input files","title":"Prepare input files","text":"atom.config.in // Configuration file for the JASMINE component.","category":"page"},{"location":"ch03/create.html","page":"Prepare input files","title":"Prepare input files","text":"Method 2:","category":"page"},{"location":"ch03/create.html","page":"Prepare input files","title":"Prepare input files","text":"Another approach is to use the u_ctqmc.py, u_hfqmc.py, and u_atomic.py to generate solver.ctqmc.in, solver.hfqmc.in, and atom.config.in files, respectively. In this approach, you have to write some python scripts. Don't worry about it. It is a trivial task. Please see","category":"page"},{"location":"ch03/create.html","page":"Prepare input files","title":"Prepare input files","text":"Scripts // HIBISCUS/scripts codes.","category":"page"},{"location":"ch03/create.html","page":"Prepare input files","title":"Prepare input files","text":"for more details.","category":"page"},{"location":"ch03/create.html","page":"Prepare input files","title":"Prepare input files","text":"","category":"page"},{"location":"ch03/create.html","page":"Prepare input files","title":"Prepare input files","text":"As for the other input files not mentioned here, please try to generate them by yourself. The detailed format descriptions can be seen in the following sections:","category":"page"},{"location":"ch03/create.html","page":"Prepare input files","title":"Prepare input files","text":"Standard input files // Input stuffs for CT-HYB/HF-QMC impurity solvers.\nStandard input files // Input stuffs for atomic eigenvalue problem solver.","category":"page"},{"location":"ch04/out_twop.html#solver.twop.dat","page":"solver.twop.dat","title":"solver.twop.dat","text":"","category":"section"},{"location":"ch04/out_twop.html","page":"solver.twop.dat","title":"solver.twop.dat","text":"Introduction","category":"page"},{"location":"ch04/out_twop.html","page":"solver.twop.dat","title":"solver.twop.dat","text":"The solver.twop.dat file is designed to store the two-particle Green's function chi(iomega_n iomega_n inu_n) and vertex function mathcalF(iomega_n iomega_n inu_n). It will be output by the quantum impurity solvers when they are shut down.","category":"page"},{"location":"ch04/out_twop.html","page":"solver.twop.dat","title":"solver.twop.dat","text":"note: Note\nOnly the GARDENIA, NARCISSUS, CAMELLIA, LAVENDER, and MANJUSHAKA components can generate the solver.twop.dat file.\nThe data stored in the solver.twop.dat file are generated using standard algorithm. However, those data in the solver.vrtx.dat file are generated using the improved estimator algorithm.","category":"page"},{"location":"ch04/out_twop.html","page":"solver.twop.dat","title":"solver.twop.dat","text":"Format","category":"page"},{"location":"ch04/out_twop.html","page":"solver.twop.dat","title":"solver.twop.dat","text":"The solver.twop.dat file contains ","category":"page"},{"location":"ch04/out_twop.html","page":"solver.twop.dat","title":"solver.twop.dat","text":"left(sumlimits^textnorbs_n=1 fracn(n+1)2right)times textnbfrq","category":"page"},{"location":"ch04/out_twop.html","page":"solver.twop.dat","title":"solver.twop.dat","text":"blocks. Each block is appended by two blank lines. The format of each block is as follows:","category":"page"},{"location":"ch04/out_twop.html","page":"solver.twop.dat","title":"solver.twop.dat","text":"","category":"page"},{"location":"ch04/out_twop.html","page":"solver.twop.dat","title":"solver.twop.dat","text":"column 1: Matsubara frequency point (fermionic type), omega_n, integer, the unit is pibeta","category":"page"},{"location":"ch04/out_twop.html","page":"solver.twop.dat","title":"solver.twop.dat","text":"column 2: Matsubara frequency point (fermionic type), omega_n, integer, the unit is pibeta","category":"page"},{"location":"ch04/out_twop.html","page":"solver.twop.dat","title":"solver.twop.dat","text":"column 3: two-particle Green's function, chi(iomega_n iomega_n inu_n), double precision","category":"page"},{"location":"ch04/out_twop.html","page":"solver.twop.dat","title":"solver.twop.dat","text":"column 4: bubble function, chi_0(iomega_n iomega_n inu_n), double precision","category":"page"},{"location":"ch04/out_twop.html","page":"solver.twop.dat","title":"solver.twop.dat","text":"column 5: irreducible part of the two-particle Green's function, chi_textirr(iomega_n iomega_n inu_n), double precision","category":"page"},{"location":"ch04/out_twop.html","page":"solver.twop.dat","title":"solver.twop.dat","text":"column 6: full vertex function, mathcalF(iomega_n iomega_n inu_n), double precision","category":"page"},{"location":"ch04/out_twop.html","page":"solver.twop.dat","title":"solver.twop.dat","text":"","category":"page"},{"location":"ch04/out_twop.html","page":"solver.twop.dat","title":"solver.twop.dat","text":"note: Note\nIn the solver.twop.dat file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch04/out_twop.html","page":"solver.twop.dat","title":"solver.twop.dat","text":"Code","category":"page"},{"location":"ch04/out_twop.html","page":"solver.twop.dat","title":"solver.twop.dat","text":"The corresponding Fortran code block for the writing of solver.twop.dat file is as follows:","category":"page"},{"location":"ch04/out_twop.html","page":"solver.twop.dat","title":"solver.twop.dat","text":"! open data file: solver.twop.dat\n     open(mytmp, file='solver.twop.dat', form='formatted', status='unknown')\n\n! write it\n     do m=1,norbs\n         do n=1,m\n             do k=1,nbfrq\n                 write(mytmp,'(a,i6)') '# flvr1:', m\n                 write(mytmp,'(a,i6)') '# flvr2:', n\n                 write(mytmp,'(a,i6)') '# nbfrq:', k\n                 do j=1,nffrq\n\n                     ......\n\n                     do i=1,nffrq\n\n                         ......\n\n                         write(mytmp,'(2i6,8f16.8)') jt, it, chit, chi0, chii, chii/(g1*g2*g3*g4)\n                     enddo ! over i={1,nffrq} loop\n                 enddo ! over j={1,nffrq} loop\n                 write(mytmp,*) ! write empty lines\n                 write(mytmp,*)\n             enddo ! over k={1,nbfrq} loop\n         enddo ! over n={1,m} loop\n     enddo ! over m={1,norbs} loop\n\n! close data file\n     close(mytmp)","category":"page"},{"location":"ch04/out_twop.html","page":"solver.twop.dat","title":"solver.twop.dat","text":"In the HIBISCUS component, we provide a Python module to read the output files of quantum impurity solvers. You can use it to read the solver.twop.dat file. See script/u_reader.py for more details.","category":"page"},{"location":"ch02/multi.html#Build-iQIST-at-multiple-steps","page":"README","title":"Build iQIST at multiple steps","text":"","category":"section"},{"location":"ch02/multi.html","page":"README","title":"README","text":"Well, maybe you don't like to compile the whole iQIST at one step. You want more controls about the compiling procedure, or you just don't want to waste time on compiling the components, or you even don't indend to compile/have. OK, the compiling system of iQIST provide an alternative way to fit your requirements.","category":"page"},{"location":"ch02/multi.html","page":"README","title":"README","text":"Anyway, the compiling procedure can be split into three successive steps:","category":"page"},{"location":"ch02/multi.html","page":"README","title":"README","text":"Build base library","category":"page"},{"location":"ch02/multi.html","page":"README","title":"README","text":"This step is mandatory, because all of the components of iQIST depend on it.","category":"page"},{"location":"ch02/multi.html","page":"README","title":"README","text":"Build application programming interfaces","category":"page"},{"location":"ch02/multi.html","page":"README","title":"README","text":"This step is optional. But all of the components about quantum impurity solvers and atomic eigenvalues solvers depend on it. So we strongly recommend to build it.","category":"page"},{"location":"ch02/multi.html","page":"README","title":"README","text":"Build selected components","category":"page"},{"location":"ch02/multi.html","page":"README","title":"README","text":"Now you can feel free to compile what you want to have in the iQIST software package. More specially, in this step you can do the following jobs as you wish:","category":"page"},{"location":"ch02/multi.html","page":"README","title":"README","text":"Build quantum impurity solvers\nBuild applications\nBuild atomic eigenvalues solver\nBuild auxiliary tools\nBuild libraries for Fortran\nBuild modules for Python","category":"page"},{"location":"ch02/multi.html","page":"README","title":"README","text":"This step is also optional. You can do the above jobs in sequence or in a random manner.","category":"page"},{"location":"ch04/in_ctqmc.html#solver.ctqmc.in","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"","category":"section"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"Introduction","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"The solver.ctqmc.in file is the only configuration file for the continuous-time quantum Monte Carlo impurity solver. You can setup the parameters for the quantum impurity solvers in it. Besides the Fortran API, this is the only way to setup the parameters for the quantum impurity solvers. But we have to emphasize that this file is optional. In other words, the CT-QMC impurity solvers can run without it. ","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"There are many input parameters for the CT-QMC impurity solvers. But all of parameters have default values. If the solver.ctqmc.in file is absent, the quantum impurity solvers will use the default values. If the solver.ctqmc.in file is present, the quantum impurity solvers will read it, parse it, and apply the settings in it to initialize the quantum impurity solvers. The default values for the parameters are designed for a single-band Hubbard model. Thus in most cases, you need a solver.ctqmc.in file to override the default settings.","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"Format","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"All of the CT-QMC impurity solvers in the iQIST software package share the same solver.ctqmc.in file. In other words, you can exchange solver.ctqmc.in files between different CT-QMC quantum impurity solvers. The format of the solver.ctqmc.in file adopts the simple \"key-value\" style. The detailed rules are as follows:","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"Anything after \"#\" and \"!\" character will be treated as comments and will be ignored completely.","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"example:\n# this is a comment line\n! this is a comment line\nnband = 4 # this is in line comment\nnorbs = 8 ! this in line comment","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"It is not case sensitive.","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"example:\nNband = 4\nNORBS = 8\nNspiN = 2","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"The key and value pair is separated by \"=\" or \":\" character.","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"example:\nnband = 4 ! you can use nband : 4\nnorbs : 8 ! you can use norbs = 8","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"Any space will be ignored. Any blank lines will be skipped as well.","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"example:\nn b a n d = 4 ! it is valid\nno   rb s = 8 ! it is valid","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"You can only use one line to define one key-value pair.","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"example\nnband = 4 norbs = 8  ! it is not valid\nnband = 4, norbs = 8 ! it is not valid\nnband = 4; norbs = 8 ! it is not valid\nnband =              !\n4                    ! it is not valid","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"In the value part, now only integer, real(dp), logical, and character data type are supported.","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"example:\nnband = 4        ! integer type\nmune  = 4.0      ! real(dp) type\nisscf = .true.   ! logical type, you can also use .false., T, F\nmodel = anderson ! character type, do not use \"\" or '' characters to quote it","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"In the value part, a vector is also support. The items in the vector  should be separated by \",\" character.","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"example:\nnband = 1, 2, 3, 4                   ! 4 items\nmune = 0.0, -1.0, 2.0                ! 3 items\nisscf = .true., .true., F, T, .true. ! 5 items\nmodel = anderson, hubbard            ! 2 items","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"An empty input file is acceptable.\nIf one key occurs in the input file for more than 1 times, only the last occurrence is recognized.","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"warning: Warning\nWe mention that the quantum impurity solvers will not check whether the settings in the solver.ctqmc.in file are reasonable and correct. It is the user's responsibility.","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"Code","category":"page"},{"location":"ch04/in_ctqmc.html","page":"solver.ctqmc.in","title":"solver.ctqmc.in","text":"N/A","category":"page"},{"location":"glossary.html#CSSL","page":"Glossary","title":"CSSL","text":"","category":"section"},{"location":"glossary.html","page":"Glossary","title":"Glossary","text":"Common Service Subroutine Library","category":"page"},{"location":"glossary.html#CSML","page":"Glossary","title":"CSML","text":"","category":"section"},{"location":"glossary.html","page":"Glossary","title":"Glossary","text":"Common Service Module Library","category":"page"},{"location":"glossary.html#QMC","page":"Glossary","title":"QMC","text":"","category":"section"},{"location":"glossary.html","page":"Glossary","title":"Glossary","text":"Quantum Monte Carlo","category":"page"},{"location":"glossary.html#SOC","page":"Glossary","title":"SOC","text":"","category":"section"},{"location":"glossary.html","page":"Glossary","title":"Glossary","text":"Spin-orbit coupling","category":"page"},{"location":"glossary.html#BLAS","page":"Glossary","title":"BLAS","text":"","category":"section"},{"location":"glossary.html","page":"Glossary","title":"Glossary","text":"Basic Linear Algebra Subprograms","category":"page"},{"location":"glossary.html#LAPACK","page":"Glossary","title":"LAPACK","text":"","category":"section"},{"location":"glossary.html","page":"Glossary","title":"Glossary","text":"Linear Algebra Package","category":"page"},{"location":"glossary.html#FFT","page":"Glossary","title":"FFT","text":"","category":"section"},{"location":"glossary.html","page":"Glossary","title":"Glossary","text":"fast Fourier transform","category":"page"},{"location":"glossary.html#MEM","page":"Glossary","title":"MEM","text":"","category":"section"},{"location":"glossary.html","page":"Glossary","title":"Glossary","text":"Maximum entropy method","category":"page"},{"location":"glossary.html#SAC","page":"Glossary","title":"SAC","text":"","category":"section"},{"location":"glossary.html","page":"Glossary","title":"Glossary","text":"Stochastic analytical continuation","category":"page"},{"location":"glossary.html#OpenMP","page":"Glossary","title":"OpenMP","text":"","category":"section"},{"location":"glossary.html","page":"Glossary","title":"Glossary","text":"Open Multi-Processing","category":"page"},{"location":"glossary.html#MPI","page":"Glossary","title":"MPI","text":"","category":"section"},{"location":"glossary.html","page":"Glossary","title":"Glossary","text":"Message passing interface","category":"page"},{"location":"glossary.html#API","page":"Glossary","title":"API","text":"","category":"section"},{"location":"glossary.html","page":"Glossary","title":"Glossary","text":"Application programming interface","category":"page"},{"location":"glossary.html#DFT","page":"Glossary","title":"DFT","text":"","category":"section"},{"location":"glossary.html","page":"Glossary","title":"Glossary","text":"Density functional theory","category":"page"},{"location":"glossary.html#DF","page":"Glossary","title":"DF","text":"","category":"section"},{"location":"glossary.html","page":"Glossary","title":"Glossary","text":"Dual fermions","category":"page"},{"location":"glossary.html#DMFT","page":"Glossary","title":"DMFT","text":"","category":"section"},{"location":"glossary.html","page":"Glossary","title":"Glossary","text":"Dynamical mean-field theory","category":"page"},{"location":"glossary.html#QIM","page":"Glossary","title":"QIM","text":"","category":"section"},{"location":"glossary.html","page":"Glossary","title":"Glossary","text":"Quantum impurity models","category":"page"},{"location":"glossary.html#AIM","page":"Glossary","title":"AIM","text":"","category":"section"},{"location":"glossary.html","page":"Glossary","title":"Glossary","text":"Anderson impurity models","category":"page"},{"location":"glossary.html#CT-QMC","page":"Glossary","title":"CT-QMC","text":"","category":"section"},{"location":"glossary.html","page":"Glossary","title":"Glossary","text":"Continuous-time quantum Monte Carlo impurity solvers","category":"page"},{"location":"glossary.html#CT-HYB","page":"Glossary","title":"CT-HYB","text":"","category":"section"},{"location":"glossary.html","page":"Glossary","title":"Glossary","text":"Hybridization expansion version CT-QMC","category":"page"},{"location":"glossary.html#CT-INT","page":"Glossary","title":"CT-INT","text":"","category":"section"},{"location":"glossary.html","page":"Glossary","title":"Glossary","text":"Interaction expansion version CT-QMC","category":"page"},{"location":"glossary.html#HF-QMC","page":"Glossary","title":"HF-QMC","text":"","category":"section"},{"location":"glossary.html","page":"Glossary","title":"Glossary","text":"Hirsch-Fye quantum Monte Carlo impurity solvers","category":"page"},{"location":"ch09/dac.html#Divide-and-conquer-algorithm","page":"Divide-and-conquer algorithm","title":"Divide-and-conquer algorithm","text":"","category":"section"},{"location":"ch09/dac.html","page":"Divide-and-conquer algorithm","title":"Divide-and-conquer algorithm","text":"(Image: divide image) Figure | Illustration of the divide-and-conquer algorithm. The imaginary time axis is split into four parts with equal length by vertical dashed lines. The open (filled) circles mean creation (annihilation) operators. The color is used to distinguish different flavors. It shows that a creation operator is inserted into the B part, while a annihilation operator is inserted into the D part.","category":"page"},{"location":"ch09/dac.html","page":"Divide-and-conquer algorithm","title":"Divide-and-conquer algorithm","text":"The Monte Carlo updates, such as inserting (removing) a pair of creation and annihilation operators, usually modify the diagrammatic configuration locally. Based on this fact, we implemented a divide-and-conquer algorithm to speed up the trace evaluation. As illustrated in the above figure, we divide the imaginary time axis into a few parts with equal length. For each part, there will be zero or nonzero fermion operators, and we save their matrix products when evaluating the local trace in the beginning. In the next Monte Carlo sampling, we first determine which parts may be modified or influenced, and then for these parts we recalculate the matrix products from scratch and save them again. For the unchanged parts, we will leave them unchanged. Finally, we will multiply the contributions of all parts to obtain the final local trace. By using this divide-and-conquer trick, we can avoid redundant computations and speed up the calculation of the acceptance probability p. This trick can be combined with the GQNs algorithm to achieve a further speedup. ","category":"page"},{"location":"ch09/ortho.html#Orthogonal-polynomial-representation","page":"Orthogonal polynomial representation","title":"Orthogonal polynomial representation","text":"","category":"section"},{"location":"ch09/ortho.html","page":"Orthogonal polynomial representation","title":"Orthogonal polynomial representation","text":"Legendre polynomial representation","category":"page"},{"location":"ch09/ortho.html","page":"Orthogonal polynomial representation","title":"Orthogonal polynomial representation","text":"Boehnke et al.[1] proposed that the Legendre polynomial can be used to improve the measurements of single-particle and two-particle Green's functions. Thanks to the Legendre polynomial representation, the numerical noise and memory space needed to store the Green's function are greatly reduced.","category":"page"},{"location":"ch09/ortho.html","page":"Orthogonal polynomial representation","title":"Orthogonal polynomial representation","text":"The imaginary time Green's function G(tau) is expressed using the Legendre polynomial P_n(x) defined in [-1,1]:","category":"page"},{"location":"ch09/ortho.html","page":"Orthogonal polynomial representation","title":"Orthogonal polynomial representation","text":"beginequation\nG(tau) = frac1beta sum_n leq 0 sqrt2n + 1 P_nx(tau) G_n\nendequation","category":"page"},{"location":"ch09/ortho.html","page":"Orthogonal polynomial representation","title":"Orthogonal polynomial representation","text":"here n is the order of Legendre polynomial, G_n is the expansion coefficient, x(tau) maps tau in 0beta to x in -11:","category":"page"},{"location":"ch09/ortho.html","page":"Orthogonal polynomial representation","title":"Orthogonal polynomial representation","text":"beginequation\nx(tau) = frac2taubeta - 1\nendequation","category":"page"},{"location":"ch09/ortho.html","page":"Orthogonal polynomial representation","title":"Orthogonal polynomial representation","text":"Using the orthogonal relations of Legendre polynomials, we obtain ","category":"page"},{"location":"ch09/ortho.html","page":"Orthogonal polynomial representation","title":"Orthogonal polynomial representation","text":"beginequation\nG_n = sqrt2n + 1 int^beta_0 dtau P_nx(tau) G(tau)\nendequation","category":"page"},{"location":"ch09/ortho.html","page":"Orthogonal polynomial representation","title":"Orthogonal polynomial representation","text":"If we substitute G(tau) into G_n, we get ","category":"page"},{"location":"ch09/ortho.html","page":"Orthogonal polynomial representation","title":"Orthogonal polynomial representation","text":"beginequation\nG_n = -fracsqrt2n + 1beta leftlangle sum^k_i=1 sum^k_j=1\nmathcalM_ji tildeP_n(tau^e_i - tau^s_j) rightrangle\nendequation","category":"page"},{"location":"ch09/ortho.html","page":"Orthogonal polynomial representation","title":"Orthogonal polynomial representation","text":"where","category":"page"},{"location":"ch09/ortho.html","page":"Orthogonal polynomial representation","title":"Orthogonal polynomial representation","text":"beginequation\ntildeP_n(tau) = \nbegincases\nP_n x(tau)  tau  0 \n-P_n x(tau + beta)  tau  0 \nendcases\nendequation","category":"page"},{"location":"ch09/ortho.html","page":"Orthogonal polynomial representation","title":"Orthogonal polynomial representation","text":"and tau^s and tau^e denote the positions of creation and annihilation operators on the imaginary time axis, respectively. We can also express the Matsubara Green's function G(iomega_n) using Legendre polynomials:","category":"page"},{"location":"ch09/ortho.html","page":"Orthogonal polynomial representation","title":"Orthogonal polynomial representation","text":"beginequation\nG(iomega_m) = sum_n leq 0 T_mn G_n\nendequation","category":"page"},{"location":"ch09/ortho.html","page":"Orthogonal polynomial representation","title":"Orthogonal polynomial representation","text":"The transformation matrix T_mn is defined as","category":"page"},{"location":"ch09/ortho.html","page":"Orthogonal polynomial representation","title":"Orthogonal polynomial representation","text":"beginequation\nT_mn = (-1)^m i^n+1 sqrt2n + 1 j_n leftfrac(2m + 1)pi2right\nendequation","category":"page"},{"location":"ch09/ortho.html","page":"Orthogonal polynomial representation","title":"Orthogonal polynomial representation","text":"where j_n(z) is the spheric Bessel function. Actually, in the Monte Carlo simulation, only the expansion coefficients G_n are measured. When the calculation is finished, the final Green's function can be evaluated. It is worthwhile to note that the T_mn do not depend on the inverse temperature beta, so that we can calculate and store the matrix elements beforehand to save computer time.","category":"page"},{"location":"ch09/ortho.html","page":"Orthogonal polynomial representation","title":"Orthogonal polynomial representation","text":"Chebyshev polynomial representation","category":"page"},{"location":"ch09/ortho.html","page":"Orthogonal polynomial representation","title":"Orthogonal polynomial representation","text":"It is easily to extend this formalism to other orthogonal polynomials. For example, in the iQIST software package, we not only implemented the Legendre polynomial representation, but also the Chebyshev polynomial representation. In the Chebyshev polynomial representation, the imaginary time Green's function G(tau) is expanded as follows:","category":"page"},{"location":"ch09/ortho.html","page":"Orthogonal polynomial representation","title":"Orthogonal polynomial representation","text":"beginequation\nG(tau) = frac2beta sum_n leq 0 U_n x(tau)G_n\nendequation","category":"page"},{"location":"ch09/ortho.html","page":"Orthogonal polynomial representation","title":"Orthogonal polynomial representation","text":"here the U_n(x) denote the second kind Chebyshev polynomials and x in -11. The equation for the expansion coefficients G_n is:","category":"page"},{"location":"ch09/ortho.html","page":"Orthogonal polynomial representation","title":"Orthogonal polynomial representation","text":"beginequation\nG_n = -frac2pibeta leftlangle  sum^k_i=1 sum^k_j=1 \nmathcalM_ji \ntildeU_n(tau^e_i - tau^s_j)\nsqrt1 - tildex(tau^e_i - tau^s_j)^2\nrightrangle\nendequation","category":"page"},{"location":"ch09/ortho.html","page":"Orthogonal polynomial representation","title":"Orthogonal polynomial representation","text":"where","category":"page"},{"location":"ch09/ortho.html","page":"Orthogonal polynomial representation","title":"Orthogonal polynomial representation","text":"beginequation\ntildeU_n (x) = \nbegincases\nU_nx(tau)  tau  0 \n-U_nx(tau+beta)  tau  0 \nendcases\nendequation","category":"page"},{"location":"ch09/ortho.html","page":"Orthogonal polynomial representation","title":"Orthogonal polynomial representation","text":"and","category":"page"},{"location":"ch09/ortho.html","page":"Orthogonal polynomial representation","title":"Orthogonal polynomial representation","text":"beginequation\ntildex(tau) = \nbegincases\nx(tau)  tau  0 \nx(tau + beta)  tau  0 \nendcases\nendequation","category":"page"},{"location":"ch09/ortho.html","page":"Orthogonal polynomial representation","title":"Orthogonal polynomial representation","text":"Unfortunately, there is no explicit expression for G(iomega_n) in the Chebyshev polynomial representation. So the Legendre polynomial representation is better.","category":"page"},{"location":"ch09/ortho.html","page":"Orthogonal polynomial representation","title":"Orthogonal polynomial representation","text":"See also","category":"page"},{"location":"ch09/ortho.html","page":"Orthogonal polynomial representation","title":"Orthogonal polynomial representation","text":"The orthogonal polynomial representation has been implemented in the GARDENIA, NARCISSUS, LAVENDER, MANJUSHAKA, CAMELLIA, and HIBISCUS/stoch components.","category":"page"},{"location":"ch09/ortho.html","page":"Orthogonal polynomial representation","title":"Orthogonal polynomial representation","text":"See isort, legrd, lemax, chgrd, chmax parameters for more details.","category":"page"},{"location":"ch09/ortho.html","page":"Orthogonal polynomial representation","title":"Orthogonal polynomial representation","text":"Reference","category":"page"},{"location":"ch09/ortho.html","page":"Orthogonal polynomial representation","title":"Orthogonal polynomial representation","text":"[1]: Lewin Boehnke, Hartmut Hafermann, Michel Ferrero, Frank Lechermann, and Olivier Parcollet, Phys. Rev. B 84, 075145 (2011)","category":"page"},{"location":"ch01/components.html#Components","page":"Components","title":"Components","text":"","category":"section"},{"location":"ch01/components.html","page":"Components","title":"Components","text":"The iQIST software package is much more complex and powerful than what you can imagine. It contains several components which can be used to solve different impurity problems, prepare the input files, post-process the calculated results, etc.","category":"page"},{"location":"ch01/components.html","page":"Components","title":"Components","text":"(Image: mindmap image)","category":"page"},{"location":"ch01/components.html","page":"Components","title":"Components","text":"Figure | Schematic picture for the iQIST's components. Components on the LHS are all CT-HYB solvers, JASMINE is the atomic eigenvalue solver, DAISY is a HF-QMC solver, and HIBISCUS contains other pre-processing and post-processing tools.","category":"page"},{"location":"ch01/components.html","page":"Components","title":"Components","text":"According to their abilities and functions, the components of the iQIST software package can be classified into the following catalogues:","category":"page"},{"location":"ch01/components.html#Continuous-time-quantum-Monte-Carlo-impurity-solvers-(segment-representation-version)","page":"Components","title":"Continuous-time quantum Monte Carlo impurity solvers (segment representation version)","text":"","category":"section"},{"location":"ch01/components.html","page":"Components","title":"Components","text":"AZALEA component\nGARDENIA component\nNARCISSUS component","category":"page"},{"location":"ch01/components.html","page":"Components","title":"Components","text":"For the details of these quantum impurity solvers, please see the chapter Quantum Monte Carlo impurity solvers.","category":"page"},{"location":"ch01/components.html#Continuous-time-quantum-Monte-Carlo-impurity-solvers-(general-matrix-version)","page":"Components","title":"Continuous-time quantum Monte Carlo impurity solvers (general matrix version)","text":"","category":"section"},{"location":"ch01/components.html","page":"Components","title":"Components","text":"BEGONIA component\nLAVENDER component\nCAMELLIA component (not ready)\nMANJUSHAKA component (unstable)\nPANSY component (unstable)","category":"page"},{"location":"ch01/components.html","page":"Components","title":"Components","text":"For the details of these quantum impurity solvers, please see the chapter Quantum Monte Carlo impurity solvers.","category":"page"},{"location":"ch01/components.html#Hirsch-Fye-quantum-Monte-Carlo-impurity-solver","page":"Components","title":"Hirsch-Fye quantum Monte Carlo impurity solver","text":"","category":"section"},{"location":"ch01/components.html","page":"Components","title":"Components","text":"DAISY component","category":"page"},{"location":"ch01/components.html","page":"Components","title":"Components","text":"For the details of these quantum impurity solvers, please see the chapter Quantum Monte Carlo impurity solvers.","category":"page"},{"location":"ch01/components.html#Auxiliary-tools","page":"Components","title":"Auxiliary tools","text":"","category":"section"},{"location":"ch01/components.html","page":"Components","title":"Components","text":"HIBISCUS component\nJASMINE component","category":"page"},{"location":"ch01/components.html","page":"Components","title":"Components","text":"For the details of these tools, please see the chapters Atomic eigenvalue problem solver and Auxiliary tools.","category":"page"},{"location":"ch01/components.html#Applications","page":"Components","title":"Applications","text":"","category":"section"},{"location":"ch01/components.html","page":"Components","title":"Components","text":"SAKURA component (DFT + DMFT code, not ready)\nROSEMARY component (ladder dual fermions code, not ready)","category":"page"},{"location":"ch01/components.html","page":"Components","title":"Components","text":"For the details of these applications, please see the chapter Applications.","category":"page"},{"location":"ch01/components.html#Miscellanies","page":"Components","title":"Miscellanies","text":"","category":"section"},{"location":"ch01/components.html","page":"Components","title":"Components","text":"Besides the above components, the iQIST software package also includes many useful and interesting things, such as:","category":"page"},{"location":"ch01/components.html","page":"Components","title":"Components","text":"The Reference Manual (It is me!)\nApplication Programming Interfaces (Fortran and Python versions)\nCommon Service Modules Library (CSML)\nCommon Service Subroutines Library (CSSL)\nTutorials and Examples","category":"page"},{"location":"ch01/components.html","page":"Components","title":"Components","text":"note: Note\nIn the Common Service Modules Library and Common Service Subroutines Library, we implement the numerical infrastructures for the iQIST software package. They can be reused in the other scientific computation projects.","category":"page"},{"location":"ch09/sparse.html#Sparse-matrix-tricks","page":"Sparse matrix tricks","title":"Sparse matrix tricks","text":"","category":"section"},{"location":"ch09/sparse.html","page":"Sparse matrix tricks","title":"Sparse matrix tricks","text":"If direct matrix-matrix multiplications are used when evaluating the local trace, the F-matrix must be very sparse. Thus, we can convert them into sparse matrices in compressed sparse row (CSR) format, and then the sparse matrix multiplication can be applied to obtain a significant speedup.","category":"page"},{"location":"ch07/sar.html#script/d_sar.sh","page":"script/d_sar.sh","title":"script/d_sar.sh","text":"","category":"section"},{"location":"ch07/sar.html","page":"script/d_sar.sh","title":"script/d_sar.sh","text":"Introduction","category":"page"},{"location":"ch07/sar.html","page":"script/d_sar.sh","title":"script/d_sar.sh","text":"The purpose of this script is to scan a file or directory, and then replace some characters with given characters. So we name it as sar.sh (Scan And Replace). We can use it to preprocess the atom.config.in/solver.ctqmc.in files in the iqist/working/ctqmc/standard directory.","category":"page"},{"location":"ch07/sar.html","page":"script/d_sar.sh","title":"script/d_sar.sh","text":"Type","category":"page"},{"location":"ch07/sar.html","page":"script/d_sar.sh","title":"script/d_sar.sh","text":"Bash shell script","category":"page"},{"location":"ch07/sar.html","page":"script/d_sar.sh","title":"script/d_sar.sh","text":"Usage","category":"page"},{"location":"ch07/sar.html","page":"script/d_sar.sh","title":"script/d_sar.sh","text":"There is not input parameter for this script. You can execute it without any parameters.","category":"page"},{"location":"ch07/sar.html","page":"script/d_sar.sh","title":"script/d_sar.sh","text":"$./d_sar.sh","category":"page"},{"location":"ch07/sar.html","page":"script/d_sar.sh","title":"script/d_sar.sh","text":"Before you start to use this shell script, you have to check and edit carefully the string match pattern in it.","category":"page"},{"location":"ch07/sar.html","page":"script/d_sar.sh","title":"script/d_sar.sh","text":"Input","category":"page"},{"location":"ch07/sar.html","page":"script/d_sar.sh","title":"script/d_sar.sh","text":"N/A","category":"page"},{"location":"ch07/sar.html","page":"script/d_sar.sh","title":"script/d_sar.sh","text":"Output","category":"page"},{"location":"ch07/sar.html","page":"script/d_sar.sh","title":"script/d_sar.sh","text":"See the terminal output.","category":"page"},{"location":"ch07/sar.html","page":"script/d_sar.sh","title":"script/d_sar.sh","text":"Comment","category":"page"},{"location":"ch07/sar.html","page":"script/d_sar.sh","title":"script/d_sar.sh","text":"For Mac OS X system, the grammar for sed is (we don't generate backup)","category":"page"},{"location":"ch07/sar.html","page":"script/d_sar.sh","title":"script/d_sar.sh","text":"sed -i '' ...","category":"page"},{"location":"ch07/sar.html","page":"script/d_sar.sh","title":"script/d_sar.sh","text":"However, for Linux-based system, the grammar for sed is","category":"page"},{"location":"ch07/sar.html","page":"script/d_sar.sh","title":"script/d_sar.sh","text":"sed -i ...","category":"page"},{"location":"ch07/sar.html","page":"script/d_sar.sh","title":"script/d_sar.sh","text":"!!! note:","category":"page"},{"location":"ch07/sar.html","page":"script/d_sar.sh","title":"script/d_sar.sh","text":"This script is used by the iQIST Developer Team *internally*.","category":"page"},{"location":"ch04/p_ifast.html#Parameter:-ifast","page":"ifast","title":"Parameter: ifast","text":"","category":"section"},{"location":"ch04/p_ifast.html","page":"ifast","title":"ifast","text":"Definition","category":"page"},{"location":"ch04/p_ifast.html","page":"ifast","title":"ifast","text":"It is a key control flag, used to choose the efficient algorithms for the calculation of the operator trace. ","category":"page"},{"location":"ch04/p_ifast.html","page":"ifast","title":"ifast","text":"Type","category":"page"},{"location":"ch04/p_ifast.html","page":"ifast","title":"ifast","text":"Integer","category":"page"},{"location":"ch04/p_ifast.html","page":"ifast","title":"ifast","text":"Default value","category":"page"},{"location":"ch04/p_ifast.html","page":"ifast","title":"ifast","text":"1","category":"page"},{"location":"ch04/p_ifast.html","page":"ifast","title":"ifast","text":"Component","category":"page"},{"location":"ch04/p_ifast.html","page":"ifast","title":"ifast","text":"Only for the MANJUSHAKA component.","category":"page"},{"location":"ch04/p_ifast.html","page":"ifast","title":"ifast","text":"Behavior","category":"page"},{"location":"ch04/p_ifast.html","page":"ifast","title":"ifast","text":"According to the ifast parameter, the quantum impurity solvers will choose suitable algorithm to evaluate the operator trace.","category":"page"},{"location":"ch04/p_ifast.html","page":"ifast","title":"ifast","text":"There are three possible values for ifast parameter so far:","category":"page"},{"location":"ch04/p_ifast.html","page":"ifast","title":"ifast","text":"ifast = 1, the divide-and-conquer algorithm will be used. At this time, you have to adjust npart parameter carefully to obtain good computational efficiency. (see npart parameter as well)\nifast = 2, the classic time evolution algorithm will be used. ","category":"page"},{"location":"ch04/p_ifast.html","page":"ifast","title":"ifast","text":"warning: Warning\nThis algorithm is not implemented in the public version. We are sorry for that.","category":"page"},{"location":"ch04/p_ifast.html","page":"ifast","title":"ifast","text":"ifast = 3, the skip listing algorithm will be used. ","category":"page"},{"location":"ch04/p_ifast.html","page":"ifast","title":"ifast","text":"warning: Warning\nThis algorithm is not implemented in the public version. We are sorry for that.","category":"page"},{"location":"ch04/p_ifast.html","page":"ifast","title":"ifast","text":"All in all, now only ifast = 1 is valid. Even you set ifast = 2 or ifast = 3, the MANJUSHAKA code will still use the divide-and-conquer algorithm to calculate the operator trace.","category":"page"},{"location":"ch04/p_ifast.html","page":"ifast","title":"ifast","text":"Comment","category":"page"},{"location":"ch04/p_ifast.html","page":"ifast","title":"ifast","text":"In the MANJUSHAKA code, the Lazy trace evaluation trick[1] is always used. As for the divide-and-conquer algorithm and the classic time evolution algorithm, please refer to Emanuel Gull's PhD thesis. ","category":"page"},{"location":"ch04/p_ifast.html","page":"ifast","title":"ifast","text":"Reference","category":"page"},{"location":"ch04/p_ifast.html","page":"ifast","title":"ifast","text":"[1]: P. SÃ©mon, Chuck-Hou Yee, Kristjan Haule, and A.-M. S. Tremblay, Phys. Rev. B 90, 075149 (2014).","category":"page"},{"location":"ch09/csml.html#Common-service-module-library","page":"Common service module library","title":"Common service module library","text":"","category":"section"},{"location":"ch09/csml.html","page":"Common service module library","title":"Common service module library","text":"In order to facilitate the development of scientific software, we gather some numerical algorithms, datatypes, and constants, and implement them as common Fortran modules. They are widely used in the iQIST software package and the other private projects. The collection of these modules is the so-called common service module library, abbreviated CSML in this manual.","category":"page"},{"location":"ch09/csml.html","page":"Common service module library","title":"Common service module library","text":"The source codes of the CSML are stored in the iqist/src/base directory. You can compile them via the following commands:","category":"page"},{"location":"ch09/csml.html","page":"Common service module library","title":"Common service module library","text":"$ cd iqist/build\n$ make base","category":"page"},{"location":"ch09/csml.html","page":"Common service module library","title":"Common service module library","text":"or","category":"page"},{"location":"ch09/csml.html","page":"Common service module library","title":"Common service module library","text":"$ cd iqist/src/base\n$ make","category":"page"},{"location":"ch09/csml.html","page":"Common service module library","title":"Common service module library","text":"The CSML contains many files (modules). Next we will introduce them one by one, so that the developers can be familiar with their functionality and limitations. Except where stated explicitly, these modules could be used individually.","category":"page"},{"location":"ch09/csml.html","page":"Common service module library","title":"Common service module library","text":"note: Note\nThis is not a API reference documentation. You should read the source codes by yourself to obtain detailed information.","category":"page"},{"location":"ch09/csml.html","page":"Common service module library","title":"Common service module library","text":"m_constants.f90","category":"page"},{"location":"ch09/csml.html","page":"Common service module library","title":"Common service module library","text":"module constants","category":"page"},{"location":"ch09/csml.html","page":"Common service module library","title":"Common service module library","text":"Some selected physical and numerical constants are provided in this modules, such as pi and 1i.","category":"page"},{"location":"ch09/csml.html","page":"Common service module library","title":"Common service module library","text":"m_leja.f90","category":"page"},{"location":"ch09/csml.html","page":"Common service module library","title":"Common service module library","text":"module leja","category":"page"},{"location":"ch09/csml.html","page":"Common service module library","title":"Common service module library","text":"In this module, the Newton-Leja polynomial interpolation algorithm is implemented, which is used to evaluate ","category":"page"},{"location":"ch09/csml.html","page":"Common service module library","title":"Common service module library","text":"psi_frangle = e^-Htau  psi_i rangle","category":"page"},{"location":"ch09/csml.html","page":"Common service module library","title":"Common service module library","text":"Now this module is only useful for the CAMELLIA component.","category":"page"},{"location":"ch09/csml.html","page":"Common service module library","title":"Common service module library","text":"m_linkedlist.f90","category":"page"},{"location":"ch09/csml.html","page":"Common service module library","title":"Common service module library","text":"module linkedlist","category":"page"},{"location":"ch09/csml.html","page":"Common service module library","title":"Common service module library","text":"As is well known, the linked list is a very useful datatype. In this module, a generic linked list is implemented. In the iQIST software package, this module is used to implement a parser for the configuration files.","category":"page"},{"location":"ch09/csml.html","page":"Common service module library","title":"Common service module library","text":"m_mpi.f90","category":"page"},{"location":"ch09/csml.html","page":"Common service module library","title":"Common service module library","text":"module mmpi","category":"page"},{"location":"ch09/csml.html","page":"Common service module library","title":"Common service module library","text":"In this module, some important MPI calls are decorated to simpler forms. ","category":"page"},{"location":"ch09/csml.html","page":"Common service module library","title":"Common service module library","text":"m_parser.f90","category":"page"},{"location":"ch09/csml.html","page":"Common service module library","title":"Common service module library","text":"module parser","category":"page"},{"location":"ch09/csml.html","page":"Common service module library","title":"Common service module library","text":"m_skynet.f90","category":"page"},{"location":"ch09/csml.html","page":"Common service module library","title":"Common service module library","text":"module skynet","category":"page"},{"location":"ch09/csml.html","page":"Common service module library","title":"Common service module library","text":"m_sparse.f90","category":"page"},{"location":"ch09/csml.html","page":"Common service module library","title":"Common service module library","text":"module sparse","category":"page"},{"location":"ch09/csml.html","page":"Common service module library","title":"Common service module library","text":"m_spring.f90","category":"page"},{"location":"ch09/csml.html","page":"Common service module library","title":"Common service module library","text":"module spring","category":"page"},{"location":"ch09/csml.html","page":"Common service module library","title":"Common service module library","text":"m_stack.f90","category":"page"},{"location":"ch09/csml.html","page":"Common service module library","title":"Common service module library","text":"module stack","category":"page"},{"location":"ch07/chi.html#toolbox/makechi","page":"toolbox/makechi","title":"toolbox/makechi","text":"","category":"section"},{"location":"ch07/chi.html","page":"toolbox/makechi","title":"toolbox/makechi","text":"Introduction","category":"page"},{"location":"ch07/chi.html","page":"toolbox/makechi","title":"toolbox/makechi","text":"The makechi code is often used to deal with the spin-spin correlation function (in imaginary time). It can output the magnetic susceptibility and effective magnetic moment. So far only the GARDENIA and NARCISSUS codes can build the spin-spin correlation function in imaginary time space. If the spin-spin correlation function is in frequency space, this code can not be used directly.","category":"page"},{"location":"ch07/chi.html","page":"toolbox/makechi","title":"toolbox/makechi","text":"Spin-spin correlation function chi_textspin(tau):","category":"page"},{"location":"ch07/chi.html","page":"toolbox/makechi","title":"toolbox/makechi","text":"chi_textspin(tau) = langle S_z(0) S_z(tau)rangle","category":"page"},{"location":"ch07/chi.html","page":"toolbox/makechi","title":"toolbox/makechi","text":"Magnetic susceptibility chi_textloc:","category":"page"},{"location":"ch07/chi.html","page":"toolbox/makechi","title":"toolbox/makechi","text":"chi_textloc = int^beta_0 dtau chi_textspin(tau)","category":"page"},{"location":"ch07/chi.html","page":"toolbox/makechi","title":"toolbox/makechi","text":"Effective local magnetic moment M_e:","category":"page"},{"location":"ch07/chi.html","page":"toolbox/makechi","title":"toolbox/makechi","text":"M_e = sqrtTchi_textloc","category":"page"},{"location":"ch07/chi.html","page":"toolbox/makechi","title":"toolbox/makechi","text":"Usage","category":"page"},{"location":"ch07/chi.html","page":"toolbox/makechi","title":"toolbox/makechi","text":"$ ./mchi","category":"page"},{"location":"ch07/chi.html","page":"toolbox/makechi","title":"toolbox/makechi","text":"Input","category":"page"},{"location":"ch07/chi.html","page":"toolbox/makechi","title":"toolbox/makechi","text":"See the terminal prompt\nsolver.schi.dat (necessary)","category":"page"},{"location":"ch07/chi.html","page":"toolbox/makechi","title":"toolbox/makechi","text":"Output","category":"page"},{"location":"ch07/chi.html","page":"toolbox/makechi","title":"toolbox/makechi","text":"See the terminal output.","category":"page"},{"location":"ch07/chi.html","page":"toolbox/makechi","title":"toolbox/makechi","text":"Comment","category":"page"},{"location":"ch07/chi.html","page":"toolbox/makechi","title":"toolbox/makechi","text":"N/A","category":"page"},{"location":"ch09/sig.html#Improved-estimator-for-the-self-energy-function","page":"Improved estimator for the self-energy function","title":"Improved estimator for the self-energy function","text":"","category":"section"},{"location":"ch09/sig.html","page":"Improved estimator for the self-energy function","title":"Improved estimator for the self-energy function","text":"Recently, Hafermann et al. proposed efficient measurement procedures for the self-energy and vertex functions within the CT-HYB algorithm[^1,2]. In their method, some higher-order correlation functions (related to the quantities being sought through the equation of motion) are measured. For the case of interactions of density-density type, the segment algorithm is available[3]. Thus, the additional correlators can be obtained essentially at no additional computational cost. When the calculations are completed, the required self-energy function and vertex function can be evaluated analytically.","category":"page"},{"location":"ch09/sig.html","page":"Improved estimator for the self-energy function","title":"Improved estimator for the self-energy function","text":"The improved estimator for the self-energy function can be expressed in the following form:","category":"page"},{"location":"ch09/sig.html","page":"Improved estimator for the self-energy function","title":"Improved estimator for the self-energy function","text":"beginequation\nSigma_ab(iomega_n) = frac12 \nsum_ij G^-1_ai(iomega_n) (U_jb + U_bj) F^j_ib(iomega_n)\nendequation","category":"page"},{"location":"ch09/sig.html","page":"Improved estimator for the self-energy function","title":"Improved estimator for the self-energy function","text":"where U_ab is the Coulomb interaction matrix element. The expression for the new two-particle correlator F^j_ab(tau - tau) reads","category":"page"},{"location":"ch09/sig.html","page":"Improved estimator for the self-energy function","title":"Improved estimator for the self-energy function","text":"beginequation\nF^j_ab(tau-tau) \n= -langle mathcalT d_a(tau) d^dagger_b(tau) n_j(tau) rangle\nendequation","category":"page"},{"location":"ch09/sig.html","page":"Improved estimator for the self-energy function","title":"Improved estimator for the self-energy function","text":"and F^j_ab(iomega_n) is its Fourier transform. The actual measurement formula is","category":"page"},{"location":"ch09/sig.html","page":"Improved estimator for the self-energy function","title":"Improved estimator for the self-energy function","text":"beginequation\nF^j_ab(tau - tau) = \n-frac1beta\nleftlangle\nsum_alphabeta = 1^k \nmathcalM_betaalphadelta^-(tau-tau tau^e_alpha - tau^s_beta)\nn_j(tau^s_beta)delta_aalphadelta_bbeta\nrightrangle\nendequation","category":"page"},{"location":"ch09/sig.html","page":"Improved estimator for the self-energy function","title":"Improved estimator for the self-energy function","text":"As one can see, this equation looks quite similar to the one for imaginary-time Green's function. Thus we use the same method to measure F^j_ab(tau - tau) and finally get the self-energy function via the first equation. Here, the matrix element n_j(tau^s_beta) (one or zero) denotes whether or not flavor j is occupied (whether or not a segment is present) at time tau^s_beta.","category":"page"},{"location":"ch09/sig.html","page":"Improved estimator for the self-energy function","title":"Improved estimator for the self-energy function","text":"This method can be combined with the orthogonal polynomial representation[4] as introduced in the previous subsection to suppress fluctuations and filter out the Monte Carlo noise. Using this technique, we can obtain the self-energy and vertex functions with unprecedented accuracy, which leads to an enhanced stability in the analytical continuations of those quantities[2]. In the iQIST software package, we only implemented the improved estimator for the self-energy function. Note that when the interaction matrix is frequency-dependent, the first equation should be modified slightly[1].","category":"page"},{"location":"ch09/sig.html","page":"Improved estimator for the self-energy function","title":"Improved estimator for the self-energy function","text":"Reference","category":"page"},{"location":"ch09/sig.html","page":"Improved estimator for the self-energy function","title":"Improved estimator for the self-energy function","text":"[1]: Hartmut Hafermann, Phys. Rev. B 89, 235128 (2014)","category":"page"},{"location":"ch09/sig.html","page":"Improved estimator for the self-energy function","title":"Improved estimator for the self-energy function","text":"[2]: Hartmut Hafermann, Kelly R. Patton, and Philipp Werner, Phys. Rev. B 85, 205106 (2012)","category":"page"},{"location":"ch09/sig.html","page":"Improved estimator for the self-energy function","title":"Improved estimator for the self-energy function","text":"[3]: Philipp Werner, Armin Comanac, Luca deâ Medici, Matthias Troyer, and Andrew J. Millis, Phys. Rev. Lett. 97, 076405 (2006)","category":"page"},{"location":"ch09/sig.html","page":"Improved estimator for the self-energy function","title":"Improved estimator for the self-energy function","text":"[4]: Lewin Boehnke, Hartmut Hafermann, Michel Ferrero, Frank Lechermann, and Olivier Parcollet, Phys. Rev. B 84, 075145 (2011)","category":"page"},{"location":"ch04/p_isspn.html#Parameter:-isspn","page":"isspn","title":"Parameter: isspn","text":"","category":"section"},{"location":"ch04/p_isspn.html","page":"isspn","title":"isspn","text":"Definition","category":"page"},{"location":"ch04/p_isspn.html","page":"isspn","title":"isspn","text":"Key control flag, determine the symmetry of spin orientation freedom of degree.","category":"page"},{"location":"ch04/p_isspn.html","page":"isspn","title":"isspn","text":"Type","category":"page"},{"location":"ch04/p_isspn.html","page":"isspn","title":"isspn","text":"Integer","category":"page"},{"location":"ch04/p_isspn.html","page":"isspn","title":"isspn","text":"Default value","category":"page"},{"location":"ch04/p_isspn.html","page":"isspn","title":"isspn","text":"1","category":"page"},{"location":"ch04/p_isspn.html","page":"isspn","title":"isspn","text":"Component","category":"page"},{"location":"ch04/p_isspn.html","page":"isspn","title":"isspn","text":"ALL","category":"page"},{"location":"ch04/p_isspn.html","page":"isspn","title":"isspn","text":"Behavior","category":"page"},{"location":"ch04/p_isspn.html","page":"isspn","title":"isspn","text":"There are two possible values for the isspn parameter so far:","category":"page"},{"location":"ch04/p_isspn.html","page":"isspn","title":"isspn","text":"isspn = 1, enforce spin up = spin down.\nisspn = 2, let spin up and spin down states evolve independently.","category":"page"},{"location":"ch04/p_isspn.html","page":"isspn","title":"isspn","text":"The quantum impurity solvers will symmetrize the relevant physical quantities according to the isspn parameter.","category":"page"},{"location":"ch04/p_isspn.html","page":"isspn","title":"isspn","text":"Comment","category":"page"},{"location":"ch04/p_isspn.html","page":"isspn","title":"isspn","text":"Usually, the isspn and issun are used at the same time to setup the magnetic order of the system. For example, if you want to simulate a model with anti-ferromagnetic order, then isspn should be 2, and issun can be 1 or 2 (a solver.eimp.in file must be available for the latter case).","category":"page"},{"location":"ch04/p_isspn.html","page":"isspn","title":"isspn","text":"See issun parameter for more details.","category":"page"},{"location":"ch04/p_isbin.html#Parameter:-isbin","page":"isbin","title":"Parameter: isbin","text":"","category":"section"},{"location":"ch04/p_isbin.html","page":"isbin","title":"isbin","text":"Definition","category":"page"},{"location":"ch04/p_isbin.html","page":"isbin","title":"isbin","text":"Key control flag. It is used to determine whether we need to enter the data binning mode. ","category":"page"},{"location":"ch04/p_isbin.html","page":"isbin","title":"isbin","text":"Type","category":"page"},{"location":"ch04/p_isbin.html","page":"isbin","title":"isbin","text":"Integer","category":"page"},{"location":"ch04/p_isbin.html","page":"isbin","title":"isbin","text":"Default value","category":"page"},{"location":"ch04/p_isbin.html","page":"isbin","title":"isbin","text":"1","category":"page"},{"location":"ch04/p_isbin.html","page":"isbin","title":"isbin","text":"Component","category":"page"},{"location":"ch04/p_isbin.html","page":"isbin","title":"isbin","text":"ALL","category":"page"},{"location":"ch04/p_isbin.html","page":"isbin","title":"isbin","text":"Behavior","category":"page"},{"location":"ch04/p_isbin.html","page":"isbin","title":"isbin","text":"There are two possible values for isbin parameter so far:","category":"page"},{"location":"ch04/p_isbin.html","page":"isbin","title":"isbin","text":"isbin = 1, normal mode.\nisbin = 2, data binning mode.","category":"page"},{"location":"ch04/p_isbin.html","page":"isbin","title":"isbin","text":"When the quantum impurity solver is in the data binning mode, the current iteration number (iter, it is a internal variable) will be fixed to 999, the nsweep and nwrite parameters will be increased by a factor of ten.","category":"page"},{"location":"ch04/p_isbin.html","page":"isbin","title":"isbin","text":"From the combinations of isscf and isbin parameters, we can reach the following four running modes:","category":"page"},{"location":"ch04/p_isbin.html","page":"isbin","title":"isbin","text":"A: isscf = 1, isbin = 1. The quantum impurity solver is called only once. No DMFT self-consistent calculation. No data binning mode.\nB: isscf = 2, isbin = 1. The quantum impurity solve is called periodically in the DMFT self-consistent calculation. Once the convergence is reached, the calculation will stop. No data binning mode.\nC: isscf = 1, isbin = 2. The quantum impurity solver is called only once in the data binning mode. No DMFT self-consistent calculation.\nD: isscf = 2, isbin = 2. The quantum impurity solves is called periodically in the DMFT self-consistent calculation. During the iterations, the quantum impurity solver is in normal mode. After the convergence is reached, the quantum impurity solver will be called once again. But at this time, the data binning mode is activated automatically.","category":"page"},{"location":"ch04/p_isbin.html","page":"isbin","title":"isbin","text":"(Image: mode image) Figure | The four running modes for quantum impurity solvers.","category":"page"},{"location":"ch04/p_isbin.html","page":"isbin","title":"isbin","text":"Please see the above figure for an intuitive view of the four running modes. If we want to perform DFT + DMFT calculations, mode A will be a good choice. Mode B is often used to solve model Hamiltonians iteratively and quickly to judge whether the results are reasonable. Once the results are reasonable and what we expect, and we want more accurate data, then we can use mode C. Mode D can be viewed as a combination of mode B and mode C, it is seldom used.","category":"page"},{"location":"ch04/p_isbin.html","page":"isbin","title":"isbin","text":"Comment","category":"page"},{"location":"ch04/p_isbin.html","page":"isbin","title":"isbin","text":"See isscf parameter for more details.","category":"page"},{"location":"ch04/p_itrun.html#Parameter:-itrun","page":"itrun","title":"Parameter: itrun","text":"","category":"section"},{"location":"ch04/p_itrun.html","page":"itrun","title":"itrun","text":"Definition","category":"page"},{"location":"ch04/p_itrun.html","page":"itrun","title":"itrun","text":"It is a control flag, used to control which scheme should be used to truncate the Hilbert space dynamically. ","category":"page"},{"location":"ch04/p_itrun.html","page":"itrun","title":"itrun","text":"Type","category":"page"},{"location":"ch04/p_itrun.html","page":"itrun","title":"itrun","text":"Integer","category":"page"},{"location":"ch04/p_itrun.html","page":"itrun","title":"itrun","text":"Default value","category":"page"},{"location":"ch04/p_itrun.html","page":"itrun","title":"itrun","text":"1","category":"page"},{"location":"ch04/p_itrun.html","page":"itrun","title":"itrun","text":"Component","category":"page"},{"location":"ch04/p_itrun.html","page":"itrun","title":"itrun","text":"Only for the MANJUSHAKA component.","category":"page"},{"location":"ch04/p_itrun.html","page":"itrun","title":"itrun","text":"Behavior","category":"page"},{"location":"ch04/p_itrun.html","page":"itrun","title":"itrun","text":"There are two possible values for itrun parameter so far:","category":"page"},{"location":"ch04/p_itrun.html","page":"itrun","title":"itrun","text":"itrun = 1, don't truncate it.\nitrun = 2, those atomic states with low probability (P_Gamma  10E  6) will be truncated for next DMFT iteration.","category":"page"},{"location":"ch04/p_itrun.html","page":"itrun","title":"itrun","text":"note: Note\nThe truncation according to the occupancy has been done in the JASMINE component. See Atomic eigenvalue problem solver for more details.","category":"page"},{"location":"ch04/p_itrun.html","page":"itrun","title":"itrun","text":"If the truncation is applied, the quantum impurity solvers will discard the un-selected atomic states which can improve the computational efficiency. On the other hand, the accuracy will be deteriorated. So it is a trade-off.","category":"page"},{"location":"ch04/p_itrun.html","page":"itrun","title":"itrun","text":"Comment","category":"page"},{"location":"ch04/p_itrun.html","page":"itrun","title":"itrun","text":"For 7-band system, sometimes it is essential to consider severe truncation. Or else the computational time is too long to be bearable.","category":"page"},{"location":"ch04/p_itrun.html","page":"itrun","title":"itrun","text":"This feature is experimental. BE CAREFULLY! Please check your calculated results carefully if you used the truncation approximation. To perform the truncation, the MANJUSHAKA will read the solver.prob.dat file at first to get the probability data. So if this file is not available, the truncation will not be done. ","category":"page"},{"location":"ch04/p_itrun.html","page":"itrun","title":"itrun","text":"To perform truncation over occupation number, you should use the JASMINE component to generate suitable atom.cix file.","category":"page"},{"location":"ch04/p_u.html#Parameter:-U","page":"U","title":"Parameter: U","text":"","category":"section"},{"location":"ch04/p_u.html","page":"U","title":"U","text":"Definition","category":"page"},{"location":"ch04/p_u.html","page":"U","title":"U","text":"Averaged Coulomb interaction U.","category":"page"},{"location":"ch04/p_u.html","page":"U","title":"U","text":"Type","category":"page"},{"location":"ch04/p_u.html","page":"U","title":"U","text":"Float, double precision","category":"page"},{"location":"ch04/p_u.html","page":"U","title":"U","text":"Default value","category":"page"},{"location":"ch04/p_u.html","page":"U","title":"U","text":"4.0","category":"page"},{"location":"ch04/p_u.html","page":"U","title":"U","text":"Component","category":"page"},{"location":"ch04/p_u.html","page":"U","title":"U","text":"ALL, except for DAISY component.","category":"page"},{"location":"ch04/p_u.html","page":"U","title":"U","text":"Behavior","category":"page"},{"location":"ch04/p_u.html","page":"U","title":"U","text":"Actually, it is not used by the quantum impurity solvers to build the Coulomb interaction matrix. It will be output by the impurity solver as a reference. You can set it to any values. I forgot why I had designed this parameter.","category":"page"},{"location":"ch04/p_u.html","page":"U","title":"U","text":"In the BEGONIA, LAVENDER, and CAMELLIA components, it is used as an internal variable. Any user-defined value will be overridden.","category":"page"},{"location":"ch04/p_u.html","page":"U","title":"U","text":"Comment","category":"page"},{"location":"ch04/p_u.html","page":"U","title":"U","text":"See also Uc, Uv, Jz, Js and Jp parameters for more details.","category":"page"},{"location":"ch02/python.html#Build-modules-for-Python","page":"Build modules for Python","title":"Build modules for Python","text":"","category":"section"},{"location":"ch02/python.html","page":"Build modules for Python","title":"Build modules for Python","text":"In the previous section, we introduce how to build Fortran library for a given component. In the section, we will introduce how to generate the required Python module.","category":"page"},{"location":"ch02/python.html","page":"Build modules for Python","title":"Build modules for Python","text":"note: Note\nIn order to generate the Python modules, the f2py package is of course necessary. Please check the following website for more details:www.f2py.com","category":"page"},{"location":"ch02/python.html","page":"Build modules for Python","title":"Build modules for Python","text":"Let's use the AZALEA component as example again.","category":"page"},{"location":"ch02/python.html","page":"Build modules for Python","title":"Build modules for Python","text":"Method 1:","category":"page"},{"location":"ch02/python.html","page":"Build modules for Python","title":"Build modules for Python","text":"$ cd iqist/build\n$ editor make.sys\n$ make base\n$ make capi\n$ make azalea-pylib","category":"page"},{"location":"ch02/python.html","page":"Build modules for Python","title":"Build modules for Python","text":"note: Note\nHere editor means any ascii text editor you prefer.\nazalea can be any other component's name, such as begonia, pansy, gardenia, etc.\nIf the base library and the application programming interfaces were already compiled successfully, then you can skip the following commands:$ make base\n$ make capi","category":"page"},{"location":"ch02/python.html","page":"Build modules for Python","title":"Build modules for Python","text":"After a few minutes, you will find pyiqist.so in the iqist/src/ctqmc/azalea directory. That is what you need, the Python module for the AZALEA component. Then you can add it to the system path, and do your great research.","category":"page"},{"location":"ch02/python.html","page":"Build modules for Python","title":"Build modules for Python","text":"Method 2:","category":"page"},{"location":"ch02/python.html","page":"Build modules for Python","title":"Build modules for Python","text":"In this approach, we go to the directory of the AZALEA component at first. Then 'make' it as usual.","category":"page"},{"location":"ch02/python.html","page":"Build modules for Python","title":"Build modules for Python","text":"$ cd iqist/src/ctqmc/azalea\n$ make pylib","category":"page"},{"location":"ch02/python.html","page":"Build modules for Python","title":"Build modules for Python","text":"Here, we assume that the compiling system was correctly configured, the base library and the application programming interfaces were already compiled successfully.","category":"page"},{"location":"ch04/out_diag.html#solver.diag.dat","page":"solver.diag.dat","title":"solver.diag.dat","text":"","category":"section"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":"Introduction","category":"page"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":"The solver.diag.dat file is used to store the diagram configurations of the perturbation expansion series. Owing to the limitation of disk capacity and computational efficiency, it is impossible to save all of the visited diagram configurations. Consequently we only save the current diagram configurations every nwrite Monte Carlo step. Namely, the frequency for writing diagram configurations is controlled by the nwrite parameter. See also nwrite for more details.","category":"page"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":"note: Note\nBesides the DAISY component, the other CT-HYB impurity solvers can output the solver.diag.dat file.","category":"page"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":"Format","category":"page"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":"The solver.diag.dat file consists many blocks. The blocks are separated by two blank lines. A typical block looks like as follows:","category":"page"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":">> cur_iter:   1 tot_iter:  20\n>> cur_diag:   4 tot_diag:1000\n# flvr:   1 rank:   2\n   1      6.49617550      0.35585709\n   1      7.30348648      7.28301304\n# flvr:   2 rank:   1\n   2      0.43805150      6.89040598","category":"page"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":"Here cur_iter means current iteration number, tot_iter the total iteration number, cur_diag the index of the current diagram configuration, tot_diag the total number of diagram configurations. Actually, we have","category":"page"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":"texttot_diag = fractextnsweeptextnwrite","category":"page"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":"Next, the positions for creator/destroy operators are given for all orbitals (flavors).","category":"page"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":"","category":"page"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":"column 1: the index of orbitals.","category":"page"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":"column 2: tau_s, the imaginary-time points for creator operators","category":"page"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":"column 3: tau_e, the imaginary-time points for destroy operators","category":"page"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":"","category":"page"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":"We can utilize the data in the solver.diag.dat file to produce animation movie. A block can be used to generate one frame in the movie.","category":"page"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":"Code","category":"page"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":"The corresponding Fortran code block for the writing of solver.diag.dat file is as follows:","category":"page"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":"! write the snapshot\n! open data file: solver.diag.dat\n     open(mytmp, file='solver.diag.dat', form='formatted', status='unknown', position='append')\n\n! write diagram info\n     write(mytmp,'(2(a,i4))') '>> cur_iter:', iter, ' tot_iter:', niter\n     write(mytmp,'(2(a,i4))') '>> cur_diag:', cstep/nwrite, ' tot_diag:', nsweep/nwrite\n\n! write the position of operators\n     do i=1,norbs\n         write(mytmp,'(2(a,i4))') '# flvr:', i, ' rank:', rank(i)\n         do j=1,rank(i)\n             write(mytmp,'(i4,2f16.8)') i, time_s( index_s(j, i), i ), time_e( index_e(j, i), i )\n         enddo ! over j={1,rank(i)} loop\n     enddo ! over i={1,norbs} loop\n\n! write two blank lines\n     write(mytmp,*)\n     write(mytmp,*)\n\n! close data file\n     close(mytmp)","category":"page"},{"location":"ch04/out_diag.html","page":"solver.diag.dat","title":"solver.diag.dat","text":"You can use the u_animator.py to visualize the diagram configurations in the solver.diag.dat file. See also script/u_animator.py for more details.","category":"page"},{"location":"ch04/p_jz.html#Parameter:-Jz","page":"Jz","title":"Parameter: Jz","text":"","category":"section"},{"location":"ch04/p_jz.html","page":"Jz","title":"Jz","text":"Definition","category":"page"},{"location":"ch04/p_jz.html","page":"Jz","title":"Jz","text":"Coupling constant for the Hund's exchange interaction in z axis, J_z.","category":"page"},{"location":"ch04/p_jz.html","page":"Jz","title":"Jz","text":"Type:","category":"page"},{"location":"ch04/p_jz.html","page":"Jz","title":"Jz","text":"Float, double precision","category":"page"},{"location":"ch04/p_jz.html","page":"Jz","title":"Jz","text":"Default value","category":"page"},{"location":"ch04/p_jz.html","page":"Jz","title":"Jz","text":"0.0","category":"page"},{"location":"ch04/p_jz.html","page":"Jz","title":"Jz","text":"Component","category":"page"},{"location":"ch04/p_jz.html","page":"Jz","title":"Jz","text":"ALL","category":"page"},{"location":"ch04/p_jz.html","page":"Jz","title":"Jz","text":"Behavior","category":"page"},{"location":"ch04/p_jz.html","page":"Jz","title":"Jz","text":"It is used to determine the Coulomb interaction matrix.","category":"page"},{"location":"ch04/p_jz.html","page":"Jz","title":"Jz","text":"Comment","category":"page"},{"location":"ch04/p_jz.html","page":"Jz","title":"Jz","text":"Actually, only the AZALEA, GARDENIA, NARCISSUS, and DAISY components need it. For the other quantum impurity solvers components (i.e., the CAMELLIA, BEGONIA, LAVENDER, MANJUSHAKA and PANSY components), the information about the Coulomb interaction matrix is imported via the atom.cix file. So you can set it to any values for the latter five components.","category":"page"},{"location":"ch04/p_jz.html","page":"Jz","title":"Jz","text":"Usually, the U_c, U_v and J_z should satisfy the following relation:","category":"page"},{"location":"ch04/p_jz.html","page":"Jz","title":"Jz","text":"beginequation\nU_c = U_v - 2J_z\nendequation","category":"page"},{"location":"ch04/p_jz.html","page":"Jz","title":"Jz","text":"See also Uc, Uv parameters for more details.","category":"page"},{"location":"ch04/p_jz.html","page":"Jz","title":"Jz","text":"Usually, J_z = J_s = J_p = J. As for a single-band model, they are zero. See also Js, Jp parameters for more details.","category":"page"},{"location":"ch04/p_jz.html","page":"Jz","title":"Jz","text":"note: Note\nFor the AZALEA, GARDENIA, NARCISSUS components, the Coulomb interaction matrix can be imported via the solver.umat.in file which has the highest priority. See solver.umat.in for more details.","category":"page"},{"location":"ch04/p_ncarlo.html#Parameter:-ncarlo","page":"ncarlo","title":"Parameter: ncarlo","text":"","category":"section"},{"location":"ch04/p_ncarlo.html","page":"ncarlo","title":"ncarlo","text":"Definition","category":"page"},{"location":"ch04/p_ncarlo.html","page":"ncarlo","title":"ncarlo","text":"How often to measure the physical observables.","category":"page"},{"location":"ch04/p_ncarlo.html","page":"ncarlo","title":"ncarlo","text":"Type","category":"page"},{"location":"ch04/p_ncarlo.html","page":"ncarlo","title":"ncarlo","text":"Integer","category":"page"},{"location":"ch04/p_ncarlo.html","page":"ncarlo","title":"ncarlo","text":"Default value","category":"page"},{"location":"ch04/p_ncarlo.html","page":"ncarlo","title":"ncarlo","text":"10","category":"page"},{"location":"ch04/p_ncarlo.html","page":"ncarlo","title":"ncarlo","text":"Component","category":"page"},{"location":"ch04/p_ncarlo.html","page":"ncarlo","title":"ncarlo","text":"All","category":"page"},{"location":"ch04/p_ncarlo.html","page":"ncarlo","title":"ncarlo","text":"Behavior","category":"page"},{"location":"ch04/p_ncarlo.html","page":"ncarlo","title":"ncarlo","text":"Every ncarlo Monte Carlo sampling steps, the quantum impurity solvers try to measure the physical observables. The affected physical observables are as follows:","category":"page"},{"location":"ch04/p_ncarlo.html","page":"ncarlo","title":"ncarlo","text":"Atomic state probability, P_Gamma,\nImaginary-time Green's function, G(tau),\nAuxiliary imaginary-time correlation function, F(tau).","category":"page"},{"location":"ch04/p_ncarlo.html","page":"ncarlo","title":"ncarlo","text":"The measuring period for the other physical observables are controlled by the nmonte parameter. See also nmonte parameter for more details.","category":"page"},{"location":"ch04/p_ncarlo.html","page":"ncarlo","title":"ncarlo","text":"note: Note\nThe histogram for the perturbation expansion series is measured in each Monte Carlo sampling step.","category":"page"},{"location":"ch04/p_ncarlo.html","page":"ncarlo","title":"ncarlo","text":"Comment","category":"page"},{"location":"ch04/p_ncarlo.html","page":"ncarlo","title":"ncarlo","text":"You can increase ncarlo to relieve the auto-correlation of physical observables between two successive measurements. However, large ncarlo will waste the CPU times. What's the best choices? We guess a good ncarlo should satisfy the following relation:","category":"page"},{"location":"ch04/p_ncarlo.html","page":"ncarlo","title":"ncarlo","text":"textncarlo * textP_textinsert = 10","category":"page"},{"location":"ch04/p_ncarlo.html","page":"ncarlo","title":"ncarlo","text":"Here, textP_textinsert means the accepted ratio for the insert update actions.","category":"page"},{"location":"ch08/complex.html#Advanced-applications-I:-Complex-systems","page":"README","title":"Advanced applications I: Complex systems","text":"","category":"section"},{"location":"ch08/complex.html","page":"README","title":"README","text":"In the first section, we demonstrate the basic usages of the CT-HYB quantum impurity solvers in the iQIST software package. Now we think that you already know how to solve the single-band Hubbard model. That's great. However, in most instances the realistic models are much more complex than the single-band Hubbard model. For example, the interaction terms are rotationally invariant, instead of density-density type. The interaction could even be frequency-dependent. The orbital degeneracy may be broken by the spin-orbital coupling, crystal field splitting, and magnetic etc. The iQIST software package can deal with these issues quite well. In this section, we will teach you how to solve the above problems.","category":"page"},{"location":"ch08/complex.html","page":"README","title":"README","text":"General Coulomb interaction\nSpin-orbital coupling\nCrystal field splitting\nRetarded interaction and dynamical screening effect","category":"page"},{"location":"ch04/p_mstep.html#Parameter:-mstep","page":"mstep","title":"Parameter: mstep","text":"","category":"section"},{"location":"ch04/p_mstep.html","page":"mstep","title":"mstep","text":"Definition","category":"page"},{"location":"ch04/p_mstep.html","page":"mstep","title":"mstep","text":"We can use the delayed Green's function updating algorithm[1] to accelerate the Hirsch-Fye quantum Monte Carlo impurity solver (the DAISY component in the iQIST software package). Here, the mstep parameter denotes the maximum number of delayed update steps which is the key control parameter for this algorithm.","category":"page"},{"location":"ch04/p_mstep.html","page":"mstep","title":"mstep","text":"Type","category":"page"},{"location":"ch04/p_mstep.html","page":"mstep","title":"mstep","text":"Integer","category":"page"},{"location":"ch04/p_mstep.html","page":"mstep","title":"mstep","text":"Default value","category":"page"},{"location":"ch04/p_mstep.html","page":"mstep","title":"mstep","text":"16","category":"page"},{"location":"ch04/p_mstep.html","page":"mstep","title":"mstep","text":"Component","category":"page"},{"location":"ch04/p_mstep.html","page":"mstep","title":"mstep","text":"Only for the DAISY component.","category":"page"},{"location":"ch04/p_mstep.html","page":"mstep","title":"mstep","text":"Behavior","category":"page"},{"location":"ch04/p_mstep.html","page":"mstep","title":"mstep","text":"There are two possible choices for mstep parameter so far:","category":"page"},{"location":"ch04/p_mstep.html","page":"mstep","title":"mstep","text":"mstep = 1, using traditional update algorithm, low efficiency.\nmstep > 1, using delayed update algorithm to improve the computational efficiency.","category":"page"},{"location":"ch04/p_mstep.html","page":"mstep","title":"mstep","text":"Comment","category":"page"},{"location":"ch04/p_mstep.html","page":"mstep","title":"mstep","text":"mstep = 16 is an optimal choice. Do not change it rashly.","category":"page"},{"location":"ch04/p_mstep.html","page":"mstep","title":"mstep","text":"Reference","category":"page"},{"location":"ch04/p_mstep.html","page":"mstep","title":"mstep","text":"[1]: Phani K. V. V. Nukala, Thomas A. Maier, Michael S. Summers, Gonzalo Alvarez, and Thomas C. Schulthess, Phys. Rev. B 80, 195111 (2009)","category":"page"},{"location":"ch01/motivation.html#Motivation","page":"Motivation","title":"Motivation","text":"","category":"section"},{"location":"ch01/motivation.html#DMFT","page":"Motivation","title":"DMFT","text":"","category":"section"},{"location":"ch01/motivation.html","page":"Motivation","title":"Motivation","text":"Dynamical mean-field theory (DMFT) and its extensions play a very important role in contemporary studies of correlated electron systems. The broad applications of this technique range from the study of Mott transitions, unconventional superconductivity in Cu- and Fe-based superconductors, and non-Fermi liquid behaviors, to the investigation of anomalous transport properties of transition metal oxides. For many of these applications, DMFT is the currently most powerful and reliable (sometimes the only) technique available and has in many cases produced new physical insights. Furthermore, the combination of ab initio calculation method (such as density functional theory) with DMFT allows to compute the subtle electronic properties of realistic correlated materials, including partially filled 3d- and 4d-electron transition metal oxides, where lattice, spin and orbital degrees of freedom all coupled.","category":"page"},{"location":"ch01/motivation.html","page":"Motivation","title":"Motivation","text":"(Image: dmft image)","category":"page"},{"location":"ch01/motivation.html","page":"Motivation","title":"Motivation","text":"Figure | The hierarchical structure of DMFT and its extensions. The iQIST software package can be used as a computational engine of them.","category":"page"},{"location":"ch01/motivation.html","page":"Motivation","title":"Motivation","text":"(Image: dft_dmft_type image)","category":"page"},{"location":"ch01/motivation.html","page":"Motivation","title":"Motivation","text":"Figure | The hierarchical structure of DFT + DMFT and its extensions. The iQIST software package can be used as a computational engine of them.","category":"page"},{"location":"ch01/motivation.html#Quantum-impurity-solvers","page":"Motivation","title":"Quantum impurity solvers","text":"","category":"section"},{"location":"ch01/motivation.html","page":"Motivation","title":"Motivation","text":"The key idea of DMFT is to map the original correlated lattice model into a quantum impurity model whose mean-field bath is determined self-consistently. Thus, the central task of a DMFT simulation becomes the numerical solution of the quantum impurity problem. During the past several decades, many methods have been tested as impurity solvers, including the exact diagonalization (ED), equation of motion (EOM), Hubbard-I approximation (HIA), iterative perturbation theory (IPT), non-crossing approximation (NCA), fluctuation-exchange approximation (FLEX), and quantum Monte Carlo (QMC). Among the methods listed above, the QMC method has several very important advantages, which makes it so far the most flexible and widely used impurity solver. First, it is based on the imaginary time action, in which the infinite bath has been integrated out. Second, it can treat arbitrary couplings, and can thus be applied to all kinds of phases including the metallic phase, insulating state, and phases with spontaneous symmetry breaking. Third, the QMC method is numerically exact with a controllable numerical error. In other words, by increasing the computational effort the numerical error of the QMC simulation can be systematically reduced. For these reasons, the QMC algorithm is considered as the method of choice for many applications.","category":"page"},{"location":"ch01/motivation.html","page":"Motivation","title":"Motivation","text":"(Image: lattice image)","category":"page"},{"location":"ch01/motivation.html","page":"Motivation","title":"Motivation","text":"Figure | A schematic diagram of the key idea of DMFT.","category":"page"},{"location":"ch01/motivation.html","page":"Motivation","title":"Motivation","text":"(Image: scf_dmft image)","category":"page"},{"location":"ch01/motivation.html","page":"Motivation","title":"Motivation","text":"Figure | A schematic diagram of the self-consistent iteration of DMFT. Actually, the role played by the iQIST software package is the quantum impurity solver.","category":"page"},{"location":"ch01/motivation.html#CT-QMC-impurity-solvers","page":"Motivation","title":"CT-QMC impurity solvers","text":"","category":"section"},{"location":"ch01/motivation.html","page":"Motivation","title":"Motivation","text":"Several QMC impurity solvers have been developed in the past three decades. An important innovation was the Hirsch-Fye QMC (HF-QMC) impurity solver, in which the time axis is divided into small time steps and the interaction term in the Hamiltonian is decoupled on each time step by means of a discrete Hubbard-Stratonovich auxiliary field. HF-QMC has been widely used in the early studies of DMFT, but is limited by the discretization on the time axis and also by the form of the electronic interactions (usually only density-density interactions can be treated). Recently, a new class of more powerful and versatile QMC impurity solvers, continuous-time quantum Monte Carlo (CT-QMC) algorithms, have been invented. In the CT-QMC impurity solvers, the partition function of the quantum impurity problem is diagrammatically expanded, and then the diagrammatic expansion series is evaluated by stochastic Monte Carlo sampling. The continuous-time nature of the algorithm means that operators can be placed at any arbitrary position on the imaginary time interval, so that time discretization errors can be completely avoided. Depending on how the diagrammatic expansion is performed, the CT-QMC approach can be further divided into interaction expansion (or weak coupling) CT-QMC (CT-INT), auxiliary field CT-QMC (CT-AUX), and hybridization expansion (or strong coupling) CT-QMC (CT-HYB).","category":"page"},{"location":"ch01/motivation.html#CT-HYB-impurity-solvers","page":"Motivation","title":"CT-HYB impurity solvers","text":"","category":"section"},{"location":"ch01/motivation.html","page":"Motivation","title":"Motivation","text":"At present, the CT-HYB is the most popular and powerful impurity solver, since it can be used to solve multi-orbital impurity model with general interactions at low temperature. In single-site DMFT calculations, the computational efficiency of CT-HYB is much higher than that of CT-INT and HF-QMC, especially when the interactions are strong. However, in order to solve more complicated quantum impurity models (for example, five-band or seven-band impurity model with general interactions and spin-orbital coupling) efficiently, further improvements of the CT-HYB impurity solvers are needed. In recent years many tricks and algorithms have been developed to increase the efficiency and accuracy of original CT-HYB impurity solver, such as the truncation approximation, Krylov subspace iteration, orthogonal polynomial representation, PS quantum number, lazy trace evaluation, and skip listing method, and matrix product state implementation, etc. ","category":"page"},{"location":"ch01/motivation.html#The-iQIST-software-package","page":"Motivation","title":"The iQIST software package","text":"","category":"section"},{"location":"ch01/motivation.html","page":"Motivation","title":"Motivation","text":"As the state-of-the-art CT-HYB impurity solvers become more and more sophisticated and specialized, it is not easy anymore to master all their facets and build ones implementations from scratch. Hence, we believe that it is a good time to provide a CT-HYB software package for the DMFT community such that researchers can focus more on the physical questions, instead of spending much time on (re-)implementing efficient codes. In fact, there are some valuable efforts in this direction, such as TRIQS, ALPS, w2dynamics, Haule's DMFT_W2K codes, etc. However, a flexible, extensible, and highly efficient CT-HYB impurity solver is still lacking. The purpose of this reference manual is to present our solution â the open source software package iQIST â which contains several well-implemented and thoroughly tested modern CT-HYB impurity solvers, and the corresponding pre- and post-processing tools. Originally the iQIST software package was internally used in our group. Now we release it publicly and hope that the whole community will benefit from it.","category":"page"},{"location":"ch06/in_atom.html#atom.config.in","page":"atom.config.in","title":"atom.config.in","text":"","category":"section"},{"location":"ch06/in_atom.html","page":"atom.config.in","title":"atom.config.in","text":"Introduction","category":"page"},{"location":"ch06/in_atom.html","page":"atom.config.in","title":"atom.config.in","text":"The main configuration file for the atomic eigenvalue problem solver in the iQIST software package is the atom.config.in file. ","category":"page"},{"location":"ch06/in_atom.html","page":"atom.config.in","title":"atom.config.in","text":"Just like the CT-QMC/HF-QMC quantum impurity solvers, since all of the input parameters have default values, the atomic eigenvalue problem solver can run without any input files. But if you want to use it to solve a specific problem, a well-prepared atom.config.in file is of course necessary.","category":"page"},{"location":"ch06/in_atom.html","page":"atom.config.in","title":"atom.config.in","text":"Format","category":"page"},{"location":"ch06/in_atom.html","page":"atom.config.in","title":"atom.config.in","text":"The atom.config.in file share the same format with the solver.ctqmc.in and solver.hfqmc.in files. In other words, it adopts the simple \"key-value\" style. See solver.ctqmc.in and solver.hfqmc.in for more details.","category":"page"},{"location":"ch06/in_atom.html","page":"atom.config.in","title":"atom.config.in","text":"Code","category":"page"},{"location":"ch06/in_atom.html","page":"atom.config.in","title":"atom.config.in","text":"N/A","category":"page"},{"location":"ch06/p_norbs.html#Parameter:-norbs","page":"norbs","title":"Parameter: norbs","text":"","category":"section"},{"location":"ch06/p_norbs.html","page":"norbs","title":"norbs","text":"Definition","category":"page"},{"location":"ch06/p_norbs.html","page":"norbs","title":"norbs","text":"Number of correlated orbitals.","category":"page"},{"location":"ch06/p_norbs.html","page":"norbs","title":"norbs","text":"Type","category":"page"},{"location":"ch06/p_norbs.html","page":"norbs","title":"norbs","text":"Integer","category":"page"},{"location":"ch06/p_norbs.html","page":"norbs","title":"norbs","text":"Default value","category":"page"},{"location":"ch06/p_norbs.html","page":"norbs","title":"norbs","text":"2","category":"page"},{"location":"ch06/p_norbs.html","page":"norbs","title":"norbs","text":"Component","category":"page"},{"location":"ch06/p_norbs.html","page":"norbs","title":"norbs","text":"Only for the JASMINE component.","category":"page"},{"location":"ch06/p_norbs.html","page":"norbs","title":"norbs","text":"Behavior","category":"page"},{"location":"ch06/p_norbs.html","page":"norbs","title":"norbs","text":"Determine the size of involved arrays.","category":"page"},{"location":"ch06/p_norbs.html","page":"norbs","title":"norbs","text":"Comment:","category":"page"},{"location":"ch06/p_norbs.html","page":"norbs","title":"norbs","text":"The following relations always hold:","category":"page"},{"location":"ch06/p_norbs.html","page":"norbs","title":"norbs","text":"textnorbs = textnpsin * textnband","category":"page"},{"location":"ch06/p_norbs.html","page":"norbs","title":"norbs","text":"textncfgs = 2^textnorbs","category":"page"},{"location":"ch06/p_norbs.html","page":"norbs","title":"norbs","text":"You have to ensure the value of norbs is compatible with nband, nspin and ncfgs. The JASMINE component will not check and correct them automatically. See also nspin, nband, and ncfgs parameters for more details.","category":"page"},{"location":"ch07/reader.html#script/u_reader.py","page":"script/u_reader.py","title":"script/u_reader.py","text":"","category":"section"},{"location":"ch07/reader.html","page":"script/u_reader.py","title":"script/u_reader.py","text":"Introduction","category":"page"},{"location":"ch07/reader.html","page":"script/u_reader.py","title":"script/u_reader.py","text":"The purpose of this script is provide an easy-to-use interface to read in and analyze the output data of the quantum impurity solver components.","category":"page"},{"location":"ch07/reader.html","page":"script/u_reader.py","title":"script/u_reader.py","text":"Type","category":"page"},{"location":"ch07/reader.html","page":"script/u_reader.py","title":"script/u_reader.py","text":"Python module","category":"page"},{"location":"ch07/reader.html","page":"script/u_reader.py","title":"script/u_reader.py","text":"APIs","category":"page"},{"location":"ch07/reader.html","page":"script/u_reader.py","title":"script/u_reader.py","text":"class iqistReader(object):\n    \"\"\" This class provide a few static methods which are used to extract\n        the data from the ouput files of ctqmc impurity solvers and hfqmc\n        impurity solver.\n    \"\"\"\n\n    @staticmethod\n    def get_green(norbs, ntime, fileName = None):\n        \"\"\" try to read the solver.green.dat or solver.green.bin.nnn file\n            to return the imaginary time Green's function G(\\tau) data\n        \"\"\"\n\n    @staticmethod\n    def get_grn(norbs, mfreq, fileName = None):\n        \"\"\" try to read the solver.grn.dat file to return the matsubara\n            Green's function G(i\\omega) data\n        \"\"\"\n\n    @staticmethod\n    def get_weiss(norbs, ntime, fileName = None):\n        \"\"\" try to read the solver.weiss.dat file to return the imaginary\n            time Weiss's function \\mathcal{G}(\\tau) data\n        \"\"\"\n\n    @staticmethod\n    def get_wss(norbs, mfreq, fileName = None):\n        \"\"\" try to read the solver.wss.dat file to return the matsubara\n            Weiss's function \\mathcal{G}(i\\omega) data\n        \"\"\"\n\n    @staticmethod\n    def get_hybri(norbs, ntime, fileName = None):\n        \"\"\" try to read the solver.hybri.dat file to return the imaginary\n            time hybridization function \\Delta(\\tau) data\n        \"\"\"\n\n    @staticmethod\n    def get_hyb(norbs, mfreq, fileName = None):\n        \"\"\" try to read the solver.hyb.dat file to return the matsubara\n            hybridization function \\Delta(i\\omega) data\n        \"\"\"\n\n    @staticmethod\n    def get_sgm(norbs, mfreq, fileName = None):\n        \"\"\" try to read the solver.sgm.dat file to return the matsubara\n            self-energy function \\Sigma(i\\omega) data\n        \"\"\"\n\n    @staticmethod\n    def get_hub(norbs, mfreq, fileName = None):\n        \"\"\" try to read the solver.hub.dat file to return the matsubara\n            Hubbard-I self-energy function \\Sigma_{hub}(i\\omega) data and\n            Green's function data\n        \"\"\"\n\n    @staticmethod\n    def get_hist(mkink, fileName = None):\n        \"\"\" try to read the solver.hist.dat file to return the histogram\n            data for diagrammatic perturbation expansion\n        \"\"\"\n\n    @staticmethod\n    def get_prob(ncfgs, nsect = 0, fileName = None):\n        \"\"\" try to read the solver.prob.dat file to return the atomic\n            state probability P_{\\Gamma} data\n        \"\"\"\n\n    @staticmethod\n    def get_nmat(norbs, fileName = None):\n        \"\"\" try to read the solver.nmat.dat file to return the occupation\n            number < N_i > and double occupation number < N_i N_j > data\n        \"\"\"\n\n    @staticmethod\n    def get_kmat(norbs, fileName = None):\n        \"\"\" try to read the solver.kmat.dat file to return the required\n            perturbation order data: < k > and < k^2 >\n        \"\"\"\n\n    @staticmethod\n    def get_lmat(norbs, fileName = None):\n        \"\"\" try to read the solver.lmat.dat file to return the fidelity\n            susceptibility data: < k_l >, < k_r >, and < k_l k_r >\n        \"\"\"\n\n    @staticmethod\n    def get_schi(nband, ntime, fileName = None):\n        \"\"\" try to read the solver.schi.dat file to return the spin-spin\n            correlation function < S_z(0) S_z(\\tau) > data\n        \"\"\"\n\n    @staticmethod\n    def get_sfom(nband, nbfrq, fileName = None):\n        \"\"\" try to read the solver.sfom.dat file to return the spin-spin\n            correlation function data\n        \"\"\"\n\n    @staticmethod\n    def get_ochi(norbs, ntime, fileName = None):\n        \"\"\" try to read the solver.ochi.dat file to return the orbital-\n            orbital correlation function < N_i(0) N_j(\\tau) > data\n        \"\"\"\n\n    @staticmethod\n    def get_ofom(norbs, nbfrq, fileName = None):\n        \"\"\" try to read the solver.ofom.dat file to return the orbital-\n            orbital correlation function data\n        \"\"\"\n\n    @staticmethod\n    def get_twop(norbs, nffrq, nbfrq, fileName = None):\n        \"\"\" try to read the solver.twop.dat file to return the two-particle\n            Green's function data\n        \"\"\"\n\n    @staticmethod\n    def get_vrtx(norbs, nffrq, nbfrq, fileName = None):\n        \"\"\" try to read the solver.vrtx.dat file to return the two-particle\n            Green's function data\n        \"\"\"\n\n    @staticmethod\n    def get_pair(norbs, nffrq, nbfrq, fileName = None):\n        \"\"\" try to read the solver.pair.dat file to return the pair\n            susceptibility data\n        \"\"\"\n\n    @staticmethod\n    def get_kernel(ntime, fileName = None):\n        \"\"\" try to read the solver.kernel.dat file to return the screening\n            function K(\\tau) and its first derivates\n        \"\"\"","category":"page"},{"location":"ch07/reader.html","page":"script/u_reader.py","title":"script/u_reader.py","text":"Examples","category":"page"},{"location":"ch07/reader.html","page":"script/u_reader.py","title":"script/u_reader.py","text":"# import this module\nfrom u_reader import *\n\n# setup parameters\nnorbs = 2\nntime = 1024\nmfreq = 8193\n\n# read the data\n(tmesh, gtau) = iqistReader.get_green(norbs, ntime)\n(tmesh, gbin) = iqistReader.get_green(norbs, ntime, \"solver.green.bin.10\")\n(rmesh, grnf) = iqistReader.get_grn(norbs, mfreq)","category":"page"},{"location":"ch07/reader.html","page":"script/u_reader.py","title":"script/u_reader.py","text":"note: Note\nYou can not execute u_reader.py in the terminal or Python environment directly, like this:$ python u_reader.py","category":"page"},{"location":"ch07/reader.html","page":"script/u_reader.py","title":"script/u_reader.py","text":"Comment","category":"page"},{"location":"ch07/reader.html","page":"script/u_reader.py","title":"script/u_reader.py","text":"N/A","category":"page"},{"location":"ch06/out_fock.html#atom.fock.dat","page":"atom.fock.dat","title":"atom.fock.dat","text":"","category":"section"},{"location":"ch06/out_fock.html","page":"atom.fock.dat","title":"atom.fock.dat","text":"Introduction","category":"page"},{"location":"ch06/out_fock.html","page":"atom.fock.dat","title":"atom.fock.dat","text":"The atom.fock.dat file contains the information about the Fock basis (occupation number basis).","category":"page"},{"location":"ch06/out_fock.html","page":"atom.fock.dat","title":"atom.fock.dat","text":"Format","category":"page"},{"location":"ch06/out_fock.html","page":"atom.fock.dat","title":"atom.fock.dat","text":"The format of the atom.fock.dat file is as follows:","category":"page"},{"location":"ch06/out_fock.html","page":"atom.fock.dat","title":"atom.fock.dat","text":"","category":"page"},{"location":"ch06/out_fock.html","page":"atom.fock.dat","title":"atom.fock.dat","text":"column 1: unified index i, integer","category":"page"},{"location":"ch06/out_fock.html","page":"atom.fock.dat","title":"atom.fock.dat","text":"column 2: decimal number, integer","category":"page"},{"location":"ch06/out_fock.html","page":"atom.fock.dat","title":"atom.fock.dat","text":"column 3: index of the Fock state, integer","category":"page"},{"location":"ch06/out_fock.html","page":"atom.fock.dat","title":"atom.fock.dat","text":"column 4: binary representation of the Fock state, integer vector","category":"page"},{"location":"ch06/out_fock.html","page":"atom.fock.dat","title":"atom.fock.dat","text":"","category":"page"},{"location":"ch06/out_fock.html","page":"atom.fock.dat","title":"atom.fock.dat","text":"Code","category":"page"},{"location":"ch06/out_fock.html","page":"atom.fock.dat","title":"atom.fock.dat","text":"The corresponding Fortran code block for the writing of the atom.fock.dat file is as follows:","category":"page"},{"location":"ch06/out_fock.html","page":"atom.fock.dat","title":"atom.fock.dat","text":"! open file atom.fock.dat to write\n     open(mytmp, file='atom.fock.dat', form='formatted', status='unknown')\n\n! write the header\n     write(mytmp,'(75a1)') dash ! dashed line\n     write(mytmp,'(a)') '# i | decimal | index | binary'\n     write(mytmp,'(75a1)') dash ! dashed line\n\n! write the data\n     do i=1,ncfgs\n         write(mytmp,'(i6)',advance='no') i\n         write(mytmp,'(i6)',advance='no') dec_basis(i)\n         write(mytmp,'(i6)',advance='no') ind_basis(dec_basis(i))\n         write(mytmp,'(4X,14i1)') bin_basis(:,i)\n     enddo ! over i={1,ncfgs} loop\n\n! close data file\n     close(mytmp)","category":"page"},{"location":"ch03/config.html#Configure-your-system","page":"Configure your system","title":"Configure your system","text":"","category":"section"},{"location":"ch03/config.html","page":"Configure your system","title":"Configure your system","text":"Please add the directory which includes the executable programs of iQIST software package to your system path. Usually, you can modify the .bashrc file in your home directory to reach this goal:","category":"page"},{"location":"ch03/config.html","page":"Configure your system","title":"Configure your system","text":"export PATH=iqist/build:$PATH","category":"page"},{"location":"ch03/config.html","page":"Configure your system","title":"Configure your system","text":"If you don't know how to modify the system environment variables, please consult your system administrator at first.","category":"page"},{"location":"ch08/general.html#General-Coulomb-interaction","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"","category":"section"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"info: Info\nThis tutorial will take you about five hours.","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"Introduction","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"In this tutorial, we will show you how to use the iQIST software package to solve a two-band Hubbard with rotationally invariant Coulomb interaction.","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"The interaction term of the Hubbard model are as follows:","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"beginalign\nhatH_textloc = - mu sum_alphasigman_alphasigma + Usum_alpha n_alphauparrown_alphadownarrow \n     + U^prime sum_alpha  gamma sigma n_alphasigman_gammabarsigma\n    + (U^prime - J) sum_alpha  gamma sigma n_alphasigman_gammasigma \n     - J sum_alpha neq gamma (d^dagger_alphadownarrowd^dagger_gammauparrowd_gammadownarrowd_alphauparrow + d^dagger_gammauparrowd^dagger_gammadownarrowd_alphauparrowd_alphadownarrow + hc)\nendalign","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"Here alpha and gamma are the orbital indices, sigma the spin index, mu the chemical potential, U (U^prime) the intra-orbital (inter-orbital) Coulomb interaction, and J the Hund's exchange interaction. Unless otherwise specified, mu is chosen to meet the half-filling condition. The U (U^prime) and J parameters fulfill the relation U^prime = U - 2J. In this tutorial, a semicircular density of states with half bandwidth D = 2t is used, which corresponds to the infinite-dimensional Bethe lattice. We solve the Hubbard model using single-site DMFT with a state-of-the-art CT-HYB quantum Monte Carlo impurity solver.","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"The model parameters are as follows:","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"U_c = 4.0\nU_v = 2.0\nJ_z = 1.0\nJ_s = 1.0\nJ_p = 1.0\nmu = 3.50","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"Recipes","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"Next we just follow the procedures described in the iQIST recipes section.","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"(1) Choose suitable component","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"Since the local Hamiltonian contain the spin-flip and pair-hopping terms, it is not diagonal under the occupation number basis. So the segment representation algorithm is not valid in this case. We have to use the general matrix version of CT-HYB quantum impurity solvers. In this tutorial, we choose the BEGONIA component to solve it. Of course, the LAVENDER, PANSY, MANJUSHAKA, and CAMELLIA components are also applicable.","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"(2) Design the programs and scripts","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"Since the Hubbard model is defined in a Bethe lattice whose density of states is semi-circular, the self-consistent equation for the dynamical mean-field theory reads:","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"G(tau) = t^2 Delta(tau)","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"As mentioned before, the BEGONIA component (and the other quantum impurity solver components) contains a mini dynamical mean-field engine and the above self-consistent equation is already implemented by default. So, we can use the BEGONIA component alone without help from any external programs or scripts.","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"(3) Prepare the input files","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"Please create a working directory for this tutorial:","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"$ mkdir test21","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"As for the BEGONIA component (and the other general matrix version of CT-HYB quantum impurity solvers), the atom.cix file is always necessary. Without it, the impurity solver won't run correctly. We have to use the JASMINE component to generate it at first. The configuration file (atom.config.in) for the JASMINE component is attached as follows:","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"!!!-----------------------------------------------------------------------\n!!! source  : t21/atom.config.in\n!!! solver  : JASMINE\n!!! purpose : for tutorial\n!!! author  : yilin wang (email:qhwyl2006@126.com)\n!!!-----------------------------------------------------------------------\n\n!!>>> setup general control flags\n!!------------------------------------------------------------------------\n  ibasis : 1\n  ictqmc : 1\n  icu    : 1\n  icf    : 0\n  isoc   : 0\n\n!!>>> setup common variables for jasmine\n!!------------------------------------------------------------------------\n  nband  : 2\n  nspin  : 2\n  norbs  : 4\n  ncfgs  : 16\n  nmini  : 0\n  nmaxi  : 4\n\n!!>>> setup common variables for jasmine\n!!------------------------------------------------------------------------\n  Uc     : 4.00\n  Uv     : 2.00\n  Jz     : 1.00\n  Js     : 1.00\n  Jp     : 1.00\n  Ud     : 0.00\n  Jh     : 0.00\n  lambda : 0.00\n  mune   : 0.00","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"Please setup your atom.config.in file, or just copy it from the iqist/tutor/t21 directory:","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"$ cp iqist/tutor/t21/atom.config.in test21","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"In the atom.config.in file, the local Hamiltonian is defined. Then we solve it using the JASMINE component.","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"$ cd test21\n$ pwd\n$ atomic","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"Here atomic is the executable program of the JASMINE component. We assume that it is in the iqist/build directory and added to the PATH. The atomic is extremely fast. After the calculation is finished, there are a lot of output files in the test21 folder. Try to find out the atom.cix file and ignore the others. Is it ready? You can use any text editor to open and read the atom.cix file. But please don't edit it for ever.","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"Next we have to prepare the solver.ctqmc.in file for the BEGONIA component. An official version is attached as follows.","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"!!!-----------------------------------------------------------------------\n!!! source  : t21/solver.ctqmc.in\n!!! solver  : BEGONIA\n!!! purpose : for tutorial\n!!! author  : yilin wang (email:qhwyl2006@126.com)\n!!!-----------------------------------------------------------------------\n\n!!>>> setup general control flags\n!!------------------------------------------------------------------------\n  isscf  : 2\n  issun  : 2\n  isspn  : 1\n  isbin  : 1\n\n!!>>> setup common variables for quantum impurity model\n!!------------------------------------------------------------------------\n  nband  : 2\n  nspin  : 2\n  norbs  : 4\n  ncfgs  : 16\n  nzero  : 256\n  niter  : 20\n  U      : 4.00\n  Uc     : 4.00\n  Uv     : 2.00\n  Jz     : 1.00\n  Js     : 1.00\n  Jp     : 1.00\n  mune   : 3.50\n  beta   : 10.0\n  part   : 0.50\n  alpha  : 0.70\n\n!!>>> setup common variables for quantum impurity solver\n!!------------------------------------------------------------------------\n  mkink  : 1024\n  mfreq  : 8193\n  nfreq  : 128\n  ntime  : 1024\n  npart  : 4\n  nflip  : 20000\n  ntherm : 20000000\n  nsweep : 200000000\n  nwrite : 20000000\n  nclean : 100000\n  nmonte : 100\n  ncarlo : 100","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"But you can also copy it from the iqist/tutor/t21 directory:","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"$ cp iqist/tutor/t21/solver.ctqmc.in .","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"The important parameters in the solver.ctqmc.in file are as follows:","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"isscf = 2: Define the DMFT self-consistent computational mode.\nnband = 2, norbs = 4, and ncfgs = 16: Specify a two-band Hubbard model.\nnzero = 256: Maximum number of non-zero matrix elements for F-matrix.\nmune = 3.5 : Chemical potential mu.\nbeta = 10.0 : Inverse temperature beta.\nnpart = 4: Number of parts that the imaginary-time axis is splitted.","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"In fact, you can create a simplified solver.ctqmc.in file which contains only the nband, norbs, ncfgs, nzero, mune, and beta parameters. The BEGONIA component will supplement the rest using default settings. Noted that now the Uc, Uv, Jz, Js and Jp parameters in the solver.ctqmc.in file are used as a reference. All of the information about the local Hamiltonian is defined in the atom.config.in file and dealed with the JASMINE component. The BEGONIA component is not responsible for constructing the local Hamiltonian model.","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"As for the format and grammar for the solver.ctqmc.in file, see solver.ctqmc.in for more details.","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"(4) Let's go","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"Now everything is ready. We can perform the calculation. Please execute the following command in the terminal, and then do another job. This calculation will cost you about five hours.","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"$ ctqmc","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"note: Note\nHere we assume that the executable program for the BEGONIA component is in iqist/build/ctqmc, and the directory iqist/build has been appended to the environment variable PATH.","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"(5) Post-processing","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"As usual we use the Python/matplotlib package to visualize the calculated results. If you are not familiar with this powerful tool, please visit its official website:http://matplotlib.org. Here is a sample Python script for plotting the imaginary-time Green's function G(tau), you can modify it to fit your requirements.","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"#!/usr/bin/env python\n\nimport numpy\nimport matplotlib\nmatplotlib.use(\"Agg\") # setup backend\nimport matplotlib.pyplot as plt\n\n# read data\nbeta = 10.0\nbi, ti, tau, gtau, error = numpy.loadtxt('solver.green.dat', unpack = True)\ntau = tau[0:1023] / beta\n\n# plot it\nplt.figure(0)\nlines = plt.plot(tau, gtau[0:1023], alpha = 0.8, clip_on = True)\n\n# setup line properties\nplt.setp(lines[0], linewidth = 2.5, color = 'khaki')\n\n# setup tics\nplt.xticks(fontsize = 18)\nplt.yticks(fontsize = 18)\nplt.tick_params(length = 8, width = 1.0, which = 'major')\nplt.tick_params(length = 4, width = 0.5, which = 'minor')\n\n# setup labels\nplt.xlabel(r\"$\\tau/\\beta$\", fontsize = 18)\nplt.ylabel(r\"$G(\\tau)$\", fontsize = 18)\n\n# setup yranges\nplt.xlim(0.0,1.0)\n\n# output the figure\nplt.savefig(\"21gtau.png\")","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"Next we will show some visualized results. The following figures were generated using the above Python script with slight modifications. You can compare them with your own results to see whether your calculations are correct.","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"Histogram (solver.hist.dat)","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"(Image: hist image)","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"Figure | The histogram for perturbation expansion series.","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"Imaginary-time Green's function (solver.green.dat)","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"(Image: gtau image)","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"Figure | The imaginary-time Green's function G(tau).","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"Matsubara Green's function (solver.grn.dat)","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"(Image: grnf image)","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"Figure | The imaginary part of Matsubara Green's function Im G(iomega_n).","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"Matsubara self-energy function (solver.sgm.dat)","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"(Image: sigf image)","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"Figure | The imaginary part of Matsubara self-energy function Im Sigma(iomega_n).","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"Since the orbitals in this model are degenerated, so for G(tau), G(iomega_n), and Sigma(iomega_n) we only plot the data for the first band. Clearly, the system is in insulating state.","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"Adventures","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"(1) Adjust the parameters","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"You can adjust the mune, beta, npart, and nsweep parameters, and redo the calculations, to see what will happen.","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"(2) Parallel computation","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"Try to execute the CT-HYB quantum impurity solvers parallelly. Such as ","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"$ mpiexec -n 8 ctqmc","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"This will greatly reduce the numerical fluctuation in physical observable with the same nsweep parameter.","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"(3) Try the LAVENDER component","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"Use the LAVENDER component to do the calculation again. The original atom.cix file can be used directly. The solver.ctqmc.in file can be the same.","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"(4) Try the PANSY and MANJUSHAKA components","category":"page"},{"location":"ch08/general.html","page":"General Coulomb interaction","title":"General Coulomb interaction","text":"Since the atom.cix used by the BEGONIA and LAVENDER components is not compatible with the one used by the PANSY and MANJUSHAKA components. So we have to rebuild the atom.cix file at first. Please change ictqmc from 1 to 2 in the atom.config.in file, and then use the JASMINE component to generate the atom.cix file again. Then you can execute the PANSY or MANJUSHAKA component to solve the model. It is unnecessary to modify the solver.ctqmc.in file. Finally, you can compare the calculated results obtained by these two kinds of general matrix version of CT-HYB quantum impurity solvers. That's all.","category":"page"},{"location":"ch02/system.html#Compiling-system","page":"Compiling system","title":"Compiling system","text":"","category":"section"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"In this section, we will illustrate the compiling system of the iQIST software package. In fact, it is completely based on the well-known GNU GCC tool-chain. ","category":"page"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"The compiling system is in the iqist/build directory which includes the following files/folders:","category":"page"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"Makefile\nmake.sys\nbuild.md\ntemplate/linux\ntemplate/macos\ntemplate/tianhe\nx_setup.sh\nx_clean.sh","category":"page"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"Next, we will explain them in detail.","category":"page"},{"location":"ch02/system.html#*Makefile*","page":"Compiling system","title":"Makefile","text":"","category":"section"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"It is the central file of the compiling system. Usually, when you type \"make target\" command in the terminal, the make utility will parse this file and then apply the rules defined in it to build the target. Now suppose that you are in the iqist/build directory, you can execute","category":"page"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"$ make help","category":"page"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"to see the available targets, and input","category":"page"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"$ make help-more","category":"page"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"for more details.","category":"page"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"warning: Warning\nDO NOT touch this file by yourself even you are very familiar with the iQIST software package.","category":"page"},{"location":"ch02/system.html#*make.sys*","page":"Compiling system","title":"make.sys","text":"","category":"section"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"We design this file to configure the compiling system. In this file, we have to specify the Fortran compiler, the parallel environment, the linear algebra library, and the target hardware architecture, etc. ","category":"page"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"warning: Warning\nThe make.sys file is system-dependent, i.e., you have to modify it to fit your systems. Or else, the compiling will fail definitely.","category":"page"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"In the iqist/build/template directory, we provide a lot of make.sys files for various systems we have tested. You can consider them as references. We strongly recommend the users go through the make.sys file carefully and check whether the settings are correct before they start to compile the iQIST.","category":"page"},{"location":"ch02/system.html#*build.md*","page":"Compiling system","title":"build.md","text":"","category":"section"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"In this file, we provide some hints/explanations about the make.sys template files.","category":"page"},{"location":"ch02/system.html#*template*","page":"Compiling system","title":"template","text":"","category":"section"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"In this folder, we provide a few make.sys files which are designed and tested for various systems. You can modify them to fit your requirement, and then copy it to override the default make.sys file (i.e., the iqist/build/make.sys file).","category":"page"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"template/linux, containing template make.sys files for Linux system.\ntemplate/macos, containing template make.sys files for Mac OS X system.\ntemplate/tianhe, containing template make.sys files for the TianHe-1 supercomputer system in Tianjin, China.","category":"page"},{"location":"ch02/system.html#*x_setup.sh*","page":"Compiling system","title":"x_setup.sh","text":"","category":"section"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"When the compiling finishes, you can execute this script in the terminal to copy all of the (available) built targets into the build directory (i.e., the iqist/build directory).","category":"page"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"$ ./x_setup.sh","category":"page"},{"location":"ch02/system.html#*x_clean.sh*","page":"Compiling system","title":"x_clean.sh","text":"","category":"section"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"Sometimes, you come across the idea of deleting the executable programs in the iqist/build directory. The x_clean.sh script can help you to clean them and give you a fresh start.","category":"page"},{"location":"ch02/system.html","page":"Compiling system","title":"Compiling system","text":"$ ./x_clean.sh","category":"page"},{"location":"ch07/std.html#toolbox/makestd","page":"toolbox/makestd","title":"toolbox/makestd","text":"","category":"section"},{"location":"ch07/std.html","page":"toolbox/makestd","title":"toolbox/makestd","text":"Introduction","category":"page"},{"location":"ch07/std.html","page":"toolbox/makestd","title":"toolbox/makestd","text":"The makestd code is often used to postprocess the self-energy function data to generate suitable input files for the HIBISCUS/swing code.","category":"page"},{"location":"ch07/std.html","page":"toolbox/makestd","title":"toolbox/makestd","text":"At first, you have to run the CT-HYB quantum impurity solver for many times to generate a series of solver.sgm.dat file. And then this code is used to deal with these solver.sgm.dat files to generate std.sgm.dat which is just what the HIBISCUS/swing code needs.","category":"page"},{"location":"ch07/std.html","page":"toolbox/makestd","title":"toolbox/makestd","text":"Usage","category":"page"},{"location":"ch07/std.html","page":"toolbox/makestd","title":"toolbox/makestd","text":"$ ./mstd","category":"page"},{"location":"ch07/std.html","page":"toolbox/makestd","title":"toolbox/makestd","text":"Input","category":"page"},{"location":"ch07/std.html","page":"toolbox/makestd","title":"toolbox/makestd","text":"See the terminal prompt\nsolver.sgm.dat.* (necessary)","category":"page"},{"location":"ch07/std.html","page":"toolbox/makestd","title":"toolbox/makestd","text":"Output","category":"page"},{"location":"ch07/std.html","page":"toolbox/makestd","title":"toolbox/makestd","text":"std.sgm.dat","category":"page"},{"location":"ch07/std.html","page":"toolbox/makestd","title":"toolbox/makestd","text":"Comment","category":"page"},{"location":"ch07/std.html","page":"toolbox/makestd","title":"toolbox/makestd","text":"N/A","category":"page"},{"location":"ch08/vertex.html#Two-particle-Green's-function-and-vertex-function","page":"Two-particle Green's function and vertex function","title":"Two-particle Green's function and vertex function","text":"","category":"section"},{"location":"ch08/gtau.html#Imaginary-time-Green's-function","page":"Imaginary-time Green's function","title":"Imaginary-time Green's function","text":"","category":"section"},{"location":"ch06/p_mune.html#Parameter:-mune","page":"mune","title":"Parameter: mune","text":"","category":"section"},{"location":"ch06/p_mune.html","page":"mune","title":"mune","text":"Definition","category":"page"},{"location":"ch06/p_mune.html","page":"mune","title":"mune","text":"Chemical potential or fermi level mu.","category":"page"},{"location":"ch06/p_mune.html","page":"mune","title":"mune","text":"Type","category":"page"},{"location":"ch06/p_mune.html","page":"mune","title":"mune","text":"Float, double precision","category":"page"},{"location":"ch06/p_mune.html","page":"mune","title":"mune","text":"Default value","category":"page"},{"location":"ch06/p_mune.html","page":"mune","title":"mune","text":"0.0","category":"page"},{"location":"ch06/p_mune.html","page":"mune","title":"mune","text":"Component","category":"page"},{"location":"ch06/p_mune.html","page":"mune","title":"mune","text":"Only for the JASMINE component.","category":"page"},{"location":"ch06/p_mune.html","page":"mune","title":"mune","text":"Behavior","category":"page"},{"location":"ch06/p_mune.html","page":"mune","title":"mune","text":"It is used to shift energy level, only useful for model calculations.","category":"page"},{"location":"ch06/p_mune.html","page":"mune","title":"mune","text":"Comment","category":"page"},{"location":"ch06/p_mune.html","page":"mune","title":"mune","text":"N/A","category":"page"},{"location":"ch04/out_kern.html#solver.kernel.dat","page":"solver.kernel.dat","title":"solver.kernel.dat","text":"","category":"section"},{"location":"ch04/out_kern.html","page":"solver.kernel.dat","title":"solver.kernel.dat","text":"Introduction","category":"page"},{"location":"ch04/out_kern.html","page":"solver.kernel.dat","title":"solver.kernel.dat","text":"The solver.kernel.dat is designed to store the screening function K(tau) and it derivates K(tau) in imaginary-time space. It will be output by the quantum impurity solvers when they are shut down.","category":"page"},{"location":"ch04/out_kern.html","page":"solver.kernel.dat","title":"solver.kernel.dat","text":"note: Note\nThe screening function K(tau) and its derivates K(tau) are the input to the quantum impurity solvers (see solver.ktau.in for more details). In other words, they won't be changed by the quantum impurity solvers.\nOnly the NARCISSUS component can generate the solver.kernel.dat file.","category":"page"},{"location":"ch04/out_kern.html","page":"solver.kernel.dat","title":"solver.kernel.dat","text":"Format","category":"page"},{"location":"ch04/out_kern.html","page":"solver.kernel.dat","title":"solver.kernel.dat","text":"The solver.kernel.dat file only contains one block. The format of the block is as follows:","category":"page"},{"location":"ch04/out_kern.html","page":"solver.kernel.dat","title":"solver.kernel.dat","text":"","category":"page"},{"location":"ch04/out_kern.html","page":"solver.kernel.dat","title":"solver.kernel.dat","text":"column 1: index of imaginary-time point, integer","category":"page"},{"location":"ch04/out_kern.html","page":"solver.kernel.dat","title":"solver.kernel.dat","text":"column 2: imaginary-time point, tau, double precision","category":"page"},{"location":"ch04/out_kern.html","page":"solver.kernel.dat","title":"solver.kernel.dat","text":"column 3: screening function, K(tau), double precision","category":"page"},{"location":"ch04/out_kern.html","page":"solver.kernel.dat","title":"solver.kernel.dat","text":"column 4: the first derivate of screening function, K(tau), double precision","category":"page"},{"location":"ch04/out_kern.html","page":"solver.kernel.dat","title":"solver.kernel.dat","text":"column 5: the second derivate of screening function, K(tau), double precision","category":"page"},{"location":"ch04/out_kern.html","page":"solver.kernel.dat","title":"solver.kernel.dat","text":"column 6: the third derivate of screening function, K(tau), double precision","category":"page"},{"location":"ch04/out_kern.html","page":"solver.kernel.dat","title":"solver.kernel.dat","text":"","category":"page"},{"location":"ch04/out_kern.html","page":"solver.kernel.dat","title":"solver.kernel.dat","text":"note: Note\nIn the NARCISSUS component, the K(tau) and K(tau) are assumed to be orbital-independent.","category":"page"},{"location":"ch04/out_kern.html","page":"solver.kernel.dat","title":"solver.kernel.dat","text":"Code","category":"page"},{"location":"ch04/out_kern.html","page":"solver.kernel.dat","title":"solver.kernel.dat","text":"The corresponding Fortran code block for the writing of solver.kernel.dat file is as follows:","category":"page"},{"location":"ch04/out_kern.html","page":"solver.kernel.dat","title":"solver.kernel.dat","text":"! open data file: solver.kernel.dat\n     open(mytmp, file='solver.kernel.dat', form='formatted', status='unknown')\n\n! write it\n     do i=1,ntime\n         write(mytmp,'(i6,5f12.6)') i, tmesh(i), ktau(i), ptau(i), ksed(i), psed(i)\n     enddo ! over i={1,ntime} loop\n\n! close data file\n     close(mytmp)","category":"page"},{"location":"ch04/out_kern.html","page":"solver.kernel.dat","title":"solver.kernel.dat","text":"In the HIBISCUS component, we provide a Python module to read the output files of quantum impurity solvers. You can use it to read the solver.kernel.dat file. See script/u_reader.py for more details.","category":"page"},{"location":"ch04/p_norbs.html#Parameter:-norbs","page":"norbs","title":"Parameter: norbs","text":"","category":"section"},{"location":"ch04/p_norbs.html","page":"norbs","title":"norbs","text":"Definition","category":"page"},{"location":"ch04/p_norbs.html","page":"norbs","title":"norbs","text":"Number of correlated orbitals considered in the calculations.","category":"page"},{"location":"ch04/p_norbs.html","page":"norbs","title":"norbs","text":"Type","category":"page"},{"location":"ch04/p_norbs.html","page":"norbs","title":"norbs","text":"Integer","category":"page"},{"location":"ch04/p_norbs.html","page":"norbs","title":"norbs","text":"Default value","category":"page"},{"location":"ch04/p_norbs.html","page":"norbs","title":"norbs","text":"2","category":"page"},{"location":"ch04/p_norbs.html","page":"norbs","title":"norbs","text":"Component","category":"page"},{"location":"ch04/p_norbs.html","page":"norbs","title":"norbs","text":"ALL","category":"page"},{"location":"ch04/p_norbs.html","page":"norbs","title":"norbs","text":"Behavior","category":"page"},{"location":"ch04/p_norbs.html","page":"norbs","title":"norbs","text":"Determine the size of involved arrays.","category":"page"},{"location":"ch04/p_norbs.html","page":"norbs","title":"norbs","text":"Comment","category":"page"},{"location":"ch04/p_norbs.html","page":"norbs","title":"norbs","text":"The following relations always hold.","category":"page"},{"location":"ch04/p_norbs.html","page":"norbs","title":"norbs","text":"textnorbs = textnpsin * textnband","category":"page"},{"location":"ch04/p_norbs.html","page":"norbs","title":"norbs","text":"textncfgs = 2^textnorbs","category":"page"},{"location":"ch04/p_norbs.html","page":"norbs","title":"norbs","text":"You have to ensure the value of norbs is compatible with nband, nspin and ncfgs. The quantum impurity solvers will not check and correct them automatically. So you have to setup them in the solver.ctqmc.in and solver.hfqmc.in files explicitly.","category":"page"},{"location":"ch04/p_norbs.html","page":"norbs","title":"norbs","text":"See also nspin, nband, and ncfgs parameters.","category":"page"},{"location":"ch04/out_prob.html#solver.prob.dat","page":"solver.prob.dat","title":"solver.prob.dat","text":"","category":"section"},{"location":"ch04/out_prob.html","page":"solver.prob.dat","title":"solver.prob.dat","text":"Introduction","category":"page"},{"location":"ch04/out_prob.html","page":"solver.prob.dat","title":"solver.prob.dat","text":"The solver.prob.dat file is used to store the atomic state probability and related information about the quantum impurity solvers. It will be output by the quantum impurity solvers when they are shut down. We can use the data in it to analyze the valence fluctuation.","category":"page"},{"location":"ch04/out_prob.html","page":"solver.prob.dat","title":"solver.prob.dat","text":"Format","category":"page"},{"location":"ch04/out_prob.html","page":"solver.prob.dat","title":"solver.prob.dat","text":"The format of the solver.prob.dat file is somewhat complex. It contains three blocks. They show the probabilities for atomic states, orbitals, and spins, respectively. In the first block, the fifth column is used to represent the error bar.","category":"page"},{"location":"ch04/out_prob.html","page":"solver.prob.dat","title":"solver.prob.dat","text":"note: Note\nFor the MANJUSHAKA and PANSY components, there is an additional block for showing the probabilities for sectors/superstates.","category":"page"},{"location":"ch04/out_prob.html","page":"solver.prob.dat","title":"solver.prob.dat","text":"Code","category":"page"},{"location":"ch04/out_prob.html","page":"solver.prob.dat","title":"solver.prob.dat","text":"The corresponding Fortran code block for the writing of solver.prob.dat file is as follows:","category":"page"},{"location":"ch04/out_prob.html","page":"solver.prob.dat","title":"solver.prob.dat","text":"! open data file: solver.prob.dat\n     open(mytmp, file='solver.prob.dat', form='formatted', status='unknown')\n\n! write it\n     write(mytmp,'(a)') '# state probability: index | prob | occupy | spin'\n     do i=1,ncfgs\n         write(mytmp,'(i6,4f12.6)') i, prob(i), noccs(i), soccs(i) * half, perr(i)\n     enddo ! over i={1,ncfgs} loop\n\n     write(mytmp,'(a)') '# orbital probability: index | occupy | prob'\n     do i=0,norbs\n         write(mytmp,'(i6,2f12.6)') i + 1, real(i), oprob(i)\n     enddo ! over i={0,norbs} loop\n     write(mytmp,'(a6,12X,f12.6)') 'sum', sum(oprob)\n\n     write(mytmp,'(a)') '# spin probability: index | spin | prob'\n     do i=-nband,nband\n         write(mytmp,'(i6,2f12.6)') i + nband + 1, i * half, sprob(i)\n     enddo ! over i={-nband,nband} loop\n     write(mytmp,'(a6,12X,f12.6)') 'sum', sum(sprob)\n\n! close data file\n     close(mytmp)","category":"page"},{"location":"ch04/out_prob.html","page":"solver.prob.dat","title":"solver.prob.dat","text":"In the HIBISCUS component, we provide a Python module to read the output files of quantum impurity solvers. You can use it to read the solver.prob.dat file. See script/u_reader.py for more details.","category":"page"},{"location":"ch06/output.html#Standard-output-files","page":"README","title":"Standard output files","text":"","category":"section"},{"location":"ch06/output.html","page":"README","title":"README","text":"The atomic eigenvalue problem solvers (the JASMINE component) will generate a lot of data files at run time. In this section, we will depict their formats and usages in detail.","category":"page"},{"location":"ch06/output.html","page":"README","title":"README","text":"The data files could be classified as the following kinds:","category":"page"},{"location":"ch06/output.html","page":"README","title":"README","text":"Direct output\nTerminal output // The runtime information of the code.\nEigensystem data\natom.eigval.dat // Eigenvalues.\natom.eigvec.dat // Eigenvectors.\nMiscellaneous data\natom.fock.dat // Fock state.\natom.tmat.dat // Transformation matrix.\natom.emat.dat // On-site impurity level.\natom.umat.dat // On-site Coulomb interaction matrix.\natom.sector.dat // Configuration of subspace.\nFor the quantum impurity solvers\nsolver.umat.in // On-site Coulomb interaction matrix (only the density-density part).\natom.cix // All-in-one file for the atomic eigenstates.","category":"page"},{"location":"ch07/mem.html#Maximum-entropy-method","page":"Maximum entropy method","title":"Maximum entropy method","text":"","category":"section"},{"location":"ch07/mem.html#Introduction","page":"Maximum entropy method","title":"Introduction","text":"","category":"section"},{"location":"ch07/mem.html","page":"Maximum entropy method","title":"Maximum entropy method","text":"In the Monte Carlo community, the maximum entropy method[1] is often employed to extract the impurity spectral function A(omega) from the imaginary-time Green's function G(tau). Thus, in the HIBISCUS component, we implemented the standard maximum entropy algorithm. In the E-DMFT calculations, sometimes we have to perform analytical continuation for the retarded interaction function U(inu) to obtain U(nu). So we developed a modified version of the maximum entropy method to enable this calculation.","category":"page"},{"location":"ch07/mem.html","page":"Maximum entropy method","title":"Maximum entropy method","text":"The HIBISCUS/entropy code is often used to perform the analytical continuation to build impurity spectral function from imaginary-time Green's function using the well-known maximum entropy method. In principle, it solves the Laplace transformation","category":"page"},{"location":"ch07/mem.html","page":"Maximum entropy method","title":"Maximum entropy method","text":"    G(tau) = int K(tauomega) A(omega) domega","category":"page"},{"location":"ch07/mem.html","page":"Maximum entropy method","title":"Maximum entropy method","text":"where K(tauomega) is the so-called kernel function. Its definition is as follows:","category":"page"},{"location":"ch07/mem.html","page":"Maximum entropy method","title":"Maximum entropy method","text":"    K(tauomega) = frac exp(-tauomega) 10+exp(-betaomega)","category":"page"},{"location":"ch07/mem.html","page":"Maximum entropy method","title":"Maximum entropy method","text":"[1]: M. Jarrell and J. Gubernatis, Phys. Rep. 269, 133 (1996).","category":"page"},{"location":"ch07/mem.html","page":"Maximum entropy method","title":"Maximum entropy method","text":"note: Note\nThe code is originally written by**Anders W. Sandvik**\n*Akademi University, Finland*\n*email:asandvik@ra.abo.fi*and modified and improved by the iQIST Developer Team using Fortran 90 language.","category":"page"},{"location":"ch07/mem.html#Usage","page":"Maximum entropy method","title":"Usage","text":"","category":"section"},{"location":"ch07/mem.html","page":"Maximum entropy method","title":"Maximum entropy method","text":"$ ./entropy","category":"page"},{"location":"ch07/mem.html","page":"Maximum entropy method","title":"Maximum entropy method","text":"or","category":"page"},{"location":"ch07/mem.html","page":"Maximum entropy method","title":"Maximum entropy method","text":"$ mpiexec -n number_of_cores ./entropy","category":"page"},{"location":"ch07/mem.html","page":"Maximum entropy method","title":"Maximum entropy method","text":"note: Note\nThe HIBISCUS/entropy code also support the MPI parallelism. So you can apply MPI to improve the computational accuracy of it.","category":"page"},{"location":"ch07/mem.html#Input","page":"Maximum entropy method","title":"Input","text":"","category":"section"},{"location":"ch07/mem.html","page":"Maximum entropy method","title":"Maximum entropy method","text":"tau.grn.dat (necessary)\nentropy.in (necessary)","category":"page"},{"location":"ch07/mem.html","page":"Maximum entropy method","title":"Maximum entropy method","text":"The tau.grn.dat file contains the G(tau) data. It has to be generated using the HIBISCUS/toolbox/maketau code. ","category":"page"},{"location":"ch07/mem.html","page":"Maximum entropy method","title":"Maximum entropy method","text":"See also toolbox/maketau for more details.","category":"page"},{"location":"ch07/mem.html","page":"Maximum entropy method","title":"Maximum entropy method","text":"The entropy.in file contains all of the necessary control parameters for the HIBISCUS/entropy code. The syntax of it is the same with the solver.ctqmc.in file. As for the valid control parameters, please see the following text.","category":"page"},{"location":"ch07/mem.html","page":"Maximum entropy method","title":"Maximum entropy method","text":"See also solver.ctqmc.in for more details.","category":"page"},{"location":"ch07/mem.html#Output","page":"Maximum entropy method","title":"Output","text":"","category":"section"},{"location":"ch07/mem.html","page":"Maximum entropy method","title":"Maximum entropy method","text":"mem.dos.dat\nmem.sum.dat","category":"page"},{"location":"ch07/mem.html","page":"Maximum entropy method","title":"Maximum entropy method","text":"The impurity spectral function A(omega) is stored in the mem.dos.dat file. In the mem.sum.dat file, the sum-rules for the impurity spectral function are examined.","category":"page"},{"location":"ch07/mem.html#Parameters","page":"Maximum entropy method","title":"Parameters","text":"","category":"section"},{"location":"ch07/mem.html","page":"Maximum entropy method","title":"Maximum entropy method","text":"In the following, we will show the original definitions for the control parameters:","category":"page"},{"location":"ch07/mem.html","page":"Maximum entropy method","title":"Maximum entropy method","text":"!!========================================================================\n!!>>> integer variables                                                <<<\n!!========================================================================\n\n! number of imaginary time slices sampling by continuous time or hirsh-fye\n! quantum Monte Carlo quantum impurity solver\n     integer, public, save :: ntime = 129\n\n! number of frequency points on half axis, energy range can be expressed by\n! [ -wstep * nwmax, wstep * nwmax ]\n     integer, public, save :: nwmax = 200\n\n! maximum number of cycles for classic maximum entropy method\n     integer, public, save :: niter = 20\n\n! number of smooth runs for classic maximum entropy method\n     integer, public, save :: ntune = 20\n\n! number of annealing steps per classic maximum entropy method cycle\n     integer, public, save :: nstep = 4000\n\n! number of bands\n     integer, public, save :: nband = 1\n\n! number of orbitals\n     integer, public, save :: norbs = 2\n\n! the way the default model function is build\n! if ntype == 0, gaussian model\n! if ntype == 1, flat model\n     integer, public, save :: ntype = 1\n\n!!========================================================================\n!!>>> real variables                                                   <<<\n!!========================================================================\n\n! initial alpha parameter\n     real(dp), public, save :: ainit = 1200._dp\n\n! it is the deviation from the average green's function\n     real(dp), public, save :: devia = 0.001_dp\n\n! \\beta, inversion of real temperature\n     real(dp), public, save :: beta  = 10.00_dp\n\n! gauss broadening parameter, used to build the default model\n     real(dp), public, save :: sigma = 1.600_dp\n\n! delta frequency, step of real frequency grid\n     real(dp), public, save :: wstep = 0.025_dp","category":"page"},{"location":"ch07/mem.html#Recipe:-how-to-convert-G(\\tau)-to-A(\\omega)-using-the-**HIBISCUS**/entropy-code","page":"Maximum entropy method","title":"Recipe: how to convert G(tau) to A(omega) using the HIBISCUS/entropy code","text":"","category":"section"},{"location":"ch07/mem.html","page":"Maximum entropy method","title":"Maximum entropy method","text":"Step 1: ","category":"page"},{"location":"ch07/mem.html","page":"Maximum entropy method","title":"Maximum entropy method","text":"Perform CT-HYB or HF-QMC calculations, generate a solver.green.dat file or multiple solver.green.dat.````* files.","category":"page"},{"location":"ch07/mem.html","page":"Maximum entropy method","title":"Maximum entropy method","text":"Step 2:","category":"page"},{"location":"ch07/mem.html","page":"Maximum entropy method","title":"Maximum entropy method","text":"Using the HIBISCUS/toolbox/maketau to post-process the solver.green.dat file or solver.green.dat.````* files. The output should be tau.grn.dat file.","category":"page"},{"location":"ch07/mem.html","page":"Maximum entropy method","title":"Maximum entropy method","text":"Step 3:","category":"page"},{"location":"ch07/mem.html","page":"Maximum entropy method","title":"Maximum entropy method","text":"Edit the entropy.in file, setup reasonable control parameters.","category":"page"},{"location":"ch07/mem.html","page":"Maximum entropy method","title":"Maximum entropy method","text":"Step 4:","category":"page"},{"location":"ch07/mem.html","page":"Maximum entropy method","title":"Maximum entropy method","text":"Execute the HIBISCUS/entropy code, the tau.grn.dat and entropy.in files are necessary inputs.","category":"page"},{"location":"ch07/mem.html","page":"Maximum entropy method","title":"Maximum entropy method","text":"Step 5:","category":"page"},{"location":"ch07/mem.html","page":"Maximum entropy method","title":"Maximum entropy method","text":"Validate the impurity spectral function A(omega) in the mem.dos.dat file. That is what you need.","category":"page"},{"location":"ch07/mem.html","page":"Maximum entropy method","title":"Maximum entropy method","text":"Step 6:","category":"page"},{"location":"ch07/mem.html","page":"Maximum entropy method","title":"Maximum entropy method","text":"Now you can use the data in mem.dos.dat file to generate beautiful figures, or use the other tools to postprocess it again.","category":"page"},{"location":"ch04/README.html#Quantum-Monte-Carlo-impurity-solvers","page":"README","title":"Quantum Monte Carlo impurity solvers","text":"","category":"section"},{"location":"ch04/README.html","page":"README","title":"README","text":"It is time to look inside the quantum impurity solvers implemented in the iQIST software package. In this chapter, we will explain the essential information about how to setup the quantum impurity solvers components. This is the most important chapter in this manual. Even if you are already an expert of the iQIST software package, this chapter is still helpful.","category":"page"},{"location":"ch04/README.html","page":"README","title":"README","text":"The contents in this chapter are related with the following components:","category":"page"},{"location":"ch04/README.html","page":"README","title":"README","text":"AZALEA\nGARDENIA\nNARCISSUS\nBEGONIA\nLAVENDER\nCAMELLIA\nPANSY\nMANJUSHAKA\nDAISY","category":"page"},{"location":"ch04/README.html","page":"README","title":"README","text":"The main topics are as follows:","category":"page"},{"location":"ch04/README.html","page":"README","title":"README","text":"How to choose suitable quantum impurity solvers? // So many CT-HYB impurity solvers!?\nStandard input files // Input stuffs.\nStandard output files // Output stuffs.\nParameters // Really a reference manual.","category":"page"},{"location":"ch04/README.html","page":"README","title":"README","text":"Maybe you are interested in the following related topics:","category":"page"},{"location":"ch04/README.html","page":"README","title":"README","text":"Getting started // To teach you how to setup and use the iQIST software package.\nAtomic eigenvalue problem solver // Another reference manual.\nAuxiliary tools // The companion of quantum impurity solvers.\nApplication programming interfaces // Write your own Python/Fortran codes.\niQIST in action // Some lightweight tutorials.\nInside iQIST // Unleashing the secrets inside the iQIST.","category":"page"},{"location":"ch04/README.html","page":"README","title":"README","text":"See also:","category":"page"},{"location":"ch04/README.html","page":"README","title":"README","text":"Besides the above links, you can find many useful examples/cases under the iqist/working/ctqmc and iqist/working/hfqmc directories.","category":"page"},{"location":"ch07/dos.html#toolbox/makedos","page":"toolbox/makedos","title":"toolbox/makedos","text":"","category":"section"},{"location":"ch07/dos.html","page":"toolbox/makedos","title":"toolbox/makedos","text":"Introduction","category":"page"},{"location":"ch07/dos.html","page":"toolbox/makedos","title":"toolbox/makedos","text":"This code will generate density of states rho(epsilon) for the following lattice models:","category":"page"},{"location":"ch07/dos.html","page":"toolbox/makedos","title":"toolbox/makedos","text":"Gaussian density of states, d = infty cubic lattice\nd = 3 cubic lattice\nSemi-circular density of states, bethe lattice\nLorentzian density of states","category":"page"},{"location":"ch07/dos.html","page":"toolbox/makedos","title":"toolbox/makedos","text":"Usage","category":"page"},{"location":"ch07/dos.html","page":"toolbox/makedos","title":"toolbox/makedos","text":"$ ./mdos","category":"page"},{"location":"ch07/dos.html","page":"toolbox/makedos","title":"toolbox/makedos","text":"Input","category":"page"},{"location":"ch07/dos.html","page":"toolbox/makedos","title":"toolbox/makedos","text":"See the terminal prompt.","category":"page"},{"location":"ch07/dos.html","page":"toolbox/makedos","title":"toolbox/makedos","text":"Output","category":"page"},{"location":"ch07/dos.html","page":"toolbox/makedos","title":"toolbox/makedos","text":"dos.gauss.dat\ndos.cubic.dat\ndos.bethe.dat\ndos.loren.dat","category":"page"},{"location":"ch07/dos.html","page":"toolbox/makedos","title":"toolbox/makedos","text":"Comment","category":"page"},{"location":"ch07/dos.html","page":"toolbox/makedos","title":"toolbox/makedos","text":"The users can rename the output files to solver.anydos.in which can be read by the ctqmc_dmft_anydos() subroutine in the ctqmc_dmft.f90 file.","category":"page"},{"location":"ch07/dos.html","page":"toolbox/makedos","title":"toolbox/makedos","text":"See also solver.anydos.in for more details.","category":"page"},{"location":"ch06/out_tmat.html#atom.tmat.dat","page":"atom.tmat.dat","title":"atom.tmat.dat","text":"","category":"section"},{"location":"ch06/out_tmat.html","page":"atom.tmat.dat","title":"atom.tmat.dat","text":"Introduction","category":"page"},{"location":"ch06/out_tmat.html","page":"atom.tmat.dat","title":"atom.tmat.dat","text":"The atom.tmat.dat file contains the transformation matrix mathcalT_alphabeta from the original basis to natural basis.","category":"page"},{"location":"ch06/out_tmat.html","page":"atom.tmat.dat","title":"atom.tmat.dat","text":"Format","category":"page"},{"location":"ch06/out_tmat.html","page":"atom.tmat.dat","title":"atom.tmat.dat","text":"The format of the atom.tmat.dat file is as follows:","category":"page"},{"location":"ch06/out_tmat.html","page":"atom.tmat.dat","title":"atom.tmat.dat","text":"","category":"page"},{"location":"ch06/out_tmat.html","page":"atom.tmat.dat","title":"atom.tmat.dat","text":"column 1: orbital index alpha, integer","category":"page"},{"location":"ch06/out_tmat.html","page":"atom.tmat.dat","title":"atom.tmat.dat","text":"column 2: orbital index beta, integer","category":"page"},{"location":"ch06/out_tmat.html","page":"atom.tmat.dat","title":"atom.tmat.dat","text":"column 3: Elements of the transformation matrix mathcalT_alphabeta, real part, double precision","category":"page"},{"location":"ch06/out_tmat.html","page":"atom.tmat.dat","title":"atom.tmat.dat","text":"column 4: Elements of the transformation matrix mathcalT_alphabeta, imaginary part, double precision","category":"page"},{"location":"ch06/out_tmat.html","page":"atom.tmat.dat","title":"atom.tmat.dat","text":"","category":"page"},{"location":"ch06/out_tmat.html","page":"atom.tmat.dat","title":"atom.tmat.dat","text":"note: Note\nIn the atom.tmat.dat file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch06/out_tmat.html","page":"atom.tmat.dat","title":"atom.tmat.dat","text":"Code","category":"page"},{"location":"ch06/out_tmat.html","page":"atom.tmat.dat","title":"atom.tmat.dat","text":"The corresponding Fortran code block for the writing of the atom.tmat.dat file is as follows:","category":"page"},{"location":"ch06/out_tmat.html","page":"atom.tmat.dat","title":"atom.tmat.dat","text":"! open file atom.tmat.dat to write\n     open(mytmp, file='atom.tmat.dat', form='formatted', status='unknown')\n\n! write the header\n     write(mytmp,'(75a1)') dash ! dashed line\n     write(mytmp,'(a)') '# i | j | tmat_real | tmat_imag'\n     write(mytmp,'(75a1)') dash ! dashed line\n\n! write the data\n     do i=1,norbs\n         do j=1,norbs\n             write(mytmp,'(2i6,2f16.8)') i, j, tmat(i,j)\n         enddo ! over j={1,norbs} loop\n     enddo ! over i={1,norbs} loop\n\n! close data file\n     close(mytmp)","category":"page"},{"location":"ch06/out_tmat.html","page":"atom.tmat.dat","title":"atom.tmat.dat","text":"In principle, the transformation matrix is complex.","category":"page"},{"location":"ch06/out_tmat.html","page":"atom.tmat.dat","title":"atom.tmat.dat","text":"See also atom.tmat.in for more details.","category":"page"},{"location":"ch01/README.html#Introduction","page":"README","title":"Introduction","text":"","category":"section"},{"location":"ch01/README.html","page":"README","title":"README","text":"Hi, welcome to the world of continuous-time quantum impurity solvers. ","category":"page"},{"location":"ch01/README.html","page":"README","title":"README","text":"This is the official user manual for the iQIST software package which implements several state-of-the-art continuous-time quantum impurity solvers. In this chapter, you will learn something you have to know about the continuous-time quantum impurity solvers, and of course the iQIST software package.","category":"page"},{"location":"ch01/README.html","page":"README","title":"README","text":"Are you ready? Let's go!","category":"page"},{"location":"ch01/README.html","page":"README","title":"README","text":"What's iQIST? // Is it a food or an animal?\nMotivation // Why do we need the iQIST software package?\nComponents // What does the iQIST software package include?\nFeatures // What can we do by using the iQIST software package?\nSoftware architecture // A bird's eye view of the iQIST software package.\nPolicy // Some basic rules and tips.","category":"page"},{"location":"ch01/README.html","page":"README","title":"README","text":"If you are already familiar with the iQIST software package, perhaps you will be interested in the following advanced topics:","category":"page"},{"location":"ch01/README.html","page":"README","title":"README","text":"Quantum Monte Carlo impurity solvers // A comprehensive reference about the impurity solvers.\nApplications // The applications, plugins that are built on top of iQIST.\nAtomic eigenvalue problem solver // A comprehensive reference about the atomic eigenvalue solver.\nAuxiliary tools // Full descriptions about the auxiliary toolbox.\nApplication programming interfaces // How to use iQIST via external Python/Fortran programs.","category":"page"},{"location":"ch01/README.html","page":"README","title":"README","text":"If you want to learn the secrets of the iQIST software package, then diving into","category":"page"},{"location":"ch01/README.html","page":"README","title":"README","text":"Inside iQIST // The principles, tricks, formulations, algorithms that are implemented in iQIST.","category":"page"},{"location":"ch01/README.html","page":"README","title":"README","text":"may be the best choices.","category":"page"},{"location":"ch08/practical.html#Practical-exercises","page":"README","title":"Practical exercises","text":"","category":"section"},{"location":"ch08/practical.html","page":"README","title":"README","text":"Orbital-selective Mott transition in two-band Hubbard model\nOrbital Kondo and spin Kondo effects in three-band Anderson impurity model","category":"page"},{"location":"ch07/atomic.html#script/u_atomic.py","page":"script/u_atomic.py","title":"script/u_atomic.py","text":"","category":"section"},{"location":"ch07/atomic.html","page":"script/u_atomic.py","title":"script/u_atomic.py","text":"Introduction","category":"page"},{"location":"ch07/atomic.html","page":"script/u_atomic.py","title":"script/u_atomic.py","text":"The purpose of this script is to generate essential input file (atom.config.in) for the JASMINE code. Note that you can not use it to control the JASMINE code directly.","category":"page"},{"location":"ch07/atomic.html","page":"script/u_atomic.py","title":"script/u_atomic.py","text":"Type","category":"page"},{"location":"ch07/atomic.html","page":"script/u_atomic.py","title":"script/u_atomic.py","text":"Python module","category":"page"},{"location":"ch07/atomic.html","page":"script/u_atomic.py","title":"script/u_atomic.py","text":"APIs","category":"page"},{"location":"ch07/atomic.html","page":"script/u_atomic.py","title":"script/u_atomic.py","text":"class p_atomic_solver(object):\n    \"\"\" This class can be used to generate the config file for the jasmine.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\" define the class variables\n        \"\"\"\n\n    def setp(self, **kwargs):\n        \"\"\" setup the parameters using a series of key-value pairs\n        \"\"\"\n\n    def check(self):\n        \"\"\" check the correctness of input parameters\n        \"\"\"\n\n    def write(self):\n        \"\"\" write the parameters to the config file: atom.config.in\n        \"\"\"","category":"page"},{"location":"ch07/atomic.html","page":"script/u_atomic.py","title":"script/u_atomic.py","text":"Examples","category":"page"},{"location":"ch07/atomic.html","page":"script/u_atomic.py","title":"script/u_atomic.py","text":"# import this module\nfrom u_atomic import *\n\n# create an instance\np = p_atomic_solver()\n\n# setup the parameters\np.setp(ibasis = 2, Uv = 2.0)\np.setp(icu = 30) # invalid parameter\np.setp(icu = 1)\np.setp()\n\n# verify the parameters\np.check()\n\n# generate the atom.config.in file\np.write()\n\n# destroy the instance\ndel p","category":"page"},{"location":"ch07/atomic.html","page":"script/u_atomic.py","title":"script/u_atomic.py","text":"note: Note\nYou can not execute u_atomic.py in the terminal or Python environment directly, like this:$ python u_atomic.py","category":"page"},{"location":"ch07/atomic.html","page":"script/u_atomic.py","title":"script/u_atomic.py","text":"Comment","category":"page"},{"location":"ch07/atomic.html","page":"script/u_atomic.py","title":"script/u_atomic.py","text":"N/A","category":"page"},{"location":"ch04/p_chgrd.html#Parameter:-chgrd","page":"chgrd","title":"Parameter: chgrd","text":"","category":"section"},{"location":"ch04/p_chgrd.html","page":"chgrd","title":"chgrd","text":"Definition","category":"page"},{"location":"ch04/p_chgrd.html","page":"chgrd","title":"chgrd","text":"Number of linear grid points in [-1,1] which is used to define the Chebyshev polynomials.","category":"page"},{"location":"ch04/p_chgrd.html","page":"chgrd","title":"chgrd","text":"Type","category":"page"},{"location":"ch04/p_chgrd.html","page":"chgrd","title":"chgrd","text":"Integer","category":"page"},{"location":"ch04/p_chgrd.html","page":"chgrd","title":"chgrd","text":"Default value","category":"page"},{"location":"ch04/p_chgrd.html","page":"chgrd","title":"chgrd","text":"20001","category":"page"},{"location":"ch04/p_chgrd.html","page":"chgrd","title":"chgrd","text":"Component","category":"page"},{"location":"ch04/p_chgrd.html","page":"chgrd","title":"chgrd","text":"Only for the GARDENIA, NARCISSUS, LAVENDER, CAMELLIA, and MANJUSHAKA components.","category":"page"},{"location":"ch04/p_chgrd.html","page":"chgrd","title":"chgrd","text":"Behavior","category":"page"},{"location":"ch04/p_chgrd.html","page":"chgrd","title":"chgrd","text":"The second kind Chebyshev orthogonal polynomials are defined in a linear grid in [-1,1]. And the number of grid points is controlled by this parameter.","category":"page"},{"location":"ch04/p_chgrd.html","page":"chgrd","title":"chgrd","text":"Comment","category":"page"},{"location":"ch04/p_chgrd.html","page":"chgrd","title":"chgrd","text":"This parameter is useful only when isort = 3 or isort = 6 . See isort for more details. The 20001 is an optimal value for chgrd. It is not recommended to modify it. ","category":"page"},{"location":"ch04/p_chgrd.html","page":"chgrd","title":"chgrd","text":"See also chmax for more details.","category":"page"},{"location":"ch04/p_chgrd.html","page":"chgrd","title":"chgrd","text":"As for the applications of orthogonal polynomials in CT-QMC impurity solver, please refer to Lewin's[1] and Hartmann's[2] papers.","category":"page"},{"location":"ch04/p_chgrd.html","page":"chgrd","title":"chgrd","text":"Reference","category":"page"},{"location":"ch04/p_chgrd.html","page":"chgrd","title":"chgrd","text":"[1]: Lewin Boehnke, Hartmut Hafermann, Michel Ferrero, Frank Lechermann, and Olivier Parcollet, Phys. Rev. B 84, 075145 (2011).","category":"page"},{"location":"ch04/p_chgrd.html","page":"chgrd","title":"chgrd","text":"[2]: Hartmut Hafermann, Kelly R. Patton, and Philipp Werner, Phys. Rev. B 85, 205106 (2012).","category":"page"},{"location":"ch06/p_nband.html#Parameter:-nband","page":"nband","title":"Parameter: nband","text":"","category":"section"},{"location":"ch06/p_nband.html","page":"nband","title":"nband","text":"Definition","category":"page"},{"location":"ch06/p_nband.html","page":"nband","title":"nband","text":"Number of correlated bands.","category":"page"},{"location":"ch06/p_nband.html","page":"nband","title":"nband","text":"Type","category":"page"},{"location":"ch06/p_nband.html","page":"nband","title":"nband","text":"Integer","category":"page"},{"location":"ch06/p_nband.html","page":"nband","title":"nband","text":"Default value","category":"page"},{"location":"ch06/p_nband.html","page":"nband","title":"nband","text":"1","category":"page"},{"location":"ch06/p_nband.html","page":"nband","title":"nband","text":"Component","category":"page"},{"location":"ch06/p_nband.html","page":"nband","title":"nband","text":"Only for the JASMINE component.","category":"page"},{"location":"ch06/p_nband.html","page":"nband","title":"nband","text":"Behavior","category":"page"},{"location":"ch06/p_nband.html","page":"nband","title":"nband","text":"Determine the size of involved arrays.","category":"page"},{"location":"ch06/p_nband.html","page":"nband","title":"nband","text":"Comment","category":"page"},{"location":"ch06/p_nband.html","page":"nband","title":"nband","text":"In iQIST software package, when we say nband, we always do not consider the spin degree of freedom. So for dâelectron system, it should be a five-band model (nband = 5), while for fâelectron, it should be a seven-band model (nband = 7).","category":"page"},{"location":"ch06/p_nband.html","page":"nband","title":"nband","text":"See nspin, norbs, and ncfgs parameters.","category":"page"},{"location":"ch04/out_weiss.html#solver.weiss.dat","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"","category":"section"},{"location":"ch04/out_weiss.html","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"Introduction","category":"page"},{"location":"ch04/out_weiss.html","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"This file is used to store the imaginary-time Weiss's function G_0(tau). It will be output by the quantum impurity solvers when they are shut down.","category":"page"},{"location":"ch04/out_weiss.html","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"Format","category":"page"},{"location":"ch04/out_weiss.html","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"The solver.weiss.dat file contains norbs block. Each block is appended by two blank lines. The format of each block is as follows:","category":"page"},{"location":"ch04/out_weiss.html","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"","category":"page"},{"location":"ch04/out_weiss.html","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"column 1: orbital index i, integer","category":"page"},{"location":"ch04/out_weiss.html","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"column 2: imaginary-time index j, integer","category":"page"},{"location":"ch04/out_weiss.html","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"column 3: imaginary-time point, tau, double precision","category":"page"},{"location":"ch04/out_weiss.html","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"column 4: imaginary-time Weiss's function, G_0(tau), double precision","category":"page"},{"location":"ch04/out_weiss.html","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"column 5: error bar, delta G_0(tau), double precision","category":"page"},{"location":"ch04/out_weiss.html","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"","category":"page"},{"location":"ch04/out_weiss.html","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"note: Note\nIn the solver.weiss.dat file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch04/out_weiss.html","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"Code","category":"page"},{"location":"ch04/out_weiss.html","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"The corresponding Fortran code block for the writing of solver.weiss.dat file is as follows:","category":"page"},{"location":"ch04/out_weiss.html","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"! open data file: solver.weiss.dat\n     open(mytmp, file='solver.weiss.dat', form='formatted', status='unknown')\n\n! write it\n     do i=1,norbs\n         do j=1,ntime\n             write(mytmp,'(2i6,3f12.6)') i, j, tmesh(j), wtau(j,i,i), zero\n         enddo ! over j={1,ntime} loop\n         write(mytmp,*) ! write empty lines\n         write(mytmp,*)\n     enddo ! over i={1,norbs} loop\n\n! close data file\n     close(mytmp)","category":"page"},{"location":"ch04/out_weiss.html","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"note: Note\nThe column for the error bar is always zero in this file.","category":"page"},{"location":"ch04/out_weiss.html","page":"solver.weiss.dat","title":"solver.weiss.dat","text":"In the HIBISCUS component, we provide a Python module to read the output files of quantum impurity solvers. You can use it to read the solver.weiss.dat file. See script/u_reader.py for more details.","category":"page"},{"location":"ch07/animator.html#script/u_animator.py","page":"script/u_animator.py","title":"script/u_animator.py","text":"","category":"section"},{"location":"ch07/animator.html","page":"script/u_animator.py","title":"script/u_animator.py","text":"Introduction","category":"page"},{"location":"ch07/animator.html","page":"script/u_animator.py","title":"script/u_animator.py","text":"The purpose of this script is to generate the animation movie using the data contained in the solver.diag.dat file.","category":"page"},{"location":"ch07/animator.html","page":"script/u_animator.py","title":"script/u_animator.py","text":"Type","category":"page"},{"location":"ch07/animator.html","page":"script/u_animator.py","title":"script/u_animator.py","text":"Python script","category":"page"},{"location":"ch07/animator.html","page":"script/u_animator.py","title":"script/u_animator.py","text":"Usage","category":"page"},{"location":"ch07/animator.html","page":"script/u_animator.py","title":"script/u_animator.py","text":"First, please edit the configuration parameters (such as inverse temperature beta, number of orbitals norbs, number of frames nsweep/nwrite, etc) in the script carefully, and then execute it in the terminal:","category":"page"},{"location":"ch07/animator.html","page":"script/u_animator.py","title":"script/u_animator.py","text":"$ ./u_animator.py movie.mp4","category":"page"},{"location":"ch07/animator.html","page":"script/u_animator.py","title":"script/u_animator.py","text":"Here movie.mp4 is the output file. We can use the VLC to play it. If you don't supply any valid filename, the default output should be diag.mp4.","category":"page"},{"location":"ch07/animator.html","page":"script/u_animator.py","title":"script/u_animator.py","text":"note: Note\nUsually, the default setting in this script is not good. You have to adjust them again and again to obtain a good mp4 video.","category":"page"},{"location":"ch07/animator.html","page":"script/u_animator.py","title":"script/u_animator.py","text":"Input","category":"page"},{"location":"ch07/animator.html","page":"script/u_animator.py","title":"script/u_animator.py","text":"solver.diag.dat","category":"page"},{"location":"ch07/animator.html","page":"script/u_animator.py","title":"script/u_animator.py","text":"All of the CT-HYB quantum impurity solvers in the iQIST software package can output the solver.diag.dat file if the nwrite parameter is correctly set.","category":"page"},{"location":"ch07/animator.html","page":"script/u_animator.py","title":"script/u_animator.py","text":"Output","category":"page"},{"location":"ch07/animator.html","page":"script/u_animator.py","title":"script/u_animator.py","text":"movie.mp4","category":"page"},{"location":"ch07/animator.html","page":"script/u_animator.py","title":"script/u_animator.py","text":"You can specify the output filename by yourself. The suffix must be mp4.","category":"page"},{"location":"ch07/animator.html","page":"script/u_animator.py","title":"script/u_animator.py","text":"Comment","category":"page"},{"location":"ch07/animator.html","page":"script/u_animator.py","title":"script/u_animator.py","text":"The generated animation movie can be played using the VLC video tool. Sometimes the Quicktime player in the Mac OS X can not play it correctly.","category":"page"},{"location":"ch04/out_kmat.html#solver.kmat.dat","page":"solver.kmat.dat","title":"solver.kmat.dat","text":"","category":"section"},{"location":"ch04/out_kmat.html","page":"solver.kmat.dat","title":"solver.kmat.dat","text":"Introduction","category":"page"},{"location":"ch04/out_kmat.html","page":"solver.kmat.dat","title":"solver.kmat.dat","text":"The solver.kmat.dat is used to store the orbital-dependent kinetic energy data (Here we use the expectation value of the perturbation expansion order langle k rangle to represent the kinetic energy). It will be output by the quantum impurity solvers when they are shut down.","category":"page"},{"location":"ch04/out_kmat.html","page":"solver.kmat.dat","title":"solver.kmat.dat","text":"note: Note\nOnly the GARDENIA, NARCISSUS, CAMELLIA, LAVENDER, and MANJUSHAKA components can generate the solver.kmat.dat file.","category":"page"},{"location":"ch04/out_kmat.html","page":"solver.kmat.dat","title":"solver.kmat.dat","text":"Format","category":"page"},{"location":"ch04/out_kmat.html","page":"solver.kmat.dat","title":"solver.kmat.dat","text":"The solver.kmat.dat file contains two blocks. One is for the orbital-dependent kinetic energy langle k_irangle, and another one is for the double kinetic energy matrix langle k_i k_jrangle. In each block, the error bar data are always shown in the rightmost column.","category":"page"},{"location":"ch04/out_kmat.html","page":"solver.kmat.dat","title":"solver.kmat.dat","text":"note: Note\nIn the solver.kmat.dat file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch04/out_kmat.html","page":"solver.kmat.dat","title":"solver.kmat.dat","text":"Code","category":"page"},{"location":"ch04/out_kmat.html","page":"solver.kmat.dat","title":"solver.kmat.dat","text":"The corresponding Fortran code block for the writing of solver.kmat.dat file is as follows:","category":"page"},{"location":"ch04/out_kmat.html","page":"solver.kmat.dat","title":"solver.kmat.dat","text":"! open data file: solver.kmat.dat\n     open(mytmp, file='solver.kmat.dat', form='formatted', status='unknown')\n\n! write it\n     write(mytmp,'(a)') '# <  k  > data:'\n     do i=1,norbs\n         write(mytmp,'(i6,2f12.6)') i, kmat(i), kerr(i)\n     enddo ! over i={1,norbs} loop\n     write(mytmp,'(a6,2f12.6)') 'k_sum', sum( kmat ), sum( kerr )\n\n     write(mytmp,'(a)') '# < k^2 > data:'\n     do i=1,norbs\n         do j=1,norbs\n             write(mytmp,'(2i6,2f12.6)') i, j, kkmat(i,j), kkerr(i,j)\n         enddo ! over j={1,norbs} loop\n     enddo ! over i={1,norbs} loop\n     write(mytmp,'(a6,2f12.6)') 'kksum', sum( kkmat ), sum( kkerr )\n     write(mytmp,'(a6,2f12.6)') 'final', f_val, f_err\n\n! close data file\n     close(mytmp)","category":"page"},{"location":"ch04/out_kmat.html","page":"solver.kmat.dat","title":"solver.kmat.dat","text":"In the HIBISCUS component, we provide a Python module to read the output files of quantum impurity solvers. You can use it to read the solver.kmat.dat file. See script/u_reader.py for more details.","category":"page"},{"location":"ch05/dft_dmft.html#DFT-DMFT","page":"DFT + DMFT","title":"DFT + DMFT","text":"","category":"section"},{"location":"ch05/dft_dmft.html","page":"DFT + DMFT","title":"DFT + DMFT","text":"warning: Warning\nSorry, this application (the SAKURA component) is not ready now. We will release it later. Thank you for your patience.","category":"page"},{"location":"ch04/parameters.html#Parameters","page":"README","title":"Parameters","text":"","category":"section"},{"location":"ch04/parameters.html","page":"README","title":"README","text":"In this section, we will introduce all of the valid parameters which can be used in the solver.ctqmc.in (for AZALEA, GARDENIA, NARCISSUS, BEGONIA, LAVENDER, CAMELLIA, PANSY, and MANJUSHAKA components) and solver.hfqmc.in (for DAISY component) files. For more information, the users can also refer to the comments in corresponding ctqmc_control.f90 file.","category":"page"},{"location":"ch04/parameters.html#Classification-of-the-parameters","page":"README","title":"Classification of the parameters","text":"","category":"section"},{"location":"ch04/parameters.html","page":"README","title":"README","text":"Parameters for the dynamical mean-field theory engine\nisscf\nisbin\nniter\nalpha\nParameters for the strongly correlated models\nissun\nisspn\nisscr\nnband\nnspin\nnorbs\nncfgs\nnzero\nU\nUc\nUv\nJz\nJs\nJp\nlc\nwc\nmune\nbeta\npart\nParameters for the quantum impurity solvers\nifast\nitrun\nmkink\nmstep\nmfreq\nnsing\nntime\nnvect\nnleja\nnpart\nnflip\nntherm\nnsweep\nnwrite\nnclean\nncarlo\nnmonte\nParameters for the Monte Carlo sampling\nisort\nissus\nisvrt\nlemax\nlegrd\nchmax\nchgrd\nnffrq\nnbfrq\nnfreq","category":"page"},{"location":"ch04/parameters.html","page":"README","title":"README","text":"","category":"page"},{"location":"ch04/parameters.html#Concerning-the-speed","page":"README","title":"Concerning the speed","text":"","category":"section"},{"location":"ch04/parameters.html","page":"README","title":"README","text":"The following parameters have big influences on the computational efficiency of the quantum impurity solvers.","category":"page"},{"location":"ch04/parameters.html","page":"README","title":"README","text":"ifast\nitrun\nmstep\nnvect\nnleja\nnpart","category":"page"},{"location":"ch04/parameters.html","page":"README","title":"README","text":"","category":"page"},{"location":"ch04/parameters.html#Concerning-the-accuracy","page":"README","title":"Concerning the accuracy","text":"","category":"section"},{"location":"ch04/parameters.html","page":"README","title":"README","text":"The following parameters will affect the computational accuracy.","category":"page"},{"location":"ch04/parameters.html","page":"README","title":"README","text":"ifast\nitrun\nntime\nnvect\nntherm\nnsweep\nnclean\nncarlo\nnmonte\nisort\nisvrt\nlemax\nlegrd\nchmax\nchgrd","category":"page"},{"location":"ch04/parameters.html","page":"README","title":"README","text":"","category":"page"},{"location":"ch04/parameters.html","page":"README","title":"README","text":"tip: Tip\nAll of the parameters are case-insensitive.\nAll of the parameters have default values. You can override them via the solver.ctqmc.in and solver.hfqmc.in files.\nThe quantum impurity solvers won't check the correctness, rationality of the parameters. They won't adjust the parameters automatically. For example, if you setup nband = 2 in the solver.ctqmc.in, you have to setup norbs, ncfgs parameters by yourself at the same time. The quantum impurity solvers won't do that.","category":"page"},{"location":"ch04/parameters.html","page":"README","title":"README","text":"See also:","category":"page"},{"location":"ch04/parameters.html","page":"README","title":"README","text":"solver.ctqmc.in // File format for solver.ctqmc.in\nsolver.hfqmc.in // File format for solver.hfqmc.in","category":"page"},{"location":"ch06/p_uc.html#Parameter:-Uc","page":"Uc","title":"Parameter: Uc","text":"","category":"section"},{"location":"ch06/p_uc.html","page":"Uc","title":"Uc","text":"Definition","category":"page"},{"location":"ch06/p_uc.html","page":"Uc","title":"Uc","text":"Intra-orbital Coulomb interaction.","category":"page"},{"location":"ch06/p_uc.html","page":"Uc","title":"Uc","text":"Type","category":"page"},{"location":"ch06/p_uc.html","page":"Uc","title":"Uc","text":"Float, double precision","category":"page"},{"location":"ch06/p_uc.html","page":"Uc","title":"Uc","text":"Default value","category":"page"},{"location":"ch06/p_uc.html","page":"Uc","title":"Uc","text":"2.0","category":"page"},{"location":"ch06/p_uc.html","page":"Uc","title":"Uc","text":"Component","category":"page"},{"location":"ch06/p_uc.html","page":"Uc","title":"Uc","text":"Only for the JASMINE component.","category":"page"},{"location":"ch06/p_uc.html","page":"Uc","title":"Uc","text":"Behavior","category":"page"},{"location":"ch06/p_uc.html","page":"Uc","title":"Uc","text":"It is used to build the interaction term in the local Hamiltonian, only valid when icu = 1 or icu = 3.","category":"page"},{"location":"ch06/p_uc.html","page":"Uc","title":"Uc","text":"Comment","category":"page"},{"location":"ch06/p_uc.html","page":"Uc","title":"Uc","text":"See also Uv, Jz, Js, Jp, and icu parameters for more details.","category":"page"},{"location":"ch04/p_ncfgs.html#Parameter:-ncfgs","page":"ncfgs","title":"Parameter: ncfgs","text":"","category":"section"},{"location":"ch04/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Definition","category":"page"},{"location":"ch04/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Number of atomic states considered in the calculations.","category":"page"},{"location":"ch04/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Type","category":"page"},{"location":"ch04/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Integer","category":"page"},{"location":"ch04/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Default value","category":"page"},{"location":"ch04/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"4","category":"page"},{"location":"ch04/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Component","category":"page"},{"location":"ch04/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"ALL","category":"page"},{"location":"ch04/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Behavior","category":"page"},{"location":"ch04/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Determine the size of involved arrays.","category":"page"},{"location":"ch04/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Comment","category":"page"},{"location":"ch04/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"The following relations always hold.","category":"page"},{"location":"ch04/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"textnorbs = textnpsin * textnband","category":"page"},{"location":"ch04/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"textncfgs = 2^textnorbs","category":"page"},{"location":"ch04/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"You have to ensure the value of norbs is compatible with nband, nspin and ncfgs. The quantum impurity solvers will not check and correct them automatically. So you have to setup them in the solver.ctqmc.in and solver.hfqmc.in files explicitly.","category":"page"},{"location":"ch04/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"See also nspin, nband, and norbs parameters.","category":"page"},{"location":"ch04/p_nzero.html#Parameter:-nzero","page":"nzero","title":"Parameter: nzero","text":"","category":"section"},{"location":"ch04/p_nzero.html","page":"nzero","title":"nzero","text":"Definition","category":"page"},{"location":"ch04/p_nzero.html","page":"nzero","title":"nzero","text":"Maximum allowed number of non-zero elements in F-matrix. In the iQIST software package, the terminology F-matrix denotes the d operator (the destroy operator for impurity electron) matrix in the eigen-basis of the local Hamiltonian or in occupation number basis.","category":"page"},{"location":"ch04/p_nzero.html","page":"nzero","title":"nzero","text":"Type","category":"page"},{"location":"ch04/p_nzero.html","page":"nzero","title":"nzero","text":"Integer","category":"page"},{"location":"ch04/p_nzero.html","page":"nzero","title":"nzero","text":"Default value","category":"page"},{"location":"ch04/p_nzero.html","page":"nzero","title":"nzero","text":"128","category":"page"},{"location":"ch04/p_nzero.html","page":"nzero","title":"nzero","text":"Component","category":"page"},{"location":"ch04/p_nzero.html","page":"nzero","title":"nzero","text":"Only for the BEGONIA, LAVENDER, and CAMELLIA components.","category":"page"},{"location":"ch04/p_nzero.html","page":"nzero","title":"nzero","text":"Behavior","category":"page"},{"location":"ch04/p_nzero.html","page":"nzero","title":"nzero","text":"In the BEGONIA, LAVENDER, and CAMELLIA components, we used the sparse matrix technology to accelerate the matrix times vector operation (spmv) and matrix times matrix (spmm). In order to save the memory, the F-matrix, the local Hamiltonian matrix, and the product matrix of the above operations are stored in CSR format. Here, we used nzero parameter to describe the maximum allowed number of non-zero elements of these matrices, and allocate the corresponding memories.","category":"page"},{"location":"ch04/p_nzero.html","page":"nzero","title":"nzero","text":"In the spmm operations, sometimes the number of the non-zero elements in the resulted matrix exceeds the value of nzero, which will trigger a fatal error/exception. At that time, you have to increase nzero by twofold, and redo the calculation.","category":"page"},{"location":"ch04/p_nzero.html","page":"nzero","title":"nzero","text":"Comment","category":"page"},{"location":"ch04/p_nzero.html","page":"nzero","title":"nzero","text":"In the BEGONIA and LAVENDER components the F-matrix mean the d operator matrix in the eigen-basis. However, in the CAMELLIA component, it means the d operator matrix in the occupation number basis.","category":"page"},{"location":"ch04/p_js.html#Parameter:-Js","page":"Js","title":"Parameter: Js","text":"","category":"section"},{"location":"ch04/p_js.html","page":"Js","title":"Js","text":"Definition","category":"page"},{"location":"ch04/p_js.html","page":"Js","title":"Js","text":"Strength of the spin-flip term in the interaction term, J_s.","category":"page"},{"location":"ch04/p_js.html","page":"Js","title":"Js","text":"Type","category":"page"},{"location":"ch04/p_js.html","page":"Js","title":"Js","text":"Float, double precision","category":"page"},{"location":"ch04/p_js.html","page":"Js","title":"Js","text":"Default value","category":"page"},{"location":"ch04/p_js.html","page":"Js","title":"Js","text":"0.0","category":"page"},{"location":"ch04/p_js.html","page":"Js","title":"Js","text":"Component","category":"page"},{"location":"ch04/p_js.html","page":"Js","title":"Js","text":"ALL, except for DAISY component.","category":"page"},{"location":"ch04/p_js.html","page":"Js","title":"Js","text":"Behavior","category":"page"},{"location":"ch04/p_js.html","page":"Js","title":"Js","text":"In principle, it is used to build the Coulomb interaction matrix. ","category":"page"},{"location":"ch04/p_js.html","page":"Js","title":"Js","text":"But the AZALEA, GARDENIA, NARCISSUS components don't support general interaction, in other words, they don't support the J_s term in the local impurity Hamiltonian. ","category":"page"},{"location":"ch04/p_js.html","page":"Js","title":"Js","text":"As for the CAMELLIA, BEGONIA, LAVENDER, MANJUSHAKA, and PANSY components, the Coulomb interaction matrix is not built within the quantum impurity solvers. All of the information is encapsulated in the atom.cix file. So they don't need the J_s parameter as well. ","category":"page"},{"location":"ch04/p_js.html","page":"Js","title":"Js","text":"Therefore, in summary, we don't use this parameter actually. You can set it to any values as you wish. But we strongly suggest to set it to the actual value.","category":"page"},{"location":"ch04/p_js.html","page":"Js","title":"Js","text":"Comment","category":"page"},{"location":"ch04/p_js.html","page":"Js","title":"Js","text":"See also Jz and Jp for more details.","category":"page"},{"location":"ch06/p_ud.html#Parameter:-Ud","page":"Ud","title":"Parameter: Ud","text":"","category":"section"},{"location":"ch06/p_ud.html","page":"Ud","title":"Ud","text":"Definition","category":"page"},{"location":"ch06/p_ud.html","page":"Ud","title":"Ud","text":"Coulomb interaction parameter.","category":"page"},{"location":"ch06/p_ud.html","page":"Ud","title":"Ud","text":"Type","category":"page"},{"location":"ch06/p_ud.html","page":"Ud","title":"Ud","text":"Float, double precision","category":"page"},{"location":"ch06/p_ud.html","page":"Ud","title":"Ud","text":"Default value","category":"page"},{"location":"ch06/p_ud.html","page":"Ud","title":"Ud","text":"2.0","category":"page"},{"location":"ch06/p_ud.html","page":"Ud","title":"Ud","text":"Component","category":"page"},{"location":"ch06/p_ud.html","page":"Ud","title":"Ud","text":"Only for the JASMINE component.","category":"page"},{"location":"ch06/p_ud.html","page":"Ud","title":"Ud","text":"Behavior","category":"page"},{"location":"ch06/p_ud.html","page":"Ud","title":"Ud","text":"It is useful when icu = 2. The Ud and Jh parameters are used to calculate the F_0, F_2, F_4, and F_6.","category":"page"},{"location":"ch06/p_ud.html","page":"Ud","title":"Ud","text":"Comment","category":"page"},{"location":"ch06/p_ud.html","page":"Ud","title":"Ud","text":"See also Jh and icu parameters for more details.","category":"page"},{"location":"ch08/kondo.html#Orbital-Kondo-and-spin-Kondo-effects-in-three-band-Anderson-impurity-model","page":"Orbital Kondo and spin Kondo effects in three-band Anderson impurity model","title":"Orbital Kondo and spin Kondo effects in three-band Anderson impurity model","text":"","category":"section"},{"location":"ch07/swing.html#Analytical-continuation-for-self-energy","page":"Analytical continuation for self-energy","title":"Analytical continuation for self-energy","text":"","category":"section"},{"location":"ch07/swing.html#Introduction","page":"Analytical continuation for self-energy","title":"Introduction","text":"","category":"section"},{"location":"ch07/swing.html","page":"Analytical continuation for self-energy","title":"Analytical continuation for self-energy","text":"The calculated results for the self-energy function on the real axis using Pade approximation strongly depend on the numerical accuracy of the original self-energy data. However, the CT-HYB/DMFT calculations usually yield a Matsubara self-energy function Sigma(iomega_n) with numerical noises. In this case, the Pade approximation does not work well. To overcome this problem, Haule et al[1]. suggested to split the Matsubara self-energy function into a low-frequency part and high-frequency tail. The low-frequency part is fitted by some sort of model functions which depends on whether the system is metallic or insulating, and the high-frequency part is fitted by modified Gaussian polynomials. It was shown that their trick works quite well even when the original self-energy function is noisy, and is superior to the Pade approximation in all cases. Thus, in the HIBISCUS component, we also implemented this algorithm. It has broad applications in the DFT + DMFT calculations.","category":"page"},{"location":"ch07/swing.html","page":"Analytical continuation for self-energy","title":"Analytical continuation for self-energy","text":"The HIBISCUS/swing code is used to continue self-energy analytically from imaginary axis to real axis using K. Haule's strategy. ","category":"page"},{"location":"ch07/swing.html","page":"Analytical continuation for self-energy","title":"Analytical continuation for self-energy","text":"[1]: K. Haule, C.-H. Yee, and K. Kim, Phys. Rev. B 81, 195107 (2010)","category":"page"},{"location":"ch07/swing.html","page":"Analytical continuation for self-energy","title":"Analytical continuation for self-energy","text":"note: Note\nThis code was written by K. Haule originally. Seehttp://hauleweb.rutgers.edu/downloads/And then we adapted this code such that it can be used with the iQIST software package.","category":"page"},{"location":"ch07/swing.html#Usage","page":"Analytical continuation for self-energy","title":"Usage","text":"","category":"section"},{"location":"ch07/swing.html","page":"Analytical continuation for self-energy","title":"Analytical continuation for self-energy","text":"$ python ./swing_main.py [options]","category":"page"},{"location":"ch07/swing.html","page":"Analytical continuation for self-energy","title":"Analytical continuation for self-energy","text":"note: Note\nIn order to run this code properly, you need to ensure scipy and numpy were correctly installed on your system. This code was tested on scipy 0.14.0 and numpy 1.7.0 only. So for the older versions of scipy and numpy, we can not guarantee that it can work always.\nTo run this code, please use the 'make' command in the source directory (i.e., iqist/src/tools/hibiscus/swing) to build the dynamical library swing_fast.so at first. The f2py package must be installed and configured correctly in advance. ","category":"page"},{"location":"ch07/swing.html#Input","page":"Analytical continuation for self-energy","title":"Input","text":"","category":"section"},{"location":"ch07/swing.html","page":"Analytical continuation for self-energy","title":"Analytical continuation for self-energy","text":"The options for the HIBISCUS/swing code can be as follows:","category":"page"},{"location":"ch07/swing.html","page":"Analytical continuation for self-energy","title":"Analytical continuation for self-energy","text":"-sig filename\n  mandatory, input self-energy on imaginary axis (default:Sig.out)\n\n-nom number\n  mandatory, number of matsubara points used (default:100)\n\n-beta float\n  mandatory, inverse temperature (default:100.0)\n\n-FL bool\n  mandatory, low energy expansion of a Fermi liquid of Mott\n  insulator (default:True)\n\n-poles [[y0,A0,B0],[y1,A1,B1],...]\n  optional, poles of self-energy determined from spectral function,\n  poles will be forced at y0,y1,... this is achieved by contribution\n  to chi2+= Al/((x_i-yl)**2+w_i*Bl) where x_i are positions and w_i\n  weights of lorentzians to be determined\n\n-b float:[0-1]\n  optional, basis functions, b parameter to determin family of basis\n  functions (default:0.8)\n\n-Ng number\n  optional, number of basis functions (default:12)\n\n-wexp float:[1-2]\n  optional, wexp^i is position where basis functions are\n  peaked (default:1.5)\n\n-ifit number[4-..]\n  optional, low energy fit, number of matsubara points used to fit\n  the low energy expansion\n\n-alpha3 float[0-1]\n  optional, weight for the normalization in functional to be\n  minimized (default:0.01)\n\n-alpha4 float[0-1]\n  optional, weight for the low energy expansion in the functional\n  to be minimized (default:0.001)\n\n-maxsteps number\n  optional, maximum number of function evaluations in minimization\n  routine (default:400000)","category":"page"},{"location":"ch07/swing.html#Output","page":"Analytical continuation for self-energy","title":"Output","text":"","category":"section"},{"location":"ch07/swing.html","page":"Analytical continuation for self-energy","title":"Analytical continuation for self-energy","text":"The possible output files are as follows:","category":"page"},{"location":"ch07/swing.html","page":"Analytical continuation for self-energy","title":"Analytical continuation for self-energy","text":"sigr.out\n  final self-energy function on real axis\n\nsigr_linear.out\n  final self-energy function on fine real axis, it is used to\n  interface with DFT + DMFT code\n\nsiom.nnn\n  current function on imaginary axis (nnn counts every 40000 steps)\n\nsres.nnn\n  current analytic continuation to real axis (nnn counts every\n  40000 steps)\n\ngaus.nnn\n  current configuration for gaussians (nnn counts every 40000 steps)","category":"page"},{"location":"ch07/swing.html#Recipe:-how-to-convert-\\Sigma(i\\omega)-to-\\Sigma(\\omega)-using-the-**HIBISCUS**/swing-code","page":"Analytical continuation for self-energy","title":"Recipe: how to convert Sigma(iomega) to Sigma(omega) using the HIBISCUS/swing code","text":"","category":"section"},{"location":"ch07/swing.html","page":"Analytical continuation for self-energy","title":"Analytical continuation for self-energy","text":"Step 1: ","category":"page"},{"location":"ch07/swing.html","page":"Analytical continuation for self-energy","title":"Analytical continuation for self-energy","text":"Perform CT-HYB or HF-QMC calculations, generate a solver.sgm.dat file or multiple solver.sgm.dat.````* files.","category":"page"},{"location":"ch07/swing.html","page":"Analytical continuation for self-energy","title":"Analytical continuation for self-energy","text":"Step 2:","category":"page"},{"location":"ch07/swing.html","page":"Analytical continuation for self-energy","title":"Analytical continuation for self-energy","text":"Using the HIBISCUS/toolbox/makestd to post-process the solver.sgm.dat file or solver.sgm.dat.````* files. The output should be std.sgm.dat file.","category":"page"},{"location":"ch07/swing.html","page":"Analytical continuation for self-energy","title":"Analytical continuation for self-energy","text":"Step 3:","category":"page"},{"location":"ch07/swing.html","page":"Analytical continuation for self-energy","title":"Analytical continuation for self-energy","text":"Guess whether the system is metallic or insulating. Edit the corresponding Bash shell scripts (metal.sh or insulator.sh). See iqist/working/tools/hibiscus/swing directory for some examples.","category":"page"},{"location":"ch07/swing.html","page":"Analytical continuation for self-energy","title":"Analytical continuation for self-energy","text":"Step 4:","category":"page"},{"location":"ch07/swing.html","page":"Analytical continuation for self-energy","title":"Analytical continuation for self-energy","text":"Execute the HIBISCUS/swing code via the Bash shell script.","category":"page"},{"location":"ch07/swing.html","page":"Analytical continuation for self-energy","title":"Analytical continuation for self-energy","text":"Step 5:","category":"page"},{"location":"ch07/swing.html","page":"Analytical continuation for self-energy","title":"Analytical continuation for self-energy","text":"Validate the real-frequency self-energy function Sigma(omega) in the sigr.dat file or sigr_linear.dat file. That is what you need.","category":"page"},{"location":"ch07/swing.html","page":"Analytical continuation for self-energy","title":"Analytical continuation for self-energy","text":"note: Note\nThe HIBISCUS/swing code does not support multi-orbital models. So if you want to use it to post-process multi-orbital systems, you have to split the self-energy function at first by youself. Once the analytical continuation is finished, you have to combine the different sigr.dat or sigr_linear.dat files to a single file. It is a trivial task. ","category":"page"},{"location":"ch07/ups.html#toolbox/makeups","page":"toolbox/makeups","title":"toolbox/makeups","text":"","category":"section"},{"location":"ch07/ups.html","page":"toolbox/makeups","title":"toolbox/makeups","text":"Introduction","category":"page"},{"location":"ch07/ups.html","page":"toolbox/makeups","title":"toolbox/makeups","text":"The makeups code is often used to postprocess the spectral function data to compare with the XAS and UPS experiments. ","category":"page"},{"location":"ch07/ups.html","page":"toolbox/makeups","title":"toolbox/makeups","text":"The Fermi-Dirac function:","category":"page"},{"location":"ch07/ups.html","page":"toolbox/makeups","title":"toolbox/makeups","text":"f_T(omega) = frac11+e^fracomega-muk_BT","category":"page"},{"location":"ch07/ups.html","page":"toolbox/makeups","title":"toolbox/makeups","text":"The theoretical PES:","category":"page"},{"location":"ch07/ups.html","page":"toolbox/makeups","title":"toolbox/makeups","text":"A_textPES(omega) = A(omega) f_T(omega)","category":"page"},{"location":"ch07/ups.html","page":"toolbox/makeups","title":"toolbox/makeups","text":"The theoretical PES with Gaussian broadening:","category":"page"},{"location":"ch07/ups.html","page":"toolbox/makeups","title":"toolbox/makeups","text":"tildeA_textPES(omega) = int domega frac1sqrt2pisigma e^frac(omega-omega)^22sigma^2A_textPES(omega)","category":"page"},{"location":"ch07/ups.html","page":"toolbox/makeups","title":"toolbox/makeups","text":"The theoretical XAS:","category":"page"},{"location":"ch07/ups.html","page":"toolbox/makeups","title":"toolbox/makeups","text":"A_textXAS(omega) = A(omega)f_T(-omega)","category":"page"},{"location":"ch07/ups.html","page":"toolbox/makeups","title":"toolbox/makeups","text":"Usage","category":"page"},{"location":"ch07/ups.html","page":"toolbox/makeups","title":"toolbox/makeups","text":"$ ./mups","category":"page"},{"location":"ch07/ups.html","page":"toolbox/makeups","title":"toolbox/makeups","text":"Input:","category":"page"},{"location":"ch07/ups.html","page":"toolbox/makeups","title":"toolbox/makeups","text":"See the terminal prompt\nmem.dos.dat (necessary)","category":"page"},{"location":"ch07/ups.html","page":"toolbox/makeups","title":"toolbox/makeups","text":"note: Note\nAbout the smearing parameter sigma:  The standard deviation smearing parameter was chosen to be in the same range as estimates of experimental resolution (which are around 0.1 for high resolution PES, and approximately 0.2 to 0.4 for XAS. A good test to decide if the broadening is correct is the comparison of the Fermi edge in theory and experiment.About the beta parameter beta (equiv 1T): The beta parameter practically plays no role if one uses the Fermi function at the experimental temperature or at the temperature of the CT-QMC calculations.","category":"page"},{"location":"ch07/ups.html","page":"toolbox/makeups","title":"toolbox/makeups","text":"Output","category":"page"},{"location":"ch07/ups.html","page":"toolbox/makeups","title":"toolbox/makeups","text":"ups.pes.dat\nups.xas.dat","category":"page"},{"location":"ch07/ups.html","page":"toolbox/makeups","title":"toolbox/makeups","text":"Comment","category":"page"},{"location":"ch07/ups.html","page":"toolbox/makeups","title":"toolbox/makeups","text":"Now this code is interfaced with the HIBISCUS/entropy code merely. It can read the mem.dos.dat file as input data. While to interface it with the others code, such as HIBISCUS/stoch code, is straightforward. What you need to do is just to rename sac.imsum.dat to mem.dos.dat file, and then supplement the lost orbital-dependent data.","category":"page"},{"location":"ch04/out_hub.html#solver.hub.dat","page":"solver.hub.dat","title":"solver.hub.dat","text":"","category":"section"},{"location":"ch04/out_hub.html","page":"solver.hub.dat","title":"solver.hub.dat","text":"Introduction","category":"page"},{"location":"ch04/out_hub.html","page":"solver.hub.dat","title":"solver.hub.dat","text":"This file is used to save the atomic self-energy function Sigma_textatomic(iomega_n) and Green's function G_textatomic(iomega_n), which are calculated using the Hubbard-I approximation. It will be output by the quantum impurity solvers when they are shut down.","category":"page"},{"location":"ch04/out_hub.html","page":"solver.hub.dat","title":"solver.hub.dat","text":"Format","category":"page"},{"location":"ch04/out_hub.html","page":"solver.hub.dat","title":"solver.hub.dat","text":"The solver.hub.dat file contains norbs block. Each block is appended by two blank lines. The format of each block is as follows:","category":"page"},{"location":"ch04/out_hub.html","page":"solver.hub.dat","title":"solver.hub.dat","text":"","category":"page"},{"location":"ch04/out_hub.html","page":"solver.hub.dat","title":"solver.hub.dat","text":"column 1: orbital index i, integer","category":"page"},{"location":"ch04/out_hub.html","page":"solver.hub.dat","title":"solver.hub.dat","text":"column 2: Matsubara frequency point, omega_n, double precision","category":"page"},{"location":"ch04/out_hub.html","page":"solver.hub.dat","title":"solver.hub.dat","text":"column 3: atomic Green's function, Re G_textatomic(iomega_n), double precision","category":"page"},{"location":"ch04/out_hub.html","page":"solver.hub.dat","title":"solver.hub.dat","text":"column 4: atomic Green's function, Im G_textatomic(iomega_n), double precision","category":"page"},{"location":"ch04/out_hub.html","page":"solver.hub.dat","title":"solver.hub.dat","text":"column 5: atomic self-energy function, Re Sigma_textatomic(iomega_n), double precision","category":"page"},{"location":"ch04/out_hub.html","page":"solver.hub.dat","title":"solver.hub.dat","text":"column 6: atomic self-energy function, Im Sigma_textatomic(iomega_n), double precision","category":"page"},{"location":"ch04/out_hub.html","page":"solver.hub.dat","title":"solver.hub.dat","text":"","category":"page"},{"location":"ch04/out_hub.html","page":"solver.hub.dat","title":"solver.hub.dat","text":"note: Note\nIn the solver.hub.dat file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots That is to say, the spin up part is always before the spin down part.","category":"page"},{"location":"ch04/out_hub.html","page":"solver.hub.dat","title":"solver.hub.dat","text":"Code","category":"page"},{"location":"ch04/out_hub.html","page":"solver.hub.dat","title":"solver.hub.dat","text":"The corresponding Fortran code block for the writing of solver.hub.dat file is as follows:","category":"page"},{"location":"ch04/out_hub.html","page":"solver.hub.dat","title":"solver.hub.dat","text":"! open data file: solver.hub.dat\n     open(mytmp, file='solver.hub.dat', form='formatted', status='unknown')\n\n! write it\n     do i=1,norbs\n         do j=1,mfreq\n             write(mytmp,'(i6,5f16.8)') i, rmesh(j), &\n                  real(ghub(j,i)), aimag(ghub(j,i)), &\n                  real(shub(j,i)), aimag(shub(j,i))\n         enddo ! over j={1,mfreq} loop\n         write(mytmp,*) ! write empty lines\n         write(mytmp,*)\n     enddo ! over i={1,norbs} loop\n\n! close data file\n     close(mytmp)","category":"page"},{"location":"ch04/out_hub.html","page":"solver.hub.dat","title":"solver.hub.dat","text":"In the HIBISCUS component, we provide a Python module to read the output files of quantum impurity solvers. You can use it to read the solver.hub.dat file. Refer to script/u_reader.py for more details.","category":"page"},{"location":"ch07/README.html#Auxiliary-tools","page":"README","title":"Auxiliary tools","text":"","category":"section"},{"location":"ch07/README.html","page":"README","title":"README","text":"In the HIBISCUS component, many auxiliary tools are provided to deal with the input/output data of the CT-HYB quantum impurity solvers. Here we briefly describe some of these tools.","category":"page"},{"location":"ch07/README.html","page":"README","title":"README","text":"Maximum entropy method // HIBISCUS/entropy code.\nStochastic analytical continuation // HIBISCUS/stoch code.\nAnalytical continuation for self-energy // HIBISCUS/swing code.\nToolbox // HIBISCUS/toolbox codes.\nScripts // HIBISCUS/scripts codes.","category":"page"},{"location":"ch07/README.html","page":"README","title":"README","text":"In principle, the JASMINE component (an atomic eigenvalue problem solver) is also an auxiliary tool for the CT-HYB quantum impurity solvers. Since it is very important, we introduce it in chapter Atomic eigenvalue problem solver individually.","category":"page"},{"location":"ch06/p_nspin.html#Parameter:-nspin","page":"nspin","title":"Parameter: nspin","text":"","category":"section"},{"location":"ch06/p_nspin.html","page":"nspin","title":"nspin","text":"warning: Warning\nPlease DO NOT modify it.","category":"page"},{"location":"ch06/p_nspin.html","page":"nspin","title":"nspin","text":"Definition:","category":"page"},{"location":"ch06/p_nspin.html","page":"nspin","title":"nspin","text":"Number of spin projection.","category":"page"},{"location":"ch06/p_nspin.html","page":"nspin","title":"nspin","text":"Type","category":"page"},{"location":"ch06/p_nspin.html","page":"nspin","title":"nspin","text":"Integer","category":"page"},{"location":"ch06/p_nspin.html","page":"nspin","title":"nspin","text":"Default value","category":"page"},{"location":"ch06/p_nspin.html","page":"nspin","title":"nspin","text":"2","category":"page"},{"location":"ch06/p_nspin.html","page":"nspin","title":"nspin","text":"Component","category":"page"},{"location":"ch06/p_nspin.html","page":"nspin","title":"nspin","text":"Only for the JASMINE component.","category":"page"},{"location":"ch06/p_nspin.html","page":"nspin","title":"nspin","text":"Behavior","category":"page"},{"location":"ch06/p_nspin.html","page":"nspin","title":"nspin","text":"Determine the size of involved arrays.","category":"page"},{"location":"ch06/p_nspin.html","page":"nspin","title":"nspin","text":"Comment","category":"page"},{"location":"ch06/p_nspin.html","page":"nspin","title":"nspin","text":"See nband, norbs, and ncfgs parameters.","category":"page"},{"location":"ch08/basic.html#Basic-applications","page":"README","title":"Basic applications","text":"","category":"section"},{"location":"ch08/basic.html","page":"README","title":"README","text":"Well, are you newbie to the iQIST software package? ","category":"page"},{"location":"ch08/basic.html","page":"README","title":"README","text":"Don't worry! ","category":"page"},{"location":"ch08/basic.html","page":"README","title":"README","text":"In this section, we will help you to be familiar with it step by step. The examples shown in this section are very simple. It is easy to finish them within a few hours under normal conditions. Now please start your computer, and let's go!","category":"page"},{"location":"ch08/basic.html","page":"README","title":"README","text":"Hello iQIST!\nMott metal-insulator transition","category":"page"},{"location":"ch04/p_issun.html#Parameter:-issun","page":"issun","title":"Parameter: issun","text":"","category":"section"},{"location":"ch04/p_issun.html","page":"issun","title":"issun","text":"Definition","category":"page"},{"location":"ch04/p_issun.html","page":"issun","title":"issun","text":"Key control flag, it is used to determine the symmetry of bands/orbitals.","category":"page"},{"location":"ch04/p_issun.html","page":"issun","title":"issun","text":"Type","category":"page"},{"location":"ch04/p_issun.html","page":"issun","title":"issun","text":"Integer","category":"page"},{"location":"ch04/p_issun.html","page":"issun","title":"issun","text":"Default value","category":"page"},{"location":"ch04/p_issun.html","page":"issun","title":"issun","text":"2","category":"page"},{"location":"ch04/p_issun.html","page":"issun","title":"issun","text":"Component","category":"page"},{"location":"ch04/p_issun.html","page":"issun","title":"issun","text":"ALL","category":"page"},{"location":"ch04/p_issun.html","page":"issun","title":"issun","text":"Behavior","category":"page"},{"location":"ch04/p_issun.html","page":"issun","title":"issun","text":"There are two possible values for the issun parameter so far:","category":"page"},{"location":"ch04/p_issun.html","page":"issun","title":"issun","text":"issun = 1, the bands are not symmetrized.\nissun = 2, the bands are symmetrized according to symmetry matrix symm.","category":"page"},{"location":"ch04/p_issun.html","page":"issun","title":"issun","text":"The quantum impurity solvers will symmetrize the relevant physical quantities according to the issun parameter.","category":"page"},{"location":"ch04/p_issun.html","page":"issun","title":"issun","text":"Comment","category":"page"},{"location":"ch04/p_issun.html","page":"issun","title":"issun","text":"There is still one question. What's the symmetry matrix and where is it? ","category":"page"},{"location":"ch04/p_issun.html","page":"issun","title":"issun","text":"In fact, we should call it symmetry vector, instead of symmetry matrix. It is an integer vector whose size is exact norbs. The quantum impurity solvers will use it to perform symmetrization. Let's suppose this vector is called symm. For example, there is a 5-band model, the symmetry vector is as follows:","category":"page"},{"location":"ch04/p_issun.html","page":"issun","title":"issun","text":"symm(01) = 1\nsymm(02) = 2\nsymm(03) = 3\nsymm(04) = 4\nsymm(05) = 4\nsymm(06) = 4\nsymm(07) = 5\nsymm(08) = 5\nsymm(09) = 5\nsymm(10) = 1","category":"page"},{"location":"ch04/p_issun.html","page":"issun","title":"issun","text":"Guess which orbitals are degenerated?","category":"page"},{"location":"ch04/p_issun.html","page":"issun","title":"issun","text":"ehh, the orbitals 1 and 10, since symm(01) and symm(10) are all 1. Similarly, the orbitals 4, 5, and 6 are degenerated. The orbitals 7, 8, and 9 are degenerated as well.","category":"page"},{"location":"ch04/p_issun.html","page":"issun","title":"issun","text":"Yes, you are right. The quantum impurity solvers will consider that those orbitals which have the same symmetry number (the element of symm) are degenerated. ","category":"page"},{"location":"ch04/p_issun.html","page":"issun","title":"issun","text":"By default, the elements in symm vector are 1. In other words, if issun = 2, all of the orbitals are degenerated. If you want to re-assign the degenerated orbitals, you can edit the solver.eimp.in file. See solver.eimp.in for more details.","category":"page"},{"location":"ch02/full.html#Build-iQIST-at-one-step","page":"Build iQIST at one step","title":"Build iQIST at one step","text":"","category":"section"},{"location":"ch02/full.html","page":"Build iQIST at one step","title":"Build iQIST at one step","text":"When the system is ready and the compiling environment is configured correctly, you can try to compile the iQIST software package right now. Let's start now.","category":"page"},{"location":"ch02/full.html","page":"Build iQIST at one step","title":"Build iQIST at one step","text":"$ cd iqist/build\n$ editor make.sys\n$ make all\n$ ./x_setup.sh","category":"page"},{"location":"ch02/full.html","page":"Build iQIST at one step","title":"Build iQIST at one step","text":"note: Note\nHere editor means any ascii text editor you prefer. The vim is our favorite.","category":"page"},{"location":"ch02/full.html","page":"Build iQIST at one step","title":"Build iQIST at one step","text":"After a few minutes (it depends on the performance of your system), if everything is OK you will find some executable programs in the iqist/build directory, which means the compiling is completed. Now all of the components of the iQIST software package are successfully built. Congratulations! You can start to enjoy using iQIST and begin with your great research!","category":"page"},{"location":"ch02/full.html","page":"Build iQIST at one step","title":"Build iQIST at one step","text":"However, don't get frustrated once the compiling fails. It is wise for you to type the following command in the terminal:","category":"page"},{"location":"ch02/full.html","page":"Build iQIST at one step","title":"Build iQIST at one step","text":"$ make clean","category":"page"},{"location":"ch02/full.html","page":"Build iQIST at one step","title":"Build iQIST at one step","text":"Then you go to check and correct the make.sys file, fix the other system-related issues, and repeat the above procedures. We are sure that you will solve this problem successfully.","category":"page"},{"location":"ch02/full.html","page":"Build iQIST at one step","title":"Build iQIST at one step","text":"Do you expect a more controllable compiling procedure? Some other great ideas are given in the next section.","category":"page"},{"location":"ch01/what.html#What's-iQIST?","page":"What's iQIST?","title":"What's iQIST?","text":"","category":"section"},{"location":"ch01/what.html","page":"What's iQIST?","title":"What's iQIST?","text":"The Interacting Quantum Impurity Solver Toolkit (dubbed iQIST) is an open source software package aiming to provide a full, reliable, flexible, and powerful tool chain for various quantum impurity models. The major objective of iQIST is to be the core (computational) engine of the dynamical mean-field theory and its extensions.","category":"page"},{"location":"ch01/what.html","page":"What's iQIST?","title":"What's iQIST?","text":"The iQIST software package offers a few continuous-time quantum Monte Carlo impurity solvers (hybridization expansion version), a Hirsch-Fye quantum Monte Carlo impurity solver, and numerous prep-processed and post-processed tools. Selected applications and plugins on top of it are also provided. It is an all-in-one software package. With it you can solve quantum impurity models and analyze the calculated results easily and efficiently. Of course, you can extend it or build complicated programs with it to fit your special requirements.","category":"page"},{"location":"ch01/what.html","page":"What's iQIST?","title":"What's iQIST?","text":"(Image: logo image)","category":"page"},{"location":"ch01/what.html","page":"What's iQIST?","title":"What's iQIST?","text":"Figure | The logo of the iQIST software package.","category":"page"},{"location":"ch04/p_nleja.html#Parameter:-nleja","page":"nleja","title":"Parameter: nleja","text":"","category":"section"},{"location":"ch04/p_nleja.html","page":"nleja","title":"nleja","text":"Definition","category":"page"},{"location":"ch04/p_nleja.html","page":"nleja","title":"nleja","text":"In the CAMELLIA component, we used the Newton-Leja interpolation algorithm to evaluate the local operator trace. Specially, the real leja points are used in the newton interpolation to evaluate ","category":"page"},{"location":"ch04/p_nleja.html","page":"nleja","title":"nleja","text":"exp( -tau H ) vrangle","category":"page"},{"location":"ch04/p_nleja.html","page":"nleja","title":"nleja","text":"efficiently. Here H is the local Hamiltonian, vrangle the propagated vector, tau imaginary-time point. The nleja parameter is a key parameter to control the Newton-Leja algorithm. It means the maximum number of real leja points. ","category":"page"},{"location":"ch04/p_nleja.html","page":"nleja","title":"nleja","text":"Type","category":"page"},{"location":"ch04/p_nleja.html","page":"nleja","title":"nleja","text":"Integer","category":"page"},{"location":"ch04/p_nleja.html","page":"nleja","title":"nleja","text":"Default value","category":"page"},{"location":"ch04/p_nleja.html","page":"nleja","title":"nleja","text":"64","category":"page"},{"location":"ch04/p_nleja.html","page":"nleja","title":"nleja","text":"Component","category":"page"},{"location":"ch04/p_nleja.html","page":"nleja","title":"nleja","text":"Only for the CAMELLIA component.","category":"page"},{"location":"ch04/p_nleja.html","page":"nleja","title":"nleja","text":"Behavior","category":"page"},{"location":"ch04/p_nleja.html","page":"nleja","title":"nleja","text":"Determine the size of involved arrays.","category":"page"},{"location":"ch04/p_nleja.html","page":"nleja","title":"nleja","text":"This Newton-Leja algorithm is unstable. Sometimes it is not easy to obtain convergence with the given leja points. At that time, you can increase nleja and redo the calculation.","category":"page"},{"location":"ch04/p_nleja.html","page":"nleja","title":"nleja","text":"Comment","category":"page"},{"location":"ch04/p_nleja.html","page":"nleja","title":"nleja","text":"The CAMELLIA component is not ready now.","category":"page"},{"location":"ch06/README.html#Atomic-eigenvalue-problem-solver","page":"README","title":"Atomic eigenvalue problem solver","text":"","category":"section"},{"location":"ch06/README.html","page":"README","title":"README","text":"The atomic eigenvalue problem solver is an important preprocessing tool for the general matrix version CT-HYB quantum impurity solvers. The purpose of it is to diagonalize the atomic Hamiltonian to obtain the eigenvalues and eigenvectors, which are essential input for some CT-HYB impurity solvers. In this chapter, we will introduce the JASMINE component, which is the only atomic eigenvalue problem solver in the iQIST software package. It should be used together with the BEGONIA, LAVENDER, CAMELLIA, PANSY, and MANJUSHAKA components.","category":"page"},{"location":"ch06/README.html","page":"README","title":"README","text":"The main topics are as follows:","category":"page"},{"location":"ch06/README.html","page":"README","title":"README","text":"Standard input files // Input stuffs.\nStandard output files // Output stuffs.\nParameters // Really a reference manual.","category":"page"},{"location":"ch06/README.html","page":"README","title":"README","text":"Maybe you are interested in the following related topics:","category":"page"},{"location":"ch06/README.html","page":"README","title":"README","text":"Getting started // To teach you how to setup and use the iQIST software package.\nQuantum Monte Carlo impurity solvers // Another reference manual.\nAuxiliary tools // The companion of quantum impurity solvers.\nApplication programming interfaces // Write your own Python/Fortran codes.\niQIST in action // Some lightweight tutorials.\nInside iQIST // Unleashing the secrets inside the iQIST.","category":"page"},{"location":"ch06/README.html","page":"README","title":"README","text":"See also:","category":"page"},{"location":"ch06/README.html","page":"README","title":"README","text":"Besides the above links, you can find many useful examples/cases under the iqist/working/tools/jasmine directory.","category":"page"},{"location":"ch05/README.html#Applications","page":"README","title":"Applications","text":"","category":"section"},{"location":"ch05/README.html","page":"README","title":"README","text":"Together with the iQIST software package, we further provide a few important applications in order to demonstrate the powerfulness and usefulness of it. These applications are built on top of the iQIST code. They are coupled with the iQIST tightly. Especially, they strongly rely on the common service subroutine library (CSSL) and common service module library (CSML) in the iQIST. All of the applications are in production. You can use them in realistic research. We hope that these applications will be helpful for you. ","category":"page"},{"location":"ch05/README.html","page":"README","title":"README","text":"Now the iQIST software package only contain two applications. They are:","category":"page"},{"location":"ch05/README.html","page":"README","title":"README","text":"DFT + DMFT // To deal with the electronic structures of realistic strongly correlated materials.\nLadder dual fermions // A diagrammatic extension of the single-site dynamical mean-field theory.","category":"page"},{"location":"ch05/README.html","page":"README","title":"README","text":"Enjoy them.","category":"page"},{"location":"ch08/osmt.html#Orbital-selective-Mott-transition-in-two-band-Hubbard-model","page":"Orbital-selective Mott transition in two-band Hubbard model","title":"Orbital-selective Mott transition in two-band Hubbard model","text":"","category":"section"},{"location":"ch04/out_lmat.html#solver.lmat.dat","page":"solver.lmat.dat","title":"solver.lmat.dat","text":"","category":"section"},{"location":"ch04/out_lmat.html","page":"solver.lmat.dat","title":"solver.lmat.dat","text":"Introduction","category":"page"},{"location":"ch04/out_lmat.html","page":"solver.lmat.dat","title":"solver.lmat.dat","text":"The solver.lmat.dat file is used to store the necessary data used to build the generalized fidelity susceptibility chi_textFS, which can be calculated via chi_textFS = langle k_L k_R rangle - langle k_L rangle langle k_R rangle. It will be output by the quantum impurity solvers when they are shut down.","category":"page"},{"location":"ch04/out_lmat.html","page":"solver.lmat.dat","title":"solver.lmat.dat","text":"note: Note\nOnly the GARDENIA, NARCISSUS, CAMELLIA, LAVENDER, and MANJUSHAKA components can generate the solver.lmat.dat file.","category":"page"},{"location":"ch04/out_lmat.html","page":"solver.lmat.dat","title":"solver.lmat.dat","text":"Format","category":"page"},{"location":"ch04/out_lmat.html","page":"solver.lmat.dat","title":"solver.lmat.dat","text":"The solver.lmat.dat file contains two blocks. One is for the langle k_L rangle and langle k_R rangle data, and another one is for the langle k_L k_R rangle. In each block, the error bar data are always shown in the rightmost column.","category":"page"},{"location":"ch04/out_lmat.html","page":"solver.lmat.dat","title":"solver.lmat.dat","text":"note: Note\nIn the solver.lmat.dat file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch04/out_lmat.html","page":"solver.lmat.dat","title":"solver.lmat.dat","text":"Code","category":"page"},{"location":"ch04/out_lmat.html","page":"solver.lmat.dat","title":"solver.lmat.dat","text":"The corresponding Fortran code block for the writing of solver.lmat.dat file is as follows:","category":"page"},{"location":"ch04/out_lmat.html","page":"solver.lmat.dat","title":"solver.lmat.dat","text":"! open data file: solver.lmat.dat\n     open(mytmp, file='solver.lmat.dat', form='formatted', status='unknown')\n\n! write it\n     write(mytmp,'(a)') '# < k_l > < k_r > data:'\n     do i=1,norbs\n         write(mytmp,'(i6,4f12.6)') i, lmat(i), rmat(i), lerr(i), rerr(i)\n     enddo ! over i={1,norbs} loop\n     write(mytmp,'(a6,2f12.6)') 'l_sum', sum( lmat ), sum( lerr )\n     write(mytmp,'(a6,2f12.6)') 'r_sum', sum( rmat ), sum( rerr )\n\n     write(mytmp,'(a)') '# < k_l k_r > data:'\n     do i=1,norbs\n         do j=1,norbs\n             write(mytmp,'(2i6,2f12.6)') i, j, lrmat(i,j), lrerr(i,j)\n         enddo ! over j={1,norbs} loop\n     enddo ! over i={1,norbs} loop\n     write(mytmp,'(a6,2f12.6)') 'lrsum', sum( lrmat ), sum( lrerr )\n     write(mytmp,'(a6,2f12.6)') 'fidel', f_val, f_err\n\n! close data file\n     close(mytmp)","category":"page"},{"location":"ch04/out_lmat.html","page":"solver.lmat.dat","title":"solver.lmat.dat","text":"In the HIBISCUS component, we provide a Python module to read the output files of quantum impurity solvers. You can use it to read the solver.lmat.dat file. See script/u_reader.py for more details.","category":"page"},{"location":"team.html#The-iQIST-Developer-Team","page":"Team","title":"The iQIST Developer Team","text":"","category":"section"},{"location":"team.html","page":"Team","title":"Team","text":"Core Developers:","category":"page"},{"location":"team.html","page":"Team","title":"Team","text":"Li Huang^dagger and Yilin Wang^dagger ","category":"page"},{"location":"team.html","page":"Team","title":"Team","text":"Key Contributors:","category":"page"},{"location":"team.html","page":"Team","title":"Team","text":"Zi Yang Meng^dagger, Haiyan Lu^daggerddagger, and Liang Du^rceil","category":"page"},{"location":"team.html","page":"Team","title":"Team","text":"Directors and Supervisors: ","category":"page"},{"location":"team.html","page":"Team","title":"Team","text":"Philipp Werner^ and Xi Dai^dagger","category":"page"},{"location":"team.html","page":"Team","title":"Team","text":"^dagger Institute of Materials, China Academy of Engineering Physics, Sichuan Jiangyou 621900, China","category":"page"},{"location":"team.html","page":"Team","title":"Team","text":"^ddagger Beijing National Laboratory for Condensed Matter Physics, and Institute of Physics, Chinese Academy of Sciences, Beijing 100190, China","category":"page"},{"location":"team.html","page":"Team","title":"Team","text":"^rceil Department of Physics, The University of Texas at Austin, Austin, Texas 78712, USA","category":"page"},{"location":"team.html","page":"Team","title":"Team","text":"^ Department of Physics, University of Fribourg, 1700 Fribourg, Switzerland","category":"page"},{"location":"team.html","page":"Team","title":"Team","text":"tip: FUNDINGS\nThis project has been financed by the following fundings:DARPA Grant No. D13AP00052 (LD)\nSwiss National Science Foundation, Grant No. 200021_140648 (PW, LH)\nNational Science Foundation of China, No. 2011CBA00108 (XD, YLW, HYL)\nNational Science Foundation of China, No. 11504340 (LH)","category":"page"},{"location":"ch06/out_emat.html#atom.emat.dat","page":"atom.emat.dat","title":"atom.emat.dat","text":"","category":"section"},{"location":"ch06/out_emat.html","page":"atom.emat.dat","title":"atom.emat.dat","text":"Introduction","category":"page"},{"location":"ch06/out_emat.html","page":"atom.emat.dat","title":"atom.emat.dat","text":"The atom.emat.dat file contains the on-site impurity level energy on natural basis.","category":"page"},{"location":"ch06/out_emat.html","page":"atom.emat.dat","title":"atom.emat.dat","text":"Format","category":"page"},{"location":"ch06/out_emat.html","page":"atom.emat.dat","title":"atom.emat.dat","text":"The format of the atom.emat.dat file is as follows:","category":"page"},{"location":"ch06/out_emat.html","page":"atom.emat.dat","title":"atom.emat.dat","text":"","category":"page"},{"location":"ch06/out_emat.html","page":"atom.emat.dat","title":"atom.emat.dat","text":"column 1: orbital index alpha, integer","category":"page"},{"location":"ch06/out_emat.html","page":"atom.emat.dat","title":"atom.emat.dat","text":"column 2: On-site impurity energy level E_alphaalpha, real part, double precision","category":"page"},{"location":"ch06/out_emat.html","page":"atom.emat.dat","title":"atom.emat.dat","text":"column 3: On-site impurity energy level E_alphaalpha, imaginary part, double precision","category":"page"},{"location":"ch06/out_emat.html","page":"atom.emat.dat","title":"atom.emat.dat","text":"","category":"page"},{"location":"ch06/out_emat.html","page":"atom.emat.dat","title":"atom.emat.dat","text":"note: Note\nIn the atom.emat.dat file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch06/out_emat.html","page":"atom.emat.dat","title":"atom.emat.dat","text":"Code","category":"page"},{"location":"ch06/out_emat.html","page":"atom.emat.dat","title":"atom.emat.dat","text":"The corresponding Fortran code block for the writing of the atom.emat.dat file is as follows:","category":"page"},{"location":"ch06/out_emat.html","page":"atom.emat.dat","title":"atom.emat.dat","text":"! open file atom.emat.dat to write\n     open(mytmp, file='atom.emat.dat', form='formatted', status='unknown')\n\n! write the header\n     write(mytmp,'(75a1)') dash ! dashed line\n     write(mytmp,'(a)') '# i | emat_real | emat_imag'\n     write(mytmp,'(75a1)') dash ! dashed line\n\n! write the data\n     do i=1,norbs\n         if ( isoc == 0 ) then\n             if ( i <= nband ) then\n                 s_order = 2*i-1\n             else\n                 s_order = 2*(i-nband)\n             endif ! back if ( i <= nband ) block\n         else\n             s_order = i\n         endif ! back if ( isoc == 0 ) block\n         write(mytmp,'(i6,2f16.8)') i, emat(s_order,s_order)\n     enddo ! over i={1,norbs} loop\n\n! close data file\n     close(mytmp)","category":"page"},{"location":"ch06/out_emat.html","page":"atom.emat.dat","title":"atom.emat.dat","text":"In principle, it is a complex matrix. Here we only write its diagonal part.","category":"page"},{"location":"ch06/out_emat.html","page":"atom.emat.dat","title":"atom.emat.dat","text":"See also atom.emat.in for more details.","category":"page"},{"location":"ch07/writer.html#script/u_writer.py","page":"script/u_writer.py","title":"script/u_writer.py","text":"","category":"section"},{"location":"ch07/writer.html","page":"script/u_writer.py","title":"script/u_writer.py","text":"Introduction","category":"page"},{"location":"ch07/writer.html","page":"script/u_writer.py","title":"script/u_writer.py","text":"The purpose of this script is provide an easy-to-use interface to write/dump necessary input files for the quantum impurity solver components.","category":"page"},{"location":"ch07/writer.html","page":"script/u_writer.py","title":"script/u_writer.py","text":"Type","category":"page"},{"location":"ch07/writer.html","page":"script/u_writer.py","title":"script/u_writer.py","text":"Python module","category":"page"},{"location":"ch07/writer.html","page":"script/u_writer.py","title":"script/u_writer.py","text":"APIs","category":"page"},{"location":"ch07/writer.html","page":"script/u_writer.py","title":"script/u_writer.py","text":"class iqistWriter(object):\n    \"\"\" This class provide a few static methods which are used to write\n        the necessary input data for the ctqmc impurity solvers and hfqmc\n        impurity solver.\n\n        Why do we need this class? Because sometimes it is not convenient\n        to call the Python API for iQIST directly. Using this class, we\n        can ensure the input file format is correct.\n    \"\"\"\n\n    @staticmethod\n    def out_hyb(norbs, mfreq, rmesh, hybf, fileName = None):\n        \"\"\" try to write the hybridization function to the solver.hyb.in\n            file, only suitable for the ctqmc impurity solver\n        \"\"\"\n\n    @staticmethod\n    def out_wss(norbs, mfreq, rmesh, wssf, fileName = None):\n        \"\"\" try to write the bath weiss's function to the solver.wss.in\n            file, only suitable for the hfqmc impurity solver\n        \"\"\"\n\n    @staticmethod\n    def out_eimp(norbs, symm, eimp, fileName = None):\n        \"\"\" try to write the impurity levels and symmetry vector to the\n            solver.eimp.in file\n        \"\"\"\n\n    @staticmethod\n    def out_umat(norbs, umat, fileName = None):\n        \"\"\" try to write the Coulomb matrix to the solver.umat.in file,\n            only suitable for the ctqmc impurity solver\n        \"\"\"\n\n    @staticmethod\n    def out_ktau(ntime, tmesh, ktau, ptau, fileName = None):\n        \"\"\" try to write the screening function K(\\tau) and its first\n            derivates to the solver.ktau.in file, only suitable for the\n            ctqmc impurity solver (narcissus)\n        \"\"\"","category":"page"},{"location":"ch07/writer.html","page":"script/u_writer.py","title":"script/u_writer.py","text":"Examples","category":"page"},{"location":"ch07/writer.html","page":"script/u_writer.py","title":"script/u_writer.py","text":"# import this module\nfrom u_writer import *\n\n# setup parameters\nnorbs = 2\nntime = 1024\nmfreq = 8193\n\n# build rmesh, hybf, wssf, symm, eimp, umat, tmesh, ktau and ptau\n...\n\n# write the data\niqistWriter.out_hyb(norbs, mfreq, rmesh, hybf)\niqistWriter.out_wss(norbs, mfreq, rmesh, wssf)\niqistWriter.out_eimp(norbs, symm, eimp)\niqistWriter.out_umat(norbs, umat)\niqistWriter.out_ktau(ntime, tmesh, ktau, ptau)","category":"page"},{"location":"ch07/writer.html","page":"script/u_writer.py","title":"script/u_writer.py","text":"note: Note\nYou can not execute u_writer.py in the terminal or Python environment directly, like this:$ python u_writer.py","category":"page"},{"location":"ch07/writer.html","page":"script/u_writer.py","title":"script/u_writer.py","text":"Comment","category":"page"},{"location":"ch07/writer.html","page":"script/u_writer.py","title":"script/u_writer.py","text":"N/A","category":"page"},{"location":"ch04/p_uv.html#Parameter:-Uv","page":"Uv","title":"Parameter: Uv","text":"","category":"section"},{"location":"ch04/p_uv.html","page":"Uv","title":"Uv","text":"Definition","category":"page"},{"location":"ch04/p_uv.html","page":"Uv","title":"Uv","text":"Inter-orbital Coulomb interaction U_v.","category":"page"},{"location":"ch04/p_uv.html","page":"Uv","title":"Uv","text":"Type","category":"page"},{"location":"ch04/p_uv.html","page":"Uv","title":"Uv","text":"Float, double precision","category":"page"},{"location":"ch04/p_uv.html","page":"Uv","title":"Uv","text":"Default value","category":"page"},{"location":"ch04/p_uv.html","page":"Uv","title":"Uv","text":"4.0","category":"page"},{"location":"ch04/p_uv.html","page":"Uv","title":"Uv","text":"Component","category":"page"},{"location":"ch04/p_uv.html","page":"Uv","title":"Uv","text":"ALL, except for DAISY component.","category":"page"},{"location":"ch04/p_uv.html","page":"Uv","title":"Uv","text":"Behavior","category":"page"},{"location":"ch04/p_uv.html","page":"Uv","title":"Uv","text":"It is used to determine the Coulomb interaction matrix.","category":"page"},{"location":"ch04/p_uv.html","page":"Uv","title":"Uv","text":"Comment","category":"page"},{"location":"ch04/p_uv.html","page":"Uv","title":"Uv","text":"Actually, only the AZALEA, GARDENIA, NARCISSUS components need it. For the other quantum impurity solvers components (i.e., the CAMELLIA, BEGONIA, LAVENDER, MANJUSHAKA and PANSY components), the information about the Coulomb interaction matrix is imported via the atom.cix file. So you can set it to any values for the latter five components.","category":"page"},{"location":"ch04/p_uv.html","page":"Uv","title":"Uv","text":"Usually, the U_c, U_v and J_z should satisfy the following relation:","category":"page"},{"location":"ch04/p_uv.html","page":"Uv","title":"Uv","text":"beginequation\nU_c = U_v - 2J_z\nendequation","category":"page"},{"location":"ch04/p_uv.html","page":"Uv","title":"Uv","text":"See also Uc, Jz parameters for more details.","category":"page"},{"location":"ch04/p_uv.html","page":"Uv","title":"Uv","text":"note: Note\nFor the AZALEA, GARDENIA, NARCISSUS components, the Coulomb interaction matrix can be imported via the solver.umat.in file which has the highest priority. See solver.umat.in for more details.","category":"page"},{"location":"ch04/p_jp.html#Parameter:-Jp","page":"Jp","title":"Parameter: Jp","text":"","category":"section"},{"location":"ch04/p_jp.html","page":"Jp","title":"Jp","text":"Definition","category":"page"},{"location":"ch04/p_jp.html","page":"Jp","title":"Jp","text":"Strength of the pair-hopping term in the interaction term, J_p.","category":"page"},{"location":"ch04/p_jp.html","page":"Jp","title":"Jp","text":"Type","category":"page"},{"location":"ch04/p_jp.html","page":"Jp","title":"Jp","text":"Float, double precision","category":"page"},{"location":"ch04/p_jp.html","page":"Jp","title":"Jp","text":"Default value","category":"page"},{"location":"ch04/p_jp.html","page":"Jp","title":"Jp","text":"0.0","category":"page"},{"location":"ch04/p_jp.html","page":"Jp","title":"Jp","text":"Component","category":"page"},{"location":"ch04/p_jp.html","page":"Jp","title":"Jp","text":"ALL, except for DAISY component.","category":"page"},{"location":"ch04/p_jp.html","page":"Jp","title":"Jp","text":"Behavior","category":"page"},{"location":"ch04/p_jp.html","page":"Jp","title":"Jp","text":"In principle, it is used to build the Coulomb interaction matrix. ","category":"page"},{"location":"ch04/p_jp.html","page":"Jp","title":"Jp","text":"But the AZALEA, GARDENIA, NARCISSUS components don't support general interaction, in other words, they don't support the J_p term in the local impurity Hamiltonian. ","category":"page"},{"location":"ch04/p_jp.html","page":"Jp","title":"Jp","text":"As for the CAMELLIA, BEGONIA, LAVENDER, MANJUSHAKA, and PANSY components, the Coulomb interaction matrix is not built within the quantum impurity solvers. All of the information is encapsulated in the atom.cix file. So they don't need the J_p parameter as well. ","category":"page"},{"location":"ch04/p_jp.html","page":"Jp","title":"Jp","text":"So, in summary, we don't use this parameter actually. You can set it to any values as you wish. But we strongly suggest to set it to the exact value.","category":"page"},{"location":"ch04/p_jp.html","page":"Jp","title":"Jp","text":"Comment","category":"page"},{"location":"ch04/p_jp.html","page":"Jp","title":"Jp","text":"See also Jz and Js for more details.","category":"page"},{"location":"ch04/out_term.html#Terminal-output","page":"Terminal output","title":"Terminal output","text":"","category":"section"},{"location":"ch04/out_term.html","page":"Terminal output","title":"Terminal output","text":"Introduction","category":"page"},{"location":"ch04/out_term.html","page":"Terminal output","title":"Terminal output","text":"At run time, the quantum impurity solvers will generate a lot of output in the terminal. We usually redirect the terminal output to an external disk file in order to facilitate further analysis. The terminal output contains a lot of useful information, where we can learn the status of the solvers and extract some important physical quantities.","category":"page"},{"location":"ch04/out_term.html","page":"Terminal output","title":"Terminal output","text":"Format","category":"page"},{"location":"ch04/out_term.html","page":"Terminal output","title":"Terminal output","text":"The format/structure of the terminal output is a bit complex. Next, let's take a typical terminal output as an example to illustrate how to get some useful information from it.","category":"page"},{"location":"ch04/out_term.html","page":"Terminal output","title":"Terminal output","text":"note: Note\nThe terminal outputs generated by various impurity solvers are somewhat different. But the main ingredients are similar.","category":"page"},{"location":"ch04/out_term.html","page":"Terminal output","title":"Terminal output","text":"The typical terminal output is as follows:","category":"page"},{"location":"ch04/out_term.html","page":"Terminal output","title":"Terminal output","text":"","category":"page"},{"location":"ch04/out_term.html","page":"Terminal output","title":"Terminal output","text":">>> Part 1:","category":"page"},{"location":"ch04/out_term.html","page":"Terminal output","title":"Terminal output","text":"  GARDENIA\n  >>> A DMFT Engine With Continuous Time Quantum Monte Carlo Impurity Solver\n\n  Version: 2015.01.06T (built at 01:24:09 Dec 17 2015)\n  Develop: by li huang (at IOP/CAS & SPCLab/CAEP & UNIFR)\n  Support: lihuang.dmft@gmail.com\n  License: GNU General Public License version 3\n\n  GARDENIA >>> start running at 14:29:29 Dec 17 2015\n  GARDENIA >>> parallelism: Yes >>> processors:   8\n\n  GARDENIA >>> parameters list:\n    isscf :         1    isbin :         2\n    issun :         2    isspn :         1\n    isort :         1    issus :        98\n    isvrt :         1\n    lemax :        32    legrd :     20001\n    chmax :        32    chgrd :     20001\n    mkink :      1024    mfreq :      8193\n    nband :         2    nspin :         2\n    norbs :         4    ncfgs :        16\n    niter :        20    nfreq :       128\n    nffrq :        32    nbfrq :         8\n    ntime :      1024    nflip :     20000\n    ntherm:   2000000    nsweep: 200000000\n    nclean:    100000    nwrite:  20000000\n    nmonte:       100    ncarlo:       100\n    U     :   4.40000    Uc    :   4.40000\n    Js    :   0.00000    Uv    :   2.20000\n    Jp    :   0.00000    Jz    :   1.10000\n    mune  :   3.85000    beta  :  50.00000\n    part  :   1.00000    temp  : 232.09010","category":"page"},{"location":"ch04/out_term.html","page":"Terminal output","title":"Terminal output","text":"It is the header of the terminal output. In this part, we can get the following messages:","category":"page"},{"location":"ch04/out_term.html","page":"Terminal output","title":"Terminal output","text":"The component we just used. Here it is the GARDENIA component.\nWhat is the version number is? And when was the compiling time of the code?\nWhat's the running mode? Is it parallel or sequential?\nWhen did the calculation start?\nHow many cores were used in the calculation?\nAll of the computational parameters. Are they reasonable?","category":"page"},{"location":"ch04/out_term.html","page":"Terminal output","title":"Terminal output","text":"","category":"page"},{"location":"ch04/out_term.html","page":"Terminal output","title":"Terminal output","text":">>> Part 2:","category":"page"},{"location":"ch04/out_term.html","page":"Terminal output","title":"Terminal output","text":"  GARDENIA >>> DMFT iter:999 <<< BINNING\n  GARDENIA >>> CTQMC quantum impurity solver running\n    nband :         2    Uc    :   4.40000\n    nspin :         2    Jz    :   1.10000\n\n    quantum impurity solver initializing\n    seed:  504449434\n    time:     3.401s\n\n    quantum impurity solver retrieving\n    time:     0.000s\n\n    quantum impurity solver warmming\n    time:     1.083s\n\n    quantum impurity solver sampling","category":"page"},{"location":"ch04/out_term.html","page":"Terminal output","title":"Terminal output","text":"In this part, we can get the following information:","category":"page"},{"location":"ch04/out_term.html","page":"Terminal output","title":"Terminal output","text":"Is the data binning activated?\nWhat's the random number seed?","category":"page"},{"location":"ch04/out_term.html","page":"Terminal output","title":"Terminal output","text":"note: Note\nThe random number seed is very important. With it we can recover the scene once a fatal error/exception occurs.","category":"page"},{"location":"ch04/out_term.html","page":"Terminal output","title":"Terminal output","text":"","category":"page"},{"location":"ch04/out_term.html","page":"Terminal output","title":"Terminal output","text":">>> Part 3:","category":"page"},{"location":"ch04/out_term.html","page":"Terminal output","title":"Terminal output","text":"  GARDENIA >>> iter:999 sweep: 200000000 of 2000000000\n    auxiliary system observables:\n    etot :   4.35130    epot :   4.38829\n    ekin :  -0.03698    <Sz> :   0.00001\n    <N1> :   2.00001    <N2> :   4.00076\n    <K2> :.62528E+01    <K3> :.59136E+02\n    <K4> :.71594E+03\n    insert kink statistics:\n    count:  89994172   3070561  86923611\n    ratio:   1.00000   0.03412   0.96588\n    remove kink statistics:\n    count:  90009856   3070563  86939293\n    ratio:   1.00000   0.03411   0.96589\n    lshift kink statistics:\n    count:   9996436    474388   9522048\n    ratio:   1.00000   0.04746   0.95254\n    rshift kink statistics:\n    count:   9999536    475572   9523964\n    ratio:   1.00000   0.04756   0.95244\n    global swap statistics:\n    count:        -1         0         0\n    ratio:   1.00000   0.00000   0.00000\n    global flip statistics:\n    count:     17943     17943         0\n    ratio:   1.00000   1.00000   0.00000\n    >>> quantum impurity solver status: normal\n    >>> used time:  4 m 48.46 s in current iteration.\n    >>> used time:  4 m 48.46 s in total iteration.","category":"page"},{"location":"ch04/out_term.html","page":"Terminal output","title":"Terminal output","text":"This is the most important part of the terminal output. The quantum impurity solvers will output this part every nwrite Monte Carlo sampling steps. So there are nsweep/nwrite similar parts in total. We usually extract useful data from the last part.","category":"page"},{"location":"ch04/out_term.html","page":"Terminal output","title":"Terminal output","text":"In this part, we can gain the following information:","category":"page"},{"location":"ch04/out_term.html","page":"Terminal output","title":"Terminal output","text":"The progress of the impurity solver.\nTotal energy, etot\nPotential energy, epot\nKinetic energy, ekin\nMagnetic momentum, langle S_z rangle\nTotal occupancy, langle N^1 rangle, langle N^2rangle\nAverage of histogram, langle K^2 rangle, langle K^3 rangle, langle K^4 rangle\nProbability for the accept/reject events for various update \nIs the status of the solver normal?\nHow long did the solver spend in this period?","category":"page"},{"location":"ch04/out_term.html","page":"Terminal output","title":"Terminal output","text":"note: Note\nFrom langle N^1 rangle and langle N^2rangle, we can calculate the charge fluctuation. From langle K^2 rangle, langle K^3 rangle, and langle K^4 rangle, we can calculate the skewness and kurtosis of the histogram of the perturbation expansion order.","category":"page"},{"location":"ch04/out_term.html","page":"Terminal output","title":"Terminal output","text":"","category":"page"},{"location":"ch04/out_term.html","page":"Terminal output","title":"Terminal output","text":">>> Part 4:","category":"page"},{"location":"ch04/out_term.html","page":"Terminal output","title":"Terminal output","text":"  GARDENIA >>> CTQMC quantum impurity solver shutdown\n\n  GARDENIA >>> total time spent:   2987.44s\n\n  GARDENIA >>> I am tired and want to go to bed. Bye!\n  GARDENIA >>> happy ending at 15:24: 8 Dec 17 2015","category":"page"},{"location":"ch04/out_term.html","page":"Terminal output","title":"Terminal output","text":"This is the final part of the terminal output, from which you will find:","category":"page"},{"location":"ch04/out_term.html","page":"Terminal output","title":"Terminal output","text":"How long did the solver spend in the whole calculation?\nWhen did the code terminate?","category":"page"},{"location":"ch04/out_term.html","page":"Terminal output","title":"Terminal output","text":"Code","category":"page"},{"location":"ch04/out_term.html","page":"Terminal output","title":"Terminal output","text":"N/A","category":"page"},{"location":"ch06/p_nmini.html#Parameter:-nmini","page":"nmini","title":"Parameter: nmini","text":"","category":"section"},{"location":"ch06/p_nmini.html","page":"nmini","title":"nmini","text":"Definition","category":"page"},{"location":"ch06/p_nmini.html","page":"nmini","title":"nmini","text":"The minimal total occupancy N which will be kept in the construction of atomic eigenstates.","category":"page"},{"location":"ch06/p_nmini.html","page":"nmini","title":"nmini","text":"Type","category":"page"},{"location":"ch06/p_nmini.html","page":"nmini","title":"nmini","text":"Integer","category":"page"},{"location":"ch06/p_nmini.html","page":"nmini","title":"nmini","text":"Default value","category":"page"},{"location":"ch06/p_nmini.html","page":"nmini","title":"nmini","text":"0","category":"page"},{"location":"ch06/p_nmini.html","page":"nmini","title":"nmini","text":"Component","category":"page"},{"location":"ch06/p_nmini.html","page":"nmini","title":"nmini","text":"Only for the JASMINE component.","category":"page"},{"location":"ch06/p_nmini.html","page":"nmini","title":"nmini","text":"Behavior","category":"page"},{"location":"ch06/p_nmini.html","page":"nmini","title":"nmini","text":"Those atomic states in which the total occupancy N in textnmini textnmaxi will be kept. The other atomic states will be discarded. It is an aggressive truncation and may led to significant derivations.","category":"page"},{"location":"ch06/p_nmini.html","page":"nmini","title":"nmini","text":"Comment","category":"page"},{"location":"ch06/p_nmini.html","page":"nmini","title":"nmini","text":"See also nmaxi parameter for more details.","category":"page"},{"location":"ch06/p_jz.html#Parameter:-Jz","page":"Jz","title":"Parameter: Jz","text":"","category":"section"},{"location":"ch06/p_jz.html","page":"Jz","title":"Jz","text":"Definition","category":"page"},{"location":"ch06/p_jz.html","page":"Jz","title":"Jz","text":"Strength of Hund's exchange interaction in z-axis.","category":"page"},{"location":"ch06/p_jz.html","page":"Jz","title":"Jz","text":"Type","category":"page"},{"location":"ch06/p_jz.html","page":"Jz","title":"Jz","text":"Float, double precision","category":"page"},{"location":"ch06/p_jz.html","page":"Jz","title":"Jz","text":"Default value","category":"page"},{"location":"ch06/p_jz.html","page":"Jz","title":"Jz","text":"0.0","category":"page"},{"location":"ch06/p_jz.html","page":"Jz","title":"Jz","text":"Component","category":"page"},{"location":"ch06/p_jz.html","page":"Jz","title":"Jz","text":"Only for the JASMINE component.","category":"page"},{"location":"ch06/p_jz.html","page":"Jz","title":"Jz","text":"Behavior","category":"page"},{"location":"ch06/p_jz.html","page":"Jz","title":"Jz","text":"It is used to build the interaction term in the local Hamiltonian, only valid when icu = 1 or icu = 3.","category":"page"},{"location":"ch06/p_jz.html","page":"Jz","title":"Jz","text":"Comment","category":"page"},{"location":"ch06/p_jz.html","page":"Jz","title":"Jz","text":"See also Uc, Uv, Js, Jp, and icu parameters for more details.","category":"page"},{"location":"ch06/p_icu.html#Parameter:-icu","page":"icu","title":"Parameter: icu","text":"","category":"section"},{"location":"ch06/p_icu.html","page":"icu","title":"icu","text":"Definition","category":"page"},{"location":"ch06/p_icu.html","page":"icu","title":"icu","text":"Key control flag, determine the scheme to build the Coulomb interaction matrix.","category":"page"},{"location":"ch06/p_icu.html","page":"icu","title":"icu","text":"Type","category":"page"},{"location":"ch06/p_icu.html","page":"icu","title":"icu","text":"Integer","category":"page"},{"location":"ch06/p_icu.html","page":"icu","title":"icu","text":"Default value","category":"page"},{"location":"ch06/p_icu.html","page":"icu","title":"icu","text":"1","category":"page"},{"location":"ch06/p_icu.html","page":"icu","title":"icu","text":"Component","category":"page"},{"location":"ch06/p_icu.html","page":"icu","title":"icu","text":"Only for the JASMINE component.","category":"page"},{"location":"ch06/p_icu.html","page":"icu","title":"icu","text":"Behavior","category":"page"},{"location":"ch06/p_icu.html","page":"icu","title":"icu","text":"There are three possible values for the icu parameter.","category":"page"},{"location":"ch06/p_icu.html","page":"icu","title":"icu","text":"icu = 1, Kanamori scheme, using U_c, U_v, J_z, J_s, J_p parameters, isotropic Hund's rule coupling.\nicu = 2, Slater-Cordon scheme, using U_d, J_h parameters to build F_0, F_2, F_4, F_6.\nicu = 3, Kanamori scheme, using U_c, U_v, J_z, J_s, J_p parameters, anisotropic Hund's rule coupling.","category":"page"},{"location":"ch06/p_icu.html","page":"icu","title":"icu","text":"When icu = 2, it is not compatible with ictqmc = 4.","category":"page"},{"location":"ch06/p_icu.html","page":"icu","title":"icu","text":"Comment","category":"page"},{"location":"ch06/p_icu.html","page":"icu","title":"icu","text":"See Uc, Uv, Jz, Js, and Jp parameters for more details.","category":"page"},{"location":"ch09/obs.html#Physical-observable","page":"Physical observable","title":"Physical observable","text":"","category":"section"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"Many physical observables are measured in our CT-HYB quantum impurity solvers. Here we provide a list of them.","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"Single-particle Green's function G(tau)","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"The most important observable is the single-particle Green's function G(tau), which is measured using the elements of the matrix mathcalM, ","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"beginalign\nG(tau) = leftlangle frac1beta sum_ijdelta^-(tau tau_i - tau_j) mathcalM_jirightrangle\nendalign","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"with","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"beginalign\ndelta^-(tau tau) = \nbegincases \ndelta(tau - tau)  tau  0 \n-delta(tau - tau + beta)  tau  0\nendcases\nendalign","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"Single-particle Green's function G(iomega_n)","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"Note that in the iQIST software package, the Matsubara Green's function G(iomega_n) is also measured directly, instead of being calculated from G(tau) using Fourier transformation.","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"G(iomega_n) = -frac1beta sum_ij e^iomega_ntau_imathcalM_ije^-iomega_ntau_j","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"Two-particle correlation function chi_alphabeta(omegaomeganu)","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"The two-particle correlation functions are often used to construct lattice susceptibilities within DMFT and diagrammatic extensions of DMFT. However, the measurements of two-particle correlation functions are a nontrivial task[1] as it is very time-consuming to obtain good quality data, and most of the previous publications in this field are restricted to measurements of two-particle correlation functions in one-band models. Thanks to the development of efficient CT-HYB algorithms, the calculation of two-particle correlation functions for multi-orbital impurity models now become affordable[2][3][4]. In the iQIST software package, we implemented the measurement for the two-particle correlation function chi_alphabeta(tau_atau_btau_ctau_d), which is defined as follows:","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"beginequation\nchi_alphabeta(tau_atau_btau_ctau_d)\n= langle c_alpha(tau_a)c^dagger_alpha(tau_b)c_beta(tau_c)c^dagger_beta(tau_d)rangle\nendequation","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"Due to the memory restrictions, the actual measurement is performed in the frequency space, for which we use the following definition of the Fourier transform:","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"beginalign\nchi_alphabeta(omegaomeganu) = frac1beta\nint^beta_0dtau_aint^beta_0dtau_bint^beta_0dtau_cint^beta_0dtau_d\n\ntimes chi_alphabeta(tau_atau_btau_ctau_d) \ne^i(omega+nu)tau_ae^-iomegatau_be^-iomegatau_ce^-i(omega+nu)tau_d\nendalign","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"where omega and omega [equiv (2n+1)pibeta] are fermionic frequencies, and nu is bosonic (equiv 2npibeta).","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"Local irreducible vertex functions Gamma_alphabeta(omegaomeganu)","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"From the two-particle Green's function chi_alphabeta(omegaomeganu), the local irreducible vertex function Gamma_alphabeta(omegaomeganu) can be calculated easily, via the Bethe-Salpeter equation[3][4][5]:","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"beginequation\nGamma_alphabeta(omegaomeganu) = \nfracchi_alphabeta(omegaomeganu) \n- betaG_alpha(omega+nu)G_beta(omega)delta_nu0 \n- G_alpha(omega+nu) G_beta(omega) delta_alphabetadelta_omegaomega\nG_alpha(omega+nu)G_alpha(omega)G_beta(omega)G_beta(omega+nu)\nendequation","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"The G(iomega_n) and Gamma_alphabeta(omegaomeganu) are essential inputs for the ladder dual fermion code ROSEMARY, see section Ladder dual fermions for more details.","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"Pair susceptibility","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"Impurity self-energy function Sigma(iomega_n)","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"The self-energy Sigma(iomega_n) is calculated using Dyson's equation directly","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"beginequation\nSigma(iomega_n) = G^-1_0(iomega_n) - G^-1(iomega_n)\nendequation","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"or measured using the so-called improved estimator[3][4]. Noted that now the latter approach only works when the segment representation is used. ","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"Histogram of the perturbation expansion order","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"We record the histogram of the perturbation expansion order k, which can be used to evaluate the kinetic energy.","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"Kurtosis and skewness of perturbation expansion order","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"Skewness","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"gamma_1 = fracE(k - langle k rangle)^3(E(k - langle k rangle)^2)^32","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"Kurtosis","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"fracE(k - langle k rangle)^4(E(k - langle k rangle)^2)^2","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"Actually, in the iQIST software package, only the langle k rangle, langle k^2 rangle, langle k^3 rangle, and langle k^4 rangle are measured. And then they are used to evaluate the skewness and kurtosis.","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"Kinetic energy","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"The expression for the system kinetic energy reads","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"E_textkin = -frac1beta langle k rangle","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"where k is the perturbation expansion order.","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"Potential energy","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"Occupation number and double occupation number","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"The orbital occupation number langle n_alpharangle and double occupation number langle n_alpha n_beta rangle are measured. From them we can calculate for example the charge fluctuation sqrtlangle N^2 rangle - langle N rangle^2, where N is the total occupation number:","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"beginequation\nN = sum_alpha n_alpha\nendequation","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"Magnetic moment","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"Actually, we only measure langle S_z rangle.","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"Spin-spin correlation function","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"For a system with spin rotational symmetry, the expression for the spin-spin correlation function reads","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"beginequation\nchi_ss(tau) = langle S_z(tau) S_z(0) rangle\nendequation","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"where S_z = n_uparrow - n_downarrow. From it we can calculate the effective magnetic moment:","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"beginequation\nmu_texteff = int^beta_0dtau chi_ss(tau)\nendequation","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"Orbital-orbital correlation function","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"The expression for the orbital-orbital correlation function reads ","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"beginequation\nchi^nn_alphabeta(tau) = langle n_alpha(tau) n_beta(0) rangle\nendequation","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"Atomic state probability","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"The expression for the atomic state probability is ","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"beginequation\np_Gamma = langle Gamma rangle langle Gamma rangle\nendequation","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"where Gamma is the atomic state.","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"Fidelity susceptibility","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"chi_textFS = langle k_L k_R rangle - langle k_L rangle langle k_R rangle","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"Kinetic energy fluctuation","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"chi_textk = langle k^2 rangle - langle k rangle^2 - langle k rangle","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"Reference","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"[1]: Jan KuneÅ¡, Phys. Rev. B 83, 085102 (2011)","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"[2]: Lewin Boehnke, Hartmut Hafermann, Michel Ferrero, Frank Lechermann, and Olivier Parcollet, Phys. Rev. B 84, 075145 (2011)","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"[3]: Hartmut Hafermann, Phys. Rev. B 89, 235128 (2014)","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"[4]: Hartmut Hafermann, Kelly R. Patton, and Philipp Werner, Phys. Rev. B 85, 205106 (2012)","category":"page"},{"location":"ch09/obs.html","page":"Physical observable","title":"Physical observable","text":"[5]: G. Rohringer, A. Valli, and A. Toschi, Phys. Rev. B 86, 125114 (2012)","category":"page"},{"location":"ch04/in_umat.html#solver.umat.in","page":"solver.umat.in","title":"solver.umat.in","text":"","category":"section"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"Introduction","category":"page"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"The quantum impurity solvers will generate the Coulomb interaction matrix using the U and J parameters provided by you automatically. But sometimes you may want to customize the Coulomb interaction matrix by yourself. ","category":"page"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"Is it possible within the iQIST code? ","category":"page"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"Yes, of course.","category":"page"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"You can define your Coulomb interaction matrix in the solver.umat.in file. And the iQIST codes will read data from it if it is available. Then the default Coulomb interaction matrix will be replaced with the new one. That's all.","category":"page"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"warning: Warning\nThe HF-QMC impurity solver (the DAISY component) does not support the solver.umat.in file. The continuous-time quantum Monte Carlo impurity solvers in the general matrix representation, i.e., the BEGONIA, LAVENDER, CAMELLIA, MANJUSHAKA, and PANSY components don't support this file/feature as well.","category":"page"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"Format","category":"page"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"The format of the solver.umat.in file is as follows:","category":"page"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"","category":"page"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"column 1: orbital index i, integer","category":"page"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"column 2: orbital index j, integer","category":"page"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"column 3: Coulomb interaction matrix element U(ij), double precision","category":"page"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"","category":"page"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"tip: Tip\nIn the solver.umat.in file, we employed the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots Namely, we put the spin up part before the spin down part.","category":"page"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"Code","category":"page"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"The corresponding Fortran code block for the reading of solver.umat.in file is as follows:","category":"page"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"open(mytmp, file='solver.umat.in', form='formatted', status='unknown')\ndo i=1,norbs\n    do j=1,norbs\n        read(mytmp,*) k, l, rtmp\n        uumat(k,l) = rtmp\n    enddo ! over j={1,norbs} loop\nenddo ! over i={1,norbs} loop\nclose(mytmp)","category":"page"},{"location":"ch04/in_umat.html","page":"solver.umat.in","title":"solver.umat.in","text":"Usually, you have to edit the solver.umat.in file by yourself.","category":"page"},{"location":"ch07/check.html#script/d_check.py","page":"script/d_check.py","title":"script/d_check.py","text":"","category":"section"},{"location":"ch07/check.html","page":"script/d_check.py","title":"script/d_check.py","text":"Introduction","category":"page"},{"location":"ch07/check.html","page":"script/d_check.py","title":"script/d_check.py","text":"It can be used to check whether the lines in a given file are ended with blanks.","category":"page"},{"location":"ch07/check.html","page":"script/d_check.py","title":"script/d_check.py","text":"Type","category":"page"},{"location":"ch07/check.html","page":"script/d_check.py","title":"script/d_check.py","text":"Python script","category":"page"},{"location":"ch07/check.html","page":"script/d_check.py","title":"script/d_check.py","text":"Usage","category":"page"},{"location":"ch07/check.html","page":"script/d_check.py","title":"script/d_check.py","text":"You have to specify the file name, like this:","category":"page"},{"location":"ch07/check.html","page":"script/d_check.py","title":"script/d_check.py","text":"$ ./d_check.py ctqmc_dmft.f90","category":"page"},{"location":"ch07/check.html","page":"script/d_check.py","title":"script/d_check.py","text":"Input","category":"page"},{"location":"ch07/check.html","page":"script/d_check.py","title":"script/d_check.py","text":"N/A","category":"page"},{"location":"ch07/check.html","page":"script/d_check.py","title":"script/d_check.py","text":"Output","category":"page"},{"location":"ch07/check.html","page":"script/d_check.py","title":"script/d_check.py","text":"See the terminal output.","category":"page"},{"location":"ch07/check.html","page":"script/d_check.py","title":"script/d_check.py","text":"Comment","category":"page"},{"location":"ch07/check.html","page":"script/d_check.py","title":"script/d_check.py","text":"note: Note\nThis script is used by the iQIST Developer Team internally.","category":"page"},{"location":"ch02/envir.html#Compiling-environment","page":"Compiling environment","title":"Compiling environment","text":"","category":"section"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"note: Note\nThe URLs/links provided in this page may be broken sometimes. If you meet the broken links, please contact us.","category":"page"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"In order to compile/execute the iQIST software package successfully, please confirm whether the following software/libraries are correctly installed and configured in your system.","category":"page"},{"location":"ch02/envir.html#Fortran-Compiler","page":"Compiling environment","title":"Fortran Compiler","text":"","category":"section"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"A modern Fortran compiler supporting ISO Fortran 2003 standard is necessary. We strongly advise you to choose the newest version of Intel Fortran Compiler (ifort) or GNU Fortran Compiler (gfortran). During the development of the iQIST software package, these two compilers are extensively used. ","category":"page"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"Check the following websites for more details:","category":"page"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"Intel Fortran compiler\nGNU Fortran compiler","category":"page"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"note: Note\nBesides ifort and gfortran, in principle the iQIST software package can be compiled by any other Fortran 90 compilers, but we can not guarantee it.","category":"page"},{"location":"ch02/envir.html#Parallel-environment","page":"Compiling environment","title":"Parallel environment","text":"","category":"section"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"We use the message passing interface (MPI) to implement the parallelism in the iQIST software package. Therefore, in order to accelerate the quantum impurity solvers, you have to install a MPI implementation in your system, and setup it to work with the Fortran compiler you choose correctly. There are many MPI implementations in the market provided by various vendors. But we recommend to use the newest versions of MPICH or Openmpi.","category":"page"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"Check the following websites for more details:","category":"page"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"Message passing interface standard\nMPICH\nOpenmpi","category":"page"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"Some features in the iQIST software package have been optimized using the OpenMP multi-thread technology. The chosen Fortran compilers should support the OpenMP standard version 3.0 or later version.","category":"page"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"Check the following websites for more details:","category":"page"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"OpenMP\nOpenMP support in GNU GCC\nOpenMP support in Intel compilers","category":"page"},{"location":"ch02/envir.html#Linear-algebra-library","page":"Compiling environment","title":"Linear algebra library","text":"","category":"section"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"The iQIST software package depends on the BLAS and LAPACK libraries heavily. Then you have to ensure that a compatible math library is installed in your system. We recommend to use the Intel Math Kernel Library (Intel MKL). If you are using the Mac OS X system, the Accelerate Framework may be an alternate choice. Keep in mind that the running efficiency of iQIST is always benefited from the highly optimized linear algebra library.","category":"page"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"Check the following websites for more details:","category":"page"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"BLAS\nLAPACK\nIntel MKL\nOpenBLAS\nAccelerate Framework","category":"page"},{"location":"ch02/envir.html#Python-environment","page":"Compiling environment","title":"Python environment","text":"","category":"section"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"There are a few python scripts in the iQIST software package. In order to run them, you need a Python interpreter. We recommend to install Python 2.6+, and the numpy, scipy, f2py, matplotlib packages must be installed as well.","category":"page"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"Check the following websites for more details:","category":"page"},{"location":"ch02/envir.html","page":"Compiling environment","title":"Compiling environment","text":"Python\nnumpy\nscipy\nf2py\nmatplotlib","category":"page"},{"location":"ch04/output.html#Standard-output-files","page":"README","title":"Standard output files","text":"","category":"section"},{"location":"ch04/output.html","page":"README","title":"README","text":"The quantum impurity solvers will generate a lot of data files at run time. In this section, we will depict their formats and usages in detail.","category":"page"},{"location":"ch04/output.html","page":"README","title":"README","text":"The data files could be classified as the following kinds:","category":"page"},{"location":"ch04/output.html","page":"README","title":"README","text":"Direct output\nTerminal output // Many useful stuffs in it\nGreen's function data\nsolver.green.dat // G(tau)\nsolver.weiss.dat // G_0(tau)\nsolver.grn.dat // G(iomega_n)\nsolver.wss.dat // G_0(iomega_n)\nHybridization function data\nsolver.hybri.dat // Delta(tau)\nsolver.hyb.dat // Delta(iomega_n)\nSelf-energy function data\nsolver.sgm.dat // Sigma(iomega_n)\nsolver.hub.dat // Sigma_textatomic(iomega_n) and G_textatomic(iomega_n)\nTwo-particle Green's function data\nsolver.twop.dat // Two-particle Green's function and vertex function\nsolver.vrtx.dat // Two-particle Green's function and vertex function\nsolver.pair.dat // Pairing susceptibility\nSusceptibility data\nsolver.schi.dat // Spin-spin correlation function in tau space\nsolver.sfom.dat // Spin-spin correlation function in Matsubara frequency space\nsolver.ochi.dat // Orbital-orbital correlation in tau space\nsolver.ofom.dat // Orbital-orbital correlation in Matsubara frequency space\nPhysical observables data\nsolver.hist.dat // Histogram for perturbation expansion order\nsolver.prob.dat // Atomic state probability\nsolver.nmat.dat // Occupation number\nsolver.kmat.dat // langle k rangle and langle k^2 rangle\nsolver.lmat.dat // langle k_L rangle and langle k_R rangle\nMiscellaneous data\nsolver.kernel.dat // Frequency-dependent interaction\nsolver.status.dat // Status of the quantum impurity solvers\nsolver.diag.dat // Snapshot of the current configuration for diagrammatic perturbation expansion","category":"page"},{"location":"ch05/ladder.html#Ladder-dual-fermions","page":"Ladder dual fermions","title":"Ladder dual fermions","text":"","category":"section"},{"location":"ch05/ladder.html","page":"Ladder dual fermions","title":"Ladder dual fermions","text":"warning: Warning\nSorry, this application (the ROSEMARY component) is not ready now. We will release it later. Thank you for your patience.","category":"page"},{"location":"ch06/p_ncfgs.html#Parameter:-ncfgs","page":"ncfgs","title":"Parameter: ncfgs","text":"","category":"section"},{"location":"ch06/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Definition","category":"page"},{"location":"ch06/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Number of atomic states or many-body configurations, the dimension of Hilbert space.","category":"page"},{"location":"ch06/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Type","category":"page"},{"location":"ch06/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Integer","category":"page"},{"location":"ch06/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Default value","category":"page"},{"location":"ch06/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"4","category":"page"},{"location":"ch06/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Component","category":"page"},{"location":"ch06/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Only for the JASMINE component.","category":"page"},{"location":"ch06/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Behavior","category":"page"},{"location":"ch06/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Determine the size of involved arrays.","category":"page"},{"location":"ch06/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"Comment","category":"page"},{"location":"ch06/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"The following relations always hold:","category":"page"},{"location":"ch06/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"textnorbs = textnpsin * textnband","category":"page"},{"location":"ch06/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"textncfgs = 2^textnorbs","category":"page"},{"location":"ch06/p_ncfgs.html","page":"ncfgs","title":"ncfgs","text":"You have to ensure the value of ncfgs is compatible with nband, nspin and norbs. The JASMINE component will not check and correct them automatically. See also nspin, nband, and norbs parameters for more details.","category":"page"},{"location":"ch04/out_ofom.html#solver.ofom.dat","page":"solver.ofom.dat","title":"solver.ofom.dat","text":"","category":"section"},{"location":"ch04/out_ofom.html","page":"solver.ofom.dat","title":"solver.ofom.dat","text":"Introduction","category":"page"},{"location":"ch04/out_ofom.html","page":"solver.ofom.dat","title":"solver.ofom.dat","text":"The solver.ofom.dat file is used to store the orbital-orbital correlation function in frequency space, chi_textcharge(inu_n). It will be output by the quantum impurity solvers when they are shut down.","category":"page"},{"location":"ch04/out_ofom.html","page":"solver.ofom.dat","title":"solver.ofom.dat","text":"note: Note\nOnly the GARDENIA and NARCISSUS components can generate the solver.ofom.dat file.","category":"page"},{"location":"ch04/out_ofom.html","page":"solver.ofom.dat","title":"solver.ofom.dat","text":"Format","category":"page"},{"location":"ch04/out_ofom.html","page":"solver.ofom.dat","title":"solver.ofom.dat","text":"The solver.ofom.dat file contains norbstimesnorbs blocks. Each block is appended by two blank lines. The format of each block is as follows:","category":"page"},{"location":"ch04/out_ofom.html","page":"solver.ofom.dat","title":"solver.ofom.dat","text":"","category":"page"},{"location":"ch04/out_ofom.html","page":"solver.ofom.dat","title":"solver.ofom.dat","text":"column 1: Matsubara frequency point (bosonic type), nu_n, double precision","category":"page"},{"location":"ch04/out_ofom.html","page":"solver.ofom.dat","title":"solver.ofom.dat","text":"column 2: orbital-orbital correlation function, Re chi_textcharge(inu_n), double precision","category":"page"},{"location":"ch04/out_ofom.html","page":"solver.ofom.dat","title":"solver.ofom.dat","text":"column 3: error bar, Re deltachi_textcharge(inu_n), double precision","category":"page"},{"location":"ch04/out_ofom.html","page":"solver.ofom.dat","title":"solver.ofom.dat","text":"","category":"page"},{"location":"ch04/out_ofom.html","page":"solver.ofom.dat","title":"solver.ofom.dat","text":"note: Note\nThe imaginary part of chi_textcharge(inu_n) should keeps zero.","category":"page"},{"location":"ch04/out_ofom.html","page":"solver.ofom.dat","title":"solver.ofom.dat","text":"note: Note\nIn the solver.ofom.dat file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch04/out_ofom.html","page":"solver.ofom.dat","title":"solver.ofom.dat","text":"Code","category":"page"},{"location":"ch04/out_ofom.html","page":"solver.ofom.dat","title":"solver.ofom.dat","text":"The corresponding Fortran code block for the writing of solver.ofom.dat file is as follows:","category":"page"},{"location":"ch04/out_ofom.html","page":"solver.ofom.dat","title":"solver.ofom.dat","text":"! open data file: solver.ofom.dat\n     open(mytmp, file='solver.ofom.dat', form='formatted', status='unknown')\n\n! write it\n     do k=1,norbs\n         do j=1,norbs\n             write(mytmp,'(2(a,i6))') '# flvr:', j, '  flvr:', k\n             do i=1,nbfrq\n                 write(mytmp,'(3f12.6)') bmesh(i), oofom(i,j,k), ooerr(i,j,k)\n             enddo ! over i={1,nbfrq} loop\n             write(mytmp,*) ! write empty lines\n             write(mytmp,*)\n         enddo ! over j={1,norbs} loop\n     enddo ! over k={1,norbs} loop\n\n! close data file\n     close(mytmp)","category":"page"},{"location":"ch04/out_ofom.html","page":"solver.ofom.dat","title":"solver.ofom.dat","text":"In the HIBISCUS component, we provide a Python module to read the output files of quantum impurity solvers. You can use it to read the solver.ofom.dat file. See script/u_reader.py for more details.","category":"page"},{"location":"ch04/out_hist.html#solver.hist.dat","page":"solver.hist.dat","title":"solver.hist.dat","text":"","category":"section"},{"location":"ch04/out_hist.html","page":"solver.hist.dat","title":"solver.hist.dat","text":"Introduction","category":"page"},{"location":"ch04/out_hist.html","page":"solver.hist.dat","title":"solver.hist.dat","text":"The solver.hist.dat file is used to store the histogram for the perturbation expansion orders of the continuous-time quantum Monte Carlo impurity solvers. It will be output by the quantum impurity solvers periodically (every nwrite Monte Carlo sampling steps, see nwrite for more details).","category":"page"},{"location":"ch04/out_hist.html","page":"solver.hist.dat","title":"solver.hist.dat","text":"Format","category":"page"},{"location":"ch04/out_hist.html","page":"solver.hist.dat","title":"solver.hist.dat","text":"The solver.hist.dat file only contains one block. The format of the block is as follows:","category":"page"},{"location":"ch04/out_hist.html","page":"solver.hist.dat","title":"solver.hist.dat","text":"","category":"page"},{"location":"ch04/out_hist.html","page":"solver.hist.dat","title":"solver.hist.dat","text":"column 1: index of perturbation expansion order, integer","category":"page"},{"location":"ch04/out_hist.html","page":"solver.hist.dat","title":"solver.hist.dat","text":"column 2: count of the perturbation expansion order, integer","category":"page"},{"location":"ch04/out_hist.html","page":"solver.hist.dat","title":"solver.hist.dat","text":"column 3: percent of the perturbation expansion order, double precision","category":"page"},{"location":"ch04/out_hist.html","page":"solver.hist.dat","title":"solver.hist.dat","text":"column 4: error bar of the histogram","category":"page"},{"location":"ch04/out_hist.html","page":"solver.hist.dat","title":"solver.hist.dat","text":"","category":"page"},{"location":"ch04/out_hist.html","page":"solver.hist.dat","title":"solver.hist.dat","text":"Code","category":"page"},{"location":"ch04/out_hist.html","page":"solver.hist.dat","title":"solver.hist.dat","text":"The corresponding Fortran code block for the writing of solver.hist.dat file is as follows:","category":"page"},{"location":"ch04/out_hist.html","page":"solver.hist.dat","title":"solver.hist.dat","text":"! open data file: solver.hist.dat\n     open(mytmp, file='solver.hist.dat', form='formatted', status='unknown')\n\n! write it\n     write(mytmp,'(a)') '# histogram: order | count | percent'\n     do i=1,mkink\n         write(mytmp,'(i6,i12,2f12.6)') i-1, int( hint(i) ), haux(i), htmp(i)\n     enddo ! over i={1,mkink} loop\n\n! close data file\n     close(mytmp)","category":"page"},{"location":"ch04/out_hist.html","page":"solver.hist.dat","title":"solver.hist.dat","text":"In the HIBISCUS component, we provide a Python module to read the output files of quantum impurity solvers. You can use it to read the solver.hist.dat file. See script/u_reader.py for more details.","category":"page"},{"location":"copy.html","page":"Copyright","title":"Copyright","text":"   o         o__ __o       __o__     o__ __o    ____o__ __o____ \n _<|>_      /v     v\\        |      /v     v\\    /   \\   /   \\  \n           />       <\\      / \\    />       <\\        \\o/       \n   o     o/           \\o    \\o/   _\\o____              |        \n  <|>   <|             |>    |         \\_\\__o__       < >       \n  / \\    \\\\           //    < >              \\         |        \n  \\o/      \\       \\o/       |     \\         /         o        \n   |        o       |        o      o       o         <|        \n  / \\       <\\__   / \\     __|>_    <\\__ __/>         / \\","category":"page"},{"location":"copy.html","page":"Copyright","title":"Copyright","text":"Copyright 2016 by The iQIST Developer Team","category":"page"},{"location":"copy.html","page":"Copyright","title":"Copyright","text":"Permission is granted to copy, distribute and/or modify the documentation under the terms of the GNU Free Documentation License, Version 1.2 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.","category":"page"},{"location":"copy.html","page":"Copyright","title":"Copyright","text":"Permission is granted to copy, distribute and/or modify the code of the package under the terms of the GNU Public License, Version 2 or any later version published by the Free Software Foundation.","category":"page"},{"location":"ch04/in_atom.html#atom.cix","page":"atom.cix","title":"atom.cix","text":"","category":"section"},{"location":"ch04/in_atom.html","page":"atom.cix","title":"atom.cix","text":"Introduction","category":"page"},{"location":"ch04/in_atom.html","page":"atom.cix","title":"atom.cix","text":"We use the atom.cix file to store the eigensystem of the local interaction Hamiltonian. It is necessary for the general matrix version of the CT-QMC impurity solvers.","category":"page"},{"location":"ch04/in_atom.html","page":"atom.cix","title":"atom.cix","text":"warning: Warning\nThe iQIST won't provide a default atom.cix file. Without this file, the general matrix version of the CT-QMC impurity solvers won't be started correctly.","category":"page"},{"location":"ch04/in_atom.html","page":"atom.cix","title":"atom.cix","text":"Format","category":"page"},{"location":"ch04/in_atom.html","page":"atom.cix","title":"atom.cix","text":"The atom.cix file is always generated by the JASMINE component. You should not modify it by yourself. Please see Atomic eigenvalue problem solver for more details about the JASMINE component.","category":"page"},{"location":"ch04/in_atom.html","page":"atom.cix","title":"atom.cix","text":"Now the JASMINE component can generate three kinds of atom.cix files.","category":"page"},{"location":"ch04/in_atom.html","page":"atom.cix","title":"atom.cix","text":"TYPE 0, only valid for the CAMELLIA component.\nTYPE 1, only valid for the BEGONIA and LAVENDER components.\nTYPE 2, only valid for the MANJUSHAKA and PANSY components.","category":"page"},{"location":"ch04/in_atom.html","page":"atom.cix","title":"atom.cix","text":"warning: Warning\nThe format of the atom.cix file may be modified in the near future. So we don't describe its format here.","category":"page"},{"location":"ch04/in_atom.html","page":"atom.cix","title":"atom.cix","text":"Code","category":"page"},{"location":"ch04/in_atom.html","page":"atom.cix","title":"atom.cix","text":"N/A","category":"page"},{"location":"ch09/README.html#Inside-iQIST","page":"README","title":"Inside iQIST","text":"","category":"section"},{"location":"ch09/README.html","page":"README","title":"README","text":"There are three aspects for this chapter. ","category":"page"},{"location":"ch09/README.html","page":"README","title":"README","text":"First of all, we will present the basic principles of CT-QMC quantum impurity solvers, with an emphasis on the hybridization expansion technique. For detailed derivations and explanations, please refer to the great review article[1]. Second, the algorithms, tricks, and optimization implemented in the iQIST software package are all discussed in details. Finally, we will introduce some technical and programming details for the iQIST from the programmer's perspective. We believe that those guys who would like to hack the iQIST software package to realize their own ideas will benefit from this.","category":"page"},{"location":"ch09/README.html","page":"README","title":"README","text":"The main topics are as follows:","category":"page"},{"location":"ch09/README.html","page":"README","title":"README","text":"Basic theory and methods // Principles for the CT-HYB quantum impurity solvers.\nAlgorithms // Why is it so fast and so powerful?\nCodes // Want to be a developer of the iQIST software package?","category":"page"},{"location":"ch09/README.html","page":"README","title":"README","text":"Reference","category":"page"},{"location":"ch09/README.html","page":"README","title":"README","text":"[1]: Emanuel Gull, Andrew J. Millis, Alexander I. Lichtenstein, Alexey N. Rubtsov, Matthias Troyer, and Philipp Werner, Rev. Mod. Phys. 83, 349 (2011).","category":"page"},{"location":"ch04/out_stat.html#solver.status.dat","page":"solver.status.dat","title":"solver.status.dat","text":"","category":"section"},{"location":"ch04/out_stat.html","page":"solver.status.dat","title":"solver.status.dat","text":"Introduction","category":"page"},{"location":"ch04/out_stat.html","page":"solver.status.dat","title":"solver.status.dat","text":"The solver.status.dat is used to store the current diagram configuration. In other words, we can treat it as a snapshot of the CT-QMC impurity solvers.","category":"page"},{"location":"ch04/out_stat.html","page":"solver.status.dat","title":"solver.status.dat","text":"Usually, the quantum impurity solvers will output solver.status.dat file periodically. In the next run, they can reload it in order to reach thermal equilibrium state as soon as possible. In addition, when they meet fatal errors/exceptions, a solver.status.dat will be generated as well. It is very useful for us to diagnose where the bug is.","category":"page"},{"location":"ch04/out_stat.html","page":"solver.status.dat","title":"solver.status.dat","text":"danger: Danger\nThe solver.status.dat is always generated by the quantum impurity solvers. DO NOT try to modify it by yourself. It is EXTREMELY DANGEROUS.","category":"page"},{"location":"ch04/out_stat.html","page":"solver.status.dat","title":"solver.status.dat","text":"Format","category":"page"},{"location":"ch04/out_stat.html","page":"solver.status.dat","title":"solver.status.dat","text":"The solver.status.dat files generated by various quantum impurity solvers are quite different. In principle you can not mix them. For example, the solver.status.dat generated by the AZALEA component can not be recognized by the BEGONIA component, and vice versa.","category":"page"},{"location":"ch04/out_stat.html","page":"solver.status.dat","title":"solver.status.dat","text":"Code","category":"page"},{"location":"ch04/out_stat.html","page":"solver.status.dat","title":"solver.status.dat","text":"N/A","category":"page"},{"location":"ch07/cmp.html#script/d_cmp.py","page":"script/d_cmp.py","title":"script/d_cmp.py","text":"","category":"section"},{"location":"ch07/cmp.html","page":"script/d_cmp.py","title":"script/d_cmp.py","text":"Introduction","category":"page"},{"location":"ch07/cmp.html","page":"script/d_cmp.py","title":"script/d_cmp.py","text":"The purpose of this script is to compare the output files between two cases when testing solvers. With this script, we can judge whether the new results generated with a new version of iQIST are consistent with the previous generated with an old iQIST code. In this script, the histogram of perturbation expansion order, G(tau), G(iomega_n), and  Sigma(iomega_n) are used as criteria.","category":"page"},{"location":"ch07/cmp.html","page":"script/d_cmp.py","title":"script/d_cmp.py","text":"Type","category":"page"},{"location":"ch07/cmp.html","page":"script/d_cmp.py","title":"script/d_cmp.py","text":"Python script","category":"page"},{"location":"ch07/cmp.html","page":"script/d_cmp.py","title":"script/d_cmp.py","text":"Usage","category":"page"},{"location":"ch07/cmp.html","page":"script/d_cmp.py","title":"script/d_cmp.py","text":"This script needs two parameters, i.e., the directories for old and new results.","category":"page"},{"location":"ch07/cmp.html","page":"script/d_cmp.py","title":"script/d_cmp.py","text":"$ ./d_cmp.py  directory_of_case_A directory_of_case_B","category":"page"},{"location":"ch07/cmp.html","page":"script/d_cmp.py","title":"script/d_cmp.py","text":"Input","category":"page"},{"location":"ch07/cmp.html","page":"script/d_cmp.py","title":"script/d_cmp.py","text":"N/A","category":"page"},{"location":"ch07/cmp.html","page":"script/d_cmp.py","title":"script/d_cmp.py","text":"Output","category":"page"},{"location":"ch07/cmp.html","page":"script/d_cmp.py","title":"script/d_cmp.py","text":"See the terminal output.","category":"page"},{"location":"ch07/cmp.html","page":"script/d_cmp.py","title":"script/d_cmp.py","text":"Comment","category":"page"},{"location":"ch07/cmp.html","page":"script/d_cmp.py","title":"script/d_cmp.py","text":"note: Note\nThis script is used by the iQIST Developer Team internally.","category":"page"},{"location":"ch04/p_part.html#Parameter:-part","page":"part","title":"Parameter: part","text":"","category":"section"},{"location":"ch04/p_part.html","page":"part","title":"part","text":"Definition","category":"page"},{"location":"ch04/p_part.html","page":"part","title":"part","text":"Hopping (or coupling) parameter t for Hubbard model.","category":"page"},{"location":"ch04/p_part.html","page":"part","title":"part","text":"Type","category":"page"},{"location":"ch04/p_part.html","page":"part","title":"part","text":"Float, double precision","category":"page"},{"location":"ch04/p_part.html","page":"part","title":"part","text":"Default value","category":"page"},{"location":"ch04/p_part.html","page":"part","title":"part","text":"0.5","category":"page"},{"location":"ch04/p_part.html","page":"part","title":"part","text":"Component","category":"page"},{"location":"ch04/p_part.html","page":"part","title":"part","text":"ALL","category":"page"},{"location":"ch04/p_part.html","page":"part","title":"part","text":"Behavior","category":"page"},{"location":"ch04/p_part.html","page":"part","title":"part","text":"It is used to initialize the default hybridization function Delta(iomega_n), and in the implementation of the dynamical mean-field theory self-consistent equation for the Bethe lattice.","category":"page"},{"location":"ch04/p_part.html","page":"part","title":"part","text":"Para-magnetic phase:","category":"page"},{"location":"ch04/p_part.html","page":"part","title":"part","text":"beginequation\nG_alphasigma(iomega_n) = t^2 Delta_alphasigma(iomega_n)\nendequation","category":"page"},{"location":"ch04/p_part.html","page":"part","title":"part","text":"Anti-ferromagnetic phase:","category":"page"},{"location":"ch04/p_part.html","page":"part","title":"part","text":"beginequation\nG_alphabarsigma(iomega_n) = t^2 Delta_alphabarsigma(iomega_n)\nendequation","category":"page"},{"location":"ch04/p_part.html","page":"part","title":"part","text":"Comment","category":"page"},{"location":"ch04/p_part.html","page":"part","title":"part","text":"It is useful only when isscf = 2. See also isscf parameter for more details.","category":"page"},{"location":"ch04/input.html#Standard-input-files","page":"README","title":"Standard input files","text":"","category":"section"},{"location":"ch04/input.html","page":"README","title":"README","text":"The quantum impurity solvers requires a few input files to setup the impurity models, configure the impurity solvers, and control the DMFT iterations, etc. In principle, the quantum impurity solvers can run without any input files. But if the input files are available, the parameters read from the input files will override the default ones.","category":"page"},{"location":"ch04/input.html","page":"README","title":"README","text":"The standard input files supported by the CT-HYB/HF-QMC quantum impurity solvers are as follows:","category":"page"},{"location":"ch04/input.html","page":"README","title":"README","text":"solver.ctqmc.in // Configuration file for CT-QMC impurity solvers.\nsolver.hfqmc.in // Configuration file for HF-QMC impurity solvers.\nsolver.umat.in // Coulomb interaction matrix.\nsolver.eimp.in // Impurity level and crystal-field splitting.\nsolver.anydos.in // Density of states from various lattice or tight-binding models.\nsolver.ktau.in // Screening interaction.\natom.cix // Atomic eigenstates data.","category":"page"},{"location":"ch09/basic.html#Basic-theory-and-methods","page":"README","title":"Basic theory and methods","text":"","category":"section"},{"location":"ch09/basic.html","page":"README","title":"README","text":"In this section, you will learn the basic principles of continuous-time quantum Monte Carlo impurity solver. Especially, the powerful hybridization expansion version is emphasized.","category":"page"},{"location":"ch09/basic.html","page":"README","title":"README","text":"Quantum impurity model // Anderson impurity model.\nPrinciples of continuous-time quantum Monte Carlo algorithm // Diagrammatic Monte Carlo.\nHybridization expansion // Core spirit of it.","category":"page"},{"location":"ch06/out_val.html#atom.eigval.dat","page":"atom.eigval.dat","title":"atom.eigval.dat","text":"","category":"section"},{"location":"ch06/out_val.html","page":"atom.eigval.dat","title":"atom.eigval.dat","text":"Introduction","category":"page"},{"location":"ch06/out_val.html","page":"atom.eigval.dat","title":"atom.eigval.dat","text":"The atom.eigval.dat file contains the eigenvalues of the atomic Hamiltonian. All of the eigenvalues are outputted.","category":"page"},{"location":"ch06/out_val.html","page":"atom.eigval.dat","title":"atom.eigval.dat","text":"Format","category":"page"},{"location":"ch06/out_val.html","page":"atom.eigval.dat","title":"atom.eigval.dat","text":"The atom.eigval.dat file has two different file formats. They depends on the ictqmc parameter.","category":"page"},{"location":"ch06/out_val.html","page":"atom.eigval.dat","title":"atom.eigval.dat","text":"File Format A, should be compatible with the CAMELLIA, BEGONIA, and LAVENDER components","category":"page"},{"location":"ch06/out_val.html","page":"atom.eigval.dat","title":"atom.eigval.dat","text":"note: Note\nictqmc = 0, 1.","category":"page"},{"location":"ch06/out_val.html","page":"atom.eigval.dat","title":"atom.eigval.dat","text":"File Format B, should be compatible with the MANJUSHAKA and PANSY components","category":"page"},{"location":"ch06/out_val.html","page":"atom.eigval.dat","title":"atom.eigval.dat","text":"note: Note\nictqmc = 2, 3, 4, 5.","category":"page"},{"location":"ch06/out_val.html","page":"atom.eigval.dat","title":"atom.eigval.dat","text":"See ictqmc parameter for more details.","category":"page"},{"location":"ch06/out_val.html","page":"atom.eigval.dat","title":"atom.eigval.dat","text":"The file formats of the atom.eigval.dat file are a bit complex. It is unnecessary to understand its full details. If you are a maintainer or developer of the JASMINE component, please read the source codes in iqist/src/tools/jasmine/atomic_dump.f90.","category":"page"},{"location":"ch06/out_val.html","page":"atom.eigval.dat","title":"atom.eigval.dat","text":"Code","category":"page"},{"location":"ch06/out_val.html","page":"atom.eigval.dat","title":"atom.eigval.dat","text":"N/A","category":"page"},{"location":"ch06/p_uv.html#Parameter:-Uv","page":"Uv","title":"Parameter: Uv","text":"","category":"section"},{"location":"ch06/p_uv.html","page":"Uv","title":"Uv","text":"Definition","category":"page"},{"location":"ch06/p_uv.html","page":"Uv","title":"Uv","text":"Inter-orbital Coulomb interaction.","category":"page"},{"location":"ch06/p_uv.html","page":"Uv","title":"Uv","text":"Type","category":"page"},{"location":"ch06/p_uv.html","page":"Uv","title":"Uv","text":"Float, double precision","category":"page"},{"location":"ch06/p_uv.html","page":"Uv","title":"Uv","text":"Default value","category":"page"},{"location":"ch06/p_uv.html","page":"Uv","title":"Uv","text":"2.0","category":"page"},{"location":"ch06/p_uv.html","page":"Uv","title":"Uv","text":"Component","category":"page"},{"location":"ch06/p_uv.html","page":"Uv","title":"Uv","text":"Only for the JASMINE component.","category":"page"},{"location":"ch06/p_uv.html","page":"Uv","title":"Uv","text":"Behavior","category":"page"},{"location":"ch06/p_uv.html","page":"Uv","title":"Uv","text":"It is used to build the interaction term in the local Hamiltonian, only valid when icu = 1 or icu = 3.","category":"page"},{"location":"ch06/p_uv.html","page":"Uv","title":"Uv","text":"Comment","category":"page"},{"location":"ch06/p_uv.html","page":"Uv","title":"Uv","text":"See also Uc, Jz, Js, Jp, and icu parameters for more details.","category":"page"},{"location":"ch09/ct.html#Principles-of-continuous-time-quantum-Monte-Carlo-algorithm","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"","category":"section"},{"location":"ch09/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"Now we already have an impurity model Hamiltonian H_textimp, the question is how to solve it using the Monte Carlo algorithm?","category":"page"},{"location":"ch09/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"We first split the impurity Hamiltonian H_textimp into two separate parts, ","category":"page"},{"location":"ch09/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"H_textimp = H_1 + H_2","category":"page"},{"location":"ch09/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"then treat H_2 as a perturbation term, and expand the partition function mathcalZ in powers of H_2,","category":"page"},{"location":"ch09/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"beginequation\nmathcalZ =  textTr e^-beta H = sum_n=0^infty int_0^beta cdots int_tau_n-1^beta omega(mathcalC_n)\nendequation","category":"page"},{"location":"ch09/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"with","category":"page"},{"location":"ch09/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"beginequation\nomega(mathcalC_n)=dtau_1 cdots dtau_n textTrleft e^-beta H_1-H_2(tau_n)cdots -H_2(tau_1)right\nendequation","category":"page"},{"location":"ch09/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"where H_2(tau) is defined in the interaction picture with ","category":"page"},{"location":"ch09/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"H_2(tau) = e^tau H_1 H_2 e^-tau H_1","category":"page"},{"location":"ch09/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"Each term in the right side of the second equation can be regarded as a diagram or configuration (labeled by mathcalC), and omega(mathcalC_n) is the diagrammatic weight of a specific order-n configuration. Next we use a stochastic Monte Carlo algorithm to sample the terms of this series. This is the core spirit of the continuous-time quantum Monte Carlo impurity solver. The idea is very simple, but the realization is not.","category":"page"},{"location":"ch09/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"Depending on the different choices of H_2 term, there are multiple variations for the continuous-time quantum Monte Carlo impurity solver. According to our knowledge, the variations at least include","category":"page"},{"location":"ch09/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"CT-INT\nCT-HYB\nCT-J\nCT-AUX","category":"page"},{"location":"ch09/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"In the CT-INT and CT-AUX quantum impurity solvers[1][2], the interaction term is the perturbation term, namely, H_2 = H_textint, while H_2 = H_texthyb is chosen for the CT-HYB quantum impurity solver[3]. The CT-J quantum impurity solver is designed for the Kondo lattice model only[4]. We won't discuss it at here. In the intermediate and strong interaction region, CT-HYB is much more efficient than CT-INT and CT-AUX. We could even say that it is the most powerful and efficient quantum impurity solver so far. This is also the main reason that we only implemented the CT-HYB quantum impurity solvers in the iQIST software package.","category":"page"},{"location":"ch09/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"Reference","category":"page"},{"location":"ch09/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"[1]: A. N. Rubtsov, V. V. Savkin, and A. I. Lichtenstein, Phys. Rev. B 72, 035122 (2005)","category":"page"},{"location":"ch09/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"[2]: Emanuel Gull, Philipp Werner, Olivier Parcollet, Matthias Troyer, EPL 82, 57003 (2008)","category":"page"},{"location":"ch09/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"[3]: Philipp Werner, Armin Comanac, Luca deâ Medici, Matthias Troyer, and Andrew J. Millis, Phys. Rev. Lett. 97, 076405 (2006)","category":"page"},{"location":"ch09/ct.html","page":"Principles of continuous-time quantum Monte Carlo algorithm","title":"Principles of continuous-time quantum Monte Carlo algorithm","text":"[4]: Junya Otsuki, Hiroaki Kusunose, Philipp Werner, and Yoshio Kuramoto, J. Phys. Soc. Jpn. 76, 114707 (2007)","category":"page"},{"location":"ch09/tran.html#Transition-probability","page":"Transition probability","title":"Transition probability","text":"","category":"section"},{"location":"ch09/atomic.html#Atomic-eigenvalue-solver","page":"Atomic eigenvalue solver","title":"Atomic eigenvalue solver","text":"","category":"section"},{"location":"ch09/atomic.html","page":"Atomic eigenvalue solver","title":"Atomic eigenvalue solver","text":"The JASMINE component of iQIST software package is used to solve a local atomic Hamiltonian defined as,","category":"page"},{"location":"ch09/atomic.html","page":"Atomic eigenvalue solver","title":"Atomic eigenvalue solver","text":"beginequation\nhatH_textatom=hatH_0+hatH_U\nendequation","category":"page"},{"location":"ch09/atomic.html","page":"Atomic eigenvalue solver","title":"Atomic eigenvalue solver","text":"where, hatH_0 is the on-site term, and hatH_U is the Coulomb interaction term.","category":"page"},{"location":"ch09/atomic.html","page":"Atomic eigenvalue solver","title":"Atomic eigenvalue solver","text":"The hatH_0 term includes the crystal field (CF) splitting term hatH_textCF, spin-orbit coupling (SOC) term hatH_textSOC, and other terms such as a Zeeman term in case of the presence of external magnetic field,","category":"page"},{"location":"ch09/atomic.html","page":"Atomic eigenvalue solver","title":"Atomic eigenvalue solver","text":"beginequation\nhatH_0=hatH_textCF+hatH_textSOC+textother on-site terms\nendequation","category":"page"},{"location":"ch09/atomic.html","page":"Atomic eigenvalue solver","title":"Atomic eigenvalue solver","text":"We can re-write the hatH_textatom in second quantization form,","category":"page"},{"location":"ch09/atomic.html","page":"Atomic eigenvalue solver","title":"Atomic eigenvalue solver","text":"beginequation\nhatH_textatom=sum_alphabetaE_alphabetahatf_alpha^daggerhatf_beta\n                     +sum_alphabetagammadeltaU_alphabetagammadeltahatf_alpha^dagger\n                     hatf_beta^daggerhatf_deltahatf_gamma\nendequation","category":"page"},{"location":"ch09/atomic.html","page":"Atomic eigenvalue solver","title":"Atomic eigenvalue solver","text":"where, alphabetagammadelta is the single particle orbital-spin index, the first term is the on-site term, the second one is the Coulomb interaction term.","category":"page"},{"location":"ch07/script.html#Scripts","page":"README","title":"Scripts","text":"","category":"section"},{"location":"ch07/script.html","page":"README","title":"README","text":"The HIBISCUS component contains lots of Python and Bash shell scripts. They are extremely useful for the users and developers. These scripts are in the iqist/src/tools/hibiscus/script directory.","category":"page"},{"location":"ch07/script.html","page":"README","title":"README","text":"For iQIST developers only:","category":"page"},{"location":"ch07/script.html","page":"README","title":"README","text":"script/d_archive.sh // Archive the repo.\nscript/d_check.py // Check the trailing blanks\nscript/d_clean.py // Clean the .DS_store files.\nscript/d_cmp.py // Compare calculated results for two cases.\nscript/d_sar.sh // Search and replace tool.\nscript/d_trailing.sh // Get rid of the trailing blanks.","category":"page"},{"location":"ch07/script.html","page":"README","title":"README","text":"For iQIST users only:","category":"page"},{"location":"ch07/script.html","page":"README","title":"README","text":"script/u_animator.py // Generate animator movie.\nscript/u_atomic.py // User interface for the JASMINE code.\nscript/u_ctqmc.py // User interface for the CT-HYB impurity solvers.\nscript/u_hfqmc.py // User interface for the HF-QMC impurity solver.\nscript/u_reader.py // Python input module for the iQIST code.\nscript/u_writer.py // Python output module for the iQIST code.","category":"page"},{"location":"ch04/out_hybri.html#solver.hybri.dat","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"","category":"section"},{"location":"ch04/out_hybri.html","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"Introduction","category":"page"},{"location":"ch04/out_hybri.html","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"This file is used to store the imaginary-time hybridization function Delta(tau). It will be output by the quantum impurity solvers when they are shut down.","category":"page"},{"location":"ch04/out_hybri.html","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"Format","category":"page"},{"location":"ch04/out_hybri.html","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"The solver.hybri.dat file contains norbs block. Each block is appended by two blank lines. The format of each block is as follows:","category":"page"},{"location":"ch04/out_hybri.html","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"","category":"page"},{"location":"ch04/out_hybri.html","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"column 1: orbital index i, integer","category":"page"},{"location":"ch04/out_hybri.html","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"column 2: imaginary-time index j, integer","category":"page"},{"location":"ch04/out_hybri.html","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"column 3: imaginary-time point, tau, double precision","category":"page"},{"location":"ch04/out_hybri.html","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"column 4: imaginary-time hybridization function, Delta(tau), double precision","category":"page"},{"location":"ch04/out_hybri.html","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"column 5: error bar, delta Delta(tau), double precision","category":"page"},{"location":"ch04/out_hybri.html","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"","category":"page"},{"location":"ch04/out_hybri.html","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"note: Note\nIn the solver.hybri.dat file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch04/out_hybri.html","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"Code","category":"page"},{"location":"ch04/out_hybri.html","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"The corresponding Fortran code block for the writing of solver.hybri.dat file is as follows:","category":"page"},{"location":"ch04/out_hybri.html","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"! open data file: solver.hybri.dat\n     open(mytmp, file='solver.hybri.dat', form='formatted', status='unknown')\n\n! write it\n     do i=1,norbs\n         do j=1,ntime\n             write(mytmp,'(2i6,3f12.6)') i, j, tmesh(j), htau(j,i,i), zero\n         enddo ! over j={1,ntime} loop\n         write(mytmp,*) ! write empty lines\n         write(mytmp,*)\n     enddo ! over i={1,norbs} loop\n\n! close data file\n     close(mytmp)","category":"page"},{"location":"ch04/out_hybri.html","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"note: Note\nThe column for the error bar is always zero in this file.","category":"page"},{"location":"ch04/out_hybri.html","page":"solver.hybri.dat","title":"solver.hybri.dat","text":"In the HIBISCUS component, we provide a Python module to read the output files of quantum impurity solvers. You can use it to read the solver.hybri.dat file. See script/u_reader.py for more details.","category":"page"},{"location":"ch04/p_nvect.html#Parameter:-nvect","page":"nvect","title":"Parameter: nvect","text":"","category":"section"},{"location":"ch04/p_nvect.html","page":"nvect","title":"nvect","text":"Definition","category":"page"},{"location":"ch04/p_nvect.html","page":"nvect","title":"nvect","text":"Number of selected eigen-vectors (maximum value is ncfgs, minimum value is 1) for the calculation of local operator trace.","category":"page"},{"location":"ch04/p_nvect.html","page":"nvect","title":"nvect","text":"Type","category":"page"},{"location":"ch04/p_nvect.html","page":"nvect","title":"nvect","text":"Integer","category":"page"},{"location":"ch04/p_nvect.html","page":"nvect","title":"nvect","text":"Default value","category":"page"},{"location":"ch04/p_nvect.html","page":"nvect","title":"nvect","text":"4","category":"page"},{"location":"ch04/p_nvect.html","page":"nvect","title":"nvect","text":"Component","category":"page"},{"location":"ch04/p_nvect.html","page":"nvect","title":"nvect","text":"Only for the CAMELLIA component.","category":"page"},{"location":"ch04/p_nvect.html","page":"nvect","title":"nvect","text":"Behavior","category":"page"},{"location":"ch04/p_nvect.html","page":"nvect","title":"nvect","text":"In the CAMELLIA component, we used the Newton-Leja interpolation algorithm to calculate the local operator trace. In this algorithm, we have to consider the time evolution of each eigenvectors of the local Hamiltonian. In order to improve the computational efficiency, we applied the truncation approximation further. In other words, we only keep a few eigenvectors in the calculations. And nvect is the number of the selected eigenstates. ","category":"page"},{"location":"ch04/p_nvect.html","page":"nvect","title":"nvect","text":"If we only retain the ground states, it is the O(1) approximation. If both the ground states and the first low-lying states are retained, it is the O(2) approximation. According to our experience, for low temperature system, the O(1) approximation is reasonable. Obviously, the larger nvect is, the more accurate and slower the calculation will be.","category":"page"},{"location":"ch04/p_nvect.html","page":"nvect","title":"nvect","text":"Comment","category":"page"},{"location":"ch04/p_nvect.html","page":"nvect","title":"nvect","text":"The CAMELLIA component is not ready now.","category":"page"},{"location":"ch06/out_umat2.html#atom.umat.dat","page":"atom.umat.dat","title":"atom.umat.dat","text":"","category":"section"},{"location":"ch06/out_umat2.html","page":"atom.umat.dat","title":"atom.umat.dat","text":"Introduction","category":"page"},{"location":"ch06/out_umat2.html","page":"atom.umat.dat","title":"atom.umat.dat","text":"The atom.umat.dat file contains the general (four-fermions) Coulomb interaction matrix. Only the non-zero matrix elements (> 1.0E-10) are outputted.","category":"page"},{"location":"ch06/out_umat2.html","page":"atom.umat.dat","title":"atom.umat.dat","text":"Format","category":"page"},{"location":"ch06/out_umat2.html","page":"atom.umat.dat","title":"atom.umat.dat","text":"The format of the atom.umat.dat file is as follows:","category":"page"},{"location":"ch06/out_umat2.html","page":"atom.umat.dat","title":"atom.umat.dat","text":"","category":"page"},{"location":"ch06/out_umat2.html","page":"atom.umat.dat","title":"atom.umat.dat","text":"column 1: orbital index alpha, integer","category":"page"},{"location":"ch06/out_umat2.html","page":"atom.umat.dat","title":"atom.umat.dat","text":"column 2: orbital index beta, integer","category":"page"},{"location":"ch06/out_umat2.html","page":"atom.umat.dat","title":"atom.umat.dat","text":"column 3: orbital index gamma, integer","category":"page"},{"location":"ch06/out_umat2.html","page":"atom.umat.dat","title":"atom.umat.dat","text":"column 4: orbital index delta, integer","category":"page"},{"location":"ch06/out_umat2.html","page":"atom.umat.dat","title":"atom.umat.dat","text":"column 5: Elements of general Coulomb matrix U_alphabetagammadelta, real part, double precision","category":"page"},{"location":"ch06/out_umat2.html","page":"atom.umat.dat","title":"atom.umat.dat","text":"column 6: Elements of general Coulomb matrix U_alphabetagammadelta, imaginary part, double precision","category":"page"},{"location":"ch06/out_umat2.html","page":"atom.umat.dat","title":"atom.umat.dat","text":"","category":"page"},{"location":"ch06/out_umat2.html","page":"atom.umat.dat","title":"atom.umat.dat","text":"note: Note\nIn the atom.umat.dat file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch06/out_umat2.html","page":"atom.umat.dat","title":"atom.umat.dat","text":"Code","category":"page"},{"location":"ch06/out_umat2.html","page":"atom.umat.dat","title":"atom.umat.dat","text":"The corresponding Fortran code block for the writing of the atom.umat.dat file is as follows:","category":"page"},{"location":"ch06/out_umat2.html","page":"atom.umat.dat","title":"atom.umat.dat","text":"! open file atom.umat.dat to write\n     open(mytmp, file='atom.umat.dat', form='formatted', status='unknown')\n\n! write the header\n     write(mytmp,'(75a1)') dash ! dashed line\n     write(mytmp,'(a)') '# i | j | k | l | umat_real | umat_imag'\n     write(mytmp,'(75a1)') dash ! dashed line\n\n! write the data, only the non-zero elements are outputed\n! note: we do not change the spin sequence here\n     do i=1,norbs\n         do j=1,norbs\n             do k=1,norbs\n                 do l=1,norbs\n                     if ( abs( umat(i,j,k,l) ) > epst ) then\n                         write(mytmp,'(4i6,2f16.8)') i, j, k, l, umat(i,j,k,l)\n                     endif ! back if ( abs( umat(i,j,k,l) ) > epst ) block\n                 enddo ! over l={1,norbs} loop\n             enddo ! over k={1,norbs} loop\n         enddo ! over j={1,norbs} loop\n     enddo ! over i={1,norbs} loop\n\n! close data file\n     close(mytmp)","category":"page"},{"location":"ch06/out_umat2.html","page":"atom.umat.dat","title":"atom.umat.dat","text":"In general, the Coulomb interaction matrix is complex.","category":"page"},{"location":"ch06/out_umat2.html","page":"atom.umat.dat","title":"atom.umat.dat","text":"See also solver.umat.in for more details.","category":"page"},{"location":"ch03/recipes.html#iQIST-recipes","page":"iQIST recipes","title":"iQIST recipes","text":"","category":"section"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"Using the iQIST software package is quite easy. Next we will show you the standard workflow for using the iQIST software package.","category":"page"},{"location":"ch03/recipes.html#Choose-suitable-component","page":"iQIST recipes","title":"Choose suitable component","text":"","category":"section"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"At first, there are several CT-HYB quantum impurity solvers in the package. Their features and efficiency are somewhat different. Thus, it is the user's responsibility to choose suitable CT-HYB components to deal with the impurity problem at hand. ","category":"page"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"See also:","category":"page"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"Components // What does the iQIST software package include?\nFeatures // Is the required feature supported by the selected component?\nHow to choose suitable quantum impurity solvers? // A guideline.","category":"page"},{"location":"ch03/recipes.html#Design-the-programs-and-scripts","page":"iQIST recipes","title":"Design the programs and scripts","text":"","category":"section"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"Second, the iQIST software package is in essence a computational engine, so users have to write scripts or programs to execute the selected CT-HYB impurity solver directly or to call it using the application programming interface. For example, if the users want to conduct CT-HYB/DMFT calculations, in principle they must implement the DMFT self-consistent equation by themselves.","category":"page"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"There is a bonus. When the users want to study the Hubbard model on Bethe/cubic lattice using the single-site dynamical mean-field theory, or solve the Anderson impurity models in one-shot mode, it is possible to execute the quantum impurity solvers directly without any additional scripts or programs.","category":"page"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"See also:","category":"page"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"Application programming interfaces // How to use iQIST via external Python/Fortran programs.","category":"page"},{"location":"ch03/recipes.html#Prepare-the-input-files","page":"iQIST recipes","title":"Prepare the input files","text":"","category":"section"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"Third, an important task is to prepare proper input data for the selected CT-HYB impurity solver. The optional inputs for the CT-HYB impurity solver are the hybridization function [Delta(iomega_n)], impurity energy level (E_alphabeta), interaction parameters (U, J, lambda, and mu), etc. If users do not provide them to the impurity solver, it will use the default settings automatically. Specifically, if the Coulomb interaction matrix is general or the spin-orbital coupling is considered, users should use the JASMINE component to solve the local atomic Hamiltonian problem at first to generate the necessary eigenvalues and eigenvectors. ","category":"page"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"See also:","category":"page"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"Prepare input files // Are you ready?\nStandard input files // Input stuffs for CT-HYB/HF-QMC impurity solvers.\nStandard input files // Input stuffs for atomic eigenvalue problem solver.","category":"page"},{"location":"ch03/recipes.html#Let's-go.","page":"iQIST recipes","title":"Let's go.","text":"","category":"section"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"Fourth, execute the CT-HYB impurity solver directly or via some external scripts/programs.","category":"page"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"See also:","category":"page"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"Execute the codes // MPI vs. OpenMP, paralleled or sequential.\nMonitor the codes // What's the status of the code?","category":"page"},{"location":"ch03/recipes.html#Post-processing","page":"iQIST recipes","title":"Post-processing","text":"","category":"section"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"Finally, when the calculations are finished, users can use the tools contained in the HIBISCUS component to post-process the output data, such as the imaginary-time Green's function G(tau), Matsubara self-energy function Sigma(iomega_n), and other physical observables.","category":"page"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"See also:","category":"page"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"Auxiliary tools // Full descriptions about the auxiliary toolbox.","category":"page"},{"location":"ch03/recipes.html","page":"iQIST recipes","title":"iQIST recipes","text":"Good luck to you.","category":"page"},{"location":"ch04/out_green.html#solver.green.dat","page":"solver.green.dat","title":"solver.green.dat","text":"","category":"section"},{"location":"ch04/out_green.html","page":"solver.green.dat","title":"solver.green.dat","text":"Introduction","category":"page"},{"location":"ch04/out_green.html","page":"solver.green.dat","title":"solver.green.dat","text":"This file is used to store the imaginary-time Green's function G(tau). It will be output by the quantum impurity solvers periodically (every nwrite Monte Carlo sampling steps, see nwrite for more details).","category":"page"},{"location":"ch04/out_green.html","page":"solver.green.dat","title":"solver.green.dat","text":"Format","category":"page"},{"location":"ch04/out_green.html","page":"solver.green.dat","title":"solver.green.dat","text":"The solver.green.dat file contains norbs block. Each block is appended by two blank lines. The format of each block is as follows:","category":"page"},{"location":"ch04/out_green.html","page":"solver.green.dat","title":"solver.green.dat","text":"","category":"page"},{"location":"ch04/out_green.html","page":"solver.green.dat","title":"solver.green.dat","text":"column 1: orbital index i, integer","category":"page"},{"location":"ch04/out_green.html","page":"solver.green.dat","title":"solver.green.dat","text":"column 2: imaginary-time index j, integer","category":"page"},{"location":"ch04/out_green.html","page":"solver.green.dat","title":"solver.green.dat","text":"column 3: imaginary-time point, tau, double precision","category":"page"},{"location":"ch04/out_green.html","page":"solver.green.dat","title":"solver.green.dat","text":"column 4: imaginary-time Green's function, G(tau), double precision","category":"page"},{"location":"ch04/out_green.html","page":"solver.green.dat","title":"solver.green.dat","text":"column 5: error bar, delta G(tau), double precision","category":"page"},{"location":"ch04/out_green.html","page":"solver.green.dat","title":"solver.green.dat","text":"","category":"page"},{"location":"ch04/out_green.html","page":"solver.green.dat","title":"solver.green.dat","text":"note: Note\nIn the solver.green.dat file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch04/out_green.html","page":"solver.green.dat","title":"solver.green.dat","text":"Code","category":"page"},{"location":"ch04/out_green.html","page":"solver.green.dat","title":"solver.green.dat","text":"The corresponding Fortran code block for the writing of solver.green.dat file is as follows:","category":"page"},{"location":"ch04/out_green.html","page":"solver.green.dat","title":"solver.green.dat","text":"! open data file: solver.green.dat\n     open(mytmp, file='solver.green.dat', form='formatted', status='unknown')\n\n! write it\n     do i=1,norbs\n         do j=1,ntime\n             write(mytmp,'(2i6,3f12.6)') i, j, tmesh(j), gaux(j,i,i), gtmp(j,i,i)\n         enddo ! over j={1,ntime} loop\n         write(mytmp,*) ! write empty lines\n         write(mytmp,*)\n     enddo ! over i={1,norbs} loop\n\n! close data file\n     close(mytmp)","category":"page"},{"location":"ch04/out_green.html","page":"solver.green.dat","title":"solver.green.dat","text":"In the HIBISCUS component, we provide a Python module to read the output files of quantum impurity solvers. You can use it to read the solver.green.dat file. See script/u_reader.py for more details.","category":"page"},{"location":"ch01/feature.html#Features","page":"Features","title":"Features","text":"","category":"section"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"The main features of the core components (i.e., quantum impurity solvers) of the iQIST software package are as follows:","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"Model\nDensity-density interaction\nGeneral interaction (Slater or Kanamori scheme)[01]\nSpin-orbital coupling and crystal field splitting[02]\nHubbard-Holstein model[03]\nFrequency-dependent Coulomb interaction[04]","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"Measurement tricks\nOrthogonal polynomial representation (Legendre and Chebyshev polynomials)[05]\nKernel polynomial representation[06]\nImproved estimator for self-energy function[07]","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"Observables\nSingle-particle Green's function in imaginary time space\nSingle-particle Green's function in matsubara frequency space\nTwo-particle correlation function in matsubara frequency space (experimental)[08]\nLocal irreducible vertex function in matsubara frequency space (experimental)[09]\nPair susceptibility in matsubara frequency space (experimental)[10]\nSelf-energy function in matsubara frequency space\nHistogram of perturbation expansion order\nKurtosis and skewness of perturbation expansion order\nKinetic and potential energies\nOrbital occupation numbers[11]\nDouble occupation numbers[12]\nMagnetic moment\nAtomic state probability\nSpin-spin correlation function in imaginary time space[13]\nSpin-spin correlation function in matsubara frequency space[13]\nOrbital-orbital correlation function in imaginary time space[14]\nOrbital-orbital correlation function in matsubara frequency space[14]\nFidelity susceptibility[15]\nKinetic energy fluctuation langle k^2rangle - langle krangle^2 - langle krangle[16]","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"Fast algorithms\nSegment algorithm for density-density interaction[17]\nDivide-and-conquer algorithm[18]\nSparse matrix multiplication[19]\nGood quantum numbers (N S_z J_z, PS)[20]\nLazy trace evaluation[21]\nDynamical truncation approximation[22]\nNewton-Leja polynomial interpolation algorithm (experimental)[23]","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"Parallelism\nMPI\nOpenMP[24]","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"API\nPython binding\nInput file generator by Python\nFortran binding","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"Preprocessing\nAtomic eigenvalue problem solver[25]","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"Postprocessing\nMaximum entropy method[26]\nStochastic analytical continuation[27]\nKramers-Kronig transformation[28]\nPade approximation[29]\nPolynomial fitting for self-energy function[30]\nMany tools and scripts, etc.","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"[01]: Only for the BEGONIA, LAVENDER, CAMELLIA, PANSY, and MANJUSHAKA.","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"[02]: Only for the BEGONIA, LAVENDER, PANSY, and MANJUSHAKA.","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"[03]: Only for the NARCISSUS.","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"[04]: Only for the NARCISSUS.","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"[05]: Only for the GARDENIA, NARCISSUS, LAVENDER, CAMELLIA, and MANJUSHAKA.","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"[06]: Only for the GARDENIA, NARCISSUS, LAVENDER, CAMELLIA, and MANJUSHAKA.","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"[07]: Only for the GARDENIA and NARCISSUS.","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"[08]: Only for the GARDENIA, NARCISSUS, LAVENDER, CAMELLIA, and MANJUSHAKA.","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"[09]: Only for the GARDENIA, NARCISSUS, LAVENDER, CAMELLIA, and MANJUSHAKA.","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"[10]: Only for the GARDENIA, NARCISSUS, LAVENDER, CAMELLIA, and MANJUSHAKA.","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"[11]: Only for the AZALEA, GARDENIA, and NARCISSUS.","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"[12]: Only for the AZALEA, GARDENIA, and NARCISSUS.","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"[13]: Only for the GARDENIA and NARCISSUS.","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"[14]: Only for the GARDENIA and NARCISSUS.","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"[15]: Only for the GARDENIA, NARCISSUS, LAVENDER, CAMELLIA, and MANJUSHAKA.","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"[16]: Only for the GARDENIA, NARCISSUS, LAVENDER, CAMELLIA, and MANJUSHAKA.","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"[17]: Only for the AZALEA, GARDENIA, and NARCISSUS.","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"[18]: Only for the BEGONIA, LAVENDER, PANSY, and MANJUSHAKA.","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"[19]: Only for the BEGONIA, LAVENDER, and CAMELLIA.","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"[20]: Only for the PANSY and MANJUSHAKA.","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"[21]: Only for the MANJUSHAKA.","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"[22]: Only for the MANJUSHAKA.","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"[23]: Only for the CAMELLIA.","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"[24]: Only for the measurement of two-particle quantities.","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"[25]: Only for the JASMINE.","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"[26]: Only for the HIBISCUS.","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"[27]: Only for the HIBISCUS.","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"[28]: Only for the HIBISCUS.","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"[29]: Only for the HIBISCUS.","category":"page"},{"location":"ch01/feature.html","page":"Features","title":"Features","text":"[30]: Only for the HIBISCUS.","category":"page"},{"location":"ch04/in_anydos.html#solver.anydos.in","page":"solver.anydos.in","title":"solver.anydos.in","text":"","category":"section"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"Introduction","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"In the CT-QMC impurity solvers contained in the iQIST software package, we provide a mini dynamical mean-field theory engine. This engine implements a self-consistent condition for the Bethe lattice which has a semi-circular density of states with bandwith 4t. Sometimes you may want to try the other models with arbitrary density of states.","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"Is it possible?","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"Yes, of course. You can define your density of states in the solver.anydos.in file. And then you have to hack the ctqmc_dmft.f90 file.","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"Change the following codes","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"......\n     use context, only : grnf\n......\n! calculate new hybridization function using self-consistent condition\n     call ctqmc_dmft_bethe(hybf, grnf)","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"to","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"......\n     use context, only : grnf, sig2\n......\n! calculate new hybridization function using self-consistent condition\n     call ctqmc_dmft_anydos(hybf, grnf, sig2)","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"You have to be very careful. Finally, recompiling the CT-QMC impurity solvers is necessary.","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"note: Note\nDon't forget to set the isscf parameter to 2, or else the CT-QMC impurity solvers will skip the dynamical mean-field theory engine and perform one-shot calculation only.\nThe HF-QMC impurity solver (the DAISY component) does not support this file/feature.","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"Format","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"The format of the solver.anydos.in file is as follows:","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"column 1: frequency point, epsilon, double precision","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"column 2: density of states, rho(epsilon), double precision","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"note: Note\nWe assume that:The orbitals are degenerated.\nThe number of frequency points is 801.If you are not satisfied with these assumptions, you have to hack the corresponding ctqmc_dmft.f90 by yourself.","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"Code","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"The corresponding Fortran code block for the reading of solver.anydos.in file is as follows:","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"open(mytmp, file='solver.anydos.in', form='formatted', status='unknown')\ndo i=1,ngrid\n    read(mytmp,*) epsi(i), pdos(i,1)\n    do j=2,norbs\n        pdos(:,j) = pdos(:,1)\n    enddo ! over j={2,norbs} loop\nenddo ! over i={1,ngrid} loop\nclose(mytmp)","category":"page"},{"location":"ch04/in_anydos.html","page":"solver.anydos.in","title":"solver.anydos.in","text":"For some typical models, the solver.anydos.in file can be generated using the toolbox/makedos tool which is included in the HIBISCUS component. See toolbox/makedos for more details.","category":"page"},{"location":"ch06/out_cix.html#atom.cix","page":"atom.cix","title":"atom.cix","text":"","category":"section"},{"location":"ch06/out_cix.html","page":"atom.cix","title":"atom.cix","text":"Introduction","category":"page"},{"location":"ch06/out_cix.html","page":"atom.cix","title":"atom.cix","text":"The atom.cix file is the most important files generated by the JASMINE component. It is an all-in-one file which contains all of the necessary information for a given atomic eigenvalues problem. It is also one of the necessary input files for the CT-HYB quantum impurity solvers (general matrix version). Once it was created, you have to copy it to a correct directory, so that the quantum impurity solvers can find it out.","category":"page"},{"location":"ch06/out_cix.html","page":"atom.cix","title":"atom.cix","text":"Format","category":"page"},{"location":"ch06/out_cix.html","page":"atom.cix","title":"atom.cix","text":"The atom.cix has three different file formats. They are suitable for different quantum impurity solvers. Which file format is used depends on the ictqmc parameter. ","category":"page"},{"location":"ch06/out_cix.html","page":"atom.cix","title":"atom.cix","text":"File Format A, should be compatible with the CAMELLIA component","category":"page"},{"location":"ch06/out_cix.html","page":"atom.cix","title":"atom.cix","text":"note: Note\nictqmc = 0.","category":"page"},{"location":"ch06/out_cix.html","page":"atom.cix","title":"atom.cix","text":"File Format B, should be compatible with the BEGONIA and LAVENDER components","category":"page"},{"location":"ch06/out_cix.html","page":"atom.cix","title":"atom.cix","text":"note: Note\nictqmc = 1.","category":"page"},{"location":"ch06/out_cix.html","page":"atom.cix","title":"atom.cix","text":"File Format C, should be compatible with the MANJUSHAKA and PANSY components","category":"page"},{"location":"ch06/out_cix.html","page":"atom.cix","title":"atom.cix","text":"note: Note\nictqmc = 2, 3, 4, 5.","category":"page"},{"location":"ch06/out_cix.html","page":"atom.cix","title":"atom.cix","text":"See ictqmc parameter for more details.","category":"page"},{"location":"ch06/out_cix.html","page":"atom.cix","title":"atom.cix","text":"The file formats of the atom.cix file are a bit complex. It is unnecessary to understand its full details. If you are a maintainer or developer of the JASMINE component, please read the source codes in iqist/src/tools/jasmine/atomic_dump.f90.","category":"page"},{"location":"ch06/out_cix.html","page":"atom.cix","title":"atom.cix","text":"See also atom.cix for more details.","category":"page"},{"location":"ch06/out_cix.html","page":"atom.cix","title":"atom.cix","text":"Code","category":"page"},{"location":"ch06/out_cix.html","page":"atom.cix","title":"atom.cix","text":"N/A","category":"page"},{"location":"ch04/p_ntherm.html#Parameter:-ntherm","page":"ntherm","title":"Parameter: ntherm","text":"","category":"section"},{"location":"ch04/p_ntherm.html","page":"ntherm","title":"ntherm","text":"Definition","category":"page"},{"location":"ch04/p_ntherm.html","page":"ntherm","title":"ntherm","text":"Maximum number of Monte Carlo thermalization steps.","category":"page"},{"location":"ch04/p_ntherm.html","page":"ntherm","title":"ntherm","text":"Type","category":"page"},{"location":"ch04/p_ntherm.html","page":"ntherm","title":"ntherm","text":"Integer","category":"page"},{"location":"ch04/p_ntherm.html","page":"ntherm","title":"ntherm","text":"Default value","category":"page"},{"location":"ch04/p_ntherm.html","page":"ntherm","title":"ntherm","text":"200000 (for CT-HYB impurity solvers) or 100 (for HF-QMC impurity solvers)","category":"page"},{"location":"ch04/p_ntherm.html","page":"ntherm","title":"ntherm","text":"Component","category":"page"},{"location":"ch04/p_ntherm.html","page":"ntherm","title":"ntherm","text":"ALL","category":"page"},{"location":"ch04/p_ntherm.html","page":"ntherm","title":"ntherm","text":"Behavior","category":"page"},{"location":"ch04/p_ntherm.html","page":"ntherm","title":"ntherm","text":"Before starting to measure the physical observables, we have to ensure the system has reached thermal equilibrium state. So during the first ntherm Monte Carlo steps, the quantum impurity solvers just update the diagrammatic configuration, but don't record the physical quantities.","category":"page"},{"location":"ch04/p_ntherm.html","page":"ntherm","title":"ntherm","text":"Comment","category":"page"},{"location":"ch04/p_ntherm.html","page":"ntherm","title":"ntherm","text":"According to our experience, the optimal value for ntherm can be one tenth of the value of nsweep. See nsweep parameter for more details.","category":"page"},{"location":"ch08/screening.html#Retarded-interaction-and-dynamical-screening-effect","page":"Retarded interaction and dynamical screening effect","title":"Retarded interaction and dynamical screening effect","text":"","category":"section"},{"location":"ch09/rng.html#Random-number-generators","page":"Random number generators","title":"Random number generators","text":"","category":"section"},{"location":"ch09/rng.html","page":"Random number generators","title":"Random number generators","text":"Fast, reliable, and long period pseudo-random number generators are a key factor for any Monte Carlo simulations. Currently, the most popular random number generator is the Mersenne Twister which was developed in 1998 by Matsumoto and Nishimura[1]. Its name derives from the fact that its period length is chosen to be a Mersenne prime. In the iQIST software package, we implemented the commonly used version of Mersenne Twister, MT19937. It has a very long period of 2^19937-1. Of course, if we choose different parameter sets, its period can be shorter or longer.","category":"page"},{"location":"ch09/rng.html","page":"Random number generators","title":"Random number generators","text":"The Mersenne Twister is a bit slow by today's standards. So in 2006, a variant of Mersenne Twister, the SIMD-oriented Fast Mersenne Twister (SFMT)[2] was introduced. It was designed to be fast when it runs on 128-bit SIMD. It is almost twice as fast as the original Mersenne Twister and has better statistics properties. We also implemented it in the iQIST software package, and use it as the default random number generator.","category":"page"},{"location":"ch09/rng.html","page":"Random number generators","title":"Random number generators","text":"Reference","category":"page"},{"location":"ch09/rng.html","page":"Random number generators","title":"Random number generators","text":"[1]: M. Matsumoto, T. Nishimura, ACM Transactions on Modeling and Computer Simulation **8 ** 3(1998)","category":"page"},{"location":"ch09/rng.html","page":"Random number generators","title":"Random number generators","text":"[2]: Mutsuo Saito and Makoto Matsumoto, Monte Carlo and Quasi-Monte Carlo Methods, Springer, 607 â 622 (2008)","category":"page"},{"location":"ch04/p_alpha.html#Parameter:-alpha","page":"alpha","title":"Parameter: alpha","text":"","category":"section"},{"location":"ch04/p_alpha.html","page":"alpha","title":"alpha","text":"Definition","category":"page"},{"location":"ch04/p_alpha.html","page":"alpha","title":"alpha","text":"Mixing parameter alpha for dynamical mean-field theory self-consistent engine.","category":"page"},{"location":"ch04/p_alpha.html","page":"alpha","title":"alpha","text":"Type","category":"page"},{"location":"ch04/p_alpha.html","page":"alpha","title":"alpha","text":"Float, double precision","category":"page"},{"location":"ch04/p_alpha.html","page":"alpha","title":"alpha","text":"Default value","category":"page"},{"location":"ch04/p_alpha.html","page":"alpha","title":"alpha","text":"0.7","category":"page"},{"location":"ch04/p_alpha.html","page":"alpha","title":"alpha","text":"Component","category":"page"},{"location":"ch04/p_alpha.html","page":"alpha","title":"alpha","text":"ALL","category":"page"},{"location":"ch04/p_alpha.html","page":"alpha","title":"alpha","text":"Behavior","category":"page"},{"location":"ch04/p_alpha.html","page":"alpha","title":"alpha","text":"In the dynamical mean-field theory self-consistent engine, the new hybridization function and self-energy function are mixed using the following equations.","category":"page"},{"location":"ch04/p_alpha.html","page":"alpha","title":"alpha","text":"beginequation\nDelta_textnew leftarrow Delta_textold(1-alpha) + alpha Delta_textnew\nendequation","category":"page"},{"location":"ch04/p_alpha.html","page":"alpha","title":"alpha","text":"beginequation\nSigma_textnew leftarrow Sigma_textold(1-alpha) + alpha Sigma_textnew\nendequation","category":"page"},{"location":"ch04/p_alpha.html","page":"alpha","title":"alpha","text":"Here, Delta_textold and Sigma_textold are obtained in the previous iteration, while Delta_textnew and Sigma_textnew are derived in the current iteration.","category":"page"},{"location":"ch04/p_alpha.html","page":"alpha","title":"alpha","text":"Comment","category":"page"},{"location":"ch04/p_alpha.html","page":"alpha","title":"alpha","text":"If you have trouble in achieving convergence, you can decrease it to 0.5 or even 0.2. If you are doing one-shot calculation (isscf = 1), this parameter is useless. It is useful only when isscf = 2. ","category":"page"},{"location":"ch04/p_alpha.html","page":"alpha","title":"alpha","text":"See also isscf parameter for more details.","category":"page"},{"location":"ch08/story.html#Successful-stories","page":"Successful stories","title":"Successful stories","text":"","category":"section"},{"location":"ch06/input.html#Standard-input-files","page":"README","title":"Standard input files","text":"","category":"section"},{"location":"ch06/input.html","page":"README","title":"README","text":"The atomic eigenvalue problem solver, i.e., the JASMINE component, is designed to diagonalize the atomic Hamiltonian and generate the necessary atom.cix file for the CT-HYB quantum impurity solvers. Since the atomic Hamiltonian is a bit complex, which may include the chemical potential term, onsite Coulomb interaction matrix term, crystal field splitting term, and spin-orbital coupling term, and so on. Some of them are in matrix-form, and the others are vectors. So in order to define the atomic Hamiltonian conveniently, it is essential to introduce multiple input files.","category":"page"},{"location":"ch06/input.html","page":"README","title":"README","text":"The standard input files supported by the atomic eigenvalue problem solver are as follows:","category":"page"},{"location":"ch06/input.html","page":"README","title":"README","text":"atom.config.in // Primary configuration file for the JASMINE component.\natom.cmat.in // Crystal field splitting.\natom.emat.in // On-site impurity energy level.\natom.tmat.in // Transformation matrix.","category":"page"},{"location":"ch01/policy.html#Policy","page":"Policy","title":"Policy","text":"","category":"section"},{"location":"ch01/policy.html#License","page":"Policy","title":"License","text":"","category":"section"},{"location":"ch01/policy.html","page":"Policy","title":"Policy","text":"The iQIST software package is released under the General Public Licence 3.0 (GPL) or later version.","category":"page"},{"location":"ch01/policy.html#Registration","page":"Policy","title":"Registration","text":"","category":"section"},{"location":"ch01/policy.html","page":"Policy","title":"Policy","text":"Registration is not obligated of course. But if you can send your email address to us, we can inform you on time once the new iQIST is released.","category":"page"},{"location":"ch01/policy.html#Technical-support","page":"Policy","title":"Technical support","text":"","category":"section"},{"location":"ch01/policy.html","page":"Policy","title":"Policy","text":"We are sorry. We DO NOT provide any technical supports now. If you meet some problems when you are using the iQIST. You can write a letter to us. But we can not guarantee that we will reply you on time.","category":"page"},{"location":"ch01/policy.html#Feedback","page":"Policy","title":"Feedback","text":"","category":"section"},{"location":"ch01/policy.html","page":"Policy","title":"Policy","text":"If you have any suggestions, comments, successful stories, or criticisms, welcome! Please write a letter to us.","category":"page"},{"location":"ch01/policy.html#Contribution","page":"Policy","title":"Contribution","text":"","category":"section"},{"location":"ch01/policy.html","page":"Policy","title":"Policy","text":"If you find a bug, want to patch it, or want to contribute your codes to the iQIST, great! Please write a letter to us as soon as possible.","category":"page"},{"location":"ch01/policy.html#Donation","page":"Policy","title":"Donation","text":"","category":"section"},{"location":"ch01/policy.html","page":"Policy","title":"Policy","text":"We DO NOT need any donations now.","category":"page"},{"location":"ch01/policy.html#Contact","page":"Policy","title":"Contact","text":"","category":"section"},{"location":"ch01/policy.html","page":"Policy","title":"Policy","text":"Dr. Li Huang","category":"page"},{"location":"ch01/policy.html","page":"Policy","title":"Policy","text":"Affiliation: Institute of Materials, China Academy of Engineering Physics, Sichuan Jiangyou, PRC","category":"page"},{"location":"ch01/policy.html","page":"Policy","title":"Policy","text":"Email: lihuang.dmft at gmail.com","category":"page"},{"location":"ch01/policy.html","page":"Policy","title":"Policy","text":"or","category":"page"},{"location":"ch01/policy.html","page":"Policy","title":"Policy","text":"Dr. Yilin Wang","category":"page"},{"location":"ch01/policy.html","page":"Policy","title":"Policy","text":"Affiliation: Institute of Physics, Chinese Academy of Sciences, Beijing, PRC","category":"page"},{"location":"ch01/policy.html","page":"Policy","title":"Policy","text":"Email: qhwyl2006 at 126.com","category":"page"},{"location":"ch01/policy.html#Citation","page":"Policy","title":"Citation","text":"","category":"section"},{"location":"ch01/policy.html","page":"Policy","title":"Policy","text":"It is really appreciated if you can cite the following paper when you would like to publish your great works by using the iQIST software package. It is really important for us. But, of course, it is also not obligated.","category":"page"},{"location":"ch01/policy.html","page":"Policy","title":"Policy","text":"iQIST: An open source continuous-time quantum Monte Carlo impurity solver toolkit\nLi Huang, Yilin Wang, Zi Yang Meng, Liang Du, Philipp Werner and Xi Dai\nComputer Physics Communications 195, 140 (2015) or arXiv:1409.7573 (2014)","category":"page"},{"location":"ch06/out_term.html#Terminal-output","page":"Terminal output","title":"Terminal output","text":"","category":"section"},{"location":"ch06/out_term.html","page":"Terminal output","title":"Terminal output","text":"Introduction","category":"page"},{"location":"ch06/out_term.html","page":"Terminal output","title":"Terminal output","text":"From the terminal output, we can monitor the running status of the atomic eigenvalue problem solver. It is not important.","category":"page"},{"location":"ch06/out_term.html","page":"Terminal output","title":"Terminal output","text":"Format","category":"page"},{"location":"ch06/out_term.html","page":"Terminal output","title":"Terminal output","text":"N/A","category":"page"},{"location":"ch06/out_term.html","page":"Terminal output","title":"Terminal output","text":"Code","category":"page"},{"location":"ch06/out_term.html","page":"Terminal output","title":"Terminal output","text":"N/A","category":"page"},{"location":"ch04/p_uc.html#Parameter:-Uc","page":"Uc","title":"Parameter: Uc","text":"","category":"section"},{"location":"ch04/p_uc.html","page":"Uc","title":"Uc","text":"Definition","category":"page"},{"location":"ch04/p_uc.html","page":"Uc","title":"Uc","text":"Intra-orbital Coulomb interaction U_c.","category":"page"},{"location":"ch04/p_uc.html","page":"Uc","title":"Uc","text":"Type","category":"page"},{"location":"ch04/p_uc.html","page":"Uc","title":"Uc","text":"Float, double precision","category":"page"},{"location":"ch04/p_uc.html","page":"Uc","title":"Uc","text":"Default value","category":"page"},{"location":"ch04/p_uc.html","page":"Uc","title":"Uc","text":"4.0","category":"page"},{"location":"ch04/p_uc.html","page":"Uc","title":"Uc","text":"Component","category":"page"},{"location":"ch04/p_uc.html","page":"Uc","title":"Uc","text":"ALL","category":"page"},{"location":"ch04/p_uc.html","page":"Uc","title":"Uc","text":"Behavior","category":"page"},{"location":"ch04/p_uc.html","page":"Uc","title":"Uc","text":"It is used to determine the Coulomb interaction matrix.","category":"page"},{"location":"ch04/p_uc.html","page":"Uc","title":"Uc","text":"Comment","category":"page"},{"location":"ch04/p_uc.html","page":"Uc","title":"Uc","text":"Actually, only the AZALEA, GARDENIA, NARCISSUS, and DAISY components need it. For the other quantum impurity solvers components (i.e., the CAMELLIA, BEGONIA, LAVENDER, MANJUSHAKA and PANSY components), the information about the Coulomb interaction matrix is imported via the atom.cix file. So you can set it to any values for the latter five components.","category":"page"},{"location":"ch04/p_uc.html","page":"Uc","title":"Uc","text":"Usually, the U_c, U_v and J_z should meet the following relation:","category":"page"},{"location":"ch04/p_uc.html","page":"Uc","title":"Uc","text":"beginequation\nU_c = U_v - 2J_z\nendequation","category":"page"},{"location":"ch04/p_uc.html","page":"Uc","title":"Uc","text":"See also Uv, Jz parameters for more details.","category":"page"},{"location":"ch04/p_uc.html","page":"Uc","title":"Uc","text":"note: Note\nFor the AZALEA, GARDENIA, NARCISSUS, and DAISY components, the Coulomb interaction matrix can be imported via the solver.umat.in file which has the highest priority. See solver.umat.in for more details.","category":"page"},{"location":"ch08/valid.html#Code-validation","page":"Code validation","title":"Code validation","text":"","category":"section"},{"location":"ch08/cfs.html#Crystal-field-splitting","page":"Crystal field splitting","title":"Crystal field splitting","text":"","category":"section"},{"location":"ch04/p_chmax.html#Parameter:-chmax","page":"chmax","title":"Parameter: chmax","text":"","category":"section"},{"location":"ch04/p_chmax.html","page":"chmax","title":"chmax","text":"Definition","category":"page"},{"location":"ch04/p_chmax.html","page":"chmax","title":"chmax","text":"The maximum allowable expansion order n for the second kind Chebyshev orthogonal polynomials. It must be greater than 2.","category":"page"},{"location":"ch04/p_chmax.html","page":"chmax","title":"chmax","text":"The recursive definition for the second kind Chebyshev polynomials is as follows:","category":"page"},{"location":"ch04/p_chmax.html","page":"chmax","title":"chmax","text":"U_0 = 1","category":"page"},{"location":"ch04/p_chmax.html","page":"chmax","title":"chmax","text":"U_1 = 2x","category":"page"},{"location":"ch04/p_chmax.html","page":"chmax","title":"chmax","text":"U_n+1(x) = 2xU_n(x) - U_n-1(x)","category":"page"},{"location":"ch04/p_chmax.html","page":"chmax","title":"chmax","text":"The second kind Chebyshev polynomials are orthogonal with respect to the weight ","category":"page"},{"location":"ch04/p_chmax.html","page":"chmax","title":"chmax","text":"sqrt1-x^2","category":"page"},{"location":"ch04/p_chmax.html","page":"chmax","title":"chmax","text":"on the interval [-1,1], i.e., we have:","category":"page"},{"location":"ch04/p_chmax.html","page":"chmax","title":"chmax","text":"beginequation\nint_-1^1 U_n(x)U_m(x)sqrt1-x^2dx = \nbegincases 0  nne m  pi2  n=m endcases \nendequation","category":"page"},{"location":"ch04/p_chmax.html","page":"chmax","title":"chmax","text":"Type","category":"page"},{"location":"ch04/p_chmax.html","page":"chmax","title":"chmax","text":"Integer","category":"page"},{"location":"ch04/p_chmax.html","page":"chmax","title":"chmax","text":"Default value","category":"page"},{"location":"ch04/p_chmax.html","page":"chmax","title":"chmax","text":"32","category":"page"},{"location":"ch04/p_chmax.html","page":"chmax","title":"chmax","text":"Component","category":"page"},{"location":"ch04/p_chmax.html","page":"chmax","title":"chmax","text":"Only for the GARDENIA, NARCISSUS, LAVENDER, CAMELLIA, and MANJUSHAKA components.","category":"page"},{"location":"ch04/p_chmax.html","page":"chmax","title":"chmax","text":"Behavior","category":"page"},{"location":"ch04/p_chmax.html","page":"chmax","title":"chmax","text":"The parameter is used as a cutoff to limit the maximum expansion order for the second kind Chebyshev orthogonal polynomials.","category":"page"},{"location":"ch04/p_chmax.html","page":"chmax","title":"chmax","text":"Comment","category":"page"},{"location":"ch04/p_chmax.html","page":"chmax","title":"chmax","text":"Only when isort = 3 or isort = 6 this parameter is useful. See isort parameter for more details. How to choose a suitable chmax parameters is a tricky job. If chmax is too small, the calculated results won't be accurate. If chmax is too large, the so-called Gibbs oscillation will occur significantly. According to our experiences, 32 or 48 may be a reasonable choice. Though there is no upper limit for isort, the larger the value of chmax is, the heavier the computational burden will be. ","category":"page"},{"location":"ch04/p_chmax.html","page":"chmax","title":"chmax","text":"See also chgrd for more details.","category":"page"},{"location":"ch04/p_chmax.html","page":"chmax","title":"chmax","text":"As for the applications of orthogonal polynomials in CT-QMC impurity solver, please refer to Lewin's[1] and Hartmann's[2] papers.","category":"page"},{"location":"ch04/p_chmax.html","page":"chmax","title":"chmax","text":"Reference","category":"page"},{"location":"ch04/p_chmax.html","page":"chmax","title":"chmax","text":"[1]: Lewin Boehnke, Hartmut Hafermann, Michel Ferrero, Frank Lechermann, and Olivier Parcollet, Phys. Rev. B 84, 075145 (2011).","category":"page"},{"location":"ch04/p_chmax.html","page":"chmax","title":"chmax","text":"[2]: Hartmut Hafermann, Kelly R. Patton, and Philipp Werner, Phys. Rev. B 85, 205106 (2012).","category":"page"},{"location":"ch08/README.html#iQIST-in-action","page":"README","title":"iQIST in action","text":"","category":"section"},{"location":"ch08/README.html","page":"README","title":"README","text":"You may have learnt a lot about iQIST from the previous chapters. In this chapter, we will show you how to do calculations using iQIST through many case studies. Before this, we presume that you have successfully installed iQIST package in your systems, and the install directory is /opt/iqist, and the directory /opt/iqist/build has been added to the PATH environment variable:","category":"page"},{"location":"ch08/README.html","page":"README","title":"README","text":"$ export PATH=/opt/iqist/build:$PATH","category":"page"},{"location":"ch08/README.html","page":"README","title":"README","text":"If you are new to iQIST, please follow the tutorials to learn it step by step. We believe that you will have become a master of iQIST after finishing all the tutorials. If you have been familiar with iQIST, there is no need to start from the beginning, you can choose some cases with your interests to learn directly.","category":"page"},{"location":"ch08/README.html","page":"README","title":"README","text":"Now the available tutorials will cover the following topics:","category":"page"},{"location":"ch08/README.html","page":"README","title":"README","text":"Basic applications\nAdvanced applications I: Complex systems\nAdvanced applications II: Accurate measurement of physical observable\nAdvanced applications III: Post-processing procedures\nPractical exercises\nLibrary mode","category":"page"},{"location":"ch08/README.html","page":"README","title":"README","text":"Beyond thatï¼we also introduce some concrete examples to illustrate the correctness of the iQIST software package.","category":"page"},{"location":"ch08/README.html","page":"README","title":"README","text":"Code validation","category":"page"},{"location":"ch08/README.html","page":"README","title":"README","text":"Some successful stories and representative applications published in the scientific journals are also collected and listed here as a reference.","category":"page"},{"location":"ch08/README.html","page":"README","title":"README","text":"Successful stories","category":"page"},{"location":"ch04/p_nspin.html#Parameter:-nspin","page":"nspin","title":"Parameter: nspin","text":"","category":"section"},{"location":"ch04/p_nspin.html","page":"nspin","title":"nspin","text":"Definition","category":"page"},{"location":"ch04/p_nspin.html","page":"nspin","title":"nspin","text":"Number of spin projection considered in the calculations.","category":"page"},{"location":"ch04/p_nspin.html","page":"nspin","title":"nspin","text":"Type","category":"page"},{"location":"ch04/p_nspin.html","page":"nspin","title":"nspin","text":"Integer","category":"page"},{"location":"ch04/p_nspin.html","page":"nspin","title":"nspin","text":"Default value","category":"page"},{"location":"ch04/p_nspin.html","page":"nspin","title":"nspin","text":"2","category":"page"},{"location":"ch04/p_nspin.html","page":"nspin","title":"nspin","text":"Component","category":"page"},{"location":"ch04/p_nspin.html","page":"nspin","title":"nspin","text":"ALL","category":"page"},{"location":"ch04/p_nspin.html","page":"nspin","title":"nspin","text":"Behavior","category":"page"},{"location":"ch04/p_nspin.html","page":"nspin","title":"nspin","text":"Determine the size of involved arrays.","category":"page"},{"location":"ch04/p_nspin.html","page":"nspin","title":"nspin","text":"Comment","category":"page"},{"location":"ch04/p_nspin.html","page":"nspin","title":"nspin","text":"See also nband, norbs, and ncfgs parameters.","category":"page"},{"location":"ch04/p_nspin.html","page":"nspin","title":"nspin","text":"warning: Warning\nPlease DO NOT modify it. Now the quantum impurity solvers in the iQIST software package don't support nspin = 1.","category":"page"},{"location":"ch04/in_eimp.html#solver.eimp.in","page":"solver.eimp.in","title":"solver.eimp.in","text":"","category":"section"},{"location":"ch04/in_eimp.html","page":"solver.eimp.in","title":"solver.eimp.in","text":"Introduction","category":"page"},{"location":"ch04/in_eimp.html","page":"solver.eimp.in","title":"solver.eimp.in","text":"The solver.eimp.in file is used to define impurity level matrix E_alphabeta and symmetry matrix symm(alpha,beta). Unfortunately, now only the diagonal elements of the two matrices are supported.","category":"page"},{"location":"ch04/in_eimp.html","page":"solver.eimp.in","title":"solver.eimp.in","text":"If the orbitals are degenerated, the impurity levels should be a constant and can be absorbed into the chemical potential mu. If the issun parameter is set to 2, the orbital-resolved observables are then symmetrized according the symmetry matrix. See issun for more details.","category":"page"},{"location":"ch04/in_eimp.html","page":"solver.eimp.in","title":"solver.eimp.in","text":"Format","category":"page"},{"location":"ch04/in_eimp.html","page":"solver.eimp.in","title":"solver.eimp.in","text":"The format of the solver.eimp.in file is as follows:","category":"page"},{"location":"ch04/in_eimp.html","page":"solver.eimp.in","title":"solver.eimp.in","text":"","category":"page"},{"location":"ch04/in_eimp.html","page":"solver.eimp.in","title":"solver.eimp.in","text":"column 1: orbital index, alpha, integer","category":"page"},{"location":"ch04/in_eimp.html","page":"solver.eimp.in","title":"solver.eimp.in","text":"column 2: diagonal element of the impurity level, E_alphaalpha, double precision","category":"page"},{"location":"ch04/in_eimp.html","page":"solver.eimp.in","title":"solver.eimp.in","text":"column 3: symmetry vector, symm(alpha), integer","category":"page"},{"location":"ch04/in_eimp.html","page":"solver.eimp.in","title":"solver.eimp.in","text":"","category":"page"},{"location":"ch04/in_eimp.html","page":"solver.eimp.in","title":"solver.eimp.in","text":"tip: Tip\nIn the solver.eimp.in file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch04/in_eimp.html","page":"solver.eimp.in","title":"solver.eimp.in","text":"Code","category":"page"},{"location":"ch04/in_eimp.html","page":"solver.eimp.in","title":"solver.eimp.in","text":"The corresponding Fortran code block for the reading of solver.eimp.in file is as follows:","category":"page"},{"location":"ch04/in_eimp.html","page":"solver.eimp.in","title":"solver.eimp.in","text":"open(mytmp, file='solver.eimp.in', form='formatted', status='unknown')\ndo i=1,norbs\n    read(mytmp,*) k, eimp(i), symm(i)\nenddo ! over i={1,norbs} loop\nclose(mytmp)","category":"page"},{"location":"ch04/in_eimp.html","page":"solver.eimp.in","title":"solver.eimp.in","text":"Usually, you have to edit the solver.eimp.in file by yourself.","category":"page"},{"location":"ch04/p_nfreq.html#Parameter:-nfreq","page":"nfreq","title":"Parameter: nfreq","text":"","category":"section"},{"location":"ch04/p_nfreq.html","page":"nfreq","title":"nfreq","text":"Definition","category":"page"},{"location":"ch04/p_nfreq.html","page":"nfreq","title":"nfreq","text":"Number of Matsubara frequency points sampling by continuous-time quantum Monte Carlo quantum impurity solver.","category":"page"},{"location":"ch04/p_nfreq.html","page":"nfreq","title":"nfreq","text":"Type","category":"page"},{"location":"ch04/p_nfreq.html","page":"nfreq","title":"nfreq","text":"Integer","category":"page"},{"location":"ch04/p_nfreq.html","page":"nfreq","title":"nfreq","text":"Default value","category":"page"},{"location":"ch04/p_nfreq.html","page":"nfreq","title":"nfreq","text":"128","category":"page"},{"location":"ch04/p_nfreq.html","page":"nfreq","title":"nfreq","text":"Component","category":"page"},{"location":"ch04/p_nfreq.html","page":"nfreq","title":"nfreq","text":"ALL, except for the DAISY component.","category":"page"},{"location":"ch04/p_nfreq.html","page":"nfreq","title":"nfreq","text":"Behavior","category":"page"},{"location":"ch04/p_nfreq.html","page":"nfreq","title":"nfreq","text":"Determine the size of involved arrays. The larger nfreq, the more computational time is needed.","category":"page"},{"location":"ch04/p_nfreq.html","page":"nfreq","title":"nfreq","text":"Comment","category":"page"},{"location":"ch04/p_nfreq.html","page":"nfreq","title":"nfreq","text":"There are mfreq matsubara frequency points in total. The physical observables on the first nfreq points are sampled directly by the Monte Carlo algorithm, however, the rest (mfreq - nfreq + 1 points) values are evaluated by using Hubbard-I approximation or the other algorithm.","category":"page"},{"location":"ch08/matsubara.html#Matsubara-Green's-function-and-self-energy-function","page":"Matsubara Green's function and self-energy function","title":"Matsubara Green's function and self-energy function","text":"","category":"section"},{"location":"ch04/p_nsing.html#Parameter:-nsing","page":"nsing","title":"Parameter: nsing","text":"","category":"section"},{"location":"ch04/p_nsing.html","page":"nsing","title":"nsing","text":"Definition","category":"page"},{"location":"ch04/p_nsing.html","page":"nsing","title":"nsing","text":"The Hirsch-Fye algorithm is an auxiliary field quantum Monte Carlo algorithm. We implemented in the DAISY component in the iQIST software package. The nsing parameter is used to determine the number of auxiliary ising-like fields.","category":"page"},{"location":"ch04/p_nsing.html","page":"nsing","title":"nsing","text":"Type","category":"page"},{"location":"ch04/p_nsing.html","page":"nsing","title":"nsing","text":"Integer","category":"page"},{"location":"ch04/p_nsing.html","page":"nsing","title":"nsing","text":"Default value","category":"page"},{"location":"ch04/p_nsing.html","page":"nsing","title":"nsing","text":"1","category":"page"},{"location":"ch04/p_nsing.html","page":"nsing","title":"nsing","text":"Component","category":"page"},{"location":"ch04/p_nsing.html","page":"nsing","title":"nsing","text":"Only for the DAISY component.","category":"page"},{"location":"ch04/p_nsing.html","page":"nsing","title":"nsing","text":"Behavior","category":"page"},{"location":"ch04/p_nsing.html","page":"nsing","title":"nsing","text":"Determine the size of involved arrays.","category":"page"},{"location":"ch04/p_nsing.html","page":"nsing","title":"nsing","text":"The following relation always holds:","category":"page"},{"location":"ch04/p_nsing.html","page":"nsing","title":"nsing","text":"textnsing = fractextnorbs * (textnorbs - 1)  2 ","category":"page"},{"location":"ch04/p_nsing.html","page":"nsing","title":"nsing","text":"So for single-band model, we obtain nband = 1, norbs = 2, nsing = 1.","category":"page"},{"location":"ch04/p_nsing.html","page":"nsing","title":"nsing","text":"Comment","category":"page"},{"location":"ch04/p_nsing.html","page":"nsing","title":"nsing","text":"N/A","category":"page"},{"location":"ch02/tools.html#Build-auxiliary-tools","page":"Build auxiliary tools","title":"Build auxiliary tools","text":"","category":"section"},{"location":"ch02/tools.html","page":"Build auxiliary tools","title":"Build auxiliary tools","text":"In fact, the auxiliary tools include the JASMINE and HIBISCUS components. You can employ the following commands to compile them.","category":"page"},{"location":"ch02/tools.html","page":"Build auxiliary tools","title":"Build auxiliary tools","text":"Method 1:","category":"page"},{"location":"ch02/tools.html","page":"Build auxiliary tools","title":"Build auxiliary tools","text":"$ cd iqist/build\n$ editor make.sys\n$ make base\n$ make capi\n$ make tool\n$ ./x_setup.sh","category":"page"},{"location":"ch02/tools.html","page":"Build auxiliary tools","title":"Build auxiliary tools","text":"note: Note\nHere editor means any ascii text editor you prefer.\nIf the base library and the application programming interfaces were already compiled successfully, then you can skip the following commands:$ make base\n$ make capi","category":"page"},{"location":"ch02/tools.html","page":"Build auxiliary tools","title":"Build auxiliary tools","text":"If you want to build the HIBISCUS component only, please replace","category":"page"},{"location":"ch02/tools.html","page":"Build auxiliary tools","title":"Build auxiliary tools","text":"$ make tool","category":"page"},{"location":"ch02/tools.html","page":"Build auxiliary tools","title":"Build auxiliary tools","text":"with","category":"page"},{"location":"ch02/tools.html","page":"Build auxiliary tools","title":"Build auxiliary tools","text":"$ make hibiscus","category":"page"},{"location":"ch02/tools.html","page":"Build auxiliary tools","title":"Build auxiliary tools","text":"If you want to build the JASMINE component only, please use","category":"page"},{"location":"ch02/tools.html","page":"Build auxiliary tools","title":"Build auxiliary tools","text":"$ make jasmine","category":"page"},{"location":"ch02/tools.html","page":"Build auxiliary tools","title":"Build auxiliary tools","text":"After a few minutes, you will find jasmine.x, entropy.x, sac.x, etc., in the iqist/build directory. They are what you need, the executable programs for the JASMINE and HIBISCUS components. Then you can add them to the system path, and do your great research.","category":"page"},{"location":"ch02/tools.html","page":"Build auxiliary tools","title":"Build auxiliary tools","text":"note: Note\nThe JASMINE component has a single executable program, jasmine.x. However, the HIBISCUS component has a few executable programs, including entropy.x, sac.x, mdos.x, etc.","category":"page"},{"location":"ch02/tools.html","page":"Build auxiliary tools","title":"Build auxiliary tools","text":"Method 2:","category":"page"},{"location":"ch02/tools.html","page":"Build auxiliary tools","title":"Build auxiliary tools","text":"In this approach, we go to the directory of the JASMINE component at first, 'make' it as usual. And then we go to the directory of the HIBISCUS component, 'make' it. That is all.","category":"page"},{"location":"ch02/tools.html","page":"Build auxiliary tools","title":"Build auxiliary tools","text":"$ cd iqist/src/tools/jasmine\n$ make\n$ cd ../hibiscus\n$ make","category":"page"},{"location":"ch02/tools.html","page":"Build auxiliary tools","title":"Build auxiliary tools","text":"Here, we assume that the compiling system was correctly configured, the base library and the application programming interfaces were already compiled successfully.","category":"page"},{"location":"ch02/tools.html","page":"Build auxiliary tools","title":"Build auxiliary tools","text":"note: Note\nNow the executable program will not be copied into the iqist/build directory. You have to go to the iqist/build directory, and execute$ ./x_setup.sh","category":"page"},{"location":"ch04/out_sgm.html#solver.sgm.dat","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"","category":"section"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"Introduction","category":"page"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"This file is used to store the Matsubara self-energy function Sigma(iomega_n). It will be output by the quantum impurity solvers when they are shut down.","category":"page"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"Format","category":"page"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"The solver.sgm.dat file contains norbs block. Each block is appended by two blank lines. The format of each block is as follows:","category":"page"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"","category":"page"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"column 1: orbital index i, integer","category":"page"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"column 2: Matsubara frequency point, omega_n, double precision","category":"page"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"column 3: Matsubara self-energy function, Re Sigma(iomega_n), double precision","category":"page"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"column 4: Matsubara self-energy function, Im Sigma(iomega_n), double precision","category":"page"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"column 5: error bar, Re delta Sigma(iomega_n), double precision","category":"page"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"column 6: error bar, Im delta Sigma(iomega_n), double precision","category":"page"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"","category":"page"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"note: Note\nIn the solver.sgm.dat file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"Code","category":"page"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"The corresponding Fortran code block for the writing of solver.sgm.dat file is as follows:","category":"page"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"! open data file: solver.sgm.dat\n     open(mytmp, file='solver.sgm.dat', form='formatted', status='unknown')\n\n! write it\n     do i=1,norbs\n         do j=1,mfreq\n             write(mytmp,'(i6,5f16.8)') i, rmesh(j), &\n              real(sigf(j,i,i)), aimag(sigf(j,i,i)), &\n                                         zero, zero\n         enddo ! over j={1,mfreq} loop\n         write(mytmp,*) ! write empty lines\n         write(mytmp,*)\n     enddo ! over i={1,norbs} loop\n\n! close data file\n     close(mytmp)","category":"page"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"note: Note\nThe columns for the error bar are always zero in this file.","category":"page"},{"location":"ch04/out_sgm.html","page":"solver.sgm.dat","title":"solver.sgm.dat","text":"In the HIBISCUS component, we provide a Python module to read the output files of quantum impurity solvers. You can use it to read the solver.sgm.dat file. See script/u_reader.py for more details.","category":"page"},{"location":"ch04/p_mfreq.html#Parameter:-mfreq","page":"mfreq","title":"Parameter: mfreq","text":"","category":"section"},{"location":"ch04/p_mfreq.html","page":"mfreq","title":"mfreq","text":"Definition","category":"page"},{"location":"ch04/p_mfreq.html","page":"mfreq","title":"mfreq","text":"Maximum number of Matsubara frequency points n_textmax. The Matsubara frequency mesh for fermions is defined as follows:","category":"page"},{"location":"ch04/p_mfreq.html","page":"mfreq","title":"mfreq","text":"omega_n = frac(2n + 1)pibeta","category":"page"},{"location":"ch04/p_mfreq.html","page":"mfreq","title":"mfreq","text":"where n = 0, 1, 2, 3, cdots, n_textmax.","category":"page"},{"location":"ch04/p_mfreq.html","page":"mfreq","title":"mfreq","text":"Type","category":"page"},{"location":"ch04/p_mfreq.html","page":"mfreq","title":"mfreq","text":"Integer","category":"page"},{"location":"ch04/p_mfreq.html","page":"mfreq","title":"mfreq","text":"Default value","category":"page"},{"location":"ch04/p_mfreq.html","page":"mfreq","title":"mfreq","text":"8193 (equiv 2^13+1)","category":"page"},{"location":"ch04/p_mfreq.html","page":"mfreq","title":"mfreq","text":"Component","category":"page"},{"location":"ch04/p_mfreq.html","page":"mfreq","title":"mfreq","text":"ALL","category":"page"},{"location":"ch04/p_mfreq.html","page":"mfreq","title":"mfreq","text":"Behavior","category":"page"},{"location":"ch04/p_mfreq.html","page":"mfreq","title":"mfreq","text":"Determine the size of involved arrays, such as G(iomega_n), G_0(iomega_n), Sigma(iomega_n), and Delta(iomega_n) etc.","category":"page"},{"location":"ch04/p_mfreq.html","page":"mfreq","title":"mfreq","text":"Comment","category":"page"},{"location":"ch04/p_mfreq.html","page":"mfreq","title":"mfreq","text":"mfreq = 8193 is a safe setting. We don't recommend to change it.","category":"page"},{"location":"ch02/apis.html#Build-application-programming-interfaces","page":"Build application programming interfaces","title":"Build application programming interfaces","text":"","category":"section"},{"location":"ch02/apis.html","page":"Build application programming interfaces","title":"Build application programming interfaces","text":"The application programming interfaces are designed for the components of quantum impurity solvers and atomic eigenvalue problem solver. So if you would like to build these components, building application programming interfaces are prerequisite. There are two ways to compile it in the compiling system.","category":"page"},{"location":"ch02/apis.html","page":"Build application programming interfaces","title":"Build application programming interfaces","text":"Once the compiling procedure is finished, you will find some *.o files in the iqist/src/capi directory.","category":"page"},{"location":"ch02/apis.html","page":"Build application programming interfaces","title":"Build application programming interfaces","text":"Method 1:","category":"page"},{"location":"ch02/apis.html","page":"Build application programming interfaces","title":"Build application programming interfaces","text":"$ cd iqist/build\n$ editor make.sys\n$ make capi","category":"page"},{"location":"ch02/apis.html","page":"Build application programming interfaces","title":"Build application programming interfaces","text":"tip: Tip\nHere editor means any ascii text editor you prefer, such as vim.","category":"page"},{"location":"ch02/apis.html","page":"Build application programming interfaces","title":"Build application programming interfaces","text":"This is the most common and direct method.","category":"page"},{"location":"ch02/apis.html","page":"Build application programming interfaces","title":"Build application programming interfaces","text":"Method 2:","category":"page"},{"location":"ch02/apis.html","page":"Build application programming interfaces","title":"Build application programming interfaces","text":"You can also go to the directory where the application programming interfaces exist, and type 'make' command in the terminal.","category":"page"},{"location":"ch02/apis.html","page":"Build application programming interfaces","title":"Build application programming interfaces","text":"$ cd iqist/src/capi\n$ make","category":"page"},{"location":"ch06/p_ibasis.html#Parameter:-ibasis","page":"ibasis","title":"Parameter: ibasis","text":"","category":"section"},{"location":"ch06/p_ibasis.html","page":"ibasis","title":"ibasis","text":"Definition","category":"page"},{"location":"ch06/p_ibasis.html","page":"ibasis","title":"ibasis","text":"Key control flag, it is used to specify the source for natural basis which is the eigenstate of crystal field splitting plus spin-orbital coupling.","category":"page"},{"location":"ch06/p_ibasis.html","page":"ibasis","title":"ibasis","text":"Type","category":"page"},{"location":"ch06/p_ibasis.html","page":"ibasis","title":"ibasis","text":"Integer","category":"page"},{"location":"ch06/p_ibasis.html","page":"ibasis","title":"ibasis","text":"Default value","category":"page"},{"location":"ch06/p_ibasis.html","page":"ibasis","title":"ibasis","text":"1","category":"page"},{"location":"ch06/p_ibasis.html","page":"ibasis","title":"ibasis","text":"Component","category":"page"},{"location":"ch06/p_ibasis.html","page":"ibasis","title":"ibasis","text":"Only for the JASMINE component.","category":"page"},{"location":"ch06/p_ibasis.html","page":"ibasis","title":"ibasis","text":"Behavior","category":"page"},{"location":"ch06/p_ibasis.html","page":"ibasis","title":"ibasis","text":"Now there are two possible values for the ibasis parameter:","category":"page"},{"location":"ch06/p_ibasis.html","page":"ibasis","title":"ibasis","text":"ibasis = 1, make natural basis inside of this program. The code will build crystal field splitting Delta_alphabeta and spin-orbital coupling terms Delta_textSOC at first, and then use them to generate the transformation matrix mathcalT_alphabeta and on-site impurity level E_alphabeta.\nibasis = 2, make natural basis outside of this program. The code will read the on-site impurity level E_alphabeta (in the atom.emat.in file) and transformation matrix mathcalT_alphabeta (in the atom.tmat.in file) from external files directly. See also atom.emat.in and atom.tmat.in for more details.","category":"page"},{"location":"ch06/p_ibasis.html","page":"ibasis","title":"ibasis","text":"Comment","category":"page"},{"location":"ch06/p_ibasis.html","page":"ibasis","title":"ibasis","text":"See also isoc and lambda parameters for more details.","category":"page"},{"location":"ch06/in_emat.html#atom.emat.in","page":"atom.emat.in","title":"atom.emat.in","text":"","category":"section"},{"location":"ch06/in_emat.html","page":"atom.emat.in","title":"atom.emat.in","text":"Introduction","category":"page"},{"location":"ch06/in_emat.html","page":"atom.emat.in","title":"atom.emat.in","text":"The purpose of the atom.emat.in file is to supply the on-site impurity energy level E_alphabeta, which is in fact the CF + SOC. It is a diagonal matrix in the natural basis. Only when ibasis = 2, the atom.emat.in file is used. See ibasis for more details.","category":"page"},{"location":"ch06/in_emat.html","page":"atom.emat.in","title":"atom.emat.in","text":"note: Note\nThe so-called natural basis is the eigenstates of CF + SOC matrix.\nOnly the diagonal elements of E_alphabeta are included in the atom.emat.in file.","category":"page"},{"location":"ch06/in_emat.html","page":"atom.emat.in","title":"atom.emat.in","text":"Format","category":"page"},{"location":"ch06/in_emat.html","page":"atom.emat.in","title":"atom.emat.in","text":"The format of the atom.emat.in file is as follows:","category":"page"},{"location":"ch06/in_emat.html","page":"atom.emat.in","title":"atom.emat.in","text":"","category":"page"},{"location":"ch06/in_emat.html","page":"atom.emat.in","title":"atom.emat.in","text":"column 1: orbital index alpha, integer","category":"page"},{"location":"ch06/in_emat.html","page":"atom.emat.in","title":"atom.emat.in","text":"column 2: orbital index beta, integer","category":"page"},{"location":"ch06/in_emat.html","page":"atom.emat.in","title":"atom.emat.in","text":"column 3: On-site impurity energy level E_alphabeta, double precision","category":"page"},{"location":"ch06/in_emat.html","page":"atom.emat.in","title":"atom.emat.in","text":"","category":"page"},{"location":"ch06/in_emat.html","page":"atom.emat.in","title":"atom.emat.in","text":"note: Note\nIn the atom.emat.in file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch06/in_emat.html","page":"atom.emat.in","title":"atom.emat.in","text":"Code","category":"page"},{"location":"ch06/in_emat.html","page":"atom.emat.in","title":"atom.emat.in","text":"The corresponding Fortran code block for the reading of the atom.emat.in file is as follows:","category":"page"},{"location":"ch06/in_emat.html","page":"atom.emat.in","title":"atom.emat.in","text":"! open file atom.emat.in\n     open(mytmp, file='atom.emat.in', form='formatted', status='unknown')\n\n! read the data file\n     do i=1,norbs\n         read(mytmp,*) i1, i2, raux\n! emat is actually real in natural basis\n         emat(i,i) = dcmplx(raux, zero)\n     enddo ! over i={1,norbs} loop\n\n! close data file\n     close(mytmp)","category":"page"},{"location":"ch06/out_vec.html#atom.eigvec.dat","page":"atom.eigvec.dat","title":"atom.eigvec.dat","text":"","category":"section"},{"location":"ch06/out_vec.html","page":"atom.eigvec.dat","title":"atom.eigvec.dat","text":"Introduction","category":"page"},{"location":"ch06/out_vec.html","page":"atom.eigvec.dat","title":"atom.eigvec.dat","text":"The atom.eigvec.dat file contains the eigenvectors of the atomic Hamiltonian. Only those elements which are larger than the threshold (> 1.0E-6) are outputted.","category":"page"},{"location":"ch06/out_vec.html","page":"atom.eigvec.dat","title":"atom.eigvec.dat","text":"Format","category":"page"},{"location":"ch06/out_vec.html","page":"atom.eigvec.dat","title":"atom.eigvec.dat","text":"The atom.eigvec.dat file has two different file formats. They depends on the ictqmc parameter.","category":"page"},{"location":"ch06/out_vec.html","page":"atom.eigvec.dat","title":"atom.eigvec.dat","text":"File Format A, should be compatible with the CAMELLIA, BEGONIA, and LAVENDER components","category":"page"},{"location":"ch06/out_vec.html","page":"atom.eigvec.dat","title":"atom.eigvec.dat","text":"note: Note\nictqmc = 0, 1.","category":"page"},{"location":"ch06/out_vec.html","page":"atom.eigvec.dat","title":"atom.eigvec.dat","text":"File Format B, should be compatible with the MANJUSHAKA and PANSY components","category":"page"},{"location":"ch06/out_vec.html","page":"atom.eigvec.dat","title":"atom.eigvec.dat","text":"note: Note\nictqmc = 2, 3, 4, 5.","category":"page"},{"location":"ch06/out_vec.html","page":"atom.eigvec.dat","title":"atom.eigvec.dat","text":"See ictqmc parameter for more details.","category":"page"},{"location":"ch06/out_vec.html","page":"atom.eigvec.dat","title":"atom.eigvec.dat","text":"The file formats of the atom.eigvec.dat file are a bit complex. It is unnecessary to understand its full details. If you are a maintainer or developer of the JASMINE component, please read the source codes in iqist/src/tools/jasmine/atomic_dump.f90.","category":"page"},{"location":"ch06/out_vec.html","page":"atom.eigvec.dat","title":"atom.eigvec.dat","text":"Code","category":"page"},{"location":"ch06/out_vec.html","page":"atom.eigvec.dat","title":"atom.eigvec.dat","text":"N/A","category":"page"},{"location":"ch09/cssl.html#Common-service-subroutine-library","page":"Common service subroutine library","title":"Common service subroutine library","text":"","category":"section"},{"location":"ch09/cssl.html","page":"Common service subroutine library","title":"Common service subroutine library","text":"s_error.f90","category":"page"},{"location":"ch09/cssl.html","page":"Common service subroutine library","title":"Common service subroutine library","text":"s_fft.f90","category":"page"},{"location":"ch09/cssl.html","page":"Common service subroutine library","title":"Common service subroutine library","text":"s_integrator.f90","category":"page"},{"location":"ch09/cssl.html","page":"Common service subroutine library","title":"Common service subroutine library","text":"s_matrix.f90","category":"page"},{"location":"ch09/cssl.html","page":"Common service subroutine library","title":"Common service subroutine library","text":"s_spline.f90","category":"page"},{"location":"ch09/cssl.html","page":"Common service subroutine library","title":"Common service subroutine library","text":"s_util.f90","category":"page"},{"location":"ch09/cssl.html","page":"Common service subroutine library","title":"Common service subroutine library","text":"s_vector.f90","category":"page"},{"location":"ch04/in_hfqmc.html#solver.hfqmc.in","page":"solver.hfqmc.in","title":"solver.hfqmc.in","text":"","category":"section"},{"location":"ch04/in_hfqmc.html","page":"solver.hfqmc.in","title":"solver.hfqmc.in","text":"Introduction","category":"page"},{"location":"ch04/in_hfqmc.html","page":"solver.hfqmc.in","title":"solver.hfqmc.in","text":"The only configuration file for the HF-QMC impurity solver in the iQIST software package is the solver.hfqmc.in. Just like the CT-QMC impurity solvers, since all of the input parameters have default values, the HF-QMC impurity solver can run without any input files. But if you want to use it to solve a specific problem, a well-prepared solver.hfqmc.in file is necessary.","category":"page"},{"location":"ch04/in_hfqmc.html","page":"solver.hfqmc.in","title":"solver.hfqmc.in","text":"Format","category":"page"},{"location":"ch04/in_hfqmc.html","page":"solver.hfqmc.in","title":"solver.hfqmc.in","text":"The solver.hfqmc.in file shares the same format with the solver.ctqmc.in file. See solver.ctqmc.in for more details.","category":"page"},{"location":"ch04/in_hfqmc.html","page":"solver.hfqmc.in","title":"solver.hfqmc.in","text":"warning: Warning\nThe quantum impurity solver will not check whether the settings in the solver.hfqmc.in file is reasonable and correct. It is the user's responsibility.","category":"page"},{"location":"ch04/in_hfqmc.html","page":"solver.hfqmc.in","title":"solver.hfqmc.in","text":"Code","category":"page"},{"location":"ch04/in_hfqmc.html","page":"solver.hfqmc.in","title":"solver.hfqmc.in","text":"N/A","category":"page"},{"location":"appendix/README.html#Appendix","page":"Appendix","title":"Appendix","text":"","category":"section"},{"location":"ch04/out_schi.html#solver.schi.dat","page":"solver.schi.dat","title":"solver.schi.dat","text":"","category":"section"},{"location":"ch04/out_schi.html","page":"solver.schi.dat","title":"solver.schi.dat","text":"Introduction","category":"page"},{"location":"ch04/out_schi.html","page":"solver.schi.dat","title":"solver.schi.dat","text":"The solver.schi.dat file is used to store the spin-spin correlation function in time space, chi_textspin(tau) = langle S_z(0)S_z(tau)rangle. It will be output by the quantum impurity solvers when they are shut down.","category":"page"},{"location":"ch04/out_schi.html","page":"solver.schi.dat","title":"solver.schi.dat","text":"note: Note\nOnly the GARDENIA and NARCISSUS components can generate the solver.schi.dat file.","category":"page"},{"location":"ch04/out_schi.html","page":"solver.schi.dat","title":"solver.schi.dat","text":"Format","category":"page"},{"location":"ch04/out_schi.html","page":"solver.schi.dat","title":"solver.schi.dat","text":"The solver.schi.dat file contains a few (nband + 2) blocks. The first nband blocks are orbital-resolved spin-spin correlation functions. The next block is the total spin-spin correlation function. The final block is the sum of orbital-resolved spin-spin correlation functions. Each block is appended by two blank lines. In each block, the error bar data are always shown in the rightmost column.","category":"page"},{"location":"ch04/out_schi.html","page":"solver.schi.dat","title":"solver.schi.dat","text":"Code","category":"page"},{"location":"ch04/out_schi.html","page":"solver.schi.dat","title":"solver.schi.dat","text":"The corresponding Fortran code block for the writing of solver.schi.dat file is as follows:","category":"page"},{"location":"ch04/out_schi.html","page":"solver.schi.dat","title":"solver.schi.dat","text":"! open data file: solver.schi.dat\n     open(mytmp, file='solver.schi.dat', form='formatted', status='unknown')\n\n! write it\n     do j=1,nband\n         write(mytmp,'(a,i6)') '# flvr:', j\n         do i=1,ntime\n             write(mytmp,'(3f12.6)') tmesh(i), sschi(i,j), sserr(i,j)\n         enddo ! over i={1,ntime} loop\n         write(mytmp,*) ! write empty lines\n         write(mytmp,*)\n     enddo ! over j={1,nband} loop\n\n     write(mytmp,'(a,i6)') '# flvr:', 8888\n     do i=1,ntime\n         write(mytmp,'(3f12.6)') tmesh(i), schi(i), serr(i) \n     enddo ! over i={1,ntime} loop\n     write(mytmp,*) ! write empty lines\n     write(mytmp,*)\n\n     write(mytmp,'(a,i6)') '# flvr:', 9999\n     do i=1,ntime\n         write(mytmp,'(3f12.6)') tmesh(i), sum( sschi(i,:) ), sum( sserr(i,:) )\n     enddo ! over i={1,ntime} loop\n     write(mytmp,*) ! write empty lines\n     write(mytmp,*)\n\n! close data file\n     close(mytmp)","category":"page"},{"location":"ch04/out_schi.html","page":"solver.schi.dat","title":"solver.schi.dat","text":"In the HIBISCUS component, we provide a Python module to read the output files of quantum impurity solvers. You can use it to read the solver.schi.dat file. See script/u_reader.py for more details.","category":"page"},{"location":"ch01/architecture.html#Software-architecture","page":"Software architecture","title":"Software architecture","text":"","category":"section"},{"location":"ch01/architecture.html","page":"Software architecture","title":"Software architecture","text":"To solve a quantum impurity model is not a straightforward job. Besides the necessary quantum impurity solvers, we need several auxiliary programs or tools. The iQIST is an all-in-one software package, which can be used to solve a broad range of quantum impurity problems. Thus, it is not surprising that iQIST is a collection of various codes and scripts. The core components contain about 50000 lines of code. ","category":"page"},{"location":"ch01/architecture.html","page":"Software architecture","title":"Software architecture","text":"(Image: layer image)","category":"page"},{"location":"ch01/architecture.html","page":"Software architecture","title":"Software architecture","text":"Figure | The hierarchical structure of the iQIST software package. Note that in the component layer, not all of the components are listed due to space limitations. See the main text for detailed explanations.","category":"page"},{"location":"ch01/architecture.html","page":"Software architecture","title":"Software architecture","text":"The software architecture of iQIST is slightly involved. In the above figure, we use a layer model to illustrate it. Next, we will explain these layers one by one.","category":"page"},{"location":"ch01/architecture.html#Operating-system-layer","page":"Software architecture","title":"Operating system layer","text":"","category":"section"},{"location":"ch01/architecture.html","page":"Software architecture","title":"Software architecture","text":"The bottom layer is the operating system (OS). In principle, the iQIST is OS-independent. It can run properly on top of Unix/Linux, Mac OS X, FreeBSD, and Windows. ","category":"page"},{"location":"ch01/architecture.html#System-layer","page":"Software architecture","title":"System layer","text":"","category":"section"},{"location":"ch01/architecture.html","page":"Software architecture","title":"Software architecture","text":"The second layer is the system layer, which contains highly optimized linear algebra math libraries (such as BLAS and LAPACK) and parallelism supports (such as MPI and OpenMP). ","category":"page"},{"location":"ch01/architecture.html#Service-layer","page":"Software architecture","title":"Service layer","text":"","category":"section"},{"location":"ch01/architecture.html","page":"Software architecture","title":"Software architecture","text":"The third layer is the service layer. In this layer, we implemented some commonly used modules and subroutines. They are named as common service subroutine library (CSSL) and common service module library (CSML), respectively. They provide a useful interface between the system layer and the component layer and facilitate the development of core components. The features of CSSL and CSML include basic data structures (stack and linked list), random number generators, spare matrix manipulations, linear algebra operations, string processing, linear interpolation, numerical integration, and fast Fourier transformation (FFT), etc. ","category":"page"},{"location":"ch01/architecture.html#Component-layer","page":"Software architecture","title":"Component layer","text":"","category":"section"},{"location":"ch01/architecture.html","page":"Software architecture","title":"Software architecture","text":"The core part of iQIST software package is in the fourth layer â the component layer â which contains various impurity solvers as shown before. At present, iQIST contains ten different components, including ","category":"page"},{"location":"ch01/architecture.html","page":"Software architecture","title":"Software architecture","text":"AZALEA\nGARDENIA\nNARCISSUS\nBEGONIA\nLAVENDER\nPANSY\nMANJUSHAKA\nDAISY\nJASMINE\nHIBISCUS","category":"page"},{"location":"ch01/architecture.html","page":"Software architecture","title":"Software architecture","text":"Here, AZALEA, GARDENIA, NARCISSUS, BEGONIA, LAVENDER, PANSY, and MANJUSHAKA are all CT-HYB components, and DAISY is a HF-QMC impurity solver component. JASMINE is an atomic eigenvalue solver. HIBISCUS is a collection of several pre- and post-processing tools, including maximum entropy method, stochastic analytical continuation, Pade approximation, and Kramers-Kronig transformation, etc. For more details about these components, please consult the following chapters. ","category":"page"},{"location":"ch01/architecture.html#Interface-layer","page":"Software architecture","title":"Interface layer","text":"","category":"section"},{"location":"ch01/architecture.html","page":"Software architecture","title":"Software architecture","text":"The top layer is the interface layer or user layer. On the one hand, users can execute the iQIST's components directly as usual. On the other hand, they can also invoke iQIST's components from other languages. The role of iQIST's components becomes a library or subroutine. To achieve this goal, in the interface layer, we offer the Fortran/Python language bindings for most of the iQIST's components, so that the users can develop their own codes on top of iQIST and consider it as a computational engine in black box.","category":"page"},{"location":"ch04/choose.html#How-to-choose-suitable-quantum-impurity-solvers?","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"","category":"section"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"At a first glance, you may feel puzzled why there are so many continuous-time quantum impurity solvers in the iQIST software package. What are the differences between them? Do we really need them? How to choose a suitable quantum impurity solvers for a given strongly correlated electron problem?","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"Relax! In the following we will uncover the secrets.","category":"page"},{"location":"ch04/choose.html#How-many-quantum-Monte-Carlo-impurity-solvers-are-there?","page":"How to choose suitable quantum impurity solvers?","title":"How many quantum Monte Carlo impurity solvers are there?","text":"","category":"section"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"Hmm, let me think. Nine. Eight CT-HYB and one HF-QMC quantum impurity solvers. These are the newest data. We are not sure whether there is new quantum impurity solver in the future.","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"The eight CT-HYB quantum impurity solvers are as follows:","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"AZALEA\nGARDENIA\nNARCISSUS\nBEGONIA\nLAVENDER\nCAMELLIA\nMANJUSHAKA\nPANSY","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"The only HF-QMC quantum impurity solver is:","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"DAISY","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"You probably have found that we always used the flowers to name the quantum impurity solvers. Well, so many flowers. I think at least you will like one of them. Next we will show two of them (lavender and manjushaka).","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"(Image: lavender image)","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"Figure | Lavender fields in Provence. Photo by Li.","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"(Image: manjushaka image)","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"Figure | Manjushaka (source: internet).","category":"page"},{"location":"ch04/choose.html#Do-we-really-need-these-quantum-impurity-solvers?","page":"How to choose suitable quantum impurity solvers?","title":"Do we really need these quantum impurity solvers?","text":"","category":"section"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"This problem is a bit complicated and equivalent to why we had designed and implemented so many quantum impurity solvers in the iQIST software package.","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"The answer is \"Yes\".","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"First, the state-of-the-art continuous-time quantum impurity solvers turn more and more complex. In order to achieve high performance, many tricky algorithms, numerical methods are invented. Some of them conflict with each other. It is almost impossible to implement all of them in a single program. Second, the quantum impurity models in strongly correlated systems are extremely complicated and polytropic. It is also impossible to design such a perfect impurity solver which can solve all of the impurity problems. Third, each quantum impurity solver in the iQIST software package is designed for a specific impurity problem. These quantum impurity solvers share similar computational kernel, but they are highly optimized for the given impurity model. For example, the BEGONIA component is only suitable for a three-band Hubbard model with general Coulomb interaction, while the PANSY component is suitable for general five-band Hubbard model.","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"The price for maintaining nine quantum impurity solvers is high, but it is worth it.","category":"page"},{"location":"ch04/choose.html#What-are-the-differences-between-these-quantum-impurity-solvers?","page":"How to choose suitable quantum impurity solvers?","title":"What are the differences between these quantum impurity solvers?","text":"","category":"section"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"AZALEA component","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"Model: Density-density interaction, no SOC.\nAlgorithm: Segment representation.\nFeature: Very limited.\nScenario: Used to develop new features and experiment new ideas.","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"GARDENIA component","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"Model: Density-density interaction, no SOC.\nAlgorithm: Segment representation.\nFeature: Full-fledged.\nScenario: Used in real research.","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"NARCISSUS component","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"Model: Density-density interaction, retarded interaction, no SOC.\nAlgorithm: Segment representation.\nFeature: Full-fledged.\nScenario: Used in real research, especially in E-DMFT calculations.","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"BEGONIA component","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"Model: General interaction, SOC.\nAlgorithm: General matrix representation + sparse matrix + divide-and-conquer algorithm.\nFeature: Very limited.\nScenario: Used to develop new features and experiment new ideas.","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"LAVENDER component","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"Model: General interaction, SOC.\nAlgorithm: General matrix representation + sparse matrix + divide-and-conquer algorithm.\nFeature: Full-fledged.\nScenario: Used in real research.","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"CAMELLIA component","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"Model: General interaction, no SOC.\nAlgorithm: General matrix representation + sparse matrix + Newton-Leja algorithm.\nFeature: Full-fledged.\nScenario: Experimental, not ready for used.","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"PANSY component","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"Model: General interaction, SOC.\nAlgorithm: General matrix representation + subspace + divide-and-conquer algorithm.\nFeature: Very limited.\nScenario: Used to develop new features and experiment new ideas.","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"MANJUSHAKA component","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"Model: General interaction, SOC.\nAlgorithm: General matrix representation + subspace + divide-and-conquer algorithm + Lazy trace evaluation + dynamical truncation + skip listing algorithm.\nFeature: Full-fledged.\nScenario: Used in real research.","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"See also:","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"Features // Exact features for the quantum impurity solvers. ","category":"page"},{"location":"ch04/choose.html#How-to-choose-suitable-quantum-impurity-solvers-for-a-given-impurity-problem?","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers for a given impurity problem?","text":"","category":"section"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"OK, now let's return to the original problem. How to choose a suitable quantum impurity solver? It depends on the problems what you face. In the following, we will provide some guidelines.","category":"page"},{"location":"ch04/choose.html","page":"How to choose suitable quantum impurity solvers?","title":"How to choose suitable quantum impurity solvers?","text":"(Image: select image) Figure | How to select suitable quantum impurity solvers.","category":"page"},{"location":"ch04/out_pair.html#solver.pair.dat","page":"solver.pair.dat","title":"solver.pair.dat","text":"","category":"section"},{"location":"ch04/out_pair.html","page":"solver.pair.dat","title":"solver.pair.dat","text":"Introduction","category":"page"},{"location":"ch04/out_pair.html","page":"solver.pair.dat","title":"solver.pair.dat","text":"The solver.pair.dat file is designed to store the particle-particle pairing susceptibility. It will be output by the quantum impurity solvers when they are shut down.","category":"page"},{"location":"ch04/out_pair.html","page":"solver.pair.dat","title":"solver.pair.dat","text":"note: Note\nOnly the GARDENIA, NARCISSUS, CAMELLIA, LAVENDER, and MANJUSHAKA components can generate the solver.pair.dat file.","category":"page"},{"location":"ch04/out_pair.html","page":"solver.pair.dat","title":"solver.pair.dat","text":"Format","category":"page"},{"location":"ch04/out_pair.html","page":"solver.pair.dat","title":"solver.pair.dat","text":"The solver.pair.dat file contains ","category":"page"},{"location":"ch04/out_pair.html","page":"solver.pair.dat","title":"solver.pair.dat","text":" left(sumlimits^textnorbs_n=1 fracn(n+1)2right)times textnbfrq","category":"page"},{"location":"ch04/out_pair.html","page":"solver.pair.dat","title":"solver.pair.dat","text":"blocks. Each block is appended by two blank lines. The format of each block is as follows:","category":"page"},{"location":"ch04/out_pair.html","page":"solver.pair.dat","title":"solver.pair.dat","text":"","category":"page"},{"location":"ch04/out_pair.html","page":"solver.pair.dat","title":"solver.pair.dat","text":"column 1: Matsubara frequency point (fermionic type), omega_n, integer, the unit is pibeta","category":"page"},{"location":"ch04/out_pair.html","page":"solver.pair.dat","title":"solver.pair.dat","text":"column 2: Matsubara frequency point (fermionic type), omega_n, integer, the unit is pibeta","category":"page"},{"location":"ch04/out_pair.html","page":"solver.pair.dat","title":"solver.pair.dat","text":"column 3: real part of the pairing susceptibility, Re chi_textpair(iomega_n iomega_n inu_n), double precision","category":"page"},{"location":"ch04/out_pair.html","page":"solver.pair.dat","title":"solver.pair.dat","text":"column 4: imaginary part of the pairing susceptibility, Im chi_textpair(iomega_n iomega_n inu_n), double precision","category":"page"},{"location":"ch04/out_pair.html","page":"solver.pair.dat","title":"solver.pair.dat","text":"","category":"page"},{"location":"ch04/out_pair.html","page":"solver.pair.dat","title":"solver.pair.dat","text":"note: Note\nIn the solver.pair.dat file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch04/out_pair.html","page":"solver.pair.dat","title":"solver.pair.dat","text":"Code","category":"page"},{"location":"ch04/out_pair.html","page":"solver.pair.dat","title":"solver.pair.dat","text":"The corresponding Fortran code block for the writing of solver.pair.dat file is as follows:","category":"page"},{"location":"ch04/out_pair.html","page":"solver.pair.dat","title":"solver.pair.dat","text":"! open data file: solver.pair.dat\n     open(mytmp, file='solver.pair.dat', form='formatted', status='unknown')\n\n! write it\n     do m=1,norbs\n         do n=1,m\n             do k=1,nbfrq\n                 write(mytmp,'(a,i6)') '# flvr1:', m\n                 write(mytmp,'(a,i6)') '# flvr2:', n\n                 write(mytmp,'(a,i6)') '# nbfrq:', k\n                 do j=1,nffrq\n                     do i=1,nffrq\n                         ......\n                         write(mytmp,'(2i6,2f16.8)') jt, it, ps_re(i,j,k,n,m), ps_im(i,j,k,n,m)\n                     enddo ! over i={1,nffrq} loop\n                 enddo ! over j={1,nffrq} loop\n                 write(mytmp,*) ! write empty lines\n                 write(mytmp,*)\n             enddo ! over k={1,nbfrq} loop\n         enddo ! over n={1,m} loop\n     enddo ! over m={1,norbs} loop\n\n! close data file\n     close(mytmp)","category":"page"},{"location":"ch04/out_pair.html","page":"solver.pair.dat","title":"solver.pair.dat","text":"In the HIBISCUS component, we provide a Python module to read the output files of quantum impurity solvers. You can use it to read the solver.pair.dat file. See script/u_reader.py for more details.","category":"page"},{"location":"ch08/mem.html#Analytical-continuation-for-imaginary-time-Green's-function","page":"Analytical continuation for imaginary-time Green's function","title":"Analytical continuation for imaginary-time Green's function","text":"","category":"section"},{"location":"ch04/p_nclean.html#Parameter:-nclean","page":"nclean","title":"Parameter: nclean","text":"","category":"section"},{"location":"ch04/p_nclean.html","page":"nclean","title":"nclean","text":"Definition","category":"page"},{"location":"ch04/p_nclean.html","page":"nclean","title":"nclean","text":"Clean update period for quantum impurity solvers.","category":"page"},{"location":"ch04/p_nclean.html","page":"nclean","title":"nclean","text":"Type","category":"page"},{"location":"ch04/p_nclean.html","page":"nclean","title":"nclean","text":"Integer","category":"page"},{"location":"ch04/p_nclean.html","page":"nclean","title":"nclean","text":"Default value","category":"page"},{"location":"ch04/p_nclean.html","page":"nclean","title":"nclean","text":"100000 (for CT-HYB impurity solvers) or 100 (for HF-QMC impurity solver)","category":"page"},{"location":"ch04/p_nclean.html","page":"nclean","title":"nclean","text":"Component","category":"page"},{"location":"ch04/p_nclean.html","page":"nclean","title":"nclean","text":"ALL","category":"page"},{"location":"ch04/p_nclean.html","page":"nclean","title":"nclean","text":"Behavior","category":"page"},{"location":"ch04/p_nclean.html","page":"nclean","title":"nclean","text":"After a few Monte Carlo sampling steps, the numerical accuracy may be deteriorated. In order to retain the numerical accuracy, the quantum impurity solvers will conduct a clean update (in other words, recalculate everything from scratch) every nclean Monte Carlo sampling step.","category":"page"},{"location":"ch04/p_nclean.html","page":"nclean","title":"nclean","text":"Comment","category":"page"},{"location":"ch04/p_nclean.html","page":"nclean","title":"nclean","text":"nclean = 100000 (for CT-HYB) or nclean = 100 (for HF-QMC) is an optimal setting. Do not modify it casually.","category":"page"},{"location":"ch04/p_lemax.html#Parameter:-lemax","page":"lemax","title":"Parameter: lemax","text":"","category":"section"},{"location":"ch04/p_lemax.html","page":"lemax","title":"lemax","text":"Definition","category":"page"},{"location":"ch04/p_lemax.html","page":"lemax","title":"lemax","text":"The maximum allowable expansion order n for the Legendre orthogonal polynomials. It must be greater than 2.","category":"page"},{"location":"ch04/p_lemax.html","page":"lemax","title":"lemax","text":"The recursive definition for the Legendre polynomials is as follows:","category":"page"},{"location":"ch04/p_lemax.html","page":"lemax","title":"lemax","text":"P_0(x) =1","category":"page"},{"location":"ch04/p_lemax.html","page":"lemax","title":"lemax","text":"P_1(x) = x","category":"page"},{"location":"ch04/p_lemax.html","page":"lemax","title":"lemax","text":"(n+1) P_n+1(x) = (2n+1)xP_n(x) - n P_n-1(x)","category":"page"},{"location":"ch04/p_lemax.html","page":"lemax","title":"lemax","text":"An important property of the Legendre polynomials is that they are orthogonal with respect to the L^2 inner product on the interval 1 leq xleq 1:","category":"page"},{"location":"ch04/p_lemax.html","page":"lemax","title":"lemax","text":"int^1_-1 P_m(x) P_n(x) dx = frac22n+1delta_mn","category":"page"},{"location":"ch04/p_lemax.html","page":"lemax","title":"lemax","text":"Type","category":"page"},{"location":"ch04/p_lemax.html","page":"lemax","title":"lemax","text":"Integer","category":"page"},{"location":"ch04/p_lemax.html","page":"lemax","title":"lemax","text":"Default value","category":"page"},{"location":"ch04/p_lemax.html","page":"lemax","title":"lemax","text":"32","category":"page"},{"location":"ch04/p_lemax.html","page":"lemax","title":"lemax","text":"Component","category":"page"},{"location":"ch04/p_lemax.html","page":"lemax","title":"lemax","text":"Only for the GARDENIA, NARCISSUS, LAVENDER, CAMELLIA, and MANJUSHAKA components.","category":"page"},{"location":"ch04/p_lemax.html","page":"lemax","title":"lemax","text":"Behavior","category":"page"},{"location":"ch04/p_lemax.html","page":"lemax","title":"lemax","text":"The parameter is used as a cutoff to limit the maximum expansion order for the Legendre orthogonal polynomials.","category":"page"},{"location":"ch04/p_lemax.html","page":"lemax","title":"lemax","text":"Comment","category":"page"},{"location":"ch04/p_lemax.html","page":"lemax","title":"lemax","text":"Only when isort = 2 or isort = 5 this parameter is useful. See isort parameter for more details. How to choose a suitable lemax parameters is a tricky job. If lemax is too small, the calculated results won't be accurate. If lemax is too large, the so-called Gibbs oscillation will occur dramatically. According to our experiences, 32 or 48 may be a reasonable choice. It is worthy to emphasis that due to the limitation of implementation, lemax must be less than 50.","category":"page"},{"location":"ch04/p_lemax.html","page":"lemax","title":"lemax","text":"See also legrd for more details.","category":"page"},{"location":"ch04/p_lemax.html","page":"lemax","title":"lemax","text":"As for the applications of orthogonal polynomials in CT-QMC impurity solver, please refer to Lewin's[1] and Hartmann's[2] papers.","category":"page"},{"location":"ch04/p_lemax.html","page":"lemax","title":"lemax","text":"Reference","category":"page"},{"location":"ch04/p_lemax.html","page":"lemax","title":"lemax","text":"[1]: Lewin Boehnke, Hartmut Hafermann, Michel Ferrero, Frank Lechermann, and Olivier Parcollet, Phys. Rev. B 84, 075145 (2011).","category":"page"},{"location":"ch04/p_lemax.html","page":"lemax","title":"lemax","text":"[2]: Hartmut Hafermann, Kelly R. Patton, and Philipp Werner, Phys. Rev. B 85, 205106 (2012).","category":"page"},{"location":"ch09/parallel.html#Parallelization","page":"Parallelization","title":"Parallelization","text":"","category":"section"},{"location":"ch09/parallel.html","page":"Parallelization","title":"Parallelization","text":"MPI","category":"page"},{"location":"ch09/parallel.html","page":"Parallelization","title":"Parallelization","text":"All of the CT-HYB impurity solvers in the iQIST software package are parallelized by MPI. The strategy is very simple. In the beginning, we launch n processes simultaneously. The master process is responsible for reading input data and configuration parameters, and broadcasts them among the children processes, and then each process will perform Monte Carlo samplings and measure physical observables independently. After all the processes finish their jobs, the master process will collect the measured quantities from all the processes and average them to obtain the final results. Apart from that, no additional inter-process communication is needed. Thus, we can anticipate that the parallel efficiency will be very good, and near linear speedups are possible, as long as the number of thermalization steps is small compared to the total number of Monte Carlo steps. ","category":"page"},{"location":"ch09/parallel.html","page":"Parallelization","title":"Parallelization","text":"In practical calculations, we always fix the number of Monte Carlo steps N_textsweep done by each process, and launch as many processes as possible. Suppose that the number of processes is N_textproc, then the total number of Monte Carlo samplings should be N_textprocN_textsweep. Naturally, the more processes we use, the more accurate data we can obtain.","category":"page"},{"location":"ch09/parallel.html","page":"Parallelization","title":"Parallelization","text":"OpenMP","category":"page"},{"location":"ch04/in_hyb.html#solver.hyb.in","page":"-","title":"solver.hyb.in","text":"","category":"section"},{"location":"ch04/in_hyb.html","page":"-","title":"-","text":"Introduction","category":"page"},{"location":"ch04/in_hyb.html","page":"-","title":"-","text":"The solver.hyb.in file is an optional input file for iQIST software package. It is defined to initialize the Matsubara hybridization function Delta(iomega_n). This file is usually not generated by hand, but directly rename the output file of iQIST software package solver.hyb.dat as solver.hyb.in. The non-interacting hybridization function will be used as an input file on the condition that the user doesn't provide the initial solver.hyb.in file. However, the system will read in the parameters from the solver.hyb.in file given by the user to replace the default values.","category":"page"},{"location":"ch04/in_hyb.html","page":"-","title":"-","text":"Format","category":"page"},{"location":"ch04/in_hyb.html","page":"-","title":"-","text":"Similar to all the components in iQIST software package, the format of the solver.hyb.in file is as follows:","category":"page"},{"location":"ch04/in_hyb.html","page":"-","title":"-","text":"","category":"page"},{"location":"ch04/in_hyb.html","page":"-","title":"-","text":"column 1: orbital index i, integer","category":"page"},{"location":"ch04/in_hyb.html","page":"-","title":"-","text":"column 2: Matsubara frequency point, omega_n, double precision","category":"page"},{"location":"ch04/in_hyb.html","page":"-","title":"-","text":"column 3: Real part of hybridization function, spin up component, Re Delta_iuparrow(iomega_n), double precision","category":"page"},{"location":"ch04/in_hyb.html","page":"-","title":"-","text":"column 4: Imaginary part of hybridization function, spin up component, Im Delta_iuparrow(iomega_n), double precision","category":"page"},{"location":"ch04/in_hyb.html","page":"-","title":"-","text":"column 5: Real part of hybridization function, spin down component, Re Delta_idownarrow(iomega_n), double precision","category":"page"},{"location":"ch04/in_hyb.html","page":"-","title":"-","text":"column 6: Imaginary part of hybridization function, spin down component, Im Delta_idownarrow(iomega_n), double precision","category":"page"},{"location":"ch04/in_hyb.html","page":"-","title":"-","text":"","category":"page"},{"location":"ch04/in_hyb.html","page":"-","title":"-","text":"note: Note\nIn the solver.hyb.in file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part. The first block stores the data of the first energy band, the second block stores the data of the second energy band and so on. Here we don't consider the nondiagonal term.","category":"page"},{"location":"ch04/in_hyb.html","page":"-","title":"-","text":"Code","category":"page"},{"location":"ch04/in_hyb.html","page":"-","title":"-","text":"The corresponding Fortran code block for the writing of solver.hybri.dat file is as follows:","category":"page"},{"location":"ch04/in_hyb.html","page":"-","title":"-","text":"! open data file: solver.hyb.in\n     open(mytmp, file='solver.hyb.in', form='formatted', status='unknown')\n\n! write it\n     do i=1,norbs\n         do j=1,mfreq\n             write(mytmp,'(i6,5f16.8)') i, rmesh(j), &\n                  real(ghub(j,i)), aimag(ghub(j,i)), &\n                  real(shub(j,i)), aimag(shub(j,i))\n         enddo ! over j={1,mfreq} loop\n         write(mytmp,*) ! write empty lines\n         write(mytmp,*)\n     enddo ! over i={1,norbs} loop\n\n! close data file\n     close(mytmp)","category":"page"},{"location":"ch04/in_hyb.html","page":"-","title":"-","text":"Generally, you have to edit the solver.hyb.in file by yourself.","category":"page"},{"location":"ch02/fortran.html#Build-libraries-for-Fortran","page":"Build libraries for Fortran ","title":"Build libraries for Fortran","text":"","category":"section"},{"location":"ch02/fortran.html","page":"Build libraries for Fortran ","title":"Build libraries for Fortran ","text":"The quantum impurity solvers in the iQIST can not only run as standalone programs, but also can be called from the external Fortran or Python programs. In the latter case, the quantum impurity solvers can be considered as computational engines.","category":"page"},{"location":"ch02/fortran.html","page":"Build libraries for Fortran ","title":"Build libraries for Fortran ","text":"Thus, in this section we will show you how to compile the quantum impurity solvers as Fortran libraries, instead of executable programs.","category":"page"},{"location":"ch02/fortran.html","page":"Build libraries for Fortran ","title":"Build libraries for Fortran ","text":"note: Note\nNot only the quantum impurity solvers, but also the atomic eigenvalues solver can be compiled into Fortran libraries and Python modules.","category":"page"},{"location":"ch02/fortran.html","page":"Build libraries for Fortran ","title":"Build libraries for Fortran ","text":"Supposed that we would like to compile the AZALEA component.","category":"page"},{"location":"ch02/fortran.html","page":"Build libraries for Fortran ","title":"Build libraries for Fortran ","text":"Method 1:","category":"page"},{"location":"ch02/fortran.html","page":"Build libraries for Fortran ","title":"Build libraries for Fortran ","text":"$ cd iqist/build\n$ editor make.sys\n$ make base\n$ make capi\n$ make azalea-lib","category":"page"},{"location":"ch02/fortran.html","page":"Build libraries for Fortran ","title":"Build libraries for Fortran ","text":"note: Note\nHere editor means any ascii text editor you prefer.\nazalea can be any other component's name, such as begonia, pansy, gardenia, etc.\nIf the base library and the application programming interfaces were already compiled successfully, then you can skip the following commands:$ make base\n$ make capi","category":"page"},{"location":"ch02/fortran.html","page":"Build libraries for Fortran ","title":"Build libraries for Fortran ","text":"After a few minutes, you will find libctqmc.a in the iqist/src/ctqmc/azalea directory. That is what you need, the Fortran library for the AZALEA component. Then you can add it to the system path, and start with your research. We are looking forward to your great finding!","category":"page"},{"location":"ch02/fortran.html","page":"Build libraries for Fortran ","title":"Build libraries for Fortran ","text":"Method 2:","category":"page"},{"location":"ch02/fortran.html","page":"Build libraries for Fortran ","title":"Build libraries for Fortran ","text":"In this approach, we go to the directory of the AZALEA component at first. Then 'make' it as usual.","category":"page"},{"location":"ch02/fortran.html","page":"Build libraries for Fortran ","title":"Build libraries for Fortran ","text":"$ cd iqist/src/ctqmc/azalea\n$ make lib","category":"page"},{"location":"ch02/fortran.html","page":"Build libraries for Fortran ","title":"Build libraries for Fortran ","text":"Here, we assume that the compiling system was correctly configured, the base library and the application programming interfaces were already compiled successfully.","category":"page"},{"location":"ch02/fortran.html","page":"Build libraries for Fortran ","title":"Build libraries for Fortran ","text":"Method 3:","category":"page"},{"location":"ch02/fortran.html","page":"Build libraries for Fortran ","title":"Build libraries for Fortran ","text":"There is a trick to compile Fortran libraries for all of the quantum impurity solvers and atomic eigenvalues solvers at the same time:","category":"page"},{"location":"ch02/fortran.html","page":"Build libraries for Fortran ","title":"Build libraries for Fortran ","text":"$ cd iqist/build\n$ editor make.sys\n$ make lib","category":"page"},{"location":"ch02/fortran.html","page":"Build libraries for Fortran ","title":"Build libraries for Fortran ","text":"Here the base library and the application programming interfaces would be compiled implicitly.","category":"page"},{"location":"ch07/toolbox.html#Toolbox","page":"README","title":"Toolbox","text":"","category":"section"},{"location":"ch07/toolbox.html","page":"README","title":"README","text":"The HIBISCUS component contains lots Fortran codes. They are extremely useful for the post-processing and prep-processing procedures. So we collect them and name them as a toolbox of iQIST. These codes are in the iqist/src/tools/hibiscus/toolbox directory.","category":"page"},{"location":"ch07/toolbox.html","page":"README","title":"README","text":"toolbox/makechi // Magnetic susceptibility chi.\ntoolbox/makedos // Density of states rho(epsilon) for lattice models.\ntoolbox/makekra // Kramers-Kronig transformation for impurity spectral function A(omega).\ntoolbox/makescr // Screening spectral function W(omega) and screening function K(tau).\ntoolbox/makesig // Pade approximation for self-energy function Sigma(iomega_n).\ntoolbox/makestd // Post-processing self-energy function Sigma(iomega_n).\ntoolbox/maketau // Post-processing imaginary-time Green's function G(tau).\ntoolbox/makeups // Evaluate XAS and UPS from A(omega).","category":"page"},{"location":"ch04/p_wc.html#Parameter:-wc","page":"wc","title":"Parameter: wc","text":"","category":"section"},{"location":"ch04/p_wc.html","page":"wc","title":"wc","text":"Definition","category":"page"},{"location":"ch04/p_wc.html","page":"wc","title":"wc","text":"It is a model parameter for the Hubbard-Holstein model or dynamical screening effect. The exact definition of wc depends on the value of isscr parameter.","category":"page"},{"location":"ch04/p_wc.html","page":"wc","title":"wc","text":"Type","category":"page"},{"location":"ch04/p_wc.html","page":"wc","title":"wc","text":"Float, double precision","category":"page"},{"location":"ch04/p_wc.html","page":"wc","title":"wc","text":"Default value","category":"page"},{"location":"ch04/p_wc.html","page":"wc","title":"wc","text":"1.0","category":"page"},{"location":"ch04/p_wc.html","page":"wc","title":"wc","text":"Component","category":"page"},{"location":"ch04/p_wc.html","page":"wc","title":"wc","text":"Only for the NARCISSUS component.","category":"page"},{"location":"ch04/p_wc.html","page":"wc","title":"wc","text":"Behavior","category":"page"},{"location":"ch04/p_wc.html","page":"wc","title":"wc","text":"There are five possible choices for the wc parameter so far:","category":"page"},{"location":"ch04/p_wc.html","page":"wc","title":"wc","text":"isscr = 1, no meaning.\nisscr = 2, the omega_0 parameter in the Hubbard-Holstein model.\nisscr = 3, the omega parameter in the plasmon-pole model for dynamical screening effect.\nisscr = 4, the omega_c parameter in the ohmic model for dynamical screening effect.\nisscr = 99, no meaning.","category":"page"},{"location":"ch04/p_wc.html","page":"wc","title":"wc","text":"Comment","category":"page"},{"location":"ch04/p_wc.html","page":"wc","title":"wc","text":"Only when isscr > 1, it matters. Please see isscr parameter for more details. About CT-QMC algorithms for the Hubbard-Holstein model and dynamical screening effect (including plasmon-pole model and ohmic model), please refer to Philipp Werner's papers[1][2].","category":"page"},{"location":"ch04/p_wc.html","page":"wc","title":"wc","text":"Reference","category":"page"},{"location":"ch04/p_wc.html","page":"wc","title":"wc","text":"[1]: Philipp Werner and Andrew J. Millis, Phys. Rev. Lett 99, 146404 (2007).","category":"page"},{"location":"ch04/p_wc.html","page":"wc","title":"wc","text":"[2]: Philipp Werner and Andrew J. Millis, Phys. Rev. Lett. 104, 146401 (2010).","category":"page"},{"location":"ch06/parameters.html#Parameters","page":"README","title":"Parameters","text":"","category":"section"},{"location":"ch06/parameters.html","page":"README","title":"README","text":"In this section, we will introduce all of the parameters which can be used in the atom.config.in file. The JASMINE component will parse this file and use the setting in it to override the default ones.","category":"page"},{"location":"ch06/parameters.html#Classification-of-the-parameters:","page":"README","title":"Classification of the parameters:","text":"","category":"section"},{"location":"ch06/parameters.html","page":"README","title":"README","text":"Parameters for the diagonalization engine\nibasis\nictqmc\nnmini\nnmaxi\nParameters for the eigensystems\nnband\nnspin\nnorbs\nncfgs\nParameters for the Coulomb interaction\nicu\nUc\nUv\nJz\nJs\nJp\nUd\nJh\nParameters for the spin-orbit coupling and crystal field splitting\nicf\nisoc\nlambda\nmune","category":"page"},{"location":"ch08/binning.html#Data-binning-mode","page":"Data binning mode","title":"Data binning mode","text":"","category":"section"},{"location":"ch04/p_isvrt.html#Parameter:-isvrt","page":"isvrt","title":"Parameter: isvrt","text":"","category":"section"},{"location":"ch04/p_isvrt.html","page":"isvrt","title":"isvrt","text":"Definition","category":"page"},{"location":"ch04/p_isvrt.html","page":"isvrt","title":"isvrt","text":"It is a key control flag, which is used to determine whether we should measure the high order correlation functions and which one we should measure.","category":"page"},{"location":"ch04/p_isvrt.html","page":"isvrt","title":"isvrt","text":"Type","category":"page"},{"location":"ch04/p_isvrt.html","page":"isvrt","title":"isvrt","text":"Integer","category":"page"},{"location":"ch04/p_isvrt.html","page":"isvrt","title":"isvrt","text":"Default value","category":"page"},{"location":"ch04/p_isvrt.html","page":"isvrt","title":"isvrt","text":"1","category":"page"},{"location":"ch04/p_isvrt.html","page":"isvrt","title":"isvrt","text":"Component","category":"page"},{"location":"ch04/p_isvrt.html","page":"isvrt","title":"isvrt","text":"Only for the GARDENIA, NARCISSUS, LAVENDER, CAMELLIA, and MANJUSHAKA components.","category":"page"},{"location":"ch04/p_isvrt.html","page":"isvrt","title":"isvrt","text":"Behavior","category":"page"},{"location":"ch04/p_isvrt.html","page":"isvrt","title":"isvrt","text":"We just use the following algorithm to judge which correlation function should be calculated:","category":"page"},{"location":"ch04/p_isvrt.html","page":"isvrt","title":"isvrt","text":"isvrt parameter is converted from a decimal representation to a binary representation at first. For example, 10_10 is converted to 1010_2, 15_10 is converted to 1111_2, etc.\nThen we examine the bits from rightmost to leftmost one by one. If it is 1, then we do the calculation specified by this bit. If it is 0, then we ignore the calculation specified by this bit. For example, we just use the second bit (from right side to left side) to represent the calculation of two-particle Green's function. So, if isvrt parameter is 10_10 (1010_2), we will calculate the two-particle Green's function since the second bit is 1. If isvrt parameter is 13_10 (1101_2), we will not calculate it since the second bit is 0.","category":"page"},{"location":"ch04/p_isvrt.html","page":"isvrt","title":"isvrt","text":"The following are the definitions of bit representation [p is the bit order (from right to left side)]:","category":"page"},{"location":"ch04/p_isvrt.html","page":"isvrt","title":"isvrt","text":"p = 1, do nothing\np = 2, calculate two-particle Green's function and vertex function (standard algorithm)\np = 3, calculate two-particle Green's function and vertex function (improved algorithm)\np = 4, calculate particle-particle pair susceptibility\np = 5, reserved\np = 6, reserved\np = 7, reserved\np = 8, reserved\np = 9, reserved","category":"page"},{"location":"ch04/p_isvrt.html","page":"isvrt","title":"isvrt","text":"Now let's illustrate a concrete example.","category":"page"},{"location":"ch04/p_isvrt.html","page":"isvrt","title":"isvrt","text":"Supposed that isvrt =  469_10, so the corresponding binary representation is 111010101_2. And then we can easily obtain that:","category":"page"},{"location":"ch04/p_isvrt.html","page":"isvrt","title":"isvrt","text":"p = 9, bit = 1\np = 8, bit = 1\np = 7, bit = 1\np = 6, bit = 0\np = 5, bit = 1\np = 4, bit = 0\np = 3, bit = 1\np = 2, bit = 0\np = 1, bit = 1","category":"page"},{"location":"ch04/p_isvrt.html","page":"isvrt","title":"isvrt","text":"According to the previous definitions about the bit representation, we can conclude that the quantum impurity solvers should calculate the two-particle Green's function and vertex function using an improved algorithm.","category":"page"},{"location":"ch04/p_isvrt.html","page":"isvrt","title":"isvrt","text":"If the bits in p = 2 or p = 3 are set, both the two-particle Green's and vertex functions are computed, but using two different algorithms. You should not set them to 1 at the same time. In order words, if you set the bit at p = 2 to 1, then the bit at p = 3 must be 0, and vice versa.","category":"page"},{"location":"ch04/p_isvrt.html","page":"isvrt","title":"isvrt","text":"If the bit in p = 2 is set, the traditional (standard) algorithm is used. If the bit in p = 3 is set, the improved estimator for two-particle Green's function is used which should have better accuracy.","category":"page"},{"location":"ch04/p_isvrt.html","page":"isvrt","title":"isvrt","text":"Comment","category":"page"},{"location":"ch04/p_isvrt.html","page":"isvrt","title":"isvrt","text":"As for the two-particle Green's function and vertex function, if the standard algorithm is used, the results are written into the solver.twop.dat file. If improved algorithm is adapted, the data are written into the solver.vrtx.dat file. The pair susceptibility will be written into the solver.pair.dat file.","category":"page"},{"location":"ch04/p_isvrt.html","page":"isvrt","title":"isvrt","text":"The Green's function G(tau) and G(iomega_n), hybridization function Delta(tau) and Delta(iomega_n), and self-energy function Sigma(iomega_n) will be calculated and output by the quantum impurity solvers in the iQIST software package implicitly. However, the susceptibilities and high-order correlation functions won't. You have to use the issus and isvrt parameters to active the related calculations.","category":"page"},{"location":"ch04/p_isvrt.html","page":"isvrt","title":"isvrt","text":"The isvrt parameter has nothing to do with the isort parameter, but when the bit in p = 3 is set to be 1, a prefactor for the improved estimator (please see pref in ctqmc_context.f90) should be calculated and used to improve the computational accuracy. On the other hand, if isort >= 4, the same prefactor will be calculated as well. You can not setup isscr = 2 at this time (only be notable for the NARCISSUS component).","category":"page"},{"location":"ch04/p_isvrt.html","page":"isvrt","title":"isvrt","text":"See isvrt, isort, and isscr for more details.","category":"page"},{"location":"ch08/chi.html#Spin-spin-correlation-function-and-orbital-orbital-correlation-function","page":"Spin-spin correlation function and orbital-orbital correlation function","title":"Spin-spin correlation function and orbital-orbital correlation function","text":"","category":"section"},{"location":"ch04/out_vrtx.html#solver.vrtx.dat","page":"solver.vrtx.dat","title":"solver.vrtx.dat","text":"","category":"section"},{"location":"ch04/out_vrtx.html","page":"solver.vrtx.dat","title":"solver.vrtx.dat","text":"Introduction","category":"page"},{"location":"ch04/out_vrtx.html","page":"solver.vrtx.dat","title":"solver.vrtx.dat","text":"The solver.vrtx.dat file is designed to store the two-particle Green's function chi(iomega_n iomega_n inu_n) and vertex function mathcalF(iomega_n iomega_n inu_n). It will be output by the quantum impurity solvers when they are shut down.","category":"page"},{"location":"ch04/out_vrtx.html","page":"solver.vrtx.dat","title":"solver.vrtx.dat","text":"note: Note\nOnly the GARDENIA and NARCISSUS components can generate the solver.vrtx.dat file.\nThe data stored in the solver.twop.dat file are generated using standard algorithm. However, those data in the solver.vrtx.dat file are generated using the improved estimator algorithm. Unfortunately, as for the CAMELLIA, LAVENDER, and MANJUSHAKA components, they don't support the improved estimator algorithm, so they couldn't generate the solver.vrtx.dat file.","category":"page"},{"location":"ch04/out_vrtx.html","page":"solver.vrtx.dat","title":"solver.vrtx.dat","text":"Format","category":"page"},{"location":"ch04/out_vrtx.html","page":"solver.vrtx.dat","title":"solver.vrtx.dat","text":"The solver.vrtx.dat file contains ","category":"page"},{"location":"ch04/out_vrtx.html","page":"solver.vrtx.dat","title":"solver.vrtx.dat","text":" left(sumlimits^textnorbs_n=1 fracn(n+1)2right)times textnbfrq","category":"page"},{"location":"ch04/out_vrtx.html","page":"solver.vrtx.dat","title":"solver.vrtx.dat","text":"blocks. Each block is appended by two blank lines. The format of each block is as follows:","category":"page"},{"location":"ch04/out_vrtx.html","page":"solver.vrtx.dat","title":"solver.vrtx.dat","text":"","category":"page"},{"location":"ch04/out_vrtx.html","page":"solver.vrtx.dat","title":"solver.vrtx.dat","text":"column 1: Matsubara frequency point (fermionic type), omega_n, integer, the unit is pibeta","category":"page"},{"location":"ch04/out_vrtx.html","page":"solver.vrtx.dat","title":"solver.vrtx.dat","text":"column 2: Matsubara frequency point (fermionic type), omega_n, integer, the unit is pibeta","category":"page"},{"location":"ch04/out_vrtx.html","page":"solver.vrtx.dat","title":"solver.vrtx.dat","text":"column 3: two-particle Green's function, chi(iomega_n iomega_n inu_n), double precision","category":"page"},{"location":"ch04/out_vrtx.html","page":"solver.vrtx.dat","title":"solver.vrtx.dat","text":"column 4: bubble function, chi_0(iomega_n iomega_n inu_n), double precision","category":"page"},{"location":"ch04/out_vrtx.html","page":"solver.vrtx.dat","title":"solver.vrtx.dat","text":"column 5: irreducible part of the two-particle Green's function, chi_textirr(iomega_n iomega_n inu_n), double precision","category":"page"},{"location":"ch04/out_vrtx.html","page":"solver.vrtx.dat","title":"solver.vrtx.dat","text":"column 6: full vertex function, mathcalF(iomega_n iomega_n inu_n), double precision","category":"page"},{"location":"ch04/out_vrtx.html","page":"solver.vrtx.dat","title":"solver.vrtx.dat","text":"","category":"page"},{"location":"ch04/out_vrtx.html","page":"solver.vrtx.dat","title":"solver.vrtx.dat","text":"note: Note\nIn the solver.vrtx.dat file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch04/out_vrtx.html","page":"solver.vrtx.dat","title":"solver.vrtx.dat","text":"Code","category":"page"},{"location":"ch04/out_vrtx.html","page":"solver.vrtx.dat","title":"solver.vrtx.dat","text":"The corresponding Fortran code block for the writing of solver.vrtx.dat file is as follows:","category":"page"},{"location":"ch04/out_vrtx.html","page":"solver.vrtx.dat","title":"solver.vrtx.dat","text":"! open data file: solver.vrtx.dat\n     open(mytmp, file='solver.vrtx.dat', form='formatted', status='unknown')\n\n! write it\n     do m=1,norbs\n         do n=1,m\n             do k=1,nbfrq\n                 write(mytmp,'(a,i6)') '# flvr1:', m\n                 write(mytmp,'(a,i6)') '# flvr2:', n\n                 write(mytmp,'(a,i6)') '# nbfrq:', k\n                 do j=1,nffrq\n\n                     ......\n\n                     do i=1,nffrq\n\n                         ......\n\n                         write(mytmp,'(2i6,8f16.8)') jt, it, chit, chi0, chii, chii/(g1*g2*g3*g4)\n                     enddo ! over i={1,nffrq} loop\n                 enddo ! over j={1,nffrq} loop\n                 write(mytmp,*) ! write empty lines\n                 write(mytmp,*)\n             enddo ! over k={1,nbfrq} loop\n         enddo ! over n={1,m} loop\n     enddo ! over m={1,norbs} loop\n\n! close data file\n     close(mytmp)","category":"page"},{"location":"ch04/out_vrtx.html","page":"solver.vrtx.dat","title":"solver.vrtx.dat","text":"In the HIBISCUS component, we provide a Python module to read the output files of quantum impurity solvers. You can use it to read the solver.vrtx.dat file. See script/u_reader.py for more details.","category":"page"},{"location":"ch04/p_nflip.html#Parameter:-nflip","page":"nflip","title":"Parameter: nflip","text":"","category":"section"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"Definition","category":"page"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"Flip period for spin up and spin down states.","category":"page"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"Type","category":"page"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"Integer","category":"page"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"Default value","category":"page"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"20000","category":"page"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"Component","category":"page"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"ALL, except for the DAISY component.","category":"page"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"Behavior","category":"page"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"Care must be taken to prevent the system from being trapped in a state which breaks a symmetry of local Hamiltonian when it should not be. To avoid un-physical trapping, we introduce \"flip\" moves, which exchange the operators corresponding, for example, to up and down spins in a given band.","category":"page"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"In this code, nowadays the following flip schemes are supported:","category":"page"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"cflip = 1, flip inter-orbital spins randomly,\ncflip = 2, flip intra-orbital spins one by one,\ncflip = 3, flip intra-orbital spins globally.","category":"page"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"Here cflip is an internal variable, instead of an input parameters, you can not setup it in the solver.ctqmc.in file. ","category":"page"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"So the question is: how to control cflip via the nflip parameter?","category":"page"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"Now we use the sign of nflip to control flip schemes","category":"page"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"nflip = 0, means infinite long period to do flip\nnflip > 0, combine cflip = 2 (80%) and cflip = 3 (20%)\nnflip < 0, combine cflip = 1 (80%) and cflip = 3 (20%)","category":"page"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"Comment","category":"page"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"If nflip /= 0, the absolute value of nflip is the flip period.","category":"page"},{"location":"ch04/p_nflip.html","page":"nflip","title":"nflip","text":"note: Note\nWhen cflip = 1, the symmetry of all orbitals must be taken into consideration, otherwise the code may be trapped by a deadlock.","category":"page"},{"location":"ch06/out_umat1.html#solver.umat.in","page":"solver.umat.in","title":"solver.umat.in","text":"","category":"section"},{"location":"ch06/out_umat1.html","page":"solver.umat.in","title":"solver.umat.in","text":"Introduction","category":"page"},{"location":"ch06/out_umat1.html","page":"solver.umat.in","title":"solver.umat.in","text":"The solver.umat.in file contains the density-density part of the general Coulomb interaction matrix. Some CT-HYB quantum impurity solvers can read it. It is compatible with the AZALEA, GARDENIA, NARCISSUS components. These components may utilize it to redefine the internal (default) Coulomb interaction matrix.","category":"page"},{"location":"ch06/out_umat1.html","page":"solver.umat.in","title":"solver.umat.in","text":"Format","category":"page"},{"location":"ch06/out_umat1.html","page":"solver.umat.in","title":"solver.umat.in","text":"The format of the solver.umat.in file is as follows:","category":"page"},{"location":"ch06/out_umat1.html","page":"solver.umat.in","title":"solver.umat.in","text":"","category":"page"},{"location":"ch06/out_umat1.html","page":"solver.umat.in","title":"solver.umat.in","text":"column 1: orbital index i, integer","category":"page"},{"location":"ch06/out_umat1.html","page":"solver.umat.in","title":"solver.umat.in","text":"column 2: orbital index j, integer","category":"page"},{"location":"ch06/out_umat1.html","page":"solver.umat.in","title":"solver.umat.in","text":"column 3: Coulomb interaction matrix element U(ij), double precision","category":"page"},{"location":"ch06/out_umat1.html","page":"solver.umat.in","title":"solver.umat.in","text":"","category":"page"},{"location":"ch06/out_umat1.html","page":"solver.umat.in","title":"solver.umat.in","text":"note: Note\nIn the solver.umat.in file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch06/out_umat1.html","page":"solver.umat.in","title":"solver.umat.in","text":"Code","category":"page"},{"location":"ch06/out_umat1.html","page":"solver.umat.in","title":"solver.umat.in","text":"The corresponding Fortran code block for the writing of the solver.umat.in file is as follows:","category":"page"},{"location":"ch06/out_umat1.html","page":"solver.umat.in","title":"solver.umat.in","text":"! open file atom.umat.dat to write\n     open(mytmp, file='solver.umat.in', form='formatted', status='unknown')\n\n! write the data, all of the elements are outputed\n! note: we have to change the spin sequence here\n     do i=1,norbs\n         if ( i <= nband ) then\n             k = 2*i-1\n         else\n             k = 2*(i-nband)\n         endif ! back if ( i <= nband ) block\n\n         do j=1,norbs\n             if ( j <= nband ) then\n                 l = 2*j-1\n             else\n                 l = 2*(j-nband)\n             endif ! back if ( j <= nband ) block\n\n             write(mytmp,'(2i6,f16.8)') i, j, umat_t(k,l)\n         enddo ! over j={1,norbs} loop\n     enddo ! over i={1,norbs} loop\n\n! close data file\n     close(mytmp)","category":"page"},{"location":"ch06/out_umat1.html","page":"solver.umat.in","title":"solver.umat.in","text":"See also solver.umat.in for more details.","category":"page"},{"location":"ch06/p_ictqmc.html#Parameter:-ictqmc","page":"ictqmc","title":"Parameter: ictqmc","text":"","category":"section"},{"location":"ch06/p_ictqmc.html","page":"ictqmc","title":"ictqmc","text":"Definition","category":"page"},{"location":"ch06/p_ictqmc.html","page":"ictqmc","title":"ictqmc","text":"Key control flag, define which algorithm is used to diagonalize the atomic Hamiltonian matrix.","category":"page"},{"location":"ch06/p_ictqmc.html","page":"ictqmc","title":"ictqmc","text":"Type","category":"page"},{"location":"ch06/p_ictqmc.html","page":"ictqmc","title":"ictqmc","text":"Integer","category":"page"},{"location":"ch06/p_ictqmc.html","page":"ictqmc","title":"ictqmc","text":"Default value","category":"page"},{"location":"ch06/p_ictqmc.html","page":"ictqmc","title":"ictqmc","text":"1","category":"page"},{"location":"ch06/p_ictqmc.html","page":"ictqmc","title":"ictqmc","text":"Component","category":"page"},{"location":"ch06/p_ictqmc.html","page":"ictqmc","title":"ictqmc","text":"Only for the JASMINE component.","category":"page"},{"location":"ch06/p_ictqmc.html","page":"ictqmc","title":"ictqmc","text":"Behavior","category":"page"},{"location":"ch06/p_ictqmc.html","page":"ictqmc","title":"ictqmc","text":"There are six possible values for the ictqmc parameter:","category":"page"},{"location":"ch06/p_ictqmc.html","page":"ictqmc","title":"ictqmc","text":"ictqmc = 0, direct diagonalization in full Hilbert space. The generated atom.cix file is only suitable for the CAMELLIA code.\nictqmc = 1, direct diagonalization in full Hilbert space. The generated atom.cix file is only suitable for the BEGONIA and LAVENDER codes.\nictqmc = 2, diagonalization in subspace using good quantum number N. The generated atom.cix file is only suitable for the MANJUSHAKA and PANSY codes.\nictqmc = 3, diagonalization in subspace using good quantum numbers N, S_z. The generated atom.cix file is only suitable for the MANJUSHAKA and PANSY codes.\nictqmc = 4, diagonalization in subspace using good quantum numbers N, S_z, PS. The generated atom.cix file is only suitable for the MANJUSHAKA and PANSY codes.\nictqmc = 5, diagonalization in subspace using good quantum numbers N, J_z. The generated atom.cix file is only suitable for the MANJUSHAKA and PANSY codes.","category":"page"},{"location":"ch06/p_ictqmc.html","page":"ictqmc","title":"ictqmc","text":"When ictqmc = 4, it is not compatible with icu = 2.","category":"page"},{"location":"ch06/p_ictqmc.html","page":"ictqmc","title":"ictqmc","text":"Comment","category":"page"},{"location":"ch06/p_ictqmc.html","page":"ictqmc","title":"ictqmc","text":"See also icu for more details.","category":"page"},{"location":"ch06/p_lambda.html#Parameter:-lambda","page":"lambda","title":"Parameter: lambda","text":"","category":"section"},{"location":"ch06/p_lambda.html","page":"lambda","title":"lambda","text":"Definition","category":"page"},{"location":"ch06/p_lambda.html","page":"lambda","title":"lambda","text":"Strength of the spin-orbital coupling lambda.","category":"page"},{"location":"ch06/p_lambda.html","page":"lambda","title":"lambda","text":"Type","category":"page"},{"location":"ch06/p_lambda.html","page":"lambda","title":"lambda","text":"Float, double precision","category":"page"},{"location":"ch06/p_lambda.html","page":"lambda","title":"lambda","text":"Default value","category":"page"},{"location":"ch06/p_lambda.html","page":"lambda","title":"lambda","text":"0.0","category":"page"},{"location":"ch06/p_lambda.html","page":"lambda","title":"lambda","text":"Component","category":"page"},{"location":"ch06/p_lambda.html","page":"lambda","title":"lambda","text":"Only for the JASMINE component.","category":"page"},{"location":"ch06/p_lambda.html","page":"lambda","title":"lambda","text":"Behavior","category":"page"},{"location":"ch06/p_lambda.html","page":"lambda","title":"lambda","text":"This parameter is used to build the spin-orbital coupling term of the local interaction Hamiltonian. It is valid only when isoc = 1.","category":"page"},{"location":"ch06/p_lambda.html","page":"lambda","title":"lambda","text":"H_textSOC = lambda textbfL cdot textbfS","category":"page"},{"location":"ch06/p_lambda.html","page":"lambda","title":"lambda","text":"Comment","category":"page"},{"location":"ch06/p_lambda.html","page":"lambda","title":"lambda","text":"See also isoc parameter for more details.","category":"page"},{"location":"ch07/archive.html#script/d_archive.sh","page":"script/d_archive.sh","title":"script/d_archive.sh","text":"","category":"section"},{"location":"ch07/archive.html","page":"script/d_archive.sh","title":"script/d_archive.sh","text":"Introduction","category":"page"},{"location":"ch07/archive.html","page":"script/d_archive.sh","title":"script/d_archive.sh","text":"We can use this script to generate a compressed archive from the current repo branch of the iQIST software package.","category":"page"},{"location":"ch07/archive.html","page":"script/d_archive.sh","title":"script/d_archive.sh","text":"Type","category":"page"},{"location":"ch07/archive.html","page":"script/d_archive.sh","title":"script/d_archive.sh","text":"Bash shell script","category":"page"},{"location":"ch07/archive.html","page":"script/d_archive.sh","title":"script/d_archive.sh","text":"Usage","category":"page"},{"location":"ch07/archive.html","page":"script/d_archive.sh","title":"script/d_archive.sh","text":"$ ./d_archive.sh","category":"page"},{"location":"ch07/archive.html","page":"script/d_archive.sh","title":"script/d_archive.sh","text":"Input","category":"page"},{"location":"ch07/archive.html","page":"script/d_archive.sh","title":"script/d_archive.sh","text":"N/A","category":"page"},{"location":"ch07/archive.html","page":"script/d_archive.sh","title":"script/d_archive.sh","text":"Output","category":"page"},{"location":"ch07/archive.html","page":"script/d_archive.sh","title":"script/d_archive.sh","text":"The name of the output archive should like this:","category":"page"},{"location":"ch07/archive.html","page":"script/d_archive.sh","title":"script/d_archive.sh","text":"iqist_43e2cbb_1441276643.tar.gz","category":"page"},{"location":"ch07/archive.html","page":"script/d_archive.sh","title":"script/d_archive.sh","text":"Here 43e2cbb is the abbreviated commit hash tag, and 1441276643 is the UNIX timestamp when this commit was committed.","category":"page"},{"location":"ch07/archive.html","page":"script/d_archive.sh","title":"script/d_archive.sh","text":"Comment","category":"page"},{"location":"ch07/archive.html","page":"script/d_archive.sh","title":"script/d_archive.sh","text":"To use this script, the git tool must be installed. ","category":"page"},{"location":"ch07/archive.html","page":"script/d_archive.sh","title":"script/d_archive.sh","text":"note: Note\nThis script is used by the iQIST Developer Team internally.","category":"page"},{"location":"ch07/scr.html#toolbox/makescr","page":"toolbox/makescr","title":"toolbox/makescr","text":"","category":"section"},{"location":"ch07/scr.html","page":"toolbox/makescr","title":"toolbox/makescr","text":"Introduction","category":"page"},{"location":"ch07/scr.html","page":"toolbox/makescr","title":"toolbox/makescr","text":"The makescr code is often used to calculate the K(tau) from classic models or from the screening spectral function W(omega) (scr.frq.dat file). The results are necessary input for the NARCISSUS code. ","category":"page"},{"location":"ch07/scr.html","page":"toolbox/makescr","title":"toolbox/makescr","text":"Retarded interaction function/screening function K(tau):","category":"page"},{"location":"ch07/scr.html","page":"toolbox/makescr","title":"toolbox/makescr","text":"K(tau) = int^infty_0 fracdomegapi fracIm W(omega)omega^2 mathcalB(omegatau)-mathcalB(omega0)","category":"page"},{"location":"ch07/scr.html","page":"toolbox/makescr","title":"toolbox/makescr","text":"Shifted interaction U_textscr:","category":"page"},{"location":"ch07/scr.html","page":"toolbox/makescr","title":"toolbox/makescr","text":"U_textscr = U + 2 int^infty_0 fracdomegapifracIm W(omega)omega","category":"page"},{"location":"ch07/scr.html","page":"toolbox/makescr","title":"toolbox/makescr","text":"Shifted chemical potential mu_textscr:","category":"page"},{"location":"ch07/scr.html","page":"toolbox/makescr","title":"toolbox/makescr","text":"mu_textscr = mu +  int^infty_0 fracdomegapifracIm W(omega)omega","category":"page"},{"location":"ch07/scr.html","page":"toolbox/makescr","title":"toolbox/makescr","text":"Usage","category":"page"},{"location":"ch07/scr.html","page":"toolbox/makescr","title":"toolbox/makescr","text":"$ ./mscr","category":"page"},{"location":"ch07/scr.html","page":"toolbox/makescr","title":"toolbox/makescr","text":"Input","category":"page"},{"location":"ch07/scr.html","page":"toolbox/makescr","title":"toolbox/makescr","text":"See the terminal prompt\nscr.frq.dat (optional)","category":"page"},{"location":"ch07/scr.html","page":"toolbox/makescr","title":"toolbox/makescr","text":"Output","category":"page"},{"location":"ch07/scr.html","page":"toolbox/makescr","title":"toolbox/makescr","text":"scr.tau.dat","category":"page"},{"location":"ch07/scr.html","page":"toolbox/makescr","title":"toolbox/makescr","text":"Comment","category":"page"},{"location":"ch07/scr.html","page":"toolbox/makescr","title":"toolbox/makescr","text":"In this code and NARCISSUS code, we assume that K(tau) is degenerated for multi-orbital system.","category":"page"},{"location":"ch07/scr.html","page":"toolbox/makescr","title":"toolbox/makescr","text":"The W(omega) data are often obtained by the cRPA calculations. This feature is unfortunately not included in the iQIST software package.","category":"page"},{"location":"ch07/scr.html","page":"toolbox/makescr","title":"toolbox/makescr","text":"In order to be compatible with the NARCISSUS code, you have to rename the output file (i.e., scr.tau.dat) to solver.ktau.in.","category":"page"},{"location":"ch07/scr.html","page":"toolbox/makescr","title":"toolbox/makescr","text":"See also solver.ktau.in for more details.","category":"page"},{"location":"ch04/p_niter.html#Parameter:-niter","page":"niter","title":"Parameter: niter","text":"","category":"section"},{"location":"ch04/p_niter.html","page":"niter","title":"niter","text":"Definition","category":"page"},{"location":"ch04/p_niter.html","page":"niter","title":"niter","text":"Maximum number of continuous time or Hirsch-Fye quantum Monte Carlo quantum impurity solver plus dynamical mean field theory self-consistent iterations.","category":"page"},{"location":"ch04/p_niter.html","page":"niter","title":"niter","text":"Type","category":"page"},{"location":"ch04/p_niter.html","page":"niter","title":"niter","text":"Integer","category":"page"},{"location":"ch04/p_niter.html","page":"niter","title":"niter","text":"Default value","category":"page"},{"location":"ch04/p_niter.html","page":"niter","title":"niter","text":"20","category":"page"},{"location":"ch04/p_niter.html","page":"niter","title":"niter","text":"Component","category":"page"},{"location":"ch04/p_niter.html","page":"niter","title":"niter","text":"ALL","category":"page"},{"location":"ch04/p_niter.html","page":"niter","title":"niter","text":"Behavior","category":"page"},{"location":"ch04/p_niter.html","page":"niter","title":"niter","text":"Terminate the quantum impurity solvers when the niter DMFT iteration is reached.","category":"page"},{"location":"ch04/p_niter.html","page":"niter","title":"niter","text":"note: Note\nIf the convergence is obtained and the minimal iteration number is reached (the default value is 16, you can modify it in the ctqmc_dmft.f90), the quantum impurity solvers will exit as well.","category":"page"},{"location":"ch04/p_niter.html","page":"niter","title":"niter","text":"If isscf = 1, the niter becomes meaningless. The self-consistent iteration won't be carried out which is equivalent to niter = 1.","category":"page"},{"location":"ch04/p_niter.html","page":"niter","title":"niter","text":"Comment","category":"page"},{"location":"ch04/p_niter.html","page":"niter","title":"niter","text":"See also isscf, isbin, and alpha parameters.","category":"page"},{"location":"ch07/kra.html#toolbox/makekra","page":"toolbox/makekra","title":"toolbox/makekra","text":"","category":"section"},{"location":"ch07/kra.html","page":"toolbox/makekra","title":"toolbox/makekra","text":"Introduction","category":"page"},{"location":"ch07/kra.html","page":"toolbox/makekra","title":"toolbox/makekra","text":"Once the analytical continuation is finished, we can obtain the spectral function A(omega) and the imaginary part of the real-frequency Green's function Im G(omega),","category":"page"},{"location":"ch07/kra.html","page":"toolbox/makekra","title":"toolbox/makekra","text":"A(omega) = -fracIm G(omega)pi","category":"page"},{"location":"ch07/kra.html","page":"toolbox/makekra","title":"toolbox/makekra","text":"From the well-known Kramers-Kronig transformation, the real part of G(omega) can be determined as well:","category":"page"},{"location":"ch07/kra.html","page":"toolbox/makekra","title":"toolbox/makekra","text":"Re G(omega) = -frac1pi int^infty_-infty domega fracIm G(omega)omega - omega","category":"page"},{"location":"ch07/kra.html","page":"toolbox/makekra","title":"toolbox/makekra","text":"In the HIBISCUS component, we offer a Fortran code to do this job. This is the toolbox/makekra code.","category":"page"},{"location":"ch07/kra.html","page":"toolbox/makekra","title":"toolbox/makekra","text":"The makekra code reads the density of states data, and then calculate the imaginary part of Matsubara green's function. And then using the Kramers-Kronig transformation, we can calculate the real part of the Matsubara green's function easily. So the complete green's function is obtained, which can be used to calculate the self-energy function on real axis by the invert Hilbert transformation.","category":"page"},{"location":"ch07/kra.html","page":"toolbox/makekra","title":"toolbox/makekra","text":"Usage","category":"page"},{"location":"ch07/kra.html","page":"toolbox/makekra","title":"toolbox/makekra","text":"$ ./mkra","category":"page"},{"location":"ch07/kra.html","page":"toolbox/makekra","title":"toolbox/makekra","text":"Input","category":"page"},{"location":"ch07/kra.html","page":"toolbox/makekra","title":"toolbox/makekra","text":"See the terminal prompt\nmem.dos.dat (necessary)","category":"page"},{"location":"ch07/kra.html","page":"toolbox/makekra","title":"toolbox/makekra","text":"Output","category":"page"},{"location":"ch07/kra.html","page":"toolbox/makekra","title":"toolbox/makekra","text":"kra.grn.dat","category":"page"},{"location":"ch07/kra.html","page":"toolbox/makekra","title":"toolbox/makekra","text":"Comment","category":"page"},{"location":"ch07/kra.html","page":"toolbox/makekra","title":"toolbox/makekra","text":"Now this code is interfaced with HIBISCUS/entropy code merely. It can read the mem.dos.dat file as input data. While to interface it with the HIBISCUS/stoch code is very simple. What you need to do is to rename sac.imsum.dat to mem.dos.dat file, and then supplement the data for different orbitals.","category":"page"},{"location":"ch04/p_issus.html#Parameter:-issus","page":"issus","title":"Parameter: issus","text":"","category":"section"},{"location":"ch04/p_issus.html","page":"issus","title":"issus","text":"Definition","category":"page"},{"location":"ch04/p_issus.html","page":"issus","title":"issus","text":"It is a key control flag, which is used to determine whether we should measure the charge or spin susceptibility and which one we should measure.","category":"page"},{"location":"ch04/p_issus.html","page":"issus","title":"issus","text":"Type","category":"page"},{"location":"ch04/p_issus.html","page":"issus","title":"issus","text":"Integer","category":"page"},{"location":"ch04/p_issus.html","page":"issus","title":"issus","text":"Default value","category":"page"},{"location":"ch04/p_issus.html","page":"issus","title":"issus","text":"1","category":"page"},{"location":"ch04/p_issus.html","page":"issus","title":"issus","text":"Component","category":"page"},{"location":"ch04/p_issus.html","page":"issus","title":"issus","text":"Only for the GARDENIA, NARCISSUS, LAVENDER, CAMELLIA, and MANJUSHAKA components.","category":"page"},{"location":"ch04/p_issus.html","page":"issus","title":"issus","text":"Behavior","category":"page"},{"location":"ch04/p_issus.html","page":"issus","title":"issus","text":"We just use the following algorithm to judge which susceptibility should be calculated:","category":"page"},{"location":"ch04/p_issus.html","page":"issus","title":"issus","text":"issus parameter is converted from a decimal representation to a binary representation at first. For example, 10_10 is converted to 1010_2, 15_10 is converted to 1111_2, etc.\nThen we examine the bits from rightmost to leftmost one by one. If it is 1, then we do the calculation specified by this bit. If it is 0, then we ignore the calculation specified by this bit. For example, we just use the second bit (from right side to left side) to represent the calculation of spin-spin correlation function. Therefore, if issus parameter is 10_10 (1010_2), we will calculate the spin-spin correlation function since the second bit is 1. Supposing issus parameter is 13_10 (1101_2), we will not calculate it as the second bit is 0.","category":"page"},{"location":"ch04/p_issus.html","page":"issus","title":"issus","text":"The following are the definitions of bit representation [p is the bit order (from right to left side)]:","category":"page"},{"location":"ch04/p_issus.html","page":"issus","title":"issus","text":"p = 1, do nothing\np = 2, calculate spin-spin correlation function (in time space)\np = 3, calculate orbital-orbital correlation function (in time space)\np = 4, calculate spin-spin correlation function (in frequency space)\np = 5, calculate orbital-orbital correlation function (in frequency space)\np = 6, calculate langle k^2 rangle - langle k rangle^2\np = 7, calculate fidelity susceptibility matrix\np = 8, reserved\np = 9, reserved","category":"page"},{"location":"ch04/p_issus.html","page":"issus","title":"issus","text":"Now let's consider a concrete example.","category":"page"},{"location":"ch04/p_issus.html","page":"issus","title":"issus","text":"Supposed that issus =  469_10, then the corresponding binary representation is 111010101_2. And then we can easily obtain that:","category":"page"},{"location":"ch04/p_issus.html","page":"issus","title":"issus","text":"p = 9, bit = 1\np = 8, bit = 1\np = 7, bit = 1\np = 6, bit = 0\np = 5, bit = 1\np = 4, bit = 0\np = 3, bit = 1\np = 2, bit = 0\np = 1, bit = 1","category":"page"},{"location":"ch04/p_issus.html","page":"issus","title":"issus","text":"According to the previous definitions about the bit representation, we can conclude that the quantum impurity solvers should calculate the orbital-orbital correlation function (in time space and frequency space) and the fidelity susceptibility simultaneously.","category":"page"},{"location":"ch04/p_issus.html","page":"issus","title":"issus","text":"For the CAMELLIA, LAVENDER, and MANJUSHAKA components, the bits at p = 2, 3, 4, and 5 are not ready.","category":"page"},{"location":"ch04/p_issus.html","page":"issus","title":"issus","text":"Comment","category":"page"},{"location":"ch04/p_issus.html","page":"issus","title":"issus","text":"The spin-spin correlation function will be written into the solver.schi.dat and solver.sfom.dat files. The orbital-orbital correlation function will be written into the solver.ochi.dat and solver.ofom.dat files. The kinetic energy fluctuation will be written into the solver.kmat.dat file. The fidelity susceptibility will be written into the solver.lmat.dat file.","category":"page"},{"location":"ch04/p_issus.html","page":"issus","title":"issus","text":"The Green's function G(tau) and G(iomega_n), hybridization function Delta(tau) and Delta(iomega_n), and self-energy function Sigma(iomega_n) will be calculated and output by the quantum impurity solvers in the iQIST software package implicitly. However, the susceptibilities and high-order correlation functions won't. You have to use the issus and isvrt parameters to active the related calculations.","category":"page"},{"location":"ch04/p_issus.html","page":"issus","title":"issus","text":"See isvrt for more details.","category":"page"},{"location":"ch02/uncompress.html#Uncompress","page":"Uncompress","title":"Uncompress","text":"","category":"section"},{"location":"ch02/uncompress.html","page":"Uncompress","title":"Uncompress","text":"Usually, the iQIST software package is released as a compressed file. Please use the following commands to uncompress the iQIST software package:","category":"page"},{"location":"ch02/uncompress.html#tar.gz-style","page":"Uncompress","title":"tar.gz style","text":"","category":"section"},{"location":"ch02/uncompress.html","page":"Uncompress","title":"Uncompress","text":"$ tar xvfz iqist.tar.gz","category":"page"},{"location":"ch02/uncompress.html#zip-style","page":"Uncompress","title":"zip style","text":"","category":"section"},{"location":"ch02/uncompress.html","page":"Uncompress","title":"Uncompress","text":"$ unzip iqist.tar.gz","category":"page"},{"location":"ch02/uncompress.html#tar.bz2-style","page":"Uncompress","title":"tar.bz2 style","text":"","category":"section"},{"location":"ch02/uncompress.html","page":"Uncompress","title":"Uncompress","text":"$ tar xvfz iqist.tar.bz2","category":"page"},{"location":"ch02/uncompress.html","page":"Uncompress","title":"Uncompress","text":"or","category":"page"},{"location":"ch02/uncompress.html","page":"Uncompress","title":"Uncompress","text":"$ bzip2 -d iqist.tar.bz2\n$ tar xvf iqist.tar","category":"page"},{"location":"ch02/uncompress.html","page":"Uncompress","title":"Uncompress","text":"note: Note\nThe tar, unzip, bzip2 are all Linux terminal commands. Please consult your system administrator for more details.","category":"page"},{"location":"ch02/solvers.html#Build-quantum-impurity-solvers:-integrally","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers: integrally","text":"","category":"section"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"ehh...","category":"page"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"I want to compile all of the components of quantum impurity solvers. Is it possible?","category":"page"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"Of course. It is just a piece of cake. Please follow the following guidelines.","category":"page"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"Method:","category":"page"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"$ cd iqist/build\n$ editor make.sys\n$ make solver\n$ ./x_setup.sh","category":"page"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"note: Note\nHere editor means any ascii text editor you prefer.\nThe base library and the application programming interfaces should be compiled implicitly.","category":"page"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"Finally, you will see a lot of executable programs, such as azalea.x, begonia.x, daisy.x, etc., in the iqist/build directory. They are the CT-HYB and HF-QMC impurity solvers. You can execute them in the terminal directly.","category":"page"},{"location":"ch02/solvers.html#Build-quantum-impurity-solvers:-individually","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers: individually","text":"","category":"section"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"Sometimes you only need to use some of the quantum impurity solver components of iQIST and you don't want to compile the whole iQIST software package. Are there any tricks to do? Yes! You will not be disappointed with iQIST.","category":"page"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"Supposed that what you need is the AZALEA component:","category":"page"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"Method 1:","category":"page"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"$ cd iqist/build\n$ editor make.sys\n$ make base\n$ make capi\n$ make azalea\n$ ./x_setup.sh","category":"page"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"note: Note\nHere editor means any ascii text editor you prefer.\nazalea can be any other component's name, such as begonia, pansy, gardenia, etc.\nIf the base library and the application programming interfaces were already compiled successfully, then you can skip the following commands:$ make base\n$ make capi","category":"page"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"After a few minutes, you will find an azalea.x file in the iqist/build directory. That is what you need, the executable program for the AZALEA component. Then you can add it to the system path, and do your great research.","category":"page"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"Method 2:","category":"page"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"In this approach, we go to the directory of the AZALEA component at first. Then 'make' it as usual.","category":"page"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"$ cd iqist/src/ctqmc/azalea\n$ make","category":"page"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"Here, we assume that the compiling system was correctly configured, the base library and the application programming interfaces were already compiled successfully.","category":"page"},{"location":"ch02/solvers.html","page":"Build quantum impurity solvers","title":"Build quantum impurity solvers","text":"note: Note\nNow the executable programs will not be copied into the iqist/build directory. You have to go to the iqist/build directory, and execute$ ./x_setup.sh","category":"page"},{"location":"ch04/p_mune.html#Parameter:-mune","page":"mune","title":"Parameter: mune","text":"","category":"section"},{"location":"ch04/p_mune.html","page":"mune","title":"mune","text":"Definition","category":"page"},{"location":"ch04/p_mune.html","page":"mune","title":"mune","text":"It means chemical potential mu or fermi level E_F.","category":"page"},{"location":"ch04/p_mune.html","page":"mune","title":"mune","text":"Type","category":"page"},{"location":"ch04/p_mune.html","page":"mune","title":"mune","text":"Float, double precision","category":"page"},{"location":"ch04/p_mune.html","page":"mune","title":"mune","text":"Default value","category":"page"},{"location":"ch04/p_mune.html","page":"mune","title":"mune","text":"2.0","category":"page"},{"location":"ch04/p_mune.html","page":"mune","title":"mune","text":"Component","category":"page"},{"location":"ch04/p_mune.html","page":"mune","title":"mune","text":"ALL","category":"page"},{"location":"ch04/p_mune.html","page":"mune","title":"mune","text":"Behavior","category":"page"},{"location":"ch04/p_mune.html","page":"mune","title":"mune","text":"It is a model parameter and can be used to determine the impurity occupancy.","category":"page"},{"location":"ch04/p_mune.html","page":"mune","title":"mune","text":"Comment","category":"page"},{"location":"ch04/p_mune.html","page":"mune","title":"mune","text":"For single-band model, the half-filling condition is mu = U2.","category":"page"},{"location":"ch04/p_mkink.html#Parameter:-mkink","page":"mkink","title":"Parameter: mkink","text":"","category":"section"},{"location":"ch04/p_mkink.html","page":"mkink","title":"mkink","text":"Definition","category":"page"},{"location":"ch04/p_mkink.html","page":"mkink","title":"mkink","text":"Maximum allowable diagrammatic perturbation order in the continuous-time quantum Monte Carlo algorithm.","category":"page"},{"location":"ch04/p_mkink.html","page":"mkink","title":"mkink","text":"Type","category":"page"},{"location":"ch04/p_mkink.html","page":"mkink","title":"mkink","text":"Integer","category":"page"},{"location":"ch04/p_mkink.html","page":"mkink","title":"mkink","text":"Default value","category":"page"},{"location":"ch04/p_mkink.html","page":"mkink","title":"mkink","text":"1024","category":"page"},{"location":"ch04/p_mkink.html","page":"mkink","title":"mkink","text":"Component","category":"page"},{"location":"ch04/p_mkink.html","page":"mkink","title":"mkink","text":"ALL, except for the DAISY component.","category":"page"},{"location":"ch04/p_mkink.html","page":"mkink","title":"mkink","text":"Behavior","category":"page"},{"location":"ch04/p_mkink.html","page":"mkink","title":"mkink","text":"Determine the size of involved arrays. If the perturbation expansion order exceeds mkink, fatal error/exceptions will happen.","category":"page"},{"location":"ch04/p_mkink.html","page":"mkink","title":"mkink","text":"Comment","category":"page"},{"location":"ch04/p_mkink.html","page":"mkink","title":"mkink","text":"mkink = 1024 is a safe setting on the condition that the temperature (controlled by the beta parameter) is not too low, the interaction (controlled by the Uc, Uv, Jz, etc,  parameters) is not too weak, the number of orbitals (controlled by the nband parameter) is not too large. ","category":"page"},{"location":"ch02/atomic.html#Build-atomic-eigenvalue-problem-solver","page":"Build atomic eigenvalue problem solver","title":"Build atomic eigenvalue problem solver","text":"","category":"section"},{"location":"ch02/atomic.html","page":"Build atomic eigenvalue problem solver","title":"Build atomic eigenvalue problem solver","text":"The JASMINE component is the built-in atomic eigenvalues solver. If you want to use the BEGONIA, LAVENDER, PANSY, MANJUSHAKA, CAMELLIA components, the JASMINE component is the necessary pre-processing tool. You can employ the following commands to compile it.","category":"page"},{"location":"ch02/atomic.html","page":"Build atomic eigenvalue problem solver","title":"Build atomic eigenvalue problem solver","text":"Method 1:","category":"page"},{"location":"ch02/atomic.html","page":"Build atomic eigenvalue problem solver","title":"Build atomic eigenvalue problem solver","text":"$ cd iqist/build\n$ editor make.sys\n$ make base\n$ make capi\n$ make jasmine\n$ ./x_setup.sh","category":"page"},{"location":"ch02/atomic.html","page":"Build atomic eigenvalue problem solver","title":"Build atomic eigenvalue problem solver","text":"note: Note\nHere editor means any ascii text editor you prefer.\nIf the base library and the application programming interfaces were already compiled successfully, then you can skip the following commands:$ make base\n$ make capi","category":"page"},{"location":"ch02/atomic.html","page":"Build atomic eigenvalue problem solver","title":"Build atomic eigenvalue problem solver","text":"This is the most common and direct method. After a few minutes, you will find a jasmine.x file in the iqist/build directory. That is what you need, the executable program for the JASMINE component. After that you can add it to the system path, and do some tests.","category":"page"},{"location":"ch02/atomic.html","page":"Build atomic eigenvalue problem solver","title":"Build atomic eigenvalue problem solver","text":"Method 2:","category":"page"},{"location":"ch02/atomic.html","page":"Build atomic eigenvalue problem solver","title":"Build atomic eigenvalue problem solver","text":"In this approach, we go to the directory of the JASMINE component at first. Then 'make' it as usual.","category":"page"},{"location":"ch02/atomic.html","page":"Build atomic eigenvalue problem solver","title":"Build atomic eigenvalue problem solver","text":"$ cd iqist/src/tools/jasmine\n$ make","category":"page"},{"location":"ch02/atomic.html","page":"Build atomic eigenvalue problem solver","title":"Build atomic eigenvalue problem solver","text":"Here, we assume that the compiling system was correctly configured, the base library and the application programming interfaces were already compiled successfully.","category":"page"},{"location":"ch02/atomic.html","page":"Build atomic eigenvalue problem solver","title":"Build atomic eigenvalue problem solver","text":"note: Note\nNow the executable program will not be copied into the iqist/build directory. You have to go to the iqist/build directory, and execute$ ./x_setup.sh","category":"page"},{"location":"ch07/trailing.html#script/d_trailing.sh","page":"script/d_trailing.sh","title":"script/d_trailing.sh","text":"","category":"section"},{"location":"ch07/trailing.html","page":"script/d_trailing.sh","title":"script/d_trailing.sh","text":"Introduction","category":"page"},{"location":"ch07/trailing.html","page":"script/d_trailing.sh","title":"script/d_trailing.sh","text":"The purpose of this script is to remove the trailing white spaces in the given file.","category":"page"},{"location":"ch07/trailing.html","page":"script/d_trailing.sh","title":"script/d_trailing.sh","text":"Type","category":"page"},{"location":"ch07/trailing.html","page":"script/d_trailing.sh","title":"script/d_trailing.sh","text":"Bash shell script","category":"page"},{"location":"ch07/trailing.html","page":"script/d_trailing.sh","title":"script/d_trailing.sh","text":"Usage","category":"page"},{"location":"ch07/trailing.html","page":"script/d_trailing.sh","title":"script/d_trailing.sh","text":"You have to supply the file name to this script, like this:","category":"page"},{"location":"ch07/trailing.html","page":"script/d_trailing.sh","title":"script/d_trailing.sh","text":"$ ./d_trailing.sh file_name","category":"page"},{"location":"ch07/trailing.html","page":"script/d_trailing.sh","title":"script/d_trailing.sh","text":"Input","category":"page"},{"location":"ch07/trailing.html","page":"script/d_trailing.sh","title":"script/d_trailing.sh","text":"N/A","category":"page"},{"location":"ch07/trailing.html","page":"script/d_trailing.sh","title":"script/d_trailing.sh","text":"Output","category":"page"},{"location":"ch07/trailing.html","page":"script/d_trailing.sh","title":"script/d_trailing.sh","text":"See the terminal output.","category":"page"},{"location":"ch07/trailing.html","page":"script/d_trailing.sh","title":"script/d_trailing.sh","text":"Comment","category":"page"},{"location":"ch07/trailing.html","page":"script/d_trailing.sh","title":"script/d_trailing.sh","text":"note: Note\nThis script is used by the iQIST Developer Team internally.","category":"page"},{"location":"ch08/library.html#Library-mode","page":"-","title":"Library mode","text":"","category":"section"},{"location":"ch08/library.html","page":"-","title":"-","text":"Call iQIST from Fortran language\nCall iQIST from Python language","category":"page"},{"location":"ch09/symmetry.html#Subspace-and-symmetry","page":"Good quantum number, subspace, and symmetry","title":"Subspace and symmetry","text":"","category":"section"},{"location":"ch09/symmetry.html","page":"Good quantum number, subspace, and symmetry","title":"Good quantum number, subspace, and symmetry","text":"For a local Hamiltonian H_textloc with general interactions, the evaluation of local trace is heavily time-consuming,","category":"page"},{"location":"ch09/symmetry.html","page":"Good quantum number, subspace, and symmetry","title":"Good quantum number, subspace, and symmetry","text":"beginequation\nomega_d(mathcalC) = \ntextTr_textloc (T_2k+1F_2kT_2k cdots F_2T_2F_1T_1)\nendequation  ","category":"page"},{"location":"ch09/symmetry.html","page":"Good quantum number, subspace, and symmetry","title":"Good quantum number, subspace, and symmetry","text":"where T=e^-tau H_textloc is time evolution operator, F is a fermion creation or annihilation operator, and k is the expansion order for the current diagrammatic configuration mathcalC. The straightforward method to evaluate this trace is to insert the complete eigenstates  Gamma  of H_textloc into the RHS of the above equation, then ","category":"page"},{"location":"ch09/symmetry.html","page":"Good quantum number, subspace, and symmetry","title":"Good quantum number, subspace, and symmetry","text":"beginalign\ntextTr_textloc = sum_Gamma_1Gamma_2 cdots Gamma_2k \n            langleGamma_1T_2k+1Gamma_1rangle\n            langleGamma_1F_2kGamma_2krangle\n            langleGamma_2kT_2kGamma_2krangle cdots   \n           times langleGamma_3F_2Gamma_2rangle\n            langleGamma_2T_2Gamma_2rangle\n            langleGamma_2F_1Gamma_1rangle\n            langleGamma_1T_1Gamma_1rangle\nendalign","category":"page"},{"location":"ch09/symmetry.html","page":"Good quantum number, subspace, and symmetry","title":"Good quantum number, subspace, and symmetry","text":"Thus, we must do 4k+1 matrix-matrix multiplications with the dimension of the Hilbert space of H_textloc. This method is robust but very slow for large multi-orbital impurity model as the dimension of the matrix is impractically large for 5- and 7-band systems, and the expansion order k is large as well.","category":"page"},{"location":"ch09/symmetry.html","page":"Good quantum number, subspace, and symmetry","title":"Good quantum number, subspace, and symmetry","text":"Actually, the matrices of the fermion operators (F-matrix) are very sparse due to the symmetry of H_textloc. We can take advantage of this to speed up the matrix-matrix multiplications. We consider the symmetry of H_textloc to find some good quantum numbers (GQNs) and divide the full Hilbert space of H_textloc with very large dimension into much smaller subspaces labeled by these GQNs[1]. We call a subspace alpharangle as a superstate[2] which consists of all the n_alpha eigenstates of this subspace, alpharangle= Gamma_1 Gamma_2 cdots Gamma_n_alpha. The F-matrix element can only be nonzero between pairs of superstates with different values of GQNs. One fermion operator may bring one initial superstate alpharangle to some other final superstates betarangle,","category":"page"},{"location":"ch09/symmetry.html","page":"Good quantum number, subspace, and symmetry","title":"Good quantum number, subspace, and symmetry","text":"beginequation\nFalpharangle= betarangle\nendequation","category":"page"},{"location":"ch09/symmetry.html","page":"Good quantum number, subspace, and symmetry","title":"Good quantum number, subspace, and symmetry","text":"or outside of the full Hilbert space. We have to carefully choose some GQNs to make sure that for a fixed initial superstate alpharangle and a fixed fermion operator, there is one and only one final superstate betarangle if it doesn't go outside of the full Hilbert space. Given an arbitrary diagrammatic configuration, starting with a superstate alpha_1rangle, there will be only one possible evolution path. That is,","category":"page"},{"location":"ch09/symmetry.html","page":"Good quantum number, subspace, and symmetry","title":"Good quantum number, subspace, and symmetry","text":"beginequation\nalpha_1rangle xrightarrowF_1 \nalpha_2rangle xrightarrowF_2 \nalpha_3rangle xrightarrowF_3 \nalpha_4rangle cdots \nalpha_2k-1rangle xrightarrowF_2k-1 \nalpha_2krangle   xrightarrowF_2k \nalpha_1rangle\nendequation","category":"page"},{"location":"ch09/symmetry.html","page":"Good quantum number, subspace, and symmetry","title":"Good quantum number, subspace, and symmetry","text":"The path may break at some point because it goes outside of the full Hilbert space or violates the Pauli principle. For a successful path starting with alpha_1rangle, its contribution to the local trace is","category":"page"},{"location":"ch09/symmetry.html","page":"Good quantum number, subspace, and symmetry","title":"Good quantum number, subspace, and symmetry","text":"beginalign\ntextTr_alpha_1 = \nsum_ Gamma_alpha_1 Gamma_alpha_2 cdots Gamma_alpha_2k\nlangleGamma_alpha_1T_2k+1Gamma_alpha_1rangle\nlangleGamma_alpha_1F_2kGamma_alpha_2krangle\nlangleGamma_alpha_2kT_2kGamma_alpha_2krangle cdots  \n  times \nlangleGamma_alpha_3F_2Gamma_alpha_2rangle\nlangleGamma_alpha_2T_2Gamma_alpha_2rangle\nlangleGamma_alpha_2F_1Gamma_alpha_1rangle\nlangleGamma_alpha_1T_1Gamma_alpha_1rangle\nendalign","category":"page"},{"location":"ch09/symmetry.html","page":"Good quantum number, subspace, and symmetry","title":"Good quantum number, subspace, and symmetry","text":"where  Gamma_alpha_i  are the eigenstates of subspace alpha_i. Thus, the final local trace should be","category":"page"},{"location":"ch09/symmetry.html","page":"Good quantum number, subspace, and symmetry","title":"Good quantum number, subspace, and symmetry","text":"beginequation\ntextTr_textloc = sum_i textTr_alpha_i\nendequation","category":"page"},{"location":"ch09/symmetry.html","page":"Good quantum number, subspace, and symmetry","title":"Good quantum number, subspace, and symmetry","text":"As a result, the original 4k+1 matrix-matrix multiplications with large dimension reduces to several 4k+1 matrix-matrix multiplications with much smaller dimensions, resulting in a huge speedup.","category":"page"},{"location":"ch09/symmetry.html","page":"Good quantum number, subspace, and symmetry","title":"Good quantum number, subspace, and symmetry","text":"GQNs Kanamori-U Slater-U SOC\nN, S_z Yes Yes No\nN, S_z, PS Yes No No\nN, J_z Yes Yes Yes\nN Yes Yes Yes","category":"page"},{"location":"ch09/symmetry.html","page":"Good quantum number, subspace, and symmetry","title":"Good quantum number, subspace, and symmetry","text":"Table | The GQNs supports for various types of local Hamiltonians H_textloc.","category":"page"},{"location":"ch09/symmetry.html","page":"Good quantum number, subspace, and symmetry","title":"Good quantum number, subspace, and symmetry","text":"In our codes, we implemented several GQNs schemes for different types of local Hamiltonians H_textloc, which is summarized in the above table. For H_textloc without spin-orbit coupling (SOC), we have two choices: (1) with Slater parameterized Coulomb interaction matrix, we use the total occupation number N, the z component of total spin S_z as GQNs; (2) with Kanamori parameterized Coulomb interaction matrix, besides N and S_z, we can use another powerful GQN, the so-called PS number[3]. It is defined as,","category":"page"},{"location":"ch09/symmetry.html","page":"Good quantum number, subspace, and symmetry","title":"Good quantum number, subspace, and symmetry","text":"beginequation\ntextPS = sum_alpha=1^N_textorb \n             (n_alphauparrow-n_alphadownarrow)^2 times 2^alpha\nendequation","category":"page"},{"location":"ch09/symmetry.html","page":"Good quantum number, subspace, and symmetry","title":"Good quantum number, subspace, and symmetry","text":"where alpha is the orbital index, uparrow downarrow is spin index, n_alphauparrow and n_alphadownarrow are the orbital occupancy numbers. The PS number labels the occupation number basis with the same singly occupied orbitals. With its help, the dimensions of the subspaces become very small, such that we can treat 5-band Kanamori systems efficiently without any approximations. For H_textloc with SOC, we can use the total occupancy number N and the z component of total angular momentum J_z as GQNs. We summarize the total number of subspaces, maximum and mean dimension of subspaces for different GQNs schemes and multi-orbital impurity models in the below table. Obviously, using these GQNs can largely reduce the dimension of the F-matrix, and make accurate DMFT calculations for complex electronic systems (such as d- and f-electron materials) possible. ","category":"page"},{"location":"ch09/symmetry.html","page":"Good quantum number, subspace, and symmetry","title":"Good quantum number, subspace, and symmetry","text":" 2-band 3-band 5-band 7-band\nGQNs N/max/mean N/max/mean N/max/mean N/max/mean\nN, S_z 9/4/1.78 16/9/4.00 36/100/28.44 64/1225/256.00\nN, S_z, PS 14/2/1.14 44/3/1.45 352/10/2.91 2368/35/6.92\nN, J_z - 26/5/2.46 96/37/10.67 246/327/66.60\nN 5/6/3.20 7/20/9.14 11/252/93.09 15/3432/1092.27","category":"page"},{"location":"ch09/symmetry.html","page":"Good quantum number, subspace, and symmetry","title":"Good quantum number, subspace, and symmetry","text":"Table | The total number of subspaces N, maximum and mean dimension of subspaces for different GQNs schemes and multi-orbital models.","category":"page"},{"location":"ch09/symmetry.html","page":"Good quantum number, subspace, and symmetry","title":"Good quantum number, subspace, and symmetry","text":"Reference","category":"page"},{"location":"ch09/symmetry.html","page":"Good quantum number, subspace, and symmetry","title":"Good quantum number, subspace, and symmetry","text":"[1]: Emanuel Gull, Andrew J. Millis, Alexander I. Lichtenstein, Alexey N. Rubtsov, Matthias Troyer, and Philipp Werner, Rev. Mod. Phys. 83, 349 (2011)","category":"page"},{"location":"ch09/symmetry.html","page":"Good quantum number, subspace, and symmetry","title":"Good quantum number, subspace, and symmetry","text":"[2]: Kristjan Haule, Phys. Rev. B 75, 155113 (2007)","category":"page"},{"location":"ch09/symmetry.html","page":"Good quantum number, subspace, and symmetry","title":"Good quantum number, subspace, and symmetry","text":"[3]: Nicolaus Parragh, Alessandro Toschi, Karsten Held, and Giorgio Sangiovanni, Phys. Rev. B 86, 155158","category":"page"},{"location":"ch02/base.html#Build-base-library","page":"Build base library","title":"Build base library","text":"","category":"section"},{"location":"ch02/base.html","page":"Build base library","title":"Build base library","text":"In essence, the base library includes CSSL and CSML which form the underlying architecture of the iQIST software package. Actually, there are two ways to compile the base library in the compiling system.","category":"page"},{"location":"ch02/base.html","page":"Build base library","title":"Build base library","text":"Once the compiling is finished, you will find the libMM.a file in the iqist/src/base directory.","category":"page"},{"location":"ch02/base.html","page":"Build base library","title":"Build base library","text":"Method 1:","category":"page"},{"location":"ch02/base.html","page":"Build base library","title":"Build base library","text":"$ cd iqist/build\n$ editor make.sys\n$ make base","category":"page"},{"location":"ch02/base.html","page":"Build base library","title":"Build base library","text":"tip: Tip\nHere editor means any ascii text editor you prefer, such as vim.","category":"page"},{"location":"ch02/base.html","page":"Build base library","title":"Build base library","text":"This is the most common and direct method.","category":"page"},{"location":"ch02/base.html","page":"Build base library","title":"Build base library","text":"Method 2:","category":"page"},{"location":"ch02/base.html","page":"Build base library","title":"Build base library","text":"You can also go to the directory where the base library exists, and type 'make' command in the terminal.","category":"page"},{"location":"ch02/base.html","page":"Build base library","title":"Build base library","text":"$ cd iqist/src/base\n$ make","category":"page"},{"location":"ch02/base.html","page":"Build base library","title":"Build base library","text":"The shortcoming of this method is that it is not straightforward to edit the make.sys file once unexpected compiling errors take place.","category":"page"},{"location":"ch07/sig.html#toolbox/makesig","page":"toolbox/makesig","title":"toolbox/makesig","text":"","category":"section"},{"location":"ch07/sig.html","page":"toolbox/makesig","title":"toolbox/makesig","text":"Introduction","category":"page"},{"location":"ch07/sig.html","page":"toolbox/makesig","title":"toolbox/makesig","text":"To calculate real physical quantities, such as the optical conductivity, Seebeck coefficient, thermopower, etc., the self-energy function on the real axis is an essential input. With the Pade approximation[1], we can convert the self-energy function from the Matsubara frequency to real frequency axis. We implemented the Pade approximation for Sigma(iomega_n) in the HIBISCUS component.","category":"page"},{"location":"ch07/sig.html","page":"toolbox/makesig","title":"toolbox/makesig","text":"The makesig code is often used to transform self-energy functions from Matsubara frequency representation to real frequency representation via the Pade approximation. The results are very sensitive to the data noises in the self-energy function. So we do not recommend to use this code to perform analytical continuation for the self-energy function. However, the HIBISCUS/swing code may be a better choice.","category":"page"},{"location":"ch07/sig.html","page":"toolbox/makesig","title":"toolbox/makesig","text":"[1]: H. Vidberg and J. Serene, J. Low Temp. Phys. 29, 179 (1977).","category":"page"},{"location":"ch07/sig.html","page":"toolbox/makesig","title":"toolbox/makesig","text":"Usage","category":"page"},{"location":"ch07/sig.html","page":"toolbox/makesig","title":"toolbox/makesig","text":"$ ./msig","category":"page"},{"location":"ch07/sig.html","page":"toolbox/makesig","title":"toolbox/makesig","text":"Input","category":"page"},{"location":"ch07/sig.html","page":"toolbox/makesig","title":"toolbox/makesig","text":"See the terminal prompt\nsolver.sgm.dat (necessary)","category":"page"},{"location":"ch07/sig.html","page":"toolbox/makesig","title":"toolbox/makesig","text":"Output","category":"page"},{"location":"ch07/sig.html","page":"toolbox/makesig","title":"toolbox/makesig","text":"sig.sgm.dat","category":"page"},{"location":"ch07/sig.html","page":"toolbox/makesig","title":"toolbox/makesig","text":"Comment","category":"page"},{"location":"ch07/sig.html","page":"toolbox/makesig","title":"toolbox/makesig","text":"N/A","category":"page"},{"location":"ch04/p_lc.html#Parameter:-lc","page":"lc","title":"Parameter: lc","text":"","category":"section"},{"location":"ch04/p_lc.html","page":"lc","title":"lc","text":"Definition","category":"page"},{"location":"ch04/p_lc.html","page":"lc","title":"lc","text":"It is a model parameter for the Hubbard-Holstein model or dynamical screening effect. The exact definition of lc depends on the value of isscr parameter.","category":"page"},{"location":"ch04/p_lc.html","page":"lc","title":"lc","text":"Type","category":"page"},{"location":"ch04/p_lc.html","page":"lc","title":"lc","text":"Float, double precision","category":"page"},{"location":"ch04/p_lc.html","page":"lc","title":"lc","text":"Default value","category":"page"},{"location":"ch04/p_lc.html","page":"lc","title":"lc","text":"1.0","category":"page"},{"location":"ch04/p_lc.html","page":"lc","title":"lc","text":"Component","category":"page"},{"location":"ch04/p_lc.html","page":"lc","title":"lc","text":"Only for the NARCISSUS component.","category":"page"},{"location":"ch04/p_lc.html","page":"lc","title":"lc","text":"Behavior","category":"page"},{"location":"ch04/p_lc.html","page":"lc","title":"lc","text":"There are five possible choices for the lc parameter so far:","category":"page"},{"location":"ch04/p_lc.html","page":"lc","title":"lc","text":"isscr = 1, no meaning.\nisscr = 2, the lambda parameter in the Hubbard-Holstein model.\nisscr = 3, the lambda parameter in the plasmon-pole model for dynamical screening effect.\nisscr = 4, the alpha parameter in the ohmic model for dynamical screening effect.\nisscr = 99, shift for the chemical potential and Coulomb interaction (when we consider the dynamical screening effect in the DFT + DMFT calculations for realistic materials). You can obtain this value from the output of HIBISCUS/toolbox/makescr. See also toolbox/makescr for more details.","category":"page"},{"location":"ch04/p_lc.html","page":"lc","title":"lc","text":"Comment","category":"page"},{"location":"ch04/p_lc.html","page":"lc","title":"lc","text":"Only when isscr > 1, it matters. Please see isscr parameter for more details. About CT-QMC algorithms for the Hubbard-Holstein model and dynamical screening effect (including plasmon-pole model and ohmic model), please refer to Philipp Werner's papers[1][2].","category":"page"},{"location":"ch04/p_lc.html","page":"lc","title":"lc","text":"Reference","category":"page"},{"location":"ch04/p_lc.html","page":"lc","title":"lc","text":"[1]: Philipp Werner and Andrew J. Millis, Phys. Rev. Lett 99, 146404 (2007).","category":"page"},{"location":"ch04/p_lc.html","page":"lc","title":"lc","text":"[2]: Philipp Werner and Andrew J. Millis, Phys. Rev. Lett. 104, 146401 (2010).","category":"page"},{"location":"ch02/apps.html#Build-applications","page":"Build applications","title":"Build applications","text":"","category":"section"},{"location":"ch02/apps.html","page":"Build applications","title":"Build applications","text":"note: Note\nSorry, this feature is not ready. In the future, we will provide the DFT + DMFT and ladder dual fermions codes in the iQIST software package. Be patient!","category":"page"},{"location":"ch03/README.html#Getting-started","page":"README","title":"Getting started","text":"","category":"section"},{"location":"ch03/README.html","page":"README","title":"README","text":"Well, I guesss that you have compiled and installed the iQIST software package on your system successfully. And you cannot help trying it now. But wait, there is still a lot of stuffs you have to keep in mind before you submit the iQIST-related jobs in your queue system.","category":"page"},{"location":"ch03/README.html","page":"README","title":"README","text":"Configure your system // Environment variables.\niQIST recipes // The basic workflow for cooking with iQIST.\nPrepare input files // Are you ready?\nExecute the codes // MPI vs. OpenMP, paralleled or serial.\nMonitor the codes // What's the status of the code?\nProfile the codes // Is it possible to accelerate the code further?","category":"page"},{"location":"ch03/README.html","page":"README","title":"README","text":"OK, if you are already familiar with the basic usage of the iQIST software package, then you can read the following advanced topics.","category":"page"},{"location":"ch03/README.html","page":"README","title":"README","text":"Quantum Monte Carlo impurity solvers // A comprehensive reference about the impurity solvers.\nApplications // The applications, plugins that are built on top of it.\nAtomic eigenvalue problem solver // A comprehensive reference about the atomic eigenvalue solver.\nAuxiliary tools // Full descriptions about the auxiliary toolbox.\nApplication programming interfaces // How to use iQIST via external Python/Fortran programs.\nInside iQIST // The principles, tricks, formulations, algorithms that implemented in iQIST.","category":"page"},{"location":"ch08/self.html#One-shot-and-self-consistent-calculations","page":"One-shot and self-consistent calculations","title":"One-shot and self-consistent calculations","text":"","category":"section"},{"location":"ch09/soc.html#Spin-orbit-coupling","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"","category":"section"},{"location":"ch09/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"The spin-orbit coupling (SOC) is implemented at atomic level, ","category":"page"},{"location":"ch09/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"beginequation\nhatH_textSOC=lambdasum_ivecmathbfl_icdotvecmathbfs_i\nendequation","category":"page"},{"location":"ch09/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"where, vecmathbfl is orbital angular momentum, and vecmathbfs is spin angular momentum. In second quantization form,","category":"page"},{"location":"ch09/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"beginequation\nhatH_textSOC=lambdasum_alphasigmabetasigma^primeleftlanglealphasigmaleftvecmathbflcdotvecmathbfsrightbetasigma^primerightranglehatf_alphasigma^daggerhatf_betasigma^prime\nendequation","category":"page"},{"location":"ch09/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"where, alpha is orbital index and sigma is spin index, and ","category":"page"},{"location":"ch09/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"beginequation\nvecmathbflcdotvecmathbfs =  frac12vecmathbflcdotvecmathbfmathbfsigma\nendequation","category":"page"},{"location":"ch09/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"where, vecmathbfsigma is Pauli operator.","category":"page"},{"location":"ch09/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"Now the question is how to write down the matrix elements for vecmathbflcdotvecmathbfsigma","category":"page"},{"location":"ch09/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"beginalign*\nvecmathbflcdotvecmathbfsigma  =  hatl_xhatsigma_x+hatl_yhatsigma_y+hatl_zhatsigma_z\n  =  leftbeginarraycc\n0  hatl_x\nhatl_x  0\nendarrayright+leftbeginarraycc\n0  -ihatl_y\nihatl_y  0\nendarrayright+leftbeginarraycc\nhatl_z  0\n0  -hatl_z\nendarrayright\n  =  leftbeginarraycc\nhatl_z  hatl_x-ihatl_y\nhatl_x+ihatl_y  -hatl_z\nendarrayright\n  =  leftbeginarraycc\nhatl_z  hatl_-\nhatl_+  -hatl_z\nendarrayright\nendalign*","category":"page"},{"location":"ch09/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"where, hatl_pm=hatl_xpmhatl_y, and","category":"page"},{"location":"ch09/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"beginequation\nhatl_pmY_l^m=sqrt(lmp m)(lpm m+1)Y_l^mpm1\nendequation","category":"page"},{"location":"ch09/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"We just write down vecmathbflcdotvecmathbfsigma in the complex shperical harmonics basis, the orbital order is:","category":"page"},{"location":"ch09/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"beginequation\nY_l^-luparrowY_l^-ldownarrowY_l^-l+1uparrowY_l^-l+1downarrowcdotsY_l^luparrowY_l^ldownarrow\nendequation","category":"page"},{"location":"ch09/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"For p system,","category":"page"},{"location":"ch09/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"beginequation\nvecmathbflcdotvecmathbfsigma=leftbeginarraycccccc\n-1  0  0  sqrt2  0  0\n0  1  0  0  0  0\n0  0  0  0  0  sqrt2\nsqrt2  0  0  0  0  0\n0  0  0  0  1  0\n0  0  sqrt2  0  0  -1\nendarrayright\nendequation","category":"page"},{"location":"ch09/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"For t_2g system, ","category":"page"},{"location":"ch09/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"beginequation\nvecmathbflcdotvecmathbfsigma=-leftbeginarraycccccc\n-1  0  0  sqrt2  0  0\n0  1  0  0  0  0\n0  0  0  0  0  sqrt2\nsqrt2  0  0  0  0  0\n0  0  0  0  1  0\n0  0  sqrt2  0  0  -1\nendarrayright\nendequation","category":"page"},{"location":"ch09/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"For d system,","category":"page"},{"location":"ch09/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"beginequation\nvecmathbflcdotvecmathbfsigma=leftbeginarraycccccccccc\n-2  0  0  2  0  0  0  0  0  0\n0  2  0  0  0  0  0  0  0  0\n0  0  -1  0  0  sqrt6  0  0  0  0\n2  0  0  1  0  0  0  0  0  0\n0  0  0  0  0  0  0  sqrt6  0  0\n0  0  sqrt6  0  0  0  0  0  0  0\n0  0  0  0  0  0  1  0  0  2\n0  0  0  0  sqrt6  0  0  -1  0  0\n0  0  0  0  0  0  0  0  2  0\n0  0  0  0  0  0  2  0  0  -2\nendarrayright\nendequation","category":"page"},{"location":"ch09/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"For f system,","category":"page"},{"location":"ch09/soc.html","page":"Spin-orbit coupling","title":"Spin-orbit coupling","text":"beginequation\nvecmathbflcdotvecmathbfsigma=leftbeginarraycccccccccccccc\n-3  0  0  sqrt6  0  0  0  0  0  0  0  0  0  0\n0  3  0  0  0  0  0  0  0  0  0  0  0  0\n0  0  -2  0  0  sqrt10  0  0  0  0  0  0  0  0\nsqrt6  0  0  2  0  0  0  0  0  0  0  0  0  0\n0  0  0  0  -1  0  0  sqrt12  0  0  0  0  0  0\n0  0  sqrt10  0  0  1  0  0  0  0  0  0  0  0\n0  0  0  0  0  0  0  0  0  sqrt12  0  0  0  0\n0  0  0  0  sqrt12  0  0  0  0  0  0  0  0  0\n0  0  0  0  0  0  0  0  1  0  0  sqrt10  0  0\n0  0  0  0  0  0  sqrt12  0  0  -1  0  0  0  0\n0  0  0  0  0  0  0  0  0  0  2  0  0  sqrt6\n0  0  0  0  0  0  0  0  sqrt10  0  0  -2  0  0\n0  0  0  0  0  0  0  0  0  0  0  0  3  0\n0  0  0  0  0  0  0  0  0  0  sqrt6  0  0  -3\nendarrayright\nendequation","category":"page"},{"location":"ch04/p_nwrite.html#Parameter:-nwrite","page":"nwrite","title":"Parameter: nwrite","text":"","category":"section"},{"location":"ch04/p_nwrite.html","page":"nwrite","title":"nwrite","text":"Definition","category":"page"},{"location":"ch04/p_nwrite.html","page":"nwrite","title":"nwrite","text":"Output period for the quantum impurity solvers.","category":"page"},{"location":"ch04/p_nwrite.html","page":"nwrite","title":"nwrite","text":"Type","category":"page"},{"location":"ch04/p_nwrite.html","page":"nwrite","title":"nwrite","text":"Integer","category":"page"},{"location":"ch04/p_nwrite.html","page":"nwrite","title":"nwrite","text":"Default value","category":"page"},{"location":"ch04/p_nwrite.html","page":"nwrite","title":"nwrite","text":"2000000","category":"page"},{"location":"ch04/p_nwrite.html","page":"nwrite","title":"nwrite","text":"Component","category":"page"},{"location":"ch04/p_nwrite.html","page":"nwrite","title":"nwrite","text":"ALL, except for the DAISY component.","category":"page"},{"location":"ch04/p_nwrite.html","page":"nwrite","title":"nwrite","text":"Behavior","category":"page"},{"location":"ch04/p_nwrite.html","page":"nwrite","title":"nwrite","text":"This parameter controls the output frequency of the quantum impurity solvers. The quantum impurity solvers will output the intermediate results to disk files and run-time information to the terminal for every nwrite Monte Carlo sampling step. As for the continuous-time quantum Monte Carlo impurity solvers, the so-called intermediate results mean the imaginary-time Green's function G(tau) and histogram for the perturbation expansion series.","category":"page"},{"location":"ch04/p_nwrite.html","page":"nwrite","title":"nwrite","text":"Especially, as","category":"page"},{"location":"ch04/p_nwrite.html","page":"nwrite","title":"nwrite","text":"fractextnsweeptextnwrite geq 100","category":"page"},{"location":"ch04/p_nwrite.html","page":"nwrite","title":"nwrite","text":"the CT-HYB quantum impurity solvers will save the current diagram configurations to the solver.diag.dat file every nwrite Monte Carlo sampling step. Then, you can use the u_animator.py to make an animation movie.","category":"page"},{"location":"ch04/p_nwrite.html","page":"nwrite","title":"nwrite","text":"Comment","category":"page"},{"location":"ch04/p_nwrite.html","page":"nwrite","title":"nwrite","text":"When the data binning mode is activated (isbin = 2), then the nwrite and nsweep parameters rise tenfold. ","category":"page"},{"location":"ch04/p_nwrite.html","page":"nwrite","title":"nwrite","text":"See also isbin and nsweep parameters, solver.diag.dat file, script/u_animator.py tool for more details.","category":"page"},{"location":"ch04/p_npart.html#Parameter:-npart","page":"npart","title":"Parameter: npart","text":"","category":"section"},{"location":"ch04/p_npart.html","page":"npart","title":"npart","text":"Definition","category":"page"},{"location":"ch04/p_npart.html","page":"npart","title":"npart","text":"Number of parts that the imaginary time axis is split.","category":"page"},{"location":"ch04/p_npart.html","page":"npart","title":"npart","text":"Type","category":"page"},{"location":"ch04/p_npart.html","page":"npart","title":"npart","text":"Integer","category":"page"},{"location":"ch04/p_npart.html","page":"npart","title":"npart","text":"Default value","category":"page"},{"location":"ch04/p_npart.html","page":"npart","title":"npart","text":"4","category":"page"},{"location":"ch04/p_npart.html","page":"npart","title":"npart","text":"Component","category":"page"},{"location":"ch04/p_npart.html","page":"npart","title":"npart","text":"Only for the BEGONIA, LAVENDER, MANJUSHAKA, and PANSY components.","category":"page"},{"location":"ch04/p_npart.html","page":"npart","title":"npart","text":"Behavior","category":"page"},{"location":"ch04/p_npart.html","page":"npart","title":"npart","text":"All operators in the imaginary time axis are grouped into npart parts according to their time values, in each Monte Carlo steps, only those changed parts are carefully dealt with, not all the parts. This trick can accelerate the codes significantly.","category":"page"},{"location":"ch04/p_npart.html","page":"npart","title":"npart","text":"Comment","category":"page"},{"location":"ch04/p_npart.html","page":"npart","title":"npart","text":"2sqrt3 langle k rangle textnband sim 4sqrt3 langle k rangle textnband may be the optimal value for npart to achieve maximum performance where langle k rangle is the averaged perturbation expansion order. See nband for more details.","category":"page"},{"location":"ch06/in_cmat.html#atom.cmat.in","page":"atom.cmat.in","title":"atom.cmat.in","text":"","category":"section"},{"location":"ch06/in_cmat.html","page":"atom.cmat.in","title":"atom.cmat.in","text":"Introduction","category":"page"},{"location":"ch06/in_cmat.html","page":"atom.cmat.in","title":"atom.cmat.in","text":"The purpose of the atom.cmat.in file is to define the crystal field splitting of the atomic Hamiltonian. The JASMINE component supports both diagonal and non-diagonal crystal field matrix. Only when ibasis = 1, the atom.cmat.in file is read. See ibasis parameter for more details.","category":"page"},{"location":"ch06/in_cmat.html","page":"atom.cmat.in","title":"atom.cmat.in","text":"Format","category":"page"},{"location":"ch06/in_cmat.html","page":"atom.cmat.in","title":"atom.cmat.in","text":"The format of the atom.cmat.in file is as follows:","category":"page"},{"location":"ch06/in_cmat.html","page":"atom.cmat.in","title":"atom.cmat.in","text":"","category":"page"},{"location":"ch06/in_cmat.html","page":"atom.cmat.in","title":"atom.cmat.in","text":"column 1: orbital index alpha, integer","category":"page"},{"location":"ch06/in_cmat.html","page":"atom.cmat.in","title":"atom.cmat.in","text":"column 2: orbital index beta, integer","category":"page"},{"location":"ch06/in_cmat.html","page":"atom.cmat.in","title":"atom.cmat.in","text":"column 3: Crystal field splitting matrix element Delta_alphabeta, double precision","category":"page"},{"location":"ch06/in_cmat.html","page":"atom.cmat.in","title":"atom.cmat.in","text":"","category":"page"},{"location":"ch06/in_cmat.html","page":"atom.cmat.in","title":"atom.cmat.in","text":"note: Note\nIn the atom.cmat.in file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch06/in_cmat.html","page":"atom.cmat.in","title":"atom.cmat.in","text":"Code","category":"page"},{"location":"ch06/in_cmat.html","page":"atom.cmat.in","title":"atom.cmat.in","text":"The corresponding Fortran code block for the reading of the atom.cmat.in file is as follows:","category":"page"},{"location":"ch06/in_cmat.html","page":"atom.cmat.in","title":"atom.cmat.in","text":"! open file atom.cmat.in\n     open(mytmp, file='atom.cmat.in', form='formatted', status='unknown')\n\n! read the data until EOF\n     do\n         read(mytmp,*,iostat = ierr) i1, i2, raux\n         if ( ierr == iostat_end ) EXIT\n! crystal field is actually real\n         call s_assert( i1 <= norbs .and. i2 <= norbs )\n         cmat(i1,i2) = dcmplx(raux, zero)\n     enddo ! over do while loop\n\n! close data file\n     close(mytmp)","category":"page"},{"location":"ch06/out_sector.html#atom.sector.dat","page":"atom.sector.dat","title":"atom.sector.dat","text":"","category":"section"},{"location":"ch06/out_sector.html","page":"atom.sector.dat","title":"atom.sector.dat","text":"Introduction","category":"page"},{"location":"ch06/out_sector.html","page":"atom.sector.dat","title":"atom.sector.dat","text":"The atom.sector.dat file contains the configuration information for the subspaces of the local Hamiltonian. Only when ictqmc = 2, 3, 4, and 5, this file is generated. See ictqmc parameter for more details.","category":"page"},{"location":"ch06/out_sector.html","page":"atom.sector.dat","title":"atom.sector.dat","text":"Format","category":"page"},{"location":"ch06/out_sector.html","page":"atom.sector.dat","title":"atom.sector.dat","text":"The file format of the atom.sector.dat file is a bit complex. It is unnecessary to understand its full details. If you are a maintainer or developer of the JASMINE component, please read the source codes in iqist/src/tools/jasmine/atomic_dump.f90.","category":"page"},{"location":"ch06/out_sector.html","page":"atom.sector.dat","title":"atom.sector.dat","text":"Code","category":"page"},{"location":"ch06/out_sector.html","page":"atom.sector.dat","title":"atom.sector.dat","text":"N/A","category":"page"},{"location":"ch09/basis.html#Definition-of-single-particle-basis","page":"Single particle basis","title":"Definition of single particle basis","text":"","category":"section"},{"location":"ch09/basis.html","page":"Single particle basis","title":"Single particle basis","text":"In this section, we define some single particle basis used in the JASMINE component to write down the atomic Hamiltonian hatH_textatom. We set hbar=1 in this note.","category":"page"},{"location":"ch09/basis.html","page":"Single particle basis","title":"Single particle basis","text":"Complex spherical harmonics basis","category":"page"},{"location":"ch09/basis.html","page":"Single particle basis","title":"Single particle basis","text":"The complex spherical harmonics Y_l^m(thetaphi) is the eigenstate of l^2l_z,","category":"page"},{"location":"ch09/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nl^2Y_l^m=l(l+1)Y_l^m\nendequation","category":"page"},{"location":"ch09/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nl_zY_l^m=mY_l^m m=-l-l+1cdotsl\nendequation","category":"page"},{"location":"ch09/basis.html","page":"Single particle basis","title":"Single particle basis","text":"Real spherical harmonics basis","category":"page"},{"location":"ch09/basis.html","page":"Single particle basis","title":"Single particle basis","text":"The real spherical harmonics Y_lm is defined as","category":"page"},{"location":"ch09/basis.html","page":"Single particle basis","title":"Single particle basis","text":"begingather\nY_lm=begincases\nfracisqrt2left(Y_l^-m-(-1)^mY_l^mright)  textif m0\nY_l^0  textif m=0\nfrac1sqrt2left(Y_l^-m+(-1)^mY_l^mright)  textif m0\nendcases\nendgather","category":"page"},{"location":"ch09/basis.html","page":"Single particle basis","title":"Single particle basis","text":"For p system,","category":"page"},{"location":"ch09/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginalign\np_x  =  Y_11=frac1sqrt2left(Y_1^-1-Y_1^1right) \np_y  =  Y_1-1=fracisqrt2left(Y_1^-1+Y_1^1right)\np_z  =  Y_10=Y_1^0\nendalign","category":"page"},{"location":"ch09/basis.html","page":"Single particle basis","title":"Single particle basis","text":"For d system,","category":"page"},{"location":"ch09/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginalign\nd_z^2  =  Y_20=Y_2^0 \nd_zx  =  Y_21=frac1sqrt2left(Y_2^-1-Y_2^1right) \nd_zy  =  Y_2-1=fracisqrt2left(Y_2^-1+Y_2^1right)\nd_x^2-y^2  =  Y_22=frac1sqrt2left(Y_2^-2+Y_2^2right) \nd_xy  =  Y_2-2=fracisqrt2left(Y_2^-2-Y_2^2right)\nendalign","category":"page"},{"location":"ch09/basis.html","page":"Single particle basis","title":"Single particle basis","text":"For t_2g system (lapprox-1), we have a T-P equivalence, ","category":"page"},{"location":"ch09/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginalign\nd_zx  rightarrow  p_y=fracisqrt2left(Y_1^-1+Y_1^1right) \nd_zy  rightarrow  p_x=frac1sqrt2left(Y_1^-1-Y_1^1right)\nd_xy  rightarrow  p_z=Y_1^0\nendalign","category":"page"},{"location":"ch09/basis.html","page":"Single particle basis","title":"Single particle basis","text":"For f system, ","category":"page"},{"location":"ch09/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginalign\nf_z^3  =  Y_30=Y_3^0 \nf_xz^2  =  Y_31=frac1sqrt2left(Y_3^-1-Y_3^1right)\nf_yz^2  =  Y_3-1=fracisqrt2left(Y_3^-1+Y_3^1right) \nf_z(x^2-y^2)  =  Y_32=frac1sqrt2left(Y_3^-2+Y_3^2right)\nf_xyz  =  Y_3-2=fracisqrt2left(Y_3^-2-Y_3^2right)\nf_x(x^2-3y^2)  =  Y_33=frac1sqrt2left(Y_3^-3-Y_3^3right)\nf_y(3x^2-y^2)  =  Y_3-3=fracisqrt2left(Y_3^-3+Y_3^3right)\nendalign","category":"page"},{"location":"ch09/basis.html","page":"Single particle basis","title":"Single particle basis","text":"Cubic spherical harmonics basis","category":"page"},{"location":"ch09/basis.html","page":"Single particle basis","title":"Single particle basis","text":"The cubic spherical harmonics is defined as the basis of the irreducible representation of cubic point group O_h.","category":"page"},{"location":"ch09/basis.html","page":"Single particle basis","title":"Single particle basis","text":"For p orbitals,","category":"page"},{"location":"ch09/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nT_1up_xp_yp_z\nendequation","category":"page"},{"location":"ch09/basis.html","page":"Single particle basis","title":"Single particle basis","text":"For d orbitals,","category":"page"},{"location":"ch09/basis.html","page":"Single particle basis","title":"Single particle basis","text":"begingather\nbegincases\nE_g  d_z^2d_x^2-y^2\nT_2g  d_zxd_zyd_xy\nendcases\nendgather","category":"page"},{"location":"ch09/basis.html","page":"Single particle basis","title":"Single particle basis","text":"For f orbitals,","category":"page"},{"location":"ch09/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginalign\nf_x^3  =  -fracsqrt64f_xz^2+fracsqrt104f_x(x^2-3y^2)\nf_y^3  =  -fracsqrt64f_yz^2-fracsqrt104f_y(3x^2-y^2) \nf_z^3  =  f_z^3 \nf_x(y^2-z^2)  =  -fracsqrt104f_xz^2-fracsqrt64f_x(x^2-3y^2) \nf_y(z^2-x^2)  =  fracsqrt104f_yz^2-fracsqrt64f_y(3x^2-y^2) \nf_z(x^2-y^2)  =  f_z(x^2-y^2)\nf_xyz  =  f_xyz\nendalign","category":"page"},{"location":"ch09/basis.html","page":"Single particle basis","title":"Single particle basis","text":"note: Note\nbegingather\nbegincases\nT_1u  f_x^3f_y^3f_z^3\nT_2u  f_x(y^2-z^2)f_y(z^2-x^2)f_z(x^2-y^2)\nA_2u  f_xyz\nendcases\nendgather","category":"page"},{"location":"ch09/basis.html","page":"Single particle basis","title":"Single particle basis","text":"j^2j_z diagonal basis","category":"page"},{"location":"ch09/basis.html","page":"Single particle basis","title":"Single particle basis","text":"Define phi_ljm_j as the eigenstate of j^2j_z,","category":"page"},{"location":"ch09/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nj^2phi_ljm_j=j(j+1)phi_ljm_j\nendequation","category":"page"},{"location":"ch09/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nj_zphi_ljm_j=m_jphi_ljm_j\nendequation","category":"page"},{"location":"ch09/basis.html","page":"Single particle basis","title":"Single particle basis","text":"For j=l+frac12m_j=m+frac12,","category":"page"},{"location":"ch09/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nphi_ljm_j=sqrtfracl+m+12l+1Y_l^muparrow+sqrtfracl-m2l+1Y_l^m+1downarrow\nendequation","category":"page"},{"location":"ch09/basis.html","page":"Single particle basis","title":"Single particle basis","text":"For j=l-frac12m_j=m+frac12,","category":"page"},{"location":"ch09/basis.html","page":"Single particle basis","title":"Single particle basis","text":"beginequation\nphi_ljm_j=-sqrtfracl-m2l+1Y_l^muparrow+sqrtfracl+m+12l+1Y_l^m+1downarrow\nendequation","category":"page"},{"location":"ch09/basis.html","page":"Single particle basis","title":"Single particle basis","text":"Natural basis","category":"page"},{"location":"ch09/basis.html","page":"Single particle basis","title":"Single particle basis","text":"The natural basis is defined as the diagonal basis of on-site term E_alphabeta.","category":"page"},{"location":"thanks.html#Dedication","page":"Dedication","title":"Dedication","text":"","category":"section"},{"location":"thanks.html","page":"Dedication","title":"Dedication","text":"To Xin and Yun-Zheng","category":"page"},{"location":"thanks.html","page":"Dedication","title":"Dedication","text":"by Li","category":"page"},{"location":"thanks.html","page":"Dedication","title":"Dedication","text":"(Image: alps image)","category":"page"},{"location":"thanks.html","page":"Dedication","title":"Dedication","text":"Figure | Xin and the Matterhorn. Photo by Li.","category":"page"},{"location":"thanks.html","page":"Dedication","title":"Dedication","text":"To my family","category":"page"},{"location":"thanks.html","page":"Dedication","title":"Dedication","text":"by Haiyan","category":"page"},{"location":"thanks.html","page":"Dedication","title":"Dedication","text":"(Image: lily image)","category":"page"},{"location":"thanks.html","page":"Dedication","title":"Dedication","text":"Figure | Lily. Photo by Haiyan","category":"page"},{"location":"ch08/accurate.html#Advanced-applications-II:-Accurate-measurement-of-physical-observable","page":"README","title":"Advanced applications II: Accurate measurement of physical observable","text":"","category":"section"},{"location":"ch08/accurate.html","page":"README","title":"README","text":"In this section, we will illustrate how to measure some representative physical observable. We will stress the implemented tricks to improve the accuracy and efficiency of Monte Carlo measurement.","category":"page"},{"location":"ch08/accurate.html","page":"README","title":"README","text":"One-shot and self-consistent calculations\nData binning mode\nImaginary-time Green's function\nMatsubara Green's function and self-energy function\nSpin-spin correlation function and orbital-orbital correlation function\nTwo-particle Green's function and vertex function","category":"page"},{"location":"ch09/hyb.html#Hybridization-expansion","page":"Hybridization expansion","title":"Hybridization expansion","text":"","category":"section"},{"location":"ch09/hyb.html","page":"Hybridization expansion","title":"Hybridization expansion","text":"In the hybridization expansion algorithm (CT-HYB), due to the fact that H_1 does not mix the impurity and bath states, the trace in omega(mathcalC_n) can be written as ","category":"page"},{"location":"ch09/hyb.html","page":"Hybridization expansion","title":"Hybridization expansion","text":"textTr = textTr_d textTr_c","category":"page"},{"location":"ch09/hyb.html","page":"Hybridization expansion","title":"Hybridization expansion","text":"As a result, we can split the weight of each configuration as ","category":"page"},{"location":"ch09/hyb.html","page":"Hybridization expansion","title":"Hybridization expansion","text":"beginequation\nomega(mathcalC_n) = omega_d(mathcalC_n) omega_c(mathcalC_n) prodlimits_i=1^n dtau_i\nendequation","category":"page"},{"location":"ch09/hyb.html","page":"Hybridization expansion","title":"Hybridization expansion","text":"omega_d(mathcalC_n) is the trace over impurity operators (textTr_d), omega_c(mathcalC_n) is the trace over bath operators (textTr_c). Further, since the Wick's theorem is applicable for the omega_c(mathcalC_n) part, we can represent it as a determinant of a matrix mathcalZ_textbathmathcalM^-1 with ","category":"page"},{"location":"ch09/hyb.html","page":"Hybridization expansion","title":"Hybridization expansion","text":"mathcalZ_textbath=textTr_c e^-beta H_textbath","category":"page"},{"location":"ch09/hyb.html","page":"Hybridization expansion","title":"Hybridization expansion","text":"and","category":"page"},{"location":"ch09/hyb.html","page":"Hybridization expansion","title":"Hybridization expansion","text":"(mathcalM^-1)_ij = Delta(tau_i - tau_j)","category":"page"},{"location":"ch09/hyb.html","page":"Hybridization expansion","title":"Hybridization expansion","text":"The omega_d(mathcalC_n) part can be expressed using segment representation when n_alpha H_textloc = 0[1]. However, if this condition is not fulfilled, we have to calculate the trace explicitly, which is called the general matrix algorithm[2][3]. The explicit calculation of the trace for a large multi-orbital AIM with general interactions is computationally expensive. Many tricks and strategies have been implemented in the iQIST software package to address this challenge. Please refer to next section for more details.","category":"page"},{"location":"ch09/hyb.html","page":"Hybridization expansion","title":"Hybridization expansion","text":"In this package, we used importance sampling and the Metropolis algorithm to evaluate the partition function mathcalZ. The following four local update procedures, with which the ergodicity of Monte Carlo algorithm is guaranteed, are used to generate the Markov chain: ","category":"page"},{"location":"ch09/hyb.html","page":"Hybridization expansion","title":"Hybridization expansion","text":"Insert a pair of creation and annihilation operators in the time interval 0beta).\nRemove a pair of creation and annihilation operators from the current configuration.\nSelect a creation operator randomly and shift its position on the imaginary time axis.\nSelect a annihilation operator randomly and shift its position on the imaginary time axis.","category":"page"},{"location":"ch09/hyb.html","page":"Hybridization expansion","title":"Hybridization expansion","text":"In the Monte Carlo simulations, sometimes the system can be trapped by some (for example symmetry-broken) state. In order to avoid unphysical trapping, we also consider the following two global updates:","category":"page"},{"location":"ch09/hyb.html","page":"Hybridization expansion","title":"Hybridization expansion","text":"Swap the operators of randomly selected spin up and spin down flavors.\nSwap the creation and annihilation operators globally.","category":"page"},{"location":"ch09/hyb.html","page":"Hybridization expansion","title":"Hybridization expansion","text":"Reference","category":"page"},{"location":"ch09/hyb.html","page":"Hybridization expansion","title":"Hybridization expansion","text":"[1]: Philipp Werner, Armin Comanac, Luca deâ Medici, Matthias Troyer, and Andrew J. Millis, Phys. Rev. Lett. 97, 076405 (2006)","category":"page"},{"location":"ch09/hyb.html","page":"Hybridization expansion","title":"Hybridization expansion","text":"[2]: Philipp Werner and Andrew J. Millis, Phys. Rev. B 74, 155107 (2006)","category":"page"},{"location":"ch09/hyb.html","page":"Hybridization expansion","title":"Hybridization expansion","text":"[3]: Kristjan Haule, Phys. Rev. B 75, 155113 (2007)","category":"page"},{"location":"ch09/kpm.html#Kernel-polynomial-method","page":"Kernel polynomial method","title":"Kernel polynomial method","text":"","category":"section"},{"location":"ch07/ctqmc.html#script/u_ctqmc.py","page":"script/u_ctqmc.py","title":"script/u_ctqmc.py","text":"","category":"section"},{"location":"ch07/ctqmc.html","page":"script/u_ctqmc.py","title":"script/u_ctqmc.py","text":"Introduction","category":"page"},{"location":"ch07/ctqmc.html","page":"script/u_ctqmc.py","title":"script/u_ctqmc.py","text":"The purpose of this script is to generate essential input file (solver.ctqmc.in) for the quantum impurity solver components. Note that you can not use it to control these codes directly.","category":"page"},{"location":"ch07/ctqmc.html","page":"script/u_ctqmc.py","title":"script/u_ctqmc.py","text":"Type","category":"page"},{"location":"ch07/ctqmc.html","page":"script/u_ctqmc.py","title":"script/u_ctqmc.py","text":"Python module","category":"page"},{"location":"ch07/ctqmc.html","page":"script/u_ctqmc.py","title":"script/u_ctqmc.py","text":"APIs","category":"page"},{"location":"ch07/ctqmc.html","page":"script/u_ctqmc.py","title":"script/u_ctqmc.py","text":"class p_ctqmc_solver(object):\n    \"\"\" This class can be used to generate the config file for the quantum\n        impurity solver components.\n    \"\"\"\n\n    def __init__(self, solver):\n        \"\"\" define the class variables\n        \"\"\"\n\n    def setp(self, **kwargs):\n        \"\"\" setup the parameters using a series of key-value pairs\n        \"\"\"\n\n    def check(self):\n        \"\"\" check the correctness of input parameters\n        \"\"\"\n        \n    def write(self):\n        \"\"\" write the parameters to the config file: solver.ctqmc.in\n        \"\"\"","category":"page"},{"location":"ch07/ctqmc.html","page":"script/u_ctqmc.py","title":"script/u_ctqmc.py","text":"Examples","category":"page"},{"location":"ch07/ctqmc.html","page":"script/u_ctqmc.py","title":"script/u_ctqmc.py","text":"# import this module\nfrom u_ctqmc import *\n\n# create an instance\np = p_ctqmc_solver('manjushaka')\n\n# setup the parameters\np.setp(isscf = 2, isort = 1, nsweep = 10000000)\np.setp(mune = 2.0, nmaxi = 10)\np.setp()\np.setp(isscf = 1)\n\n# verify the parameters\np.check()\n\n# generate the solver.ctqmc.in file\np.write()\n\n# destroy the instance\ndel p","category":"page"},{"location":"ch07/ctqmc.html","page":"script/u_ctqmc.py","title":"script/u_ctqmc.py","text":"note: Note\nYou can not execute u_ctqmc.py in the terminal or Python environment directly, like this:$ python u_ctqmc.py","category":"page"},{"location":"ch07/ctqmc.html","page":"script/u_ctqmc.py","title":"script/u_ctqmc.py","text":"Comment","category":"page"},{"location":"ch07/ctqmc.html","page":"script/u_ctqmc.py","title":"script/u_ctqmc.py","text":"N/A","category":"page"},{"location":"ch09/lazy.html#Lazy-trace-evaluation","page":"Lazy trace evaluation","title":"Lazy trace evaluation","text":"","category":"section"},{"location":"ch09/lazy.html","page":"Lazy trace evaluation","title":"Lazy trace evaluation","text":"The diagrammatic Monte Carlo sampling algorithm consists of the following steps: (1) Propose an update for the current diagrammatic configuration. (2) Calculate the acceptance probability p according to the Metropolis-Hasting algorithm,","category":"page"},{"location":"ch09/lazy.html","page":"Lazy trace evaluation","title":"Lazy trace evaluation","text":"beginequation\np = textmin (1 fracA^primeA left fracomega_comega_c^primeright \n     leftfracomega_domega_d^prime right)\nendequation","category":"page"},{"location":"ch09/lazy.html","page":"Lazy trace evaluation","title":"Lazy trace evaluation","text":"where, A is the proposal probability for the current update and A^prime for the inverse update, omega_c and omega_c^prime are the determinants for the new and old configurations, respectively, and omega_d and omega_d^prime are the local traces for the new and old configurations, respectively. (3) Generate a random number r. If pr, the proposed update is accepted, otherwise it is rejected. (4) Update the current diagrammatic configuration if the proposed update is accepted. It turns out that for CT-HYB, p is usually low (1 sim 20), especially in the low temperature region. On the other hand, the calculation of p involves a costly local trace evaluation. To avoid wasting computation time when the acceptance probability is very low, in the subspace algorithm, we implemented the so-called lazy trace evaluation proposed in Reference[1].","category":"page"},{"location":"ch09/lazy.html","page":"Lazy trace evaluation","title":"Lazy trace evaluation","text":"The basic idea of the lazy trace evaluation is simple. For the proposed Monte Carlo move, we first generate a random number r. Then, instead of calculating the local trace from scratch to determine p, we calculate bounds for lefttextTr_textlocright,","category":"page"},{"location":"ch09/lazy.html","page":"Lazy trace evaluation","title":"Lazy trace evaluation","text":"beginequation\nleftomega_dright = lefttextTr_textlocright leq sum_i lefttextTr_iright leq sum_i B_i\nendequation","category":"page"},{"location":"ch09/lazy.html","page":"Lazy trace evaluation","title":"Lazy trace evaluation","text":"where B_i geq lefttextTr_iright. B_i is a product of some chosen matrix norms of T and F matrices: ","category":"page"},{"location":"ch09/lazy.html","page":"Lazy trace evaluation","title":"Lazy trace evaluation","text":"beginequation\nB_i = C  left T_2k+1 \nright left F_2k right cdots left F_2 right left T_2 right \nleft F_1 right left T_1 right geq\nlefttextTr(T_2k+1F_2k cdots F_2T_2F_1T_1)right\nendequation","category":"page"},{"location":"ch09/lazy.html","page":"Lazy trace evaluation","title":"Lazy trace evaluation","text":"where C is a parameter depending on the specific type of matrix norm, and left cdot right denotes a matrix norm. If textTr_i^prime denotes the exact trace of some subspaces, then we have ","category":"page"},{"location":"ch09/lazy.html","page":"Lazy trace evaluation","title":"Lazy trace evaluation","text":"beginequation\nleft lefttextTr_textlocright - sum_i^primelefttextTr_i^primeright right \nleq sum_i neq i^prime B_i\nendequation","category":"page"},{"location":"ch09/lazy.html","page":"Lazy trace evaluation","title":"Lazy trace evaluation","text":"Thus, we can determine the upper p_textmax and lower p_textmin bounds of p as","category":"page"},{"location":"ch09/lazy.html","page":"Lazy trace evaluation","title":"Lazy trace evaluation","text":"beginequation\nbeginaligned\np_textmax=R left(sum_i^primelefttextTr_i^primeright + sum_i neq i^prime B_iright)\np_textmin=R left(sum_i^primelefttextTr_i^primeright - sum_i neq i^prime B_iright)\nendaligned\nendequation ","category":"page"},{"location":"ch09/lazy.html","page":"Lazy trace evaluation","title":"Lazy trace evaluation","text":"where R=fracA^primeA left fracomega_comega_c^primeright leftfrac1omega_d^prime right. ","category":"page"},{"location":"ch09/lazy.html","page":"Lazy trace evaluation","title":"Lazy trace evaluation","text":"If rp_textmax, we reject this move immediately. If rp_textmin, we accept the move and calculate the determinant and local trace from scratch. If p_textmin  r  p_textmax, we refine the bounds by calculating the local trace of one more subspace textTr_i until we can reject or accept the move. The calculation of these bounds involves only simple linear algebra calculations of matrix norms which cost little computation time, and one refining operation involves only one subspace trace evaluation. On average, it saves a lot of computation time, as confirmed by our benchmarks.","category":"page"},{"location":"ch09/lazy.html","page":"Lazy trace evaluation","title":"Lazy trace evaluation","text":"Reference","category":"page"},{"location":"ch09/lazy.html","page":"Lazy trace evaluation","title":"Lazy trace evaluation","text":"[1]: P. SÃ©mon, Chuck-Hou Yee, Kristjan Haule, and A.-M. S. Tremblay, Phys. Rev. B 90, 075149","category":"page"},{"location":"ch06/p_jp.html#Parameter:-Jp","page":"Jp","title":"Parameter: Jp","text":"","category":"section"},{"location":"ch06/p_jp.html","page":"Jp","title":"Jp","text":"Definition","category":"page"},{"location":"ch06/p_jp.html","page":"Jp","title":"Jp","text":"Strength of pair-hopping interaction.","category":"page"},{"location":"ch06/p_jp.html","page":"Jp","title":"Jp","text":"Type","category":"page"},{"location":"ch06/p_jp.html","page":"Jp","title":"Jp","text":"Float, double precision","category":"page"},{"location":"ch06/p_jp.html","page":"Jp","title":"Jp","text":"Default value","category":"page"},{"location":"ch06/p_jp.html","page":"Jp","title":"Jp","text":"0.0","category":"page"},{"location":"ch06/p_jp.html","page":"Jp","title":"Jp","text":"Component","category":"page"},{"location":"ch06/p_jp.html","page":"Jp","title":"Jp","text":"Only for the JASMINE component.","category":"page"},{"location":"ch06/p_jp.html","page":"Jp","title":"Jp","text":"Behavior","category":"page"},{"location":"ch06/p_jp.html","page":"Jp","title":"Jp","text":"It is used to build the interaction term in the local Hamiltonian, only valid when icu = 1 or icu = 3.","category":"page"},{"location":"ch06/p_jp.html","page":"Jp","title":"Jp","text":"Comment","category":"page"},{"location":"ch06/p_jp.html","page":"Jp","title":"Jp","text":"See also Uc, Uv, Jz, Js, and icu parameters for more details.","category":"page"},{"location":"ch04/p_ntime.html#Parameter:-ntime","page":"ntime","title":"Parameter: ntime","text":"","category":"section"},{"location":"ch04/p_ntime.html","page":"ntime","title":"ntime","text":"Definition","category":"page"},{"location":"ch04/p_ntime.html","page":"ntime","title":"ntime","text":"Number of imaginary time slices sampling by continuous time or Hirsch-Fye quantum Monte Carlo quantum impurity solver.","category":"page"},{"location":"ch04/p_ntime.html","page":"ntime","title":"ntime","text":"In the iQIST software package, the imaginary time mesh is calculated as follows:","category":"page"},{"location":"ch04/p_ntime.html","page":"ntime","title":"ntime","text":"tau_i = fracbeta (i-1)n-1 ","category":"page"},{"location":"ch04/p_ntime.html","page":"ntime","title":"ntime","text":"where i in 1n and tau_i in 0beta. So, the value of n is just ntime.","category":"page"},{"location":"ch04/p_ntime.html","page":"ntime","title":"ntime","text":"Type","category":"page"},{"location":"ch04/p_ntime.html","page":"ntime","title":"ntime","text":"Integer","category":"page"},{"location":"ch04/p_ntime.html","page":"ntime","title":"ntime","text":"Default value","category":"page"},{"location":"ch04/p_ntime.html","page":"ntime","title":"ntime","text":"1024 (for CT-HYB impurity solvers) or 64 (for HF-QMC impurity solvers) ","category":"page"},{"location":"ch04/p_ntime.html","page":"ntime","title":"ntime","text":"Component","category":"page"},{"location":"ch04/p_ntime.html","page":"ntime","title":"ntime","text":"ALL","category":"page"},{"location":"ch04/p_ntime.html","page":"ntime","title":"ntime","text":"Behavior","category":"page"},{"location":"ch04/p_ntime.html","page":"ntime","title":"ntime","text":"Determine the size of involved arrays, such as the imaginary-time Green's function G(tau), the hybridization function Delta(tau), the auxiliary correlation function F(tau), the spin-spin correlation function langle S_z(0) S_z(tau) rangle, etc.","category":"page"},{"location":"ch04/p_ntime.html","page":"ntime","title":"ntime","text":"Comment","category":"page"},{"location":"ch04/p_ntime.html","page":"ntime","title":"ntime","text":"The ntime = 1024 is an optimal value for most cases. But if the system temperature is too low, it is useful to increase ntime to obtain higher accurate. For example, if beta = 100, it is better to let ntime = 2048 or 4096.","category":"page"},{"location":"ch04/p_ntime.html","page":"ntime","title":"ntime","text":"See mfreq and nfreq parameters for more details.","category":"page"},{"location":"ch07/sac.html#Stochastic-analytical-continuation","page":"Stochastic analytical continuation","title":"Stochastic analytical continuation","text":"","category":"section"},{"location":"ch07/sac.html#Introduction","page":"Stochastic analytical continuation","title":"Introduction","text":"","category":"section"},{"location":"ch07/sac.html","page":"Stochastic analytical continuation","title":"Stochastic analytical continuation","text":"An alternative way to extract the A(omega) from G(tau) is using the stochastic analytical continuation[1]. Unlike the maximum entropy method, the stochastic analytical continuation does not depend on any a priori parameters. It has been argued that the stochastic analytical continuation can produce more accurate spectral functions with more subtle structures. ","category":"page"},{"location":"ch07/sac.html","page":"Stochastic analytical continuation","title":"Stochastic analytical continuation","text":"In the HIBISCUS component, we also implemented the stochastic analytical continuation which can be viewed as a useful complementary procedure to the maximum entropy method. Since the stochastic analytical continuation is computationally much heavier than the maximum entropy method, we parallelized it with MPI and OpenMP.","category":"page"},{"location":"ch07/sac.html","page":"Stochastic analytical continuation","title":"Stochastic analytical continuation","text":"The HIBISCUS/stoch code is often used to perform the analytical continuation to build impurity spectral function from imaginary-time Green's function using the modern stochastic analytic continuation method. In principle, it solves the Laplace transformation","category":"page"},{"location":"ch07/sac.html","page":"Stochastic analytical continuation","title":"Stochastic analytical continuation","text":"    G(tau) = int K(tauomega) A(omega) domega","category":"page"},{"location":"ch07/sac.html","page":"Stochastic analytical continuation","title":"Stochastic analytical continuation","text":"where K(tauomega) is the so-called kernel function. Its definition is as follows:","category":"page"},{"location":"ch07/sac.html","page":"Stochastic analytical continuation","title":"Stochastic analytical continuation","text":"    K(tauomega) = frac exp(-tauomega) 10+exp(-betaomega)","category":"page"},{"location":"ch07/sac.html","page":"Stochastic analytical continuation","title":"Stochastic analytical continuation","text":"[1]: K. S. D. Beach, arXiv:0403055 [cond-mat]","category":"page"},{"location":"ch07/sac.html","page":"Stochastic analytical continuation","title":"Stochastic analytical continuation","text":"note: Note\nThis code is based originally on Dr. QuanSheng. Wu's code. Now QuanSheng is a postdoc in ETH Zurich, Switzerland. ","category":"page"},{"location":"ch07/sac.html#Usage","page":"Stochastic analytical continuation","title":"Usage","text":"","category":"section"},{"location":"ch07/sac.html","page":"Stochastic analytical continuation","title":"Stochastic analytical continuation","text":"$ ./sac","category":"page"},{"location":"ch07/sac.html","page":"Stochastic analytical continuation","title":"Stochastic analytical continuation","text":"or","category":"page"},{"location":"ch07/sac.html","page":"Stochastic analytical continuation","title":"Stochastic analytical continuation","text":"$ mpiexec -n number_of_cores ./sac","category":"page"},{"location":"ch07/sac.html","page":"Stochastic analytical continuation","title":"Stochastic analytical continuation","text":"note: Note\nThe HIBISCUS/stoch code also support the MPI parallelism. So you can apply MPI to improve the computational accuracy of it.","category":"page"},{"location":"ch07/sac.html#Input","page":"Stochastic analytical continuation","title":"Input","text":"","category":"section"},{"location":"ch07/sac.html","page":"Stochastic analytical continuation","title":"Stochastic analytical continuation","text":"tau.grn.dat (necessary)\nsac.in (necessary)","category":"page"},{"location":"ch07/sac.html","page":"Stochastic analytical continuation","title":"Stochastic analytical continuation","text":"The tau.grn.dat file contains the G(tau) data. It has to be generated using the HIBISCUS/toolbox/maketau code. ","category":"page"},{"location":"ch07/sac.html","page":"Stochastic analytical continuation","title":"Stochastic analytical continuation","text":"See also toolbox/maketau for more details.","category":"page"},{"location":"ch07/sac.html","page":"Stochastic analytical continuation","title":"Stochastic analytical continuation","text":"The sac.in file contains all of the necessary control parameters for the HIBISCUS/stoch code. The syntax of it is the same with the solver.ctqmc.in file. As for the valid control parameters, please see the following text.","category":"page"},{"location":"ch07/sac.html","page":"Stochastic analytical continuation","title":"Stochastic analytical continuation","text":"See also solver.ctqmc.in for more details.","category":"page"},{"location":"ch07/sac.html#Output","page":"Stochastic analytical continuation","title":"Output","text":"","category":"section"},{"location":"ch07/sac.html","page":"Stochastic analytical continuation","title":"Stochastic analytical continuation","text":"sac.image.dat\nsac.imsum.dat\nsac.move.dat\nsac.swap.dat","category":"page"},{"location":"ch07/sac.html","page":"Stochastic analytical continuation","title":"Stochastic analytical continuation","text":"The alpha-resolved and alpha-averaged impurity spectral functions are stored in the sac.image.dat and sac.imsum.dat files, respectively. In the sac.move.dat and sac.swap.dat files, the statistics for the Monte Carlo move/swap operations are recorded.","category":"page"},{"location":"ch07/sac.html#Parameters","page":"Stochastic analytical continuation","title":"Parameters","text":"","category":"section"},{"location":"ch07/sac.html","page":"Stochastic analytical continuation","title":"Stochastic analytical continuation","text":"In the following, we will show the original definitions for the control parameters:","category":"page"},{"location":"ch07/sac.html","page":"Stochastic analytical continuation","title":"Stochastic analytical continuation","text":"!!========================================================================\n!!>>> integer variables                                                <<<\n!!========================================================================\n\n! number of imaginary time slices sampling by continuous time or hirsh-fye\n! quantum Monte Carlo quantum impurity solver\n     integer, public, save :: ntime = 1024\n\n! number of frequency points on half axis, energy range can be expressed by\n! [ -wstep * nwmax, wstep * nwmax ]\n     integer, public, save :: nwmax = 128\n\n! number of slices of x in [0,1]\n     integer, public, save :: ngrid = 10001\n\n! number of configurations, dimension for r_{\\gamma} and a_{\\gamma}\n     integer, public, save :: ngamm = 1024\n\n! number of alpha parameters used in parallel tempering\n! note: it must be an even number, since we need to exchange configurations\n! between different alpha channel\n     integer, public, save :: nalph = 10\n\n! maximum number of thermalization steps\n     integer, public, save :: nwarm = 4000\n\n! maximum number of quantum Monte Carlo sampling steps\n     integer, public, save :: nstep = 4000000\n\n! output period for stochastic analytic continuation code\n     integer, public, save :: ndump = 40000\n\n! measurement scheme\n! if ltype == 1, normal measurement\n! if ltype == 2, using legendre polynomial representation\n     integer, public, save :: ltype = 1\n\n! maximum order for legendre polynomial\n     integer, public, save :: lemax = 64\n\n! number of mesh points for legendre polynomial in [-1,1] range\n     integer, public, save :: legrd = 20001\n\n!!========================================================================\n!!>>> real variables                                                   <<<\n!!========================================================================\n\n! initial alpha parameter\n     real(dp), public, save :: ainit = 1.00_dp\n\n! \\alpha_(p+1) / \\alpha_p = R, used to build alpha parameter list\n     real(dp), public, save :: ratio = 2.00_dp\n\n! \\beta, inversion of real temperature\n     real(dp), public, save :: beta  = 10.0_dp\n\n! lorentz broadening parameter \\eta, used to represent delta function\n     real(dp), public, save :: eta1  = 0.02_dp\n     real(dp), public, save :: eta2  = 4E-4_dp\n\n! gauss broadening parameter, used to build the default model\n     real(dp), public, save :: sigma = 1.00_dp\n\n! frequency step, used to build the frequency mesh\n     real(dp), public, save :: wstep = 0.05_dp","category":"page"},{"location":"ch07/sac.html#Recipe:-how-to-convert-G(\\tau)-to-A(\\omega)-using-the-**HIBISCUS**/stoch-code","page":"Stochastic analytical continuation","title":"Recipe: how to convert G(tau) to A(omega) using the HIBISCUS/stoch code","text":"","category":"section"},{"location":"ch07/sac.html","page":"Stochastic analytical continuation","title":"Stochastic analytical continuation","text":"Step 1: ","category":"page"},{"location":"ch07/sac.html","page":"Stochastic analytical continuation","title":"Stochastic analytical continuation","text":"Perform CT-HYB or HF-QMC calculations, generate a solver.green.dat file or multiple solver.green.dat.````* files.","category":"page"},{"location":"ch07/sac.html","page":"Stochastic analytical continuation","title":"Stochastic analytical continuation","text":"Step 2:","category":"page"},{"location":"ch07/sac.html","page":"Stochastic analytical continuation","title":"Stochastic analytical continuation","text":"Using the HIBISCUS/toolbox/maketau to post-process the solver.green.dat file or solver.green.dat.````* files. The output should be tau.grn.dat file.","category":"page"},{"location":"ch07/sac.html","page":"Stochastic analytical continuation","title":"Stochastic analytical continuation","text":"Step 3:","category":"page"},{"location":"ch07/sac.html","page":"Stochastic analytical continuation","title":"Stochastic analytical continuation","text":"Edit the sac.in file, setup reasonable control parameters.","category":"page"},{"location":"ch07/sac.html","page":"Stochastic analytical continuation","title":"Stochastic analytical continuation","text":"Step 4:","category":"page"},{"location":"ch07/sac.html","page":"Stochastic analytical continuation","title":"Stochastic analytical continuation","text":"Execute the HIBISCUS/sac code, the tau.grn.dat and sac.in files are necessary inputs.","category":"page"},{"location":"ch07/sac.html","page":"Stochastic analytical continuation","title":"Stochastic analytical continuation","text":"Step 5:","category":"page"},{"location":"ch07/sac.html","page":"Stochastic analytical continuation","title":"Stochastic analytical continuation","text":"Validate the impurity spectral function A(omega) in the sac.imsum.dat file. That is what you need.","category":"page"},{"location":"ch07/sac.html","page":"Stochastic analytical continuation","title":"Stochastic analytical continuation","text":"note: Note\nThe HIBISCUS/stoch code does not support multi-orbital models. So if you want to use it to post-process multi-orbital systems, you have to split the Green's function at first by yourself. Once the analytical continuation is finished, you have to combine the different sac.imsum.dat files to a single file. It is a trivial task. ","category":"page"},{"location":"ch07/sac.html","page":"Stochastic analytical continuation","title":"Stochastic analytical continuation","text":"Step 6:","category":"page"},{"location":"ch07/sac.html","page":"Stochastic analytical continuation","title":"Stochastic analytical continuation","text":"Now you can use the data in sac.imsum.dat file to generate beautiful figures, or use the other tools to postprocess it again.","category":"page"},{"location":"ch06/p_js.html#Parameter:-Js","page":"Js","title":"Parameter: Js","text":"","category":"section"},{"location":"ch06/p_js.html","page":"Js","title":"Js","text":"Definition","category":"page"},{"location":"ch06/p_js.html","page":"Js","title":"Js","text":"Strength of spin-flip interaction.","category":"page"},{"location":"ch06/p_js.html","page":"Js","title":"Js","text":"Type","category":"page"},{"location":"ch06/p_js.html","page":"Js","title":"Js","text":"Float, double precision","category":"page"},{"location":"ch06/p_js.html","page":"Js","title":"Js","text":"Default value","category":"page"},{"location":"ch06/p_js.html","page":"Js","title":"Js","text":"0.0","category":"page"},{"location":"ch06/p_js.html","page":"Js","title":"Js","text":"Component","category":"page"},{"location":"ch06/p_js.html","page":"Js","title":"Js","text":"Only for the JASMINE component.","category":"page"},{"location":"ch06/p_js.html","page":"Js","title":"Js","text":"Behavior","category":"page"},{"location":"ch06/p_js.html","page":"Js","title":"Js","text":"It is used to build the interaction term in the local Hamiltonian, only valid when icu = 1 or icu = 3.","category":"page"},{"location":"ch06/p_js.html","page":"Js","title":"Js","text":"Comment","category":"page"},{"location":"ch06/p_js.html","page":"Js","title":"Js","text":"See also Uc, Uv, Jz, Jp, and icu parameters for more details.","category":"page"},{"location":"ch04/out_grn.html#solver.grn.dat","page":"solver.grn.dat","title":"solver.grn.dat","text":"","category":"section"},{"location":"ch04/out_grn.html","page":"solver.grn.dat","title":"solver.grn.dat","text":"Introduction","category":"page"},{"location":"ch04/out_grn.html","page":"solver.grn.dat","title":"solver.grn.dat","text":"This file is used to store the Matsubara Green's function G(iomega_n). It will be output by the quantum impurity solvers when they are shut down.","category":"page"},{"location":"ch04/out_grn.html","page":"solver.grn.dat","title":"solver.grn.dat","text":"Format","category":"page"},{"location":"ch04/out_grn.html","page":"solver.grn.dat","title":"solver.grn.dat","text":"The solver.grn.dat file contains norbs block. Each block is appended by two blank lines. The format of each block is as follows:","category":"page"},{"location":"ch04/out_grn.html","page":"solver.grn.dat","title":"solver.grn.dat","text":"","category":"page"},{"location":"ch04/out_grn.html","page":"solver.grn.dat","title":"solver.grn.dat","text":"column 1: orbital index i, integer","category":"page"},{"location":"ch04/out_grn.html","page":"solver.grn.dat","title":"solver.grn.dat","text":"column 2: Matsubara frequency point, omega_n, double precision","category":"page"},{"location":"ch04/out_grn.html","page":"solver.grn.dat","title":"solver.grn.dat","text":"column 3: Matsubara Green's function, Re G(iomega_n), double precision","category":"page"},{"location":"ch04/out_grn.html","page":"solver.grn.dat","title":"solver.grn.dat","text":"column 4: Matsubara Green's function, Im G(iomega_n), double precision","category":"page"},{"location":"ch04/out_grn.html","page":"solver.grn.dat","title":"solver.grn.dat","text":"column 5: error bar, Re delta G(iomega_n), double precision","category":"page"},{"location":"ch04/out_grn.html","page":"solver.grn.dat","title":"solver.grn.dat","text":"column 6: error bar, Im delta G(iomega_n), double precision","category":"page"},{"location":"ch04/out_grn.html","page":"solver.grn.dat","title":"solver.grn.dat","text":"","category":"page"},{"location":"ch04/out_grn.html","page":"solver.grn.dat","title":"solver.grn.dat","text":"note: Note\nIn the solver.grn.dat file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch04/out_grn.html","page":"solver.grn.dat","title":"solver.grn.dat","text":"Code","category":"page"},{"location":"ch04/out_grn.html","page":"solver.grn.dat","title":"solver.grn.dat","text":"The corresponding Fortran code block for the writing of solver.grn.dat file is as follows:","category":"page"},{"location":"ch04/out_grn.html","page":"solver.grn.dat","title":"solver.grn.dat","text":"! open data file: solver.grn.dat\n     open(mytmp, file='solver.grn.dat', form='formatted', status='unknown')\n\n! write it\n     do i=1,norbs\n         do j=1,mfreq\n             write(mytmp,'(i6,5f16.8)') i, rmesh(j), &\n              real(grnf(j,i,i)), aimag(grnf(j,i,i)), &\n              real(gerr(j,i,i)), aimag(gerr(j,i,i))\n         enddo ! over j={1,mfreq} loop\n         write(mytmp,*) ! write empty lines\n         write(mytmp,*)\n     enddo ! over i={1,norbs} loop\n\n! close data file\n     close(mytmp)","category":"page"},{"location":"ch04/out_grn.html","page":"solver.grn.dat","title":"solver.grn.dat","text":"In the HIBISCUS component, we provide a Python module to read the output files of quantum impurity solvers. You can use it to read the solver.grn.dat file. See script/u_reader.py for more details.","category":"page"},{"location":"ch04/out_sfom.html#solver.sfom.dat","page":"solver.sfom.dat","title":"solver.sfom.dat","text":"","category":"section"},{"location":"ch04/out_sfom.html","page":"solver.sfom.dat","title":"solver.sfom.dat","text":"Introduction","category":"page"},{"location":"ch04/out_sfom.html","page":"solver.sfom.dat","title":"solver.sfom.dat","text":"The solver.sfom.dat file is used to store the spin-spin correlation function in frequency space, chi_textspin(inu_n). It will be output by the quantum impurity solvers when they are shut down.","category":"page"},{"location":"ch04/out_sfom.html","page":"solver.sfom.dat","title":"solver.sfom.dat","text":"note: Note\nOnly the GARDENIA and NARCISSUS components can generate the solver.sfom.dat file.","category":"page"},{"location":"ch04/out_sfom.html","page":"solver.sfom.dat","title":"solver.sfom.dat","text":"Format","category":"page"},{"location":"ch04/out_sfom.html","page":"solver.sfom.dat","title":"solver.sfom.dat","text":"The solver.sfom.dat file contains nband blocks. Each block is appended by two blank lines. The format of each block is as follows:","category":"page"},{"location":"ch04/out_sfom.html","page":"solver.sfom.dat","title":"solver.sfom.dat","text":"","category":"page"},{"location":"ch04/out_sfom.html","page":"solver.sfom.dat","title":"solver.sfom.dat","text":"column 1: Matsubara frequency point (bosonic type), nu_n, double precision","category":"page"},{"location":"ch04/out_sfom.html","page":"solver.sfom.dat","title":"solver.sfom.dat","text":"column 2: spin-spin correlation function, Re chi_textspin(inu_n), double precision","category":"page"},{"location":"ch04/out_sfom.html","page":"solver.sfom.dat","title":"solver.sfom.dat","text":"column 3: error bar, Re deltachi_textspin(inu_n), double precision","category":"page"},{"location":"ch04/out_sfom.html","page":"solver.sfom.dat","title":"solver.sfom.dat","text":"","category":"page"},{"location":"ch04/out_sfom.html","page":"solver.sfom.dat","title":"solver.sfom.dat","text":"note: Note\nThe imaginary part of chi_textspin(inu_n) should be kept zero.","category":"page"},{"location":"ch04/out_sfom.html","page":"solver.sfom.dat","title":"solver.sfom.dat","text":"Code","category":"page"},{"location":"ch04/out_sfom.html","page":"solver.sfom.dat","title":"solver.sfom.dat","text":"The corresponding Fortran code block for the writing of solver.sfom.dat file is as follows:","category":"page"},{"location":"ch04/out_sfom.html","page":"solver.sfom.dat","title":"solver.sfom.dat","text":"! open data file: solver.sfom.dat\n     open(mytmp, file='solver.sfom.dat', form='formatted', status='unknown')\n\n! write it\n     do j=1,nband\n         write(mytmp,'(a,i6)') '# flvr:', j\n         do i=1,nbfrq\n             write(mytmp,'(3f12.6)') bmesh(i), ssfom(i,j), sserr(i,j)\n         enddo ! over i={1,nbfrq} loop\n         write(mytmp,*) ! write empty lines\n         write(mytmp,*)\n     enddo ! over j={1,nband} loop\n\n! close data file\n     close(mytmp)","category":"page"},{"location":"ch04/out_sfom.html","page":"solver.sfom.dat","title":"solver.sfom.dat","text":"In the HIBISCUS component, we provide a Python module to read the output files of quantum impurity solvers. You can use it to read the solver.sfom.dat file. See script/u_reader.py for more details.","category":"page"},{"location":"ch04/p_beta.html#Parameter:-beta","page":"beta","title":"Parameter: beta","text":"","category":"section"},{"location":"ch04/p_beta.html","page":"beta","title":"beta","text":"Definition","category":"page"},{"location":"ch04/p_beta.html","page":"beta","title":"beta","text":"Inversion of temperature beta (equiv 1T).","category":"page"},{"location":"ch04/p_beta.html","page":"beta","title":"beta","text":"Type","category":"page"},{"location":"ch04/p_beta.html","page":"beta","title":"beta","text":"Float, double precision","category":"page"},{"location":"ch04/p_beta.html","page":"beta","title":"beta","text":"Default value","category":"page"},{"location":"ch04/p_beta.html","page":"beta","title":"beta","text":"8.0","category":"page"},{"location":"ch04/p_beta.html","page":"beta","title":"beta","text":"Component","category":"page"},{"location":"ch04/p_beta.html","page":"beta","title":"beta","text":"ALL","category":"page"},{"location":"ch04/p_beta.html","page":"beta","title":"beta","text":"Behavior","category":"page"},{"location":"ch04/p_beta.html","page":"beta","title":"beta","text":"It is used to determine the system temperature. The larger beta is, the slower computation is.","category":"page"},{"location":"ch04/p_beta.html","page":"beta","title":"beta","text":"Comment","category":"page"},{"location":"ch04/p_beta.html","page":"beta","title":"beta","text":"To convert beta to real temperature, you can use the following formula:","category":"page"},{"location":"ch04/p_beta.html","page":"beta","title":"beta","text":"T = 11604505008098  beta","category":"page"},{"location":"ch04/p_beta.html","page":"beta","title":"beta","text":"The unit is Kelvin (K). For beta = 400, the corresponding temperature (290.11262520245 K) is roughly the room temperature.","category":"page"},{"location":"ch07/hfqmc.html#script/u_hfqmc.py","page":"script/u_hfqmc.py","title":"script/u_hfqmc.py","text":"","category":"section"},{"location":"ch07/hfqmc.html","page":"script/u_hfqmc.py","title":"script/u_hfqmc.py","text":"Introduction","category":"page"},{"location":"ch07/hfqmc.html","page":"script/u_hfqmc.py","title":"script/u_hfqmc.py","text":"The purpose of this script is to generate essential input file (solver.hfqmc.in) for the DAISY code. Note that you can not use it to control the DAISY code directly.","category":"page"},{"location":"ch07/hfqmc.html","page":"script/u_hfqmc.py","title":"script/u_hfqmc.py","text":"Type","category":"page"},{"location":"ch07/hfqmc.html","page":"script/u_hfqmc.py","title":"script/u_hfqmc.py","text":"Python module","category":"page"},{"location":"ch07/hfqmc.html","page":"script/u_hfqmc.py","title":"script/u_hfqmc.py","text":"APIs","category":"page"},{"location":"ch07/hfqmc.html","page":"script/u_hfqmc.py","title":"script/u_hfqmc.py","text":"class p_hfqmc_solver(object):\n    \"\"\" This class can be used to generate the config file for the quantum\n        impurity solver daisy code.\n    \"\"\"\n\n    def __init__(self, solver):\n        \"\"\" define the class variables\n        \"\"\"\n\n    def setp(self, **kwargs):\n        \"\"\" setup the parameters using a series of key-value pairs\n        \"\"\"\n\n    def check(self):\n        \"\"\" check the correctness of input parameters\n        \"\"\"\n        \n    def write(self):\n        \"\"\" write the parameters to the config file: solver.hfqmc.in\n        \"\"\"","category":"page"},{"location":"ch07/hfqmc.html","page":"script/u_hfqmc.py","title":"script/u_hfqmc.py","text":"Examples","category":"page"},{"location":"ch07/hfqmc.html","page":"script/u_hfqmc.py","title":"script/u_hfqmc.py","text":"# import this module\nfrom u_hfqmc import *\n\n# create an instance\np = p_hfqmc_solver('daisy')\n\n# setup the parameters\np.setp(isscf = 2, nsweep = 10000000)\np.setp(mune = 2.0, mstep = 10)\np.setp()\np.setp(isscf = 1)\n\n# verify the parameters\np.check()\n\n# generate the solver.hfqmc.in file\np.write()\n\n# destroy the instance\ndel p","category":"page"},{"location":"ch07/hfqmc.html","page":"script/u_hfqmc.py","title":"script/u_hfqmc.py","text":"note: Note\nYou can not execute u_hfqmc.py in the terminal or Python environment directly, like this:$ python u_hfqmc.py","category":"page"},{"location":"ch07/hfqmc.html","page":"script/u_hfqmc.py","title":"script/u_hfqmc.py","text":"Comment","category":"page"},{"location":"ch07/hfqmc.html","page":"script/u_hfqmc.py","title":"script/u_hfqmc.py","text":"N/A","category":"page"},{"location":"ch02/directory.html#Directory-structures","page":"Directory structures","title":"Directory structures","text":"","category":"section"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"The uncompressed iQIST software package is somewhat complicated, but have a rich content. We think that it is helpful to introduce the detailed directory structure of it. As has been explained before, in the following, we always use the term iqist to denote the top folder which contains the uncompressed iQIST software package.","category":"page"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"(Image: dir image)","category":"page"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"Figure | The directory structures of the iQIST software package.","category":"page"},{"location":"ch02/directory.html#Where-is-the-compling-system?","page":"Directory structures","title":"Where is the compling system?","text":"","category":"section"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"iqist/build","category":"page"},{"location":"ch02/directory.html#Where-are-the-executable-programs-installed-by-default?","page":"Directory structures","title":"Where are the executable programs installed by default?","text":"","category":"section"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"iqist/build","category":"page"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"warning: Warning\nYou have to compile the iQIST successfully, and then execute $ iqist/build/x_setup.shat first. So that the executable programs will be copied into the iqist/build directory.","category":"page"},{"location":"ch02/directory.html#Where-are-the-source-codes?","page":"Directory structures","title":"Where are the source codes?","text":"","category":"section"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"iqist/src","category":"page"},{"location":"ch02/directory.html#Where-are-the-applications-or-plugins?","page":"Directory structures","title":"Where are the applications or plugins?","text":"","category":"section"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"iqist/src/app","category":"page"},{"location":"ch02/directory.html#Where-is-the-base-library?","page":"Directory structures","title":"Where is the base library?","text":"","category":"section"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"iqist/src/base","category":"page"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"note: Note\nThe base library includes CSSL and CSML, which provide the numerical infrastructures for the other components of iQIST.","category":"page"},{"location":"ch02/directory.html#Where-are-the-application-programming-interfaces?","page":"Directory structures","title":"Where are the application programming interfaces?","text":"","category":"section"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"iqist/src/capi","category":"page"},{"location":"ch02/directory.html#Where-are-the-quantum-impurity-solvers?","page":"Directory structures","title":"Where are the quantum impurity solvers?","text":"","category":"section"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"For CT-QMC quantum impurity solvers","category":"page"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"iqist/src/ctqmc/azalea\niqist/src/ctqmc/begonia\niqist/src/ctqmc/camellia\niqist/src/ctqmc/gardenia\niqist/src/ctqmc/lavender\niqist/src/ctqmc/manjushaka\niqist/src/ctqmc/narcissus\niqist/src/ctqmc/pansy\n","category":"page"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"For HF-QMC quantum impurity solvers","category":"page"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"iqist/src/hfqmc/daisy","category":"page"},{"location":"ch02/directory.html#Where-is-the-atomic-eigenvalue-problem-solver?","page":"Directory structures","title":"Where is the atomic eigenvalue problem solver?","text":"","category":"section"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"iqist/src/tools/jasmine","category":"page"},{"location":"ch02/directory.html#Where-are-the-auxiliary-tools?","page":"Directory structures","title":"Where are the auxiliary tools?","text":"","category":"section"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"iqist/src/tools/hibiscus","category":"page"},{"location":"ch02/directory.html#Where-are-the-documentations?","page":"Directory structures","title":"Where are the documentations?","text":"","category":"section"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"Unfortunately, the documentations are not included in the iQIST software package. The official reference manual is released on the following website:","category":"page"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"https://www.gitbook.com/book/huangli712/iqist/details","category":"page"},{"location":"ch02/directory.html#Where-are-the-tutorials?","page":"Directory structures","title":"Where are the tutorials?","text":"","category":"section"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"iqist/tutor","category":"page"},{"location":"ch02/directory.html#Where-are-the-benchmark-cases?","page":"Directory structures","title":"Where are the benchmark cases?","text":"","category":"section"},{"location":"ch02/directory.html","page":"Directory structures","title":"Directory structures","text":"iqist/working","category":"page"},{"location":"ch09/truncation.html#Truncation-approximation","page":"Truncation approximation","title":"Truncation approximation","text":"","category":"section"},{"location":"ch09/truncation.html","page":"Truncation approximation","title":"Truncation approximation","text":"As discussed in previous section, although we have used GQNs to split the full Hilbert space with very large dimension into blocks with smaller dimensions [for cases such as 7-band systems with GQNs (N, J_z) and 5-band systems with GQN (N)], the dimensions of some blocks are still too large and the numbers of blocks are too much so that it is still very expensive to evaluate the local trace. Haule proposed to discard some high-energy states because they are rarely visited[1]. For example, for 7-band system with only 1 electron (like Ce metal), only states with occupancy N=0, 1, 2 will be frequently visited, and states with occupancy N2 can be truncated completely to reduce the large Hilbert space to a very small one. Of course, this truncation approximation may cause some bias because a frequently visited state may be accessed via an infrequently visited state. Therefore, one should be cautious when adopting the truncation approximation, and for example run some convergence tests. ","category":"page"},{"location":"ch09/truncation.html","page":"Truncation approximation","title":"Truncation approximation","text":"Currently, we adopted two truncation schemes in our codes. The first scheme relies on the occupation number. We just keep those states whose occupation numbers are close to the nominal valence and skip the other states, as shown in the above example. This scheme is quite robust if the charge fluctuations are small enough, such as in the case of a Mott insulating phase. Another scheme is to dynamically truncate the states with very low probability based on statistics which is recorded during the Monte Carlo sampling. This scheme is not very stable, so one needs to use it with caution.","category":"page"},{"location":"ch09/truncation.html","page":"Truncation approximation","title":"Truncation approximation","text":"Reference","category":"page"},{"location":"ch09/truncation.html","page":"Truncation approximation","title":"Truncation approximation","text":"[1]: Kristjan Haule, Phys. Rev. B 75, 155113 (2007)","category":"page"},{"location":"ch08/hello.html#Hello-iQIST!","page":"Hello iQIST!","title":"Hello iQIST!","text":"","category":"section"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"info: Info\nThis tutorial will take you about half an hour.","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"Introduction","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"Now we will introduce the easiest and simplest application of the iQIST software package â- to solve a single-band Hubbard model on a Bethe lattice within the framework of dynamical mean-field theory.","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"The general Hubbard model reads:","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"beginequation\nhatH = -t sum_langle ij ranglesigmac^dagger_isigmac_jsigma + sum_i hatH^i_textloc\nendequation","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"where hatH^i_textloc is the local Hamiltonian on each site i. In the case of the single-band Hubbard model, hatH_textloc reads ","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"beginequation\nhatH_textloc =  -mu sum_sigman_sigma + U n_uparrow n_downarrow\nendequation","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"where mu is the chemical potential and U the Coulomb interaction strength. We will solve it using the dynamical mean-field theory with a CT-HYB quantum impurity solver. Then the problem is that how to use the iQIST software package to reach this goal?","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"Recipes","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"Next we just follow the procedures described in the iQIST recipes section.","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"(1) Choose suitable component","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"Since it is a single-band model, all of the quantum impurity solver components in the iQIST software package can be employed. In other words, both the segment representation version and general matrix version of CT-HYB impurity solvers are usable. In this tutorial, we choose the AZALEA component.","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"(2) Design the programs and scripts","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"Since the Hubbard model is defined in a Bethe lattice whose density of states is semi-circular, the self-consistent equation for the dynamical mean-field theory reads:","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"G(tau) = t^2 Delta(tau)","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"As mentioned before, the AZALEA component (and the other quantum impurity solver components) contains a mini dynamical mean-field engine and the above self-consistent equation is already implemented by default. So, we can use the AZALEA component alone without help from any external programs or scripts.","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"(3) Prepare the input files","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"Next, we have to setup the necessary parameters for the AZALEA component via the solver.ctqmc.in file. You can find this file in the iqist/tutor/t11 directory. Please create your own working directory, and copy the solver.ctqmc.in file to it.","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"$ mkdir test11\n$ cp iqist/tutor/t11/solver.ctqmc.in test11\n$ cd test11","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"The solver.ctqmc.in file is attached as follows:","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"!!!-----------------------------------------------------------------------\n!!! source  : t11/solver.ctqmc.in\n!!! solver  : AZALEA\n!!! purpose : for tutorial\n!!! author  : yilin wang (email:qhwyl2006@126.com)\n!!!-----------------------------------------------------------------------\n\n!!>>> setup general control flags\n!!------------------------------------------------------------------------\n  isscf  : 2\n  issun  : 2\n  isspn  : 1\n  isbin  : 2\n\n!!>>> setup common variables for quantum impurity model\n!!------------------------------------------------------------------------\n  nband  : 1\n  nspin  : 2\n  norbs  : 2\n  ncfgs  : 4\n  niter  : 20\n  U      : 2.00\n  Uc     : 2.00\n  Uv     : 2.00\n  Jz     : 0.00\n  Js     : 0.00\n  Jp     : 0.00\n  mune   : 1.00\n  beta   : 40.0\n  part   : 0.50\n  alpha  : 0.70\n\n!!>>> setup common variables for quantum impurity solver\n!!------------------------------------------------------------------------\n  mkink  : 1024\n  mfreq  : 8193\n  nfreq  : 128\n  ntime  : 1024\n  nflip  : 20000\n  ntherm : 200000\n  nsweep : 20000000\n  nwrite : 2000000\n  nclean : 100000\n  nmonte : 100\n  ncarlo : 100","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"Well, at first glance, there are a lot of parameters in it. Relax. Actually, only a few parameters are essential. We will pick them out and explain them one by one.","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"The important parameters are as follows:","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"isscf = 2: Define the DMFT self-consistent computational mode.\nnband = 1, norbs = 2, and ncfgs = 4: Specify a single-band Hubbard model.\nUc = 2.0   : Coulomb interaction U = 2.\nmune = 1.0 : Chemical potential mu, mu = U2 leads to half-filling.\nbeta = 40.0 : Inverse temperature beta.","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"In fact, you can create a simplified solver.ctqmc.in file which contains only the Uc, mune, and beta parameters. The AZALEA component will supplement the rest using default settings. As for the format and grammar for the solver.ctqmc.in file, see solver.ctqmc.in for more details.","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"(4) Let's go","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"Now everything is ready. We can perform the calculation. Please execute the following command in the terminal, and go on a coffee or tea break.","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"$ ctqmc","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"note: Note\nHere we assume that the executable program for the AZALEA component is in iqist/build/ctqmc, and the directory iqist/build has been appended to the environment variable PATH.","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"From the terminal output, we can learn a lot of useful information about the simulation, such as the total energy E_texttot, potential energy E_textpot, kinetic energy E_textkin, magnetic moment langle S_z rangle, occupation number langle N^1 rangle and langle N^2 rangle (they can be used to calculate the charge fluctuation), perturbation expansion order langle K^2 rangle, langle K^3 rangle and langle K^4 rangle (they can be used to calculate the skewness and kurtosis), Monte Carlo update action statistics, etc. As for more details of the terminal output, please check the Terminal output section.","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"On the other hand, the CT-HYB quantum impurity solvers will generate a few files in the current directory (i.e., test11 folder in this tutorial), such as solver.hist.dat, solver.green.dat, etc. You can visualize them using some plotting tools (such as gnuplot) occasionally to see whether the results are reasonable. For example, the system with the given parameters must be metallic and half-filling. As for the metallicity, you should check whether the low-frequency Im G(iomega_n) is monotonically increasing (using the solver.grn.dat file). For the half-filling criterion, you should check the orbital occupancy in the solver.nmat.dat file. The total occupation number should be N cong 10, and the orbital occupation numbers n_1 cong n_2 cong 05. Due to the numerical noise and round-off error, tiny deviation is inevitable and acceptable.","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"After a few minutes (in my laptop, it cost about 23 minutes), the calculation is finished.","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"(5) Post-processing","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"Since the calculation is done, it is time to analyze the calculated results. All of the output data are stored in well-formatted ascii text files. So it is not difficult to read, parse, visualize, and analyze them. In this tutorial, we will show you how to generate figures using the calculated results.","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"Let's take the histogram data for the perturbation expansion series (stored in the solver.hist.dat file) as an example.","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"> Method 1: Using gnuplot for a quick plot","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"gnuplot> plot 'solver.hist.dat' u 1:3 w lp\ngnuplot> set terminal postscript enhanced solid color eps\ngnuplot> set output \"hist.eps\"\ngnuplot> replot","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"As you will see, the figure is in the hist.eps. You can improve the above gnuplot script to obtain a better visualization.","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"> Method 2: Using Python/matplotlib for a high-quality plot","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"As is well known, high-quality vector figures are always welcomed by the scientific journals. We strongly recommend to use the Python/matplotlib to generate beautiful and impressive figures. The following Python script can help you to reach this goal.","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"#!/usr/bin/env python\n\nimport numpy\nimport matplotlib\nmatplotlib.use(\"Agg\") # setup backend\nimport matplotlib.pyplot as plt\n\n# read data\norder, count, percent, error = numpy.loadtxt('solver.hist.dat', unpack = True)\n\n# plot it\nplt.figure(0)\nlines = plt.plot(order, percent, alpha = 0.8, clip_on = True)\n\n# setup line properties\nplt.setp(lines[0], linewidth = 2.5, marker = 'o', ms = 12, mew = 2, mec = 'yellowgreen', color = 'khaki')\n\n# setup tics\nplt.xticks(fontsize = 18)\nplt.yticks(fontsize = 18)\nplt.tick_params(length = 8, width = 1.0, which = 'major')\nplt.tick_params(length = 4, width = 0.5, which = 'minor')\n\n# setup labels\nplt.xlabel(r\"order $n$\", fontsize = 18)\nplt.ylabel(r\"histogram\", fontsize = 18)\n\n# setup yranges\nplt.xlim(0.0,20.0)\n\n# output the figure\nplt.savefig(\"hist.png\")","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"In the above script, the numpy.loadtxt() function is used to read data from the solver.hist.dat file. Actually, you can also use the functions implemented in the script/u_reader.py to do this job. See script/u_reader.py for more details.","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"Next we will show some visualized results. The following figures were generated using the above Python script with slight modifications. You can compare them with your own results to see whether your calculations are correct.","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"Histogram (solver.hist.dat)","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"(Image: hist image)","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"Figure | The histogram for perturbation expansion series.","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"Imaginary-time Green's function (solver.green.dat)","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"(Image: gtau image)","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"Figure | The imaginary-time Green's function G(tau).","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"Matsubara Green's function (solver.grn.dat)","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"(Image: grnf image)","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"Figure | The imaginary part of Matsubara Green's function Im G(iomega_n).","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"Matsubara self-energy function (solver.sgm.dat)","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"(Image: sigf image)","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"Figure | The imaginary part of Matsubara self-energy function Im Sigma(iomega_n).","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"Clearly, from the G(iomega_n) and Sigma(iomega_n) data, we can speculate that this system is exactly metallic.","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"OK. Now this tutorial is over. How do you feel?","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"Adventures","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"(1) Adjust the parameters","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"You can adjust the mune, beta, and nsweep parameters, and redo the calculations, to see what will happen.","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"(2) Parallel computation","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"Try to execute the CT-HYB quantum impurity solvers parallelly. Such as ","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"$ mpiexec -n 8 ctqmc","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"Pay attention to the numerical noises and data fluctuations of physical observable. Noted that once the CT-HYB quantum impurity solvers are executed parallelly, the error bars of physical observable should be non-zero. Here is a sample plot:","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"(Image: grnf_error image)","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"Figure | The imaginary part of Matsubara Green's function Im G(iomega_n). The error bar data are magnified by a factor of 10 for a better visualization.","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"(3) Generate animation movie","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"The iQIST software package provide an unique feature â- to visualize the diagrammatic Monte Carlo steps using short movie clip.","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"Really? It is funny.","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"Yes. To use this feature, please setup the nwrite and nsweep parameters carefully. Only when","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"textnwrite  textnsweep geq 100","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"this feature is actived. Then redo the calculation, and you will get a solver.diag.dat file. With the help of script/u_animator.py, an animation movie is generated.","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"(4) Try other CT-HYB quantum impurity solvers","category":"page"},{"location":"ch08/hello.html","page":"Hello iQIST!","title":"Hello iQIST!","text":"In addition to the AZALEA component, you still can choose the GARDENIA or NARCISSUS component to solve this single-band Hubbard model. The only task you have to do is call the proper executable programs. The solver.ctqmc.in file can remain unchanged.","category":"page"},{"location":"ch04/p_legrd.html#Parameter:-legrd","page":"legrd","title":"Parameter: legrd","text":"","category":"section"},{"location":"ch04/p_legrd.html","page":"legrd","title":"legrd","text":"Definition","category":"page"},{"location":"ch04/p_legrd.html","page":"legrd","title":"legrd","text":"Number of linear grid points in [-1,1] which is used to define the Legendre polynomials.","category":"page"},{"location":"ch04/p_legrd.html","page":"legrd","title":"legrd","text":"Type","category":"page"},{"location":"ch04/p_legrd.html","page":"legrd","title":"legrd","text":"Integer","category":"page"},{"location":"ch04/p_legrd.html","page":"legrd","title":"legrd","text":"Default value","category":"page"},{"location":"ch04/p_legrd.html","page":"legrd","title":"legrd","text":"20001","category":"page"},{"location":"ch04/p_legrd.html","page":"legrd","title":"legrd","text":"Component","category":"page"},{"location":"ch04/p_legrd.html","page":"legrd","title":"legrd","text":"Only for the GARDENIA, NARCISSUS, CAMELLIA, LAVENDER, and MANJUSHAKA components.","category":"page"},{"location":"ch04/p_legrd.html","page":"legrd","title":"legrd","text":"Behavior","category":"page"},{"location":"ch04/p_legrd.html","page":"legrd","title":"legrd","text":"The Legendre orthogonal polynomials are defined in a linear grid in [-1,1]. And the number of grid points are controlled by this parameter.","category":"page"},{"location":"ch04/p_legrd.html","page":"legrd","title":"legrd","text":"Comment","category":"page"},{"location":"ch04/p_legrd.html","page":"legrd","title":"legrd","text":"Only when isort = 2 or isort = 5 this parameter is useful. See isort for more details. The 20001 is an optimal value for legrd. It is not suggested to modify it. ","category":"page"},{"location":"ch04/p_legrd.html","page":"legrd","title":"legrd","text":"See also lemax for more details.","category":"page"},{"location":"ch04/p_legrd.html","page":"legrd","title":"legrd","text":"As for the applications of orthogonal polynomials in CT-QMC impurity solver, please refer to Lewin's[1] and Hartmann's[2] papers.","category":"page"},{"location":"ch04/p_legrd.html","page":"legrd","title":"legrd","text":"Reference","category":"page"},{"location":"ch04/p_legrd.html","page":"legrd","title":"legrd","text":"[1]: Lewin Boehnke, Hartmut Hafermann, Michel Ferrero, Frank Lechermann, and Olivier Parcollet, Phys. Rev. B 84, 075145 (2011).","category":"page"},{"location":"ch04/p_legrd.html","page":"legrd","title":"legrd","text":"[2]: Hartmut Hafermann, Kelly R. Patton, and Philipp Werner, Phys. Rev. B 85, 205106 (2012).","category":"page"},{"location":"ch06/p_jh.html#Parameter:-Jh","page":"Jh","title":"Parameter: Jh","text":"","category":"section"},{"location":"ch06/p_jh.html","page":"Jh","title":"Jh","text":"Definition","category":"page"},{"location":"ch06/p_jh.html","page":"Jh","title":"Jh","text":"Hund's exchange interaction parameter.","category":"page"},{"location":"ch06/p_jh.html","page":"Jh","title":"Jh","text":"Type","category":"page"},{"location":"ch06/p_jh.html","page":"Jh","title":"Jh","text":"Float, double precision","category":"page"},{"location":"ch06/p_jh.html","page":"Jh","title":"Jh","text":"Default value","category":"page"},{"location":"ch06/p_jh.html","page":"Jh","title":"Jh","text":"0.0","category":"page"},{"location":"ch06/p_jh.html","page":"Jh","title":"Jh","text":"Component","category":"page"},{"location":"ch06/p_jh.html","page":"Jh","title":"Jh","text":"Only for the JASMINE component.","category":"page"},{"location":"ch06/p_jh.html","page":"Jh","title":"Jh","text":"Behavior","category":"page"},{"location":"ch06/p_jh.html","page":"Jh","title":"Jh","text":"It is used to define the interaction term in the local Hamiltonian, only valid when icu = 2.","category":"page"},{"location":"ch06/p_jh.html","page":"Jh","title":"Jh","text":"Comment","category":"page"},{"location":"ch06/p_jh.html","page":"Jh","title":"Jh","text":"See also Ud and icu parameters for more details.","category":"page"},{"location":"ch04/p_nffrq.html#Parameter:-nffrq","page":"nffrq","title":"Parameter: nffrq","text":"","category":"section"},{"location":"ch04/p_nffrq.html","page":"nffrq","title":"nffrq","text":"Definition","category":"page"},{"location":"ch04/p_nffrq.html","page":"nffrq","title":"nffrq","text":"Number of fermionic Matsubara frequency points for the two-particle green's function.","category":"page"},{"location":"ch04/p_nffrq.html","page":"nffrq","title":"nffrq","text":"The two-particle Green's function chi(iomega_n iomega_n inu_n) and vertex function mathcalF(iomega_n iomega_n inu_n) have three frequency indices where omega_n and omega_n are fermionic frequencies, and nu_n bosonic frequency: ","category":"page"},{"location":"ch04/p_nffrq.html","page":"nffrq","title":"nffrq","text":"nu_n = frac2npibeta","category":"page"},{"location":"ch04/p_nffrq.html","page":"nffrq","title":"nffrq","text":"omega_n = frac(2n+1)pibeta","category":"page"},{"location":"ch04/p_nffrq.html","page":"nffrq","title":"nffrq","text":"The nbfrq parameter is used to define and generate nu_n bosonic mesh. The corresponding omega_n fermionic mesh is defined by the nffrq parameter.","category":"page"},{"location":"ch04/p_nffrq.html","page":"nffrq","title":"nffrq","text":"Type","category":"page"},{"location":"ch04/p_nffrq.html","page":"nffrq","title":"nffrq","text":"Integer","category":"page"},{"location":"ch04/p_nffrq.html","page":"nffrq","title":"nffrq","text":"Default value","category":"page"},{"location":"ch04/p_nffrq.html","page":"nffrq","title":"nffrq","text":"32","category":"page"},{"location":"ch04/p_nffrq.html","page":"nffrq","title":"nffrq","text":"Component","category":"page"},{"location":"ch04/p_nffrq.html","page":"nffrq","title":"nffrq","text":"Only for the GARDENIA, NARCISSUS, CAMELLIA, LAVENDER, and MANJUSHAKA components.","category":"page"},{"location":"ch04/p_nffrq.html","page":"nffrq","title":"nffrq","text":"Behavior","category":"page"},{"location":"ch04/p_nffrq.html","page":"nffrq","title":"nffrq","text":"Determine the size of involved arrays. Only useful when we need to compute the two-particle quantities.","category":"page"},{"location":"ch04/p_nffrq.html","page":"nffrq","title":"nffrq","text":"Comment","category":"page"},{"location":"ch04/p_nffrq.html","page":"nffrq","title":"nffrq","text":"If the nffrq is too large, the computational time is not bearable. So we suggest to set nffrq  128. The computation of two-particle quantities is extremely time-consuming, though we have tried our best optimizing it.","category":"page"},{"location":"ch04/p_nffrq.html","page":"nffrq","title":"nffrq","text":"See nbfrq and nfreq for more details.","category":"page"},{"location":"ch04/p_nffrq.html","page":"nffrq","title":"nffrq","text":"tip: Tip\nThe computation of two-particle quantities has been optimized using the OpenMP multi-thread technology. You can enable this feature in the compiling procedure. See also Compiling environment for more details.","category":"page"},{"location":"ch09/qim.html#Quantum-impurity-model","page":"Quantum impurity model","title":"Quantum impurity model","text":"","category":"section"},{"location":"ch09/qim.html","page":"Quantum impurity model","title":"Quantum impurity model","text":"The main goal of the iQIST software package is to provide a comprehensive tool for solving the quantum impurity models, especially the Anderson impurity model. Generally speaking, the multi-orbital Anderson impurity model (AIM) can be written as ","category":"page"},{"location":"ch09/qim.html","page":"Quantum impurity model","title":"Quantum impurity model","text":"H_textimp = H_textloc + H_textbath + H_texthyb","category":"page"},{"location":"ch09/qim.html","page":"Quantum impurity model","title":"Quantum impurity model","text":"where","category":"page"},{"location":"ch09/qim.html","page":"Quantum impurity model","title":"Quantum impurity model","text":"beginalign\n H_textloc = sum_alphabeta E_alphabeta d_alpha^dagger d_beta+sum_alphabetagammadelta U_alphabetagammadelta \n    d^dagger_alphad^dagger_beta d_gamma d_delta \n H_texthyb  = sum_textbfkalphabeta V^alphabeta_textbfk c_textbfkalpha^dagger d_beta + hc \n H_textbath = sum_textbfkalpha epsilon_textbfkalpha c_textbfkalpha^dagger c_textbfkalpha\nendalign","category":"page"},{"location":"ch09/qim.html","page":"Quantum impurity model","title":"Quantum impurity model","text":"In these equations, Greek letters in the subscripts denote a combined spin-orbital index, the fermion operator d_alpha^dagger (d_alpha) is creating (annihilating) an electron with index alpha on the impurity site, while c_textbfkalpha^dagger (c_textbfkalpha) is the creation (annihilation) operator for conduction band (bath) electron with spin-orbital index alpha and momentum textbfk. ","category":"page"},{"location":"ch09/qim.html","page":"Quantum impurity model","title":"Quantum impurity model","text":"The first term in H_textloc is the general form of the impurity single particle term with energy level splitting and inter-orbital hybridization. This term can be generated by crystal field (CF) splitting or spin-orbit coupling (SOC), etc. The second term in H_textloc is the Coulomb interaction term which can be parameterized by intra(inter)-band Coulomb interactions U (U) and Hund's rule coupling J or Slater integral parameters F^k. The hybridization term H_texthyb describes the process of electrons hopping from the impurity site to the environment and back. H_textbath describes the non-interacting bath. This Anderson impurity model is usually solved self-consistently in the DMFT calculations.","category":"page"},{"location":"ch03/profile.html#Profile-the-codes","page":"Profile the codes","title":"Profile the codes","text":"","category":"section"},{"location":"ch03/profile.html","page":"Profile the codes","title":"Profile the codes","text":"note: Note\nTrust me, if you don't want to get involved into the tedious development of the iQIST software package, you can skip this section.","category":"page"},{"location":"ch03/profile.html","page":"Profile the codes","title":"Profile the codes","text":"Are you satisfying with the efficiency of the iQIST's quantum impurity solvers? Though we have spent a lot of time in improving the efficiency of the iQIST, there are still a lot of codes/algorithms to be optimized.","category":"page"},{"location":"ch03/profile.html","page":"Profile the codes","title":"Profile the codes","text":"Well, how to optimize the iQIST software package is not a trivial task. But, it is very important to figure out the hot-spots of the code at first. Usually, we use the following approach to analyze the computational efficiency of iQIST.","category":"page"},{"location":"ch03/profile.html","page":"Profile the codes","title":"Profile the codes","text":"Modify iqist/build/make.sys. Active the \"-pg\" compiler opinion\nRerun the codes.\nAfter the execution is finished, you will find a gmon.out file in the working directory. Here, we assume that you are running the iQIST codes in a Linux system. If you are using the Mac OS X system, the situation may be a bit different.\nThen you can use the GNU gprof tool to analyze the gmon.out file. You have to ensure the execute program is in the same directory. As for the usage of the gprof tool, please google or 'man' it by yourself.\nOf course, you can use any other advanced GUI tools to do this job. But it is far beyond the scopes of this reference manual.","category":"page"},{"location":"ch07/clean.html#script/d_clean.py","page":"script/d_clean.py","title":"script/d_clean.py","text":"","category":"section"},{"location":"ch07/clean.html","page":"script/d_clean.py","title":"script/d_clean.py","text":"Introduction","category":"page"},{"location":"ch07/clean.html","page":"script/d_clean.py","title":"script/d_clean.py","text":"The purpose of this script is to clean the dull .DS_Store files for the Mac OS X filesystem.","category":"page"},{"location":"ch07/clean.html","page":"script/d_clean.py","title":"script/d_clean.py","text":"Type","category":"page"},{"location":"ch07/clean.html","page":"script/d_clean.py","title":"script/d_clean.py","text":"Python script","category":"page"},{"location":"ch07/clean.html","page":"script/d_clean.py","title":"script/d_clean.py","text":"Usage","category":"page"},{"location":"ch07/clean.html","page":"script/d_clean.py","title":"script/d_clean.py","text":"You have to specify the folder/directory name in which you want to clean the .DS_Store files, like this:","category":"page"},{"location":"ch07/clean.html","page":"script/d_clean.py","title":"script/d_clean.py","text":"$ ./d_clean.py /home/my/iqist","category":"page"},{"location":"ch07/clean.html","page":"script/d_clean.py","title":"script/d_clean.py","text":"Input","category":"page"},{"location":"ch07/clean.html","page":"script/d_clean.py","title":"script/d_clean.py","text":"N/A","category":"page"},{"location":"ch07/clean.html","page":"script/d_clean.py","title":"script/d_clean.py","text":"Output","category":"page"},{"location":"ch07/clean.html","page":"script/d_clean.py","title":"script/d_clean.py","text":"N/A","category":"page"},{"location":"ch07/clean.html","page":"script/d_clean.py","title":"script/d_clean.py","text":"Comment","category":"page"},{"location":"ch07/clean.html","page":"script/d_clean.py","title":"script/d_clean.py","text":"note: Note\nThis script is used by the iQIST Developer Team internally.","category":"page"},{"location":"ch04/p_isort.html#Parameter:-isort","page":"isort","title":"Parameter: isort","text":"","category":"section"},{"location":"ch04/p_isort.html","page":"isort","title":"isort","text":"Definition","category":"page"},{"location":"ch04/p_isort.html","page":"isort","title":"isort","text":"Key control flag. It is used to determine whether we should use the orthogonal polynomials trick to improve the accuracy and suppress the numerical noises. ","category":"page"},{"location":"ch04/p_isort.html","page":"isort","title":"isort","text":"Type","category":"page"},{"location":"ch04/p_isort.html","page":"isort","title":"isort","text":"Integer","category":"page"},{"location":"ch04/p_isort.html","page":"isort","title":"isort","text":"Default value","category":"page"},{"location":"ch04/p_isort.html","page":"isort","title":"isort","text":"1","category":"page"},{"location":"ch04/p_isort.html","page":"isort","title":"isort","text":"Component","category":"page"},{"location":"ch04/p_isort.html","page":"isort","title":"isort","text":"Only for the GARDENIA, NARCISSUS, LAVENDER, CAMELLIA, and MANJUSHAKA components.","category":"page"},{"location":"ch04/p_isort.html","page":"isort","title":"isort","text":"Behavior","category":"page"},{"location":"ch04/p_isort.html","page":"isort","title":"isort","text":"There are six possible values for isort parameter so far:","category":"page"},{"location":"ch04/p_isort.html","page":"isort","title":"isort","text":"isort = 1, the standard method is used to measure G(tau).\nisort = 2, the Legendre orthogonal polynomials trick is used to measure G(tau).\nisort = 3, the Chebyshev orthogonal polynomials trick is used to measure G(tau).\nisort = 4, the standard method is used to measure G(tau) and F(tau).\nisort = 5, the Legendre orthogonal polynomials trick is used to measure G(tau) and F(tau).\nisort = 6, the Chebyshev orthogonal polynomials trick is used to measure G(tau) and F(tau).","category":"page"},{"location":"ch04/p_isort.html","page":"isort","title":"isort","text":"Here G(tau) is the imaginary-time Green's function and F(tau) auxiliary imaginary-time function which can be used to calculate Sigma(iomega_n) analytically. ","category":"page"},{"location":"ch04/p_isort.html","page":"isort","title":"isort","text":"Sigma(iomega_n) = fracF(iomega_n)G(iomega_n)","category":"page"},{"location":"ch04/p_isort.html","page":"isort","title":"isort","text":"If the orthogonal polynomials trick is used, the G(tau) and F(tau) are expanded using orthogonal polynomials. And then the expansion coefficients are measured during Monte Carlo sampling procedure. Finally, according the expansion coefficients the G(tau) and F(tau) can be calculated analytically.","category":"page"},{"location":"ch04/p_isort.html","page":"isort","title":"isort","text":"The expansion series are defined by the chmax, chgrd, lemax, and legrd parameters.","category":"page"},{"location":"ch04/p_isort.html","page":"isort","title":"isort","text":"The GARDENIA and NARCISSUS components support all of the six possible values of isort. However, in the LAVENDER, CAMELLIA, and MANJUSHAKA components, isort must be less than or equal to 3. In order words, the improved estimator for self-energy function was not implemented in the LAVENDER, CAMELLIA, and MANJUSHAKA components.","category":"page"},{"location":"ch04/p_isort.html","page":"isort","title":"isort","text":"Comment","category":"page"},{"location":"ch04/p_isort.html","page":"isort","title":"isort","text":"See chmax, chgrd, lemax, and legrd parameters for more details.","category":"page"},{"location":"ch09/coulomb.html#Coulomb-interaction","page":"Coulomb interaction matrix","title":"Coulomb interaction","text":"","category":"section"},{"location":"ch09/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"The standard form of Coulomb interaction in second quantization form is:","category":"page"},{"location":"ch09/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"beginequation\nhatH_U=frac12sum_sigmasigma^primesum_abcd\nleftlangle asigmabsigma^primeleftfrac1r_12rightcsigmadsigma^primerightrangle\nhatf_asigma^daggerhatf_bsigma^prime^daggerhatf_dsigma^primehatf_csigma\nendequation","category":"page"},{"location":"ch09/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"beginequation\nleftlangle asigmabsigma^primeleftfrac1r_12rightcsigmadsigma^primerightrangle=\nint dvecr_1dvecr_2phi_alphasigma^*(vecr_1)phi_bsigma^prime^*(vecr_2)frac1r_12phi_csigma\n(vecr_1)phi_dsigma^prime(vecr_2)\nendequation","category":"page"},{"location":"ch09/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"where, frac1r_12 is the Coulomb interaction, r_12=vecr_1-vecr_2, abcd is orbital index and sigmasigma^prime=uparrowdownarrow is spin index. In the JASMINE component, we use a array UMAT to store the U tensor. BE VERY CAREFUL WITH THE ORBITAL ORDER. The indices order of UMAT is the same with that of the fermion operators, it is NOT the same with that of the U tensor.","category":"page"},{"location":"ch09/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"Slater Type","category":"page"},{"location":"ch09/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"Expand frac1r_12 in terms of complex spherical harmonics Y_l^m,","category":"page"},{"location":"ch09/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"beginequation\nfrac1r_12=sum_kfracr_^kr_^k+1sum_m(-1)^mC_m^k(theta_1phi_1)C_-m^k(theta_2phi_2)\nendequation","category":"page"},{"location":"ch09/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"where, ","category":"page"},{"location":"ch09/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"C_m^k(thetaphi)=sqrtfrac4pi2k+1Y_l^m(thetaphi)","category":"page"},{"location":"ch09/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"Set phi(vecr)=R_nl(r)Y_l^m(thetaphi), then for fixed nl, we obtain,","category":"page"},{"location":"ch09/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"beginalign\nleftlangle m_1m_2leftfrac1r_12rightm_1^primem_2^primerightrangle  =  sum_km(-1)^mc_l^k(m_1m_1^prime)c_l^k(m_2m_2^prime)delta(m+m_1^primem_1)delta(-m+m_2^primem_2)F_nl^k \n  =  delta(m_1+m_2m_1^prime+m_2^prime)(-1)^m_2^prime-m_2sum_kc_l^k(m_1m_1^prime)c_l^k(m_2m_2^prime)F_nl^k \n  =  delta(m_1+m_2m_1^prime+m_2^prime)sum_kc_l^k(m_1m_1^prime)c_l^k(m_2^primem_2)F_nl^k\nendalign","category":"page"},{"location":"ch09/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"where, ","category":"page"},{"location":"ch09/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"beginequation\nc_l^k(m^primem^primeprime)=int dphi dtheta sin(theta)Y_l^m^prime*(thetaphi)C_m^prime-m^primeprime^k(thetaphi)Y_l^m^primeprime(thetaphi)\nendequation","category":"page"},{"location":"ch09/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"is the Gaunt coefficient for fixed l, and","category":"page"},{"location":"ch09/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"beginequation\nF_nl^k=int_0^inftyr_1^2dr_1int_0^inftyr_2^2dr_2R_nl^2(r_1)R_nl^2(r_2)fracr_^kr_^k+1\nendequation","category":"page"},{"location":"ch09/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"is the Slater integrals.","category":"page"},{"location":"ch09/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"In this single particle basis, the Coulomb interaction Hamiltonian is:","category":"page"},{"location":"ch09/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"beginequation\nhatH_U=frac12sum_m_1m_2m_1^primem_2^primesigmasigma^primeleftlangle m_1sigmam_2sigma^primeleftfrac1r_12rightm_1^primesigmam_2^primesigma^primerightrangle hatf_m_1sigma^daggerhatf_m_2sigma^prime^daggerhatf_m_2^primesigma^primehatf_m_1^primesigma\nendequation","category":"page"},{"location":"ch09/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"where, sigmasigma^prime is spin index. Set ","category":"page"},{"location":"ch09/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"alpha=m_1sigma beta=m_2sigma^prime gamma=m_1^primesigma delta=m_2^primesigma^prime","category":"page"},{"location":"ch09/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"thus the UMAT in the JASMINE component reads:","category":"page"},{"location":"ch09/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"beginequation\ntextbfUMAT(alphabetadeltagamma)=frac12delta(m_1+m_2m_1^prime+m_2^prime)sum_kc_l^k(m_1m_1^prime)c_l^k(m_2^primem_2)F_nl^k\nendequation","category":"page"},{"location":"ch09/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"Kanamori Type","category":"page"},{"location":"ch09/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"The Kanomori type of Coulomb interaction Hamiltonian in the JASMINE component is defined as:","category":"page"},{"location":"ch09/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"beginalign\nhatH_U  =  Usum_ahatf_auparrow^daggerhatf_auparrowhatf_adownarrow^daggerhatf_adownarrow\n  =  U^primesum_atextbsigmahatf_asigma^daggerhatf_asigmahatf_b-sigma^daggerhatf_b-sigma\n  + (U^prime-J_z)sum_absigmahatf_asigma^daggerhatf_asigmahatf_bsigma^daggerhatf_bsigma\n  -  J_ssum_absigmahatf_asigma^daggerhatf_a-sigmahatf_b-sigma^daggerhatf_bsigma\n  +  J_psum_aneq bhatf_auparrow^daggerhatf_adownarrow^daggerhatf_bdownarrowhatf_buparrow\nendalign","category":"page"},{"location":"ch09/coulomb.html","page":"Coulomb interaction matrix","title":"Coulomb interaction matrix","text":"where, ab is orbital index, and sigma=uparrowdownarrow is spin index.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: header image)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"<h1>\nReference Manual <font face = 'times'><i>for</i></font> <br/> <font color = 'purple'>I</font>nteracting <font color = 'orange'>Q</font>uantum <font color = 'orange'>I</font>mpurity <font color = 'orange'>S</font>olver <font color = 'orange'>T</font>oolkit\n</h1>","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Draft Version January 20, 2017 (in progress)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Written by:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Li Huang, Yilin Wang, Haiyan Lu, Liang Du, and Zi Yang Meng","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Obi-Wan Kenobi: \n\n    1. Use the Manual, Luke! (To Luke Skywalker)\n\n    2. May the Manual be with you. (To Anakin Skywalker)","category":"page"},{"location":"ch04/out_nmat.html#solver.nmat.dat","page":"solver.nmat.dat","title":"solver.nmat.dat","text":"","category":"section"},{"location":"ch04/out_nmat.html","page":"solver.nmat.dat","title":"solver.nmat.dat","text":"Introduction","category":"page"},{"location":"ch04/out_nmat.html","page":"solver.nmat.dat","title":"solver.nmat.dat","text":"The solver.nmat.dat file is used to memory the impurity occupancy and double occupancy matrix. It will be output by the quantum impurity solvers when they stop working.","category":"page"},{"location":"ch04/out_nmat.html","page":"solver.nmat.dat","title":"solver.nmat.dat","text":"Format","category":"page"},{"location":"ch04/out_nmat.html","page":"solver.nmat.dat","title":"solver.nmat.dat","text":"The solver.nmat.dat file contains two blocks. One is for the impurity occupancy langle n_irangle, and another one is for the double occupancy matrix langle n_i n_jrangle. In each block, the error bar data are always shown in the rightmost column.","category":"page"},{"location":"ch04/out_nmat.html","page":"solver.nmat.dat","title":"solver.nmat.dat","text":"note: Note\nIn the solver.nmat.dat file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch04/out_nmat.html","page":"solver.nmat.dat","title":"solver.nmat.dat","text":"Code","category":"page"},{"location":"ch04/out_nmat.html","page":"solver.nmat.dat","title":"solver.nmat.dat","text":"The corresponding Fortran code block for the writing of solver.nmat.dat file is as follows:","category":"page"},{"location":"ch04/out_nmat.html","page":"solver.nmat.dat","title":"solver.nmat.dat","text":"! open data file: solver.nmat.dat\n     open(mytmp, file='solver.nmat.dat', form='formatted', status='unknown')\n\n! write it\n     write(mytmp,'(a)') '#   < n_i >   data:'\n     do i=1,norbs\n         write(mytmp,'(i6,2f12.6)') i, nmat(i), nerr(i)\n     enddo ! over i={1,norbs} loop\n     write(mytmp,'(a6,2f12.6)') 'sup', sum( nmat(1:nband) ), sum( nerr(1:nband) )\n     write(mytmp,'(a6,2f12.6)') 'sdn', sum( nmat(nband+1:norbs) ), sum( nerr(nband+1:norbs) )\n     write(mytmp,'(a6,2f12.6)') 'sum', sum( nmat(1:norbs) ), sum( nerr(1:norbs) )\n\n     write(mytmp,'(a)') '# < n_i n_j > data:'\n     do i=1,norbs\n         do j=1,norbs\n             write(mytmp,'(2i6,2f12.6)') i, j, nnmat(i,j), nnerr(i,j)\n         enddo ! over j={1,norbs} loop\n     enddo ! over i={1,norbs} loop\n\n! close data file\n     close(mytmp)","category":"page"},{"location":"ch04/out_nmat.html","page":"solver.nmat.dat","title":"solver.nmat.dat","text":"In the HIBISCUS component, we provide a Python module to read the output files of quantum impurity solvers. You can use it to read the solver.nmat.dat file. See script/u_reader.py for more details.","category":"page"},{"location":"ch06/p_nmaxi.html#Parameter:-nmaxi","page":"nmaxi","title":"Parameter: nmaxi","text":"","category":"section"},{"location":"ch06/p_nmaxi.html","page":"nmaxi","title":"nmaxi","text":"Definition","category":"page"},{"location":"ch06/p_nmaxi.html","page":"nmaxi","title":"nmaxi","text":"The maximal total occupancy N which will be kept in the construction of atomic eigenstates.","category":"page"},{"location":"ch06/p_nmaxi.html","page":"nmaxi","title":"nmaxi","text":"Type","category":"page"},{"location":"ch06/p_nmaxi.html","page":"nmaxi","title":"nmaxi","text":"Integer","category":"page"},{"location":"ch06/p_nmaxi.html","page":"nmaxi","title":"nmaxi","text":"Default value","category":"page"},{"location":"ch06/p_nmaxi.html","page":"nmaxi","title":"nmaxi","text":"2","category":"page"},{"location":"ch06/p_nmaxi.html","page":"nmaxi","title":"nmaxi","text":"Component","category":"page"},{"location":"ch06/p_nmaxi.html","page":"nmaxi","title":"nmaxi","text":"Only for the JASMINE component.","category":"page"},{"location":"ch06/p_nmaxi.html","page":"nmaxi","title":"nmaxi","text":"Behavior","category":"page"},{"location":"ch06/p_nmaxi.html","page":"nmaxi","title":"nmaxi","text":"Those atomic states in which the total occupancy N in textnmini textnmaxi will be kept. The other atomic states will be discarded. It is an aggressive truncation and may led to significant derivations.","category":"page"},{"location":"ch06/p_nmaxi.html","page":"nmaxi","title":"nmaxi","text":"Comment","category":"page"},{"location":"ch06/p_nmaxi.html","page":"nmaxi","title":"nmaxi","text":"See also nmini parameter for more details.","category":"page"},{"location":"ch02/obtain.html#Obtain","page":"Obtain","title":"Obtain","text":"","category":"section"},{"location":"ch02/obtain.html","page":"Obtain","title":"Obtain","text":"The first rule of thumb is to get the newest version of iQIST. Unfortunately, the release period for the iQIST software package is not fixed. In other words, it is very difficult to predict that when the new generation of iQIST will be released. There are two ways to get the newest release of iQIST software package.","category":"page"},{"location":"ch02/obtain.html","page":"Obtain","title":"Obtain","text":"Method 1:","category":"page"},{"location":"ch02/obtain.html","page":"Obtain","title":"Obtain","text":"Download it directly from the online repository. Now we ONLY maintain two repositories:","category":"page"},{"location":"ch02/obtain.html","page":"Obtain","title":"Obtain","text":"Bitbucket (preferred)\nGithub (mirror)","category":"page"},{"location":"ch02/obtain.html","page":"Obtain","title":"Obtain","text":"The newest release of iQIST software package is v0.6.7 @ 2016.02.13T (testing).","category":"page"},{"location":"ch02/obtain.html","page":"Obtain","title":"Obtain","text":"note: Note\nSometimes the latest commit will not be compiled correctly. So, please download the released version of iQIST which has an unique version tag.","category":"page"},{"location":"ch02/obtain.html","page":"Obtain","title":"Obtain","text":"Method 2:","category":"page"},{"location":"ch02/obtain.html","page":"Obtain","title":"Obtain","text":"Write a letter to one of the core members of the iQIST Developer Team (iDT), i.e., ","category":"page"},{"location":"ch02/obtain.html","page":"Obtain","title":"Obtain","text":"Dr. Li HUANG ","category":"page"},{"location":"ch02/obtain.html","page":"Obtain","title":"Obtain","text":"and ","category":"page"},{"location":"ch02/obtain.html","page":"Obtain","title":"Obtain","text":"Dr. Yilin WANG","category":"page"},{"location":"ch02/obtain.html","page":"Obtain","title":"Obtain","text":"As for the relevant contact information, please see Policy.","category":"page"},{"location":"ch06/in_tmat.html#atom.tmat.in","page":"atom.tmat.in","title":"atom.tmat.in","text":"","category":"section"},{"location":"ch06/in_tmat.html","page":"atom.tmat.in","title":"atom.tmat.in","text":"Introduction","category":"page"},{"location":"ch06/in_tmat.html","page":"atom.tmat.in","title":"atom.tmat.in","text":"The purpose of the atom.tmat.in file is to supply the transformation matrix mathcalT_alphabeta, which transforms an operator from its original basis to the natural basis. Only when ibasis = 2, the atom.tmat.in file is used. See ibasis for more details.","category":"page"},{"location":"ch06/in_tmat.html","page":"atom.tmat.in","title":"atom.tmat.in","text":"Format","category":"page"},{"location":"ch06/in_tmat.html","page":"atom.tmat.in","title":"atom.tmat.in","text":"The format of the atom.tmat.in file is as follows:","category":"page"},{"location":"ch06/in_tmat.html","page":"atom.tmat.in","title":"atom.tmat.in","text":"","category":"page"},{"location":"ch06/in_tmat.html","page":"atom.tmat.in","title":"atom.tmat.in","text":"column 1: orbital index alpha, integer","category":"page"},{"location":"ch06/in_tmat.html","page":"atom.tmat.in","title":"atom.tmat.in","text":"column 2: orbital index beta, integer","category":"page"},{"location":"ch06/in_tmat.html","page":"atom.tmat.in","title":"atom.tmat.in","text":"column 3: Elements of the transformation matrix mathcalT_alphabeta, double precision","category":"page"},{"location":"ch06/in_tmat.html","page":"atom.tmat.in","title":"atom.tmat.in","text":"","category":"page"},{"location":"ch06/in_tmat.html","page":"atom.tmat.in","title":"atom.tmat.in","text":"note: Note\nIn the atom.tmat.in file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch06/in_tmat.html","page":"atom.tmat.in","title":"atom.tmat.in","text":"Code","category":"page"},{"location":"ch06/in_tmat.html","page":"atom.tmat.in","title":"atom.tmat.in","text":"The corresponding Fortran code block for the reading of the atom.tmat.in file is as follows:","category":"page"},{"location":"ch06/in_tmat.html","page":"atom.tmat.in","title":"atom.tmat.in","text":"! open file atom.tmat.in\n     open(mytmp, file='atom.tmat.in', form='formatted', status='unknown')\n\n! read the data file\n     do i=1,norbs\n         do j=1,norbs\n             read(mytmp,*) i1, i2, raux\n! tmat is actually real\n             tmat(j,i) = dcmplx(raux, zero)\n         enddo ! over j={1,norbs} loop\n     enddo ! over i={1,norbs} loop\n\n! close data file\n     close(mytmp)","category":"page"},{"location":"ch06/in_tmat.html","page":"atom.tmat.in","title":"atom.tmat.in","text":"In principle, the transformation matrix is complex. Here we think that its imaginary part is zero and only take the real part into consideration.","category":"page"},{"location":"ch04/p_nsweep.html#Parameter:-nsweep","page":"nsweep","title":"Parameter: nsweep","text":"","category":"section"},{"location":"ch04/p_nsweep.html","page":"nsweep","title":"nsweep","text":"Definition","category":"page"},{"location":"ch04/p_nsweep.html","page":"nsweep","title":"nsweep","text":"Maximum number of quantum Monte Carlo sampling steps.","category":"page"},{"location":"ch04/p_nsweep.html","page":"nsweep","title":"nsweep","text":"Type","category":"page"},{"location":"ch04/p_nsweep.html","page":"nsweep","title":"nsweep","text":"Integer","category":"page"},{"location":"ch04/p_nsweep.html","page":"nsweep","title":"nsweep","text":"Default value","category":"page"},{"location":"ch04/p_nsweep.html","page":"nsweep","title":"nsweep","text":"20000000 (for CT-HYB impurity solvers) or 240000 (for HF-QMC impurity solver)","category":"page"},{"location":"ch04/p_nsweep.html","page":"nsweep","title":"nsweep","text":"Component","category":"page"},{"location":"ch04/p_nsweep.html","page":"nsweep","title":"nsweep","text":"ALL","category":"page"},{"location":"ch04/p_nsweep.html","page":"nsweep","title":"nsweep","text":"Behavior","category":"page"},{"location":"ch04/p_nsweep.html","page":"nsweep","title":"nsweep","text":"This is the number of Monte Carlo sampling steps conducted by the current process. If you run the quantum impurity solvers parallelly with N_textprocs processes, then the total number of Monte Carlo sampling steps in the calculation is ","category":"page"},{"location":"ch04/p_nsweep.html","page":"nsweep","title":"nsweep","text":"N_textprocs times textnsweep","category":"page"},{"location":"ch04/p_nsweep.html","page":"nsweep","title":"nsweep","text":"Larger the nsweep is, more accurate and more time-consuming the calculation is. If you conduct the quantum impurity solver on many cores, you can decrease nsweep. But the minimal value of it should not be less than its default value. ","category":"page"},{"location":"ch04/p_nsweep.html","page":"nsweep","title":"nsweep","text":"Comment","category":"page"},{"location":"ch04/p_nsweep.html","page":"nsweep","title":"nsweep","text":"In order to improve the numerical quality and suppress the numerical noise, the most direct and practicable route is to increase nsweep.","category":"page"},{"location":"ch04/p_nsweep.html","page":"nsweep","title":"nsweep","text":"If the data binning mode is activated, nsweep should not be larger than 200000000.","category":"page"},{"location":"ch04/p_nsweep.html","page":"nsweep","title":"nsweep","text":"nsweep should be always larger than ntherm, nwrite, nmonte, and ncarlo.","category":"page"},{"location":"ch04/p_nsweep.html","page":"nsweep","title":"nsweep","text":"See also ntherm, nwrite, nmonte, ncarlo parameters for more details.","category":"page"},{"location":"ch02/README.html#Installation","page":"README","title":"Installation","text":"","category":"section"},{"location":"ch02/README.html","page":"README","title":"README","text":"Are you interested in the iQIST software package? ","category":"page"},{"location":"ch02/README.html","page":"README","title":"README","text":"Yes? Do you have passion for iQIST and want to have a try?","category":"page"},{"location":"ch02/README.html","page":"README","title":"README","text":"Yes? Great!","category":"page"},{"location":"ch02/README.html","page":"README","title":"README","text":"In this chapter, we will guide you to compile and install the iQIST software package step by step. Supposing that you have installed the iQIST software package successfully, you can skip this chapter and go to the next one.","category":"page"},{"location":"ch02/README.html","page":"README","title":"README","text":"Basic recipes:","category":"page"},{"location":"ch02/README.html","page":"README","title":"README","text":"Obtain // How to get the source codes?\nUncompress // Hmm, un-tar it.\nDirectory structures // Where are the quantum impurity solvers?\nCompiling environment // Fortran compiler and math library.\nCompiling system // How to make it?\nBuild iQIST at one step // Quickly build.","category":"page"},{"location":"ch02/README.html","page":"README","title":"README","text":"Advanced recipes:","category":"page"},{"location":"ch02/README.html","page":"README","title":"README","text":"Build base library // Many common modules and subroutines.\nBuild application programming interfaces // APIs.\nBuild quantum impurity solvers // Core components.\nBuild applications // not ready now!, ð\nBuild atomic eigenvalues solver // Companion of the quantum impurity solvers.\nBuild auxiliary tools // Post- and prep-processing tools.\nBuild libraries for Fortran // Get binary library used by your own Fortran codes.\nBuild modules for Python // Get Python modules.","category":"page"},{"location":"ch02/README.html","page":"README","title":"README","text":"note: Note\nWe assume that you are familiar with the basic terminal commands/operations of Linux system.\nWe assume that the root directory of the iQIST software package is just iqist in the manual, except stated explicitly. For example, if the iQIST software package was installed at /home/lihuang/iqist2016, then we just use iqist to denote this directory.","category":"page"},{"location":"ch04/out_ochi.html#solver.ochi.dat","page":"solver.ochi.dat","title":"solver.ochi.dat","text":"","category":"section"},{"location":"ch04/out_ochi.html","page":"solver.ochi.dat","title":"solver.ochi.dat","text":"Introduction","category":"page"},{"location":"ch04/out_ochi.html","page":"solver.ochi.dat","title":"solver.ochi.dat","text":"The solver.ochi.dat file is used to store the orbital-orbital correlation function in time space, chi_textcharge(tau) = langle n(0)n(tau)rangle. It will be output by the quantum impurity solvers when they are shut down.","category":"page"},{"location":"ch04/out_ochi.html","page":"solver.ochi.dat","title":"solver.ochi.dat","text":"note: Note\nOnly the GARDENIA and NARCISSUS components can generate the solver.ochi.dat file.","category":"page"},{"location":"ch04/out_ochi.html","page":"solver.ochi.dat","title":"solver.ochi.dat","text":"Format","category":"page"},{"location":"ch04/out_ochi.html","page":"solver.ochi.dat","title":"solver.ochi.dat","text":"The solver.ochi.dat file contains a few (norbstimesnorbs + 2) blocks. The first norbstimesnorbs blocks are orbital-resolved orbital-orbital correlation functions. The next block is the total orbital-orbital correlation function. The final block is the sum of orbital-resolved orbital-orbital correlation functions. Each block is appended by two blank lines. In each block, the error bar data are always shown in the rightmost column.","category":"page"},{"location":"ch04/out_ochi.html","page":"solver.ochi.dat","title":"solver.ochi.dat","text":"note: Note\nIn the solver.ochi.dat file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch04/out_ochi.html","page":"solver.ochi.dat","title":"solver.ochi.dat","text":"Code","category":"page"},{"location":"ch04/out_ochi.html","page":"solver.ochi.dat","title":"solver.ochi.dat","text":"The corresponding Fortran code block for the writing of solver.ochi.dat file is as follows:","category":"page"},{"location":"ch04/out_ochi.html","page":"solver.ochi.dat","title":"solver.ochi.dat","text":"! open data file: solver.ochi.dat\n     open(mytmp, file='solver.ochi.dat', form='formatted', status='unknown')\n\n! write it\n     do k=1,norbs\n         do j=1,norbs\n             write(mytmp,'(2(a,i6))') '# flvr:', j, '  flvr:', k\n             do i=1,ntime\n                 write(mytmp,'(3f12.6)') tmesh(i), oochi(i,j,k), ooerr(i,j,k)\n             enddo ! over i={1,ntime} loop\n             write(mytmp,*) ! write empty lines\n             write(mytmp,*)\n         enddo ! over j={1,norbs} loop\n     enddo ! over k={1,norbs} loop\n\n     write(mytmp,'(a,i6)') '# flvr:', 8888\n     do i=1,ntime\n         write(mytmp,'(3f12.6)') tmesh(i), ochi(i), oerr(i) \n     enddo ! over i={1,ntime} loop\n     write(mytmp,*) ! write empty lines\n     write(mytmp,*)\n\n     write(mytmp,'(a,i6)') '# flvr:', 9999\n     do i=1,ntime\n         write(mytmp,'(3f12.6)') tmesh(i), sum( oochi(i,:,:) ), sum( ooerr(i,:,:) ) \n     enddo ! over i={1,ntime} loop\n     write(mytmp,*) ! write empty lines\n     write(mytmp,*)\n\n! close data file\n     close(mytmp)","category":"page"},{"location":"ch04/out_ochi.html","page":"solver.ochi.dat","title":"solver.ochi.dat","text":"In the HIBISCUS component, we provide a Python module to read the output files of quantum impurity solvers. You can use it to read the solver.ochi.dat file. See script/u_reader.py for more details.","category":"page"},{"location":"ch06/p_icf.html#Parameter:-icf","page":"icf","title":"Parameter: icf","text":"","category":"section"},{"location":"ch06/p_icf.html","page":"icf","title":"icf","text":"Definition","category":"page"},{"location":"ch06/p_icf.html","page":"icf","title":"icf","text":"Key control flag, to define the type of crystal field splitting.","category":"page"},{"location":"ch06/p_icf.html","page":"icf","title":"icf","text":"Type","category":"page"},{"location":"ch06/p_icf.html","page":"icf","title":"icf","text":"Integer","category":"page"},{"location":"ch06/p_icf.html","page":"icf","title":"icf","text":"Default value","category":"page"},{"location":"ch06/p_icf.html","page":"icf","title":"icf","text":"0","category":"page"},{"location":"ch06/p_icf.html","page":"icf","title":"icf","text":"Component","category":"page"},{"location":"ch06/p_icf.html","page":"icf","title":"icf","text":"Only for the JASMINE component.","category":"page"},{"location":"ch06/p_icf.html","page":"icf","title":"icf","text":"Behavior","category":"page"},{"location":"ch06/p_icf.html","page":"icf","title":"icf","text":"There are three possible values for the icf parameter:","category":"page"},{"location":"ch06/p_icf.html","page":"icf","title":"icf","text":"icf = 0, no crystal field splitting.\nicf = 1, diagonal crystal field splitting.\nicf = 2, non-diagonal crystal field splitting.","category":"page"},{"location":"ch06/p_icf.html","page":"icf","title":"icf","text":"Comment","category":"page"},{"location":"ch06/p_icf.html","page":"icf","title":"icf","text":"The crystal field splitting can be read from the atom.cmat.in file. See also atom.cmat.in for more details.","category":"page"},{"location":"ch04/p_nmonte.html#Parameter:-nmonte","page":"nmonte","title":"Parameter: nmonte","text":"","category":"section"},{"location":"ch04/p_nmonte.html","page":"nmonte","title":"nmonte","text":"Definition","category":"page"},{"location":"ch04/p_nmonte.html","page":"nmonte","title":"nmonte","text":"How many Monte Carlo sampling steps the physical observables should be measured.","category":"page"},{"location":"ch04/p_nmonte.html","page":"nmonte","title":"nmonte","text":"Type","category":"page"},{"location":"ch04/p_nmonte.html","page":"nmonte","title":"nmonte","text":"Integer","category":"page"},{"location":"ch04/p_nmonte.html","page":"nmonte","title":"nmonte","text":"Default value","category":"page"},{"location":"ch04/p_nmonte.html","page":"nmonte","title":"nmonte","text":"10","category":"page"},{"location":"ch04/p_nmonte.html","page":"nmonte","title":"nmonte","text":"Component","category":"page"},{"location":"ch04/p_nmonte.html","page":"nmonte","title":"nmonte","text":"For all components except for the DAISY component.","category":"page"},{"location":"ch04/p_nmonte.html","page":"nmonte","title":"nmonte","text":"Behavior","category":"page"},{"location":"ch04/p_nmonte.html","page":"nmonte","title":"nmonte","text":"Every nmonte Monte Carlo sampling steps, the quantum impurity solvers try to measure the physical observables. The affected physical observables are as follows:","category":"page"},{"location":"ch04/p_nmonte.html","page":"nmonte","title":"nmonte","text":"Impurity occupancy, langle n_alpha rangle, langle n_alphan_beta rangle,\nImpurity Matsubara Green's function, G(iomega_n),\nSpin-spin correlation function, langle S_z(0) S_z(tau) rangle, chi_textsp(inu_n),\nOrbital-orbital correlation function, langle n_alpha(0) n_beta(tau)rangle, chi_textch(inu_n),\nMomentum of kinetic energy, langle k^2 rangle - langle k rangle^2,\nFidelity susceptibility, langle k_L k_R rangle - langle k_L rangle langle k_R rangle,\nTwo-particle Green's function, chi(iomega_niomega_ninu_n),\nTwo-particle vertex function, mathcalF(iomega_niomega_ninu_n),\nPairing susceptibility, Gamma(iomega_niomega_ninu_n),.","category":"page"},{"location":"ch04/p_nmonte.html","page":"nmonte","title":"nmonte","text":"The measuring period for the other physical observables are controlled by the ncarlo parameter. See also ncarlo parameter for more details.","category":"page"},{"location":"ch04/p_nmonte.html","page":"nmonte","title":"nmonte","text":"note: Note\nThe histogram for the perturbation expansion series is measured in each Monte Carlo sampling step.","category":"page"},{"location":"ch04/p_nmonte.html","page":"nmonte","title":"nmonte","text":"Comment","category":"page"},{"location":"ch04/p_nmonte.html","page":"nmonte","title":"nmonte","text":"You can increase nmonte to relieve the auto-correlation of physical observables between two successive measurements. However, large nmonte will waste the CPU times. It is recommended that a good nmonte should satisfy the following relation:","category":"page"},{"location":"ch04/p_nmonte.html","page":"nmonte","title":"nmonte","text":"textnmonte * textP_textinsert = 10","category":"page"},{"location":"ch04/p_nmonte.html","page":"nmonte","title":"nmonte","text":"Here, textP_textinsert means the accepted ratio for the insert update actions.","category":"page"},{"location":"ch10/README.html#Typical-examples","page":"Typical examples","title":"Typical examples","text":"","category":"section"},{"location":"ch10/README.html","page":"Typical examples","title":"Typical examples","text":"This chapter includes examples from basic application to real material calculation, which are recommended for the users to master the usage of iQIST.","category":"page"},{"location":"ch10/README.html","page":"Typical examples","title":"Typical examples","text":"We start from the half filled single Hubbard band model based on bethe lattice. And then we will illustrate the Mott transition through increasing Coulomb interaction strength. After that we would like to introduce the advanced physics by considering the general interaction and dynamical screening effect, etc. Finally, real material calculation will be addressed. Especially, the input and output files mentioned in previous chapters will be given in these examples. Postprocessing tools are in detailed description and figures are plotted to show the physics. ","category":"page"},{"location":"ch10/README.html","page":"Typical examples","title":"Typical examples","text":"Hope you enjoy these typical examples listed below to begin a new journey of learning and using iQIST.","category":"page"},{"location":"ch04/in_ktau.html#solver.ktau.in","page":"solver.ktau.in","title":"solver.ktau.in","text":"","category":"section"},{"location":"ch04/in_ktau.html","page":"solver.ktau.in","title":"solver.ktau.in","text":"Introduction","category":"page"},{"location":"ch04/in_ktau.html","page":"solver.ktau.in","title":"solver.ktau.in","text":"The solver.ktau.in is used to store the screening function K(tau) and its derivates K(tau) in imaginary-time space. It is only useful for the NARCISSUS component.","category":"page"},{"location":"ch04/in_ktau.html","page":"solver.ktau.in","title":"solver.ktau.in","text":"note: Note\nOnly when isscr = 99, the solver.ktau.in is essential for the NARCISSUS component. See isscr for more details.","category":"page"},{"location":"ch04/in_ktau.html","page":"solver.ktau.in","title":"solver.ktau.in","text":"Format","category":"page"},{"location":"ch04/in_ktau.html","page":"solver.ktau.in","title":"solver.ktau.in","text":"The format of the solver.ktau.in file is as follows:","category":"page"},{"location":"ch04/in_ktau.html","page":"solver.ktau.in","title":"solver.ktau.in","text":"","category":"page"},{"location":"ch04/in_ktau.html","page":"solver.ktau.in","title":"solver.ktau.in","text":"column 1: imaginary-time point, tau, double precision","category":"page"},{"location":"ch04/in_ktau.html","page":"solver.ktau.in","title":"solver.ktau.in","text":"column 2: screening function, K(tau), double precision","category":"page"},{"location":"ch04/in_ktau.html","page":"solver.ktau.in","title":"solver.ktau.in","text":"column 3: the first derivates of screening function, K(tau), double precision","category":"page"},{"location":"ch04/in_ktau.html","page":"solver.ktau.in","title":"solver.ktau.in","text":"","category":"page"},{"location":"ch04/in_ktau.html","page":"solver.ktau.in","title":"solver.ktau.in","text":"In principle, K(tau) and K(tau) should be orbital-dependent. However in the NARCISSUS component, for the sake of simplicity, we treat them as orbital-independent vectors.","category":"page"},{"location":"ch04/in_ktau.html","page":"solver.ktau.in","title":"solver.ktau.in","text":"Code","category":"page"},{"location":"ch04/in_ktau.html","page":"solver.ktau.in","title":"solver.ktau.in","text":"The corresponding Fortran code block for the reading of solver.ktau.in file is as follows:","category":"page"},{"location":"ch04/in_ktau.html","page":"solver.ktau.in","title":"solver.ktau.in","text":"open(mytmp, file='solver.ktau.in', form='formatted', status='unknown')\nread(mytmp,*) ! skip one line\ndo i=1,ntime\n    read(mytmp,*) rtmp, ktau(i), ptau(i)\nenddo ! over i={1,ntime} loop\nclose(mytmp)","category":"page"},{"location":"ch04/in_ktau.html","page":"solver.ktau.in","title":"solver.ktau.in","text":"For some typical models, the solver.ktau.in file can be generated using the toolbox/makescr tool which is included in the HIBISCUS component. See toolbox/makescr for more details.","category":"page"},{"location":"ch09/platform.html#Development-platform","page":"Development platform","title":"Development platform","text":"","category":"section"},{"location":"ch09/platform.html","page":"Development platform","title":"Development platform","text":"Programming languages","category":"page"},{"location":"ch09/platform.html","page":"Development platform","title":"Development platform","text":"The main part of the iQIST software package was developed with the modern Fortran 90 language. We extensively used advanced language features in the Fortran 2003/2008 standard such as an object oriented programming style (polymorphic, inheritance, and module, etc.) to improve the readability and re-usability of the source codes. The compilers are fixed to the Intel Fortran compiler and GNU GCC gfortran. We can not guarantee that the iQIST can be compiled successfully with other Fortran compilers. Some auxiliary scripts, pre- and post-processing tools are written using the Python language and Bash shell scripts. These scripts and tools act like a glue. They are very flexible and very easily extended or adapted to deal with various problems. In order to avoid incompatibilities, our Python codes only run on the Python 2.x runtime environment.","category":"page"},{"location":"ch09/platform.html","page":"Development platform","title":"Development platform","text":"Version control system","category":"page"},{"location":"ch09/platform.html","page":"Development platform","title":"Development platform","text":"We use git as the version control tool, and the source codes are hosted in some remote servers. Many thanks to Bitbucket and Github for providing free code repository services. The developers pull the source codes from the server into their local machines, and then try to improve them. Once the development is done, the source codes can be pushed back to the server and merged with the master branch. Then the other developers can access them and use them immediately to start further developments. The members of our developer team and the other users can access the public code repository anywhere and anytime.","category":"page"},{"location":"ch09/platform.html","page":"Development platform","title":"Development platform","text":"The official code repositories are as follows:","category":"page"},{"location":"ch09/platform.html","page":"Development platform","title":"Development platform","text":"Bitbucket (preferred)\nGithub (mirror)","category":"page"},{"location":"ch08/swing.html#Analytical-continuation-for-Matsubara-self-energy-function","page":"Analytical continuation for Matsubara self-energy function","title":"Analytical continuation for Matsubara self-energy function","text":"","category":"section"},{"location":"ch04/p_isscf.html#Parameter:-isscf","page":"isscf","title":"Parameter: isscf","text":"","category":"section"},{"location":"ch04/p_isscf.html","page":"isscf","title":"isscf","text":"Definition","category":"page"},{"location":"ch04/p_isscf.html","page":"isscf","title":"isscf","text":"It is the most important control flag, which is used to control the running mode of the quantum impurity solvers. As mentioned before, the quantum impurity solvers in the iQIST software package contain a mini dynamical mean-field theory self-consistent engine, concerning the Hubbard model on a Bethe lattice. You can use the isscf parameter to control whether to active this self-consistent engine or not.","category":"page"},{"location":"ch04/p_isscf.html","page":"isscf","title":"isscf","text":"Type","category":"page"},{"location":"ch04/p_isscf.html","page":"isscf","title":"isscf","text":"Integer","category":"page"},{"location":"ch04/p_isscf.html","page":"isscf","title":"isscf","text":"Default value","category":"page"},{"location":"ch04/p_isscf.html","page":"isscf","title":"isscf","text":"1","category":"page"},{"location":"ch04/p_isscf.html","page":"isscf","title":"isscf","text":"Component","category":"page"},{"location":"ch04/p_isscf.html","page":"isscf","title":"isscf","text":"ALL","category":"page"},{"location":"ch04/p_isscf.html","page":"isscf","title":"isscf","text":"Behavior","category":"page"},{"location":"ch04/p_isscf.html","page":"isscf","title":"isscf","text":"There are two possible values for the isscf parameter so far:","category":"page"},{"location":"ch04/p_isscf.html","page":"isscf","title":"isscf","text":"isscf = 1, one-shot non-self-consistent scheme, usually used in local density approximation plus dynamical mean-field theory scenario. The internal dynamical mean-field theory self-consistent is disabled.\nisscf = 2, self-consistent scheme, used in standard Hubbard model (on Bethe lattice) plus dynamical mean-field theory scenario. The internal dynamical mean-field theory self-consistent engine is used.","category":"page"},{"location":"ch04/p_isscf.html","page":"isscf","title":"isscf","text":"Comment","category":"page"},{"location":"ch04/p_isscf.html","page":"isscf","title":"isscf","text":"The internal dynamical mean-field theory self-consistent engine is implemented in the ctqmc_dmft.f90. The experienced users can customize their own versions of it.","category":"page"},{"location":"ch04/p_isscf.html","page":"isscf","title":"isscf","text":"The isscf parameter is often used with the isbin parameter to implement some complex iterations. See isbin for more details.","category":"page"},{"location":"ch04/p_nbfrq.html#Parameter:-nbfrq","page":"nbfrq","title":"Parameter: nbfrq","text":"","category":"section"},{"location":"ch04/p_nbfrq.html","page":"nbfrq","title":"nbfrq","text":"Definition","category":"page"},{"location":"ch04/p_nbfrq.html","page":"nbfrq","title":"nbfrq","text":"Number of bosonic Matsubara frequency points for the two-particle green's function.","category":"page"},{"location":"ch04/p_nbfrq.html","page":"nbfrq","title":"nbfrq","text":"The two-particle Green's function chi(iomega_n iomega_n inu_n) and vertex function mathcalF(iomega_n iomega_n inu_n) have three frequency indices where omega_n and omega_n are fermionic frequencies, and nu_n bosonic frequency: ","category":"page"},{"location":"ch04/p_nbfrq.html","page":"nbfrq","title":"nbfrq","text":"nu_n = frac2npibeta","category":"page"},{"location":"ch04/p_nbfrq.html","page":"nbfrq","title":"nbfrq","text":"omega_n = frac(2n+1)pibeta","category":"page"},{"location":"ch04/p_nbfrq.html","page":"nbfrq","title":"nbfrq","text":"The nbfrq parameter is used to define and generate nu_n bosonic mesh. The corresponding omega_n fermionic mesh is defined by the nffrq parameter.","category":"page"},{"location":"ch04/p_nbfrq.html","page":"nbfrq","title":"nbfrq","text":"Type","category":"page"},{"location":"ch04/p_nbfrq.html","page":"nbfrq","title":"nbfrq","text":"Integer","category":"page"},{"location":"ch04/p_nbfrq.html","page":"nbfrq","title":"nbfrq","text":"Default value","category":"page"},{"location":"ch04/p_nbfrq.html","page":"nbfrq","title":"nbfrq","text":"8","category":"page"},{"location":"ch04/p_nbfrq.html","page":"nbfrq","title":"nbfrq","text":"Component","category":"page"},{"location":"ch04/p_nbfrq.html","page":"nbfrq","title":"nbfrq","text":"Only for the GARDENIA, NARCISSUS, CAMELLIA, LAVENDER, and MANJUSHAKA components.","category":"page"},{"location":"ch04/p_nbfrq.html","page":"nbfrq","title":"nbfrq","text":"Behavior","category":"page"},{"location":"ch04/p_nbfrq.html","page":"nbfrq","title":"nbfrq","text":"Determine the size of involved arrays. Only useful when we need to compute the two-particle quantities.","category":"page"},{"location":"ch04/p_nbfrq.html","page":"nbfrq","title":"nbfrq","text":"Comment","category":"page"},{"location":"ch04/p_nbfrq.html","page":"nbfrq","title":"nbfrq","text":"If the nbfrq is too large, the computational time is not bearable. So we recommend to set nbfrq leq 32 The computation of two-particle quantities is extremely time-consuming, though we have tried our best optimizing it.","category":"page"},{"location":"ch04/p_nbfrq.html","page":"nbfrq","title":"nbfrq","text":"See nffrq and nfreq for more details.","category":"page"},{"location":"ch04/p_nbfrq.html","page":"nbfrq","title":"nbfrq","text":"tip: Tip\nThe computation of two-particle quantities has been optimized using the OpenMP multi-thread technology. You can enable this feature in the compiling procedure. See also Compiling environment for more details.","category":"page"},{"location":"ch08/mott.html#Mott-metal-insulator-transition","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"","category":"section"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"info: Info\nThis tutorial will take you about two hours.","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"Introduction","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"The Mott metal-insulator transitions in strongly correlated electron systems are always hot topics in the condense matter physics. There are numerous theoretical and experimental studies about it in the last decades. The dynamical mean-field theory is a well-established tool to study the Mott metal-insulator transitions. In the previous tutorial, we learnt how to use the AZALEA component to solve a single-band Hubbard model within the framework of DMFT. Then in this tutorial, we will go a step further. The central task of this tutorial is show you how to use the iQIST software package to study an interaction-driven Mott metal-insulator transition for a single-band Hubbard model.","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"The Hamiltonian for the single-band Hubbard model is just the same with the one we have studied in the previous section. Here we won't write it down again. The model parameters are as follows:","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"U = 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 5.0, and 6.0\nt = 0.5\nbeta = 40\nmu = U2","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"We will perform a series calculations with various Coulomb interaction U in this tutorial. The calculated Matsubara Green's function G(iomega_n) and self-energy function Sigma(iomega_n) will exhibit drastic changes with respect to the increment of U.","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"Recipes","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"Next we just follow the procedures described in the iQIST recipes section.","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"(1) Choose suitable component","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"Since it is a single-band model, all of the quantum impurity solver components in the iQIST software package can be employed. In other words, both the segment representation version and general matrix version of CT-HYB impurity solvers are usable. In this tutorial, we choose the AZALEA component.","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"(2) Design the programs and scripts","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"Since the Hubbard model is defined in a Bethe lattice whose density of states is semi-circular, the self-consistent equation for the dynamical mean-field theory reads:","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"G(tau) = t^2 Delta(tau)","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"As mentioned before, the AZALEA component (and the other quantum impurity solver components) contains a mini dynamical mean-field engine and the above self-consistent equation is already implemented by default. So, we can use the AZALEA component alone without help from any external programs or scripts.","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"(3) Prepare the input files","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"Next, we have to setup the necessary parameters for the AZALEA component via the solver.ctqmc.in file. Since we have to solve the Hubbard model for a few times with different U parameters, so we have to prepare several solver.ctqmc.in files at the same time. You can find these files in the iqist/tutor/t12 directory. Noted that there exist a few sub-folders in it. Each folder contains one unique solver.ctqmc.in file. For example, in the iqist/tutor/t12/u40 directory, the Uc parameter in the solver.ctqmc.in file is just 4.0.","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"Please create your own working directory, and copy the corresponding solver.ctqmc.in file to it.","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"$ mkdir test12\n$ mkdir test12/u10 test12/u15 test12/u20 test12/u25 test12/u30 test12/u35 test12/u40 test12/u50 test12/u60\n$ cp iqist/tutor/t12/u10/solver.ctqmc.in test12/u10\n$ cp iqist/tutor/t12/u15/solver.ctqmc.in test12/u15\n$ cp iqist/tutor/t12/u20/solver.ctqmc.in test12/u20\n$ cp iqist/tutor/t12/u25/solver.ctqmc.in test12/u25\n$ cp iqist/tutor/t12/u30/solver.ctqmc.in test12/u30\n$ cp iqist/tutor/t12/u35/solver.ctqmc.in test12/u35\n$ cp iqist/tutor/t12/u40/solver.ctqmc.in test12/u40\n$ cp iqist/tutor/t12/u50/solver.ctqmc.in test12/u50\n$ cp iqist/tutor/t12/u60/solver.ctqmc.in test12/u60","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"These solver.ctqmc.in files are similar with each other. The only difference lies in the Uc and mune parameters. Next, the iqist/tutor/t12/u10/solver.ctqmc.in file is attached as a example:","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"!!!-----------------------------------------------------------------------\n!!! source  : t12/u10/solver.ctqmc.in\n!!! solver  : AZALEA\n!!! purpose : for tutorial\n!!! author  : yilin wang (email:qhwyl2006@126.com)\n!!!-----------------------------------------------------------------------\n\n!!>>> setup general control flags\n!!------------------------------------------------------------------------\n  isscf  : 2\n  issun  : 2\n  isspn  : 1\n  isbin  : 1\n\n!!>>> setup common variables for quantum impurity model\n!!------------------------------------------------------------------------\n  nband  : 1\n  nspin  : 2\n  norbs  : 2\n  ncfgs  : 4\n  niter  : 20\n  U      : 1.00\n  Uc     : 1.00\n  Uv     : 1.00\n  Jz     : 0.00\n  Js     : 0.00\n  Jp     : 0.00\n  mune   : 0.50\n  beta   : 40.0\n  part   : 0.50\n  alpha  : 0.70\n\n!!>>> setup common variables for quantum impurity solver\n!!------------------------------------------------------------------------\n  mkink  : 1024\n  mfreq  : 8193\n  nfreq  : 128\n  ntime  : 1024\n  nflip  : 20000\n  ntherm : 200000\n  nsweep : 20000000\n  nwrite : 2000000\n  nclean : 100000\n  nmonte : 100\n  ncarlo : 100","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"Please use the diff command or the other file comparison tools to verify the differences between these solver.ctqmc.in files. In fact, the solver.ctqmc.in file in the iqist/tutor/t11/u20/ directory is almost identical to the one in the iqist/tutor/t12 directory.","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"You can create simplified solver.ctqmc.in files which contains only the Uc, mune, and beta parameters. The AZALEA component will supplement the rest using default settings. As for the format and grammar for the solver.ctqmc.in file, see solver.ctqmc.in for more details.","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"(4) Let's go","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"Now everything is ready. We can perform the calculations. Please execute the following Bash shell script in the terminal, and go on a coffee or tea break.","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"#!/bin/bash\n\nfor u in u*\ndo\n    cd u\n    pwd\n    ctqmc\n    cd ..\ndone","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"The above shell script will enter each sub-folder and execute the CT-HYB quantum impurity solver one by one. Of course, you can leave this script alone, and execute the ctqmc program manually. But it is less efficient. During the calculations, you can check the immediate results from time to time as introduced in the previous tutorial. ","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"In my Macbook pro 2013, this script cost me about one and a half hour. ","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"(5) Post-processing","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"We choose the Python/matplotlib again to visualize the calculated results. A typical Python plotting script for the Matsubara Green's function data is as follows. You can modify it to satisfy your requirements.","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"#!/usr/bin/env python\n\nimport numpy\nimport matplotlib\nmatplotlib.use(\"Agg\") # setup backend\nimport matplotlib.pyplot as plt\n\n# read data\nbi, omega, sre10, sim10, sre_err, sim_err = numpy.loadtxt('u10/solver.grn.dat', unpack = True)\nbi, omega, sre20, sim20, sre_err, sim_err = numpy.loadtxt('u20/solver.grn.dat', unpack = True)\nbi, omega, sre30, sim30, sre_err, sim_err = numpy.loadtxt('u30/solver.grn.dat', unpack = True)\nbi, omega, sre40, sim40, sre_err, sim_err = numpy.loadtxt('u40/solver.grn.dat', unpack = True)\nbi, omega, sre50, sim50, sre_err, sim_err = numpy.loadtxt('u50/solver.grn.dat', unpack = True)\nbi, omega, sre60, sim60, sre_err, sim_err = numpy.loadtxt('u60/solver.grn.dat', unpack = True)\nomega = omega[0:8192] / 1.0\n\n# plot it\nplt.figure(0)\nlines = plt.plot(omega, sim10[0:8192], omega, sim20[0:8192], omega, sim30[0:8192], omega, sim40[0:8192], omega, sim50[0:8192], omega, sim60[0:8192], alpha = 0.6, clip_on = True)\n\n# setup line properties\nplt.setp(lines[0], linewidth = 2.5, marker = 'o', ms = 12, mew = 2, label = r\"$U = 1.0$\")\nplt.setp(lines[1], linewidth = 2.5, marker = 'o', ms = 12, mew = 2, label = r\"$U = 2.0$\")\nplt.setp(lines[2], linewidth = 2.5, marker = 'o', ms = 12, mew = 2, label = r\"$U = 3.0$\")\nplt.setp(lines[3], linewidth = 2.5, marker = 'o', ms = 12, mew = 2, label = r\"$U = 4.0$\")\nplt.setp(lines[4], linewidth = 2.5, marker = 'o', ms = 12, mew = 2, label = r\"$U = 5.0$\")\nplt.setp(lines[5], linewidth = 2.5, marker = 'o', ms = 12, mew = 2, label = r\"$U = 6.0$\")\n\n# setup tics\nplt.xticks(fontsize = 18)\nplt.yticks(fontsize = 18)\nplt.tick_params(length = 8, width = 1.0, which = 'major')\nplt.tick_params(length = 4, width = 0.5, which = 'minor')\n\n# setup labels\nplt.xlabel(r\"$\\omega_n$\", fontsize = 18)\nplt.ylabel(r\"$\\Im G(i\\omega_n)$\", fontsize = 18)\nplt.legend(frameon = True, loc = 'lower right')\n\n# setup yranges\nplt.xlim(0.0,4.0)\n\n# output the figure\nax = plt.gca()\nax.patch.set_facecolor('wheat')\nplt.savefig(\"mott_grnf.png\")","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"Next we will show some visualized results. The following figures were generated using the above Python script with slight modifications. You can compare them with your own results to see whether your calculations are correct.","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"Histogram (solver.hist.dat)","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"(Image: hist image)","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"Figure | The histogram for perturbation expansion series.","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"Imaginary-time Green's function (solver.green.dat)","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"(Image: gtau image)","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"Figure | The imaginary-time Green's function G(tau).","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"Matsubara Green's function (solver.grn.dat)","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"(Image: grnf image)","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"Figure | The imaginary part of Matsubara Green's function Im G(iomega_n).","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"According to the Im G(iomega_n), we can conclude that the Mott metal-insulator transition occurs at U in 23. It would be very helpful if we can determine the critical Coulomb interaction U for the Mott transition. In the DMFT community, the two quantities are usually used to detect the Mott transition: beta G(beta2) and quasiparticle weight Z. At low temperature, we can use the following approximated equation to calculate Z:","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"Z cong left1 - fracIm Sigma(iomega_0)omega_0 right^-1","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"where omega_0 equiv pi beta is the lowest Matsubara frequency. When beta G(beta2) and Z are larger than zero, it is metallic, and vice versa. Then we gather the beta G(beta2) and Z data from the solver.green.dat and solver.sgm.dat files, respectively, and then plot figure using them. The figure is shown as follows. As is seen in this figure, the critical U is 2.5.","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"Quasiparticle weight (solver.sgm.dat)","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"(Image: zb image)","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"Figure | The beta G(beta2) and quasiparticle weight Z.","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"Besides the beta G(beta2) and quasiparticle weight Z, the double occupation number D = langle nn rangle is another good observable to determine the transition point. In the metallic state, the double occupation number is large. However, it turns small in the insulating phase. See the below figure for a direct impression. The transition point determined by D is consistent with those by the beta G(beta2) and Z.","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"Double occupation number (solver.nmat.dat)","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"(Image: nmat image)","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"Figure | The double occupation number D = langle nn rangle.","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"OK. This tutorial is over. If you can finish this tutorial and the previous one, it means that you have grasped the basic usages of the iQIST software package and become an expert in the DMFT. ","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"Adventures","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"(1) Try other CT-HYB quantum impurity solvers","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"In addition to the AZALEA component, you still can choose the GARDENIA or NARCISSUS component to solve this single-band Hubbard model. The only task you have to do is call the proper executable programs. The solver.ctqmc.in file can remain unchanged.","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"(2) Temperature and hopping parameter","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"Please adjust the beta (beta) or t (part) parameters, and re-visit the Mott metal-insulator transitions again. Pay attention to the evolution of the critical U.","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"(3) Mott metal-insulator transition in multi-orbital Hubbard model","category":"page"},{"location":"ch08/mott.html","page":"Mott metal-insulator transition","title":"Mott metal-insulator transition","text":"Please change nband to 2, and modify the corresponding norbs, ncfgs, and mune parameters, try to find out the transition point for this two-band Hubbard model.","category":"page"},{"location":"ch04/out_wss.html#solver.wss.dat","page":"solver.wss.dat","title":"solver.wss.dat","text":"","category":"section"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"Introduction","category":"page"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"This file is used to store the Matsubara Weiss's function G_0(iomega_n). It will be output by the quantum impurity solvers when they are shut down.","category":"page"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"Format","category":"page"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"The solver.wss.dat file contains norbs block. Each block is appended by two blank lines. The format of each block is as follows:","category":"page"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"","category":"page"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"column 1: orbital index i, integer","category":"page"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"column 2: Matsubara frequency point, omega_n, double precision","category":"page"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"column 3: Matsubara Weiss's function, Re G_0(iomega_n), double precision","category":"page"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"column 4: Matsubara Weiss's function, Im G_0(iomega_n), double precision","category":"page"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"column 5: error bar, Re delta G_0(iomega_n), double precision","category":"page"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"column 6: error bar, Im delta G_0(iomega_n), double precision","category":"page"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"","category":"page"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"note: Note\nIn the solver.wss.dat file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"Code","category":"page"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"The corresponding Fortran code block for the writing of solver.wss.dat file is as follows:","category":"page"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"! open data file: solver.wss.dat\n     open(mytmp, file='solver.wss.dat', form='formatted', status='unknown')\n\n! write it\n     do i=1,norbs\n         do j=1,mfreq\n             write(mytmp,'(i6,5f16.8)') i, rmesh(j), &\n              real(wssf(j,i,i)), aimag(wssf(j,i,i)), &\n                                         zero, zero\n         enddo ! over j={1,mfreq} loop\n         write(mytmp,*) ! write empty lines\n         write(mytmp,*)\n     enddo ! over i={1,norbs} loop\n\n! close data file\n     close(mytmp)","category":"page"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"note: Note\nThe columns for the error bar are always zero in this file.","category":"page"},{"location":"ch04/out_wss.html","page":"solver.wss.dat","title":"solver.wss.dat","text":"In the HIBISCUS component, we provide a Python module to read the output files of quantum impurity solvers. You can use it to read the solver.wss.dat file. See script/u_reader.py for more details.","category":"page"},{"location":"ch04/p_isscr.html#Parameter:-isscr","page":"isscr","title":"Parameter: isscr","text":"","category":"section"},{"location":"ch04/p_isscr.html","page":"isscr","title":"isscr","text":"Definition","category":"page"},{"location":"ch04/p_isscr.html","page":"isscr","title":"isscr","text":"It is a key control flag, which specifies what kind of impurity Hamiltonian model need to be solved. Usually, the quantum impurity solvers in the iQIST software package only support the Hubbard model/Anderson impurity model. But with the help of the NARCISSUS component, we have several other choices.","category":"page"},{"location":"ch04/p_isscr.html","page":"isscr","title":"isscr","text":"Type","category":"page"},{"location":"ch04/p_isscr.html","page":"isscr","title":"isscr","text":"Integer","category":"page"},{"location":"ch04/p_isscr.html","page":"isscr","title":"isscr","text":"Default value","category":"page"},{"location":"ch04/p_isscr.html","page":"isscr","title":"isscr","text":"1","category":"page"},{"location":"ch04/p_isscr.html","page":"isscr","title":"isscr","text":"Component","category":"page"},{"location":"ch04/p_isscr.html","page":"isscr","title":"isscr","text":"Only for the NARCISSUS component.","category":"page"},{"location":"ch04/p_isscr.html","page":"isscr","title":"isscr","text":"Behavior","category":"page"},{"location":"ch04/p_isscr.html","page":"isscr","title":"isscr","text":"There are five possible values for the isscr parameters so far:","category":"page"},{"location":"ch04/p_isscr.html","page":"isscr","title":"isscr","text":"isscr = 1, normal Hubbard model/Anderson impurity model (U is static)\nisscr = 2, Holstein-Hubbard model\nisscr = 3, Dynamic screening effect (U is frequency-dependent), palsmon pole model\nisscr = 4, Dynamic screening effect (U is frequency-dependent), ohmic model\nisscr =99, Dynamic screening effect (U is frequency-dependent), realistic materials","category":"page"},{"location":"ch04/p_isscr.html","page":"isscr","title":"isscr","text":"When isscr = 1, lc and wc are ignored. ","category":"page"},{"location":"ch04/p_isscr.html","page":"isscr","title":"isscr","text":"When isscr = 2, lc means the electron-phonon coupling constant lambda, and wc phonon vibration frequency omega_0. The dynamical U is built analytically.","category":"page"},{"location":"ch04/p_isscr.html","page":"isscr","title":"isscr","text":"When isscr = 3, lc and wc just mean the control parameters lambda and omega^, respectively. The dynamical U is built analytically.","category":"page"},{"location":"ch04/p_isscr.html","page":"isscr","title":"isscr","text":"When isscr = 4, lc and wc just mean the control parameters alpha and omega_c, respectively. The dynamical U is built analytically.","category":"page"},{"location":"ch04/p_isscr.html","page":"isscr","title":"isscr","text":"When isscr = 99, wc is ignored and lc means the shift for interaction matrix and chemical potential. The dynamical U is read from the solver.ktau.in file. Please see solver.ktau.in for more details.","category":"page"},{"location":"ch04/p_isscr.html","page":"isscr","title":"isscr","text":"Comment","category":"page"},{"location":"ch04/p_isscr.html","page":"isscr","title":"isscr","text":"When you want to use the quantum impurity solvers contained in iQIST software package in extended-DMFT calculations, the isscr parameter must be considered.","category":"page"},{"location":"ch04/p_isscr.html","page":"isscr","title":"isscr","text":"When isscr = 1, 3, 4, or 99, you can use the combination of improved estimator and orthogonal polynomial technology to measure G and Sigma. In other words, in such cases, the isort parameter can be any values (isort in 16). On the other hand, when isscr = 2, the orthogonal polynomial technology is useful as well (G is accurate), but the improved estimator for Sigma and vertex function does not work any more! So in this case, you can not setup isort to 4, 5, or 6. See isort parameter for more details.","category":"page"},{"location":"ch04/p_isscr.html","page":"isscr","title":"isscr","text":"isscr = 2 is not compatible with the p = 3 bit of the isvrt parameter. Then if you want to study the two-particle Green's function and vertex function of the Holstein-Hubbard model, you can only set the p = 2 bit of the isvrt parameter. Consult isvrt parameter for more details.","category":"page"},{"location":"ch04/p_isscr.html","page":"isscr","title":"isscr","text":"Please refer to lc and wc parameters for more details.","category":"page"},{"location":"ch03/execute.html#Execute-codes","page":"Execute the codes","title":"Execute codes","text":"","category":"section"},{"location":"ch03/execute.html","page":"Execute the codes","title":"Execute the codes","text":"There are also several ways to execute the quantum impurity solvers in the iQIST software package.","category":"page"},{"location":"ch03/execute.html#Parallelism-mode","page":"Execute the codes","title":"Parallelism mode","text":"","category":"section"},{"location":"ch03/execute.html","page":"Execute the codes","title":"Execute the codes","text":"$ mpiexec -n num_of_cores iqist/build/ctqmc","category":"page"},{"location":"ch03/execute.html#Sequential-mode","page":"Execute the codes","title":"Sequential mode","text":"","category":"section"},{"location":"ch03/execute.html","page":"Execute the codes","title":"Execute the codes","text":"$ ./iqist/build/ctqmc","category":"page"},{"location":"ch03/execute.html#Fortran-library-mode","page":"Execute the codes","title":"Fortran library mode","text":"","category":"section"},{"location":"ch03/execute.html","page":"Execute the codes","title":"Execute the codes","text":"$ mpiexec -n num_of_cores your_fortran_program","category":"page"},{"location":"ch03/execute.html","page":"Execute the codes","title":"Execute the codes","text":"or","category":"page"},{"location":"ch03/execute.html","page":"Execute the codes","title":"Execute the codes","text":"$ ./your_fortran_program","category":"page"},{"location":"ch03/execute.html#Python-module-mode","page":"Execute the codes","title":"Python module mode","text":"","category":"section"},{"location":"ch03/execute.html","page":"Execute the codes","title":"Execute the codes","text":"mpiexec -n num_of_cores your_python_script.py","category":"page"},{"location":"ch03/execute.html","page":"Execute the codes","title":"Execute the codes","text":"or","category":"page"},{"location":"ch03/execute.html","page":"Execute the codes","title":"Execute the codes","text":"$ ./your_python_script.py","category":"page"},{"location":"ch03/execute.html","page":"Execute the codes","title":"Execute the codes","text":"tip: Tip\nBe sure all of the input files are ready and in correct position. Sometimes the quantum impurity solvers can run without any inputs, but the results may be completely wrong.\nBe sure the message passing interface works properly. If not, please solve it immediately.\nIf you are using a queue system to manage the computational jobs, please edit the submit script by yourself. We could not provide further help.\nSometimes, you want to use the multi-thread technology (OpenMP) to accelerate the quantum impurity solvers in the share memory architecture, it is wise to setup the number of threads in advance. For example:$ export OMP_NUM_THREADS=number_of_cpu_cores_per_node","category":"page"},{"location":"ch03/execute.html","page":"Execute the codes","title":"Execute the codes","text":"note: Note\nAs for the Python script, the mpi4py package can be used to implement parallelism.\nEven the iQIST is compiled as a paralleled program, it still can run in a sequential mode.","category":"page"},{"location":"ch07/tau.html#toolbox/maketau","page":"toolbox/maketau","title":"toolbox/maketau","text":"","category":"section"},{"location":"ch07/tau.html","page":"toolbox/maketau","title":"toolbox/maketau","text":"Introduction","category":"page"},{"location":"ch07/tau.html","page":"toolbox/maketau","title":"toolbox/maketau","text":"The maketau code is often used to convert solver.green.dat.````* or solver.green.dat files to tau.grn.dat file, which contains the necessary input data for the HIBISCUS/entropy or HIBISCUS/stoch codes.","category":"page"},{"location":"ch07/tau.html","page":"toolbox/maketau","title":"toolbox/maketau","text":"Usage","category":"page"},{"location":"ch07/tau.html","page":"toolbox/maketau","title":"toolbox/maketau","text":"./mtau","category":"page"},{"location":"ch07/tau.html","page":"toolbox/maketau","title":"toolbox/maketau","text":"Input","category":"page"},{"location":"ch07/tau.html","page":"toolbox/maketau","title":"toolbox/maketau","text":"See the terminal prompt\nsolver.green.dat or solver.green.dat.* (necessary)","category":"page"},{"location":"ch07/tau.html","page":"toolbox/maketau","title":"toolbox/maketau","text":"info: Info\nAbout nskip control parameter: If ctqmc = 2 or 4, then nskip must be 1. If ctqmc = 1 or 3, then nskip could be positive integer. Be careful, nskip can not be arbitrary integer. Notice that mod(ntime - 1, nskip) must be 0, or else the obtained tau.grn.dat should be wrong.About solver.green.dat.``* files In order to obtain *solvergreendat`` files, you have to run the CT-HYB/HF-QMC codes for several times, and rename the solver.green.dat file to solver.green.dat.````* file manually.","category":"page"},{"location":"ch07/tau.html","page":"toolbox/maketau","title":"toolbox/maketau","text":"Output","category":"page"},{"location":"ch07/tau.html","page":"toolbox/maketau","title":"toolbox/maketau","text":"tau.grn.dat","category":"page"},{"location":"ch07/tau.html","page":"toolbox/maketau","title":"toolbox/maketau","text":"Comment","category":"page"},{"location":"ch07/tau.html","page":"toolbox/maketau","title":"toolbox/maketau","text":"N/A","category":"page"},{"location":"ch04/out_hyb.html#solver.hyb.dat","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"","category":"section"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"Introduction","category":"page"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"This file is used to store the Matsubara hybridization function Delta(iomega_n). It will be output by the quantum impurity solvers when they are shut down.","category":"page"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"Format","category":"page"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"The solver.hyb.dat file contains norbs block. Each block is appended by two blank lines. The format of each block is as follows:","category":"page"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"","category":"page"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"column 1: orbital index i, integer","category":"page"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"column 2: Matsubara frequency point, omega_n, double precision","category":"page"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"column 3: Matsubara hybridization function, Re Delta(iomega_n), double precision","category":"page"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"column 4: Matsubara hybridization function, Im Delta(iomega_n), double precision","category":"page"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"column 5: error bar, Re delta Delta(iomega_n), double precision","category":"page"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"column 6: error bar, Im delta Delta(iomega_n), double precision","category":"page"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"","category":"page"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"note: Note\nIn the solver.hyb.dat file, we adopt the following orbital sequence: 1uparrow, 2uparrow, 3uparrow, cdots, 1downarrow, 2downarrow, 3downarrow, cdots In other words, the spin up part is always before the spin down part.","category":"page"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"Code","category":"page"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"The corresponding Fortran code block for the writing of solver.hyb.dat file is as follows:","category":"page"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"! open data file: solver.hyb.dat\n     open(mytmp, file='solver.hyb.dat', form='formatted', status='unknown')\n\n! write it\n     do i=1,norbs\n         do j=1,mfreq\n             write(mytmp,'(i6,5f16.8)') i, rmesh(j), &\n              real(hybf(j,i,i)), aimag(hybf(j,i,i)), &\n                                         zero, zero\n         enddo ! over j={1,mfreq} loop\n         write(mytmp,*) ! write empty lines\n         write(mytmp,*)\n     enddo ! over i={1,norbs} loop\n\n! close data file\n     close(mytmp)","category":"page"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"note: Note\nThe columns for the error bar are always zero in this file.","category":"page"},{"location":"ch04/out_hyb.html","page":"solver.hyb.dat","title":"solver.hyb.dat","text":"In the HIBISCUS component, we provide a Python module to read the output files of quantum impurity solvers. You can use it to read the solver.hyb.dat file. See script/u_reader.py for more details.","category":"page"},{"location":"ch03/monitor.html#Monitor-the-codes","page":"Monitor the codes","title":"Monitor the codes","text":"","category":"section"},{"location":"ch03/monitor.html","page":"Monitor the codes","title":"Monitor the codes","text":"The quantum impurity solvers in the iQIST software package will generate a lot of terminal output and data files (such as solver.hist.dat, solver.status.dat, solver.nmat.dat, etc.) at run time. Through them you can judge the status of the solvers.","category":"page"},{"location":"ch03/monitor.html","page":"Monitor the codes","title":"Monitor the codes","text":"See","category":"page"},{"location":"ch03/monitor.html","page":"Monitor the codes","title":"Monitor the codes","text":"Standard output files // Output stuffs for CT-HYB/HF-QMC impurity solvers.","category":"page"},{"location":"ch03/monitor.html","page":"Monitor the codes","title":"Monitor the codes","text":"for more details.","category":"page"},{"location":"ch04/p_nband.html#Parameter:-nband","page":"nband","title":"Parameter: nband","text":"","category":"section"},{"location":"ch04/p_nband.html","page":"nband","title":"nband","text":"Definition","category":"page"},{"location":"ch04/p_nband.html","page":"nband","title":"nband","text":"Number of correlated bands in the model Hamiltonian.","category":"page"},{"location":"ch04/p_nband.html","page":"nband","title":"nband","text":"Type","category":"page"},{"location":"ch04/p_nband.html","page":"nband","title":"nband","text":"Integer","category":"page"},{"location":"ch04/p_nband.html","page":"nband","title":"nband","text":"Default value","category":"page"},{"location":"ch04/p_nband.html","page":"nband","title":"nband","text":"1","category":"page"},{"location":"ch04/p_nband.html","page":"nband","title":"nband","text":"Component","category":"page"},{"location":"ch04/p_nband.html","page":"nband","title":"nband","text":"ALL","category":"page"},{"location":"ch04/p_nband.html","page":"nband","title":"nband","text":"Behavior","category":"page"},{"location":"ch04/p_nband.html","page":"nband","title":"nband","text":"Determine the size of involved arrays.","category":"page"},{"location":"ch04/p_nband.html","page":"nband","title":"nband","text":"Comment","category":"page"},{"location":"ch04/p_nband.html","page":"nband","title":"nband","text":"In iQIST software package, when we say nband, we always do not consider the spin degree of freedom. So for dâelectron system, it should be a five-band model (nband = 5), while for fâelectron, it should be a seven-band model (nband = 7).","category":"page"},{"location":"ch04/p_nband.html","page":"nband","title":"nband","text":"When you try to setup the nband parameter in the solver.ctqmc.in or solver.hfqmc.in file, the corresponding norbs and ncfgs parameters must be set as well.","category":"page"},{"location":"ch04/p_nband.html","page":"nband","title":"nband","text":"See nspin, norbs, and ncfgs parameters.","category":"page"},{"location":"ch08/post.html#Advanced-applications-III:-Post-processing-procedures","page":"README","title":"Advanced applications III: Post-processing procedures","text":"","category":"section"},{"location":"ch08/post.html","page":"README","title":"README","text":"The CT-HYB quantum impurity solvers usually work in the imaginary time axis, so that the calculated single-particle and two-particle correlation functions are in the imaginary-time axis [such as G(tau)] or Matsubara frequency space [such as G(iomega_n) and Sigma(iomega_n)]. In order to compare them with the experimental results, subtly analytical continuation procedures for them are necessary. After the analytical continuations, the correlation functions are converted into real axis.","category":"page"},{"location":"ch08/post.html","page":"README","title":"README","text":"In this section, we will illustrate that how to use the scripts/programs contained in the HIBISCUS component to perform analytical continuation for G(tau) and Sigma(iomega_n). Through the analytical continuation, we can extract spectral function A(omega) from G(tau), and Sigma(omega) from Sigma(iomega_n). A(omega) can be compared with the photoemission spectra directly, and Sigma(omega) is useful in the calculations of angle-resolved photoemission spectra A(veckomega), optical conductivity sigma(omega), and transport properties, etc.","category":"page"},{"location":"ch08/post.html","page":"README","title":"README","text":"Analytical continuation for imaginary-time Green's function\nAnalytical continuation for Matsubara self-energy function","category":"page"},{"location":"ch09/algo.html#Algorithms","page":"README","title":"Algorithms","text":"","category":"section"},{"location":"ch09/algo.html","page":"README","title":"README","text":"Well, in the previous section, we introduced the basic principles about the continuous-time quantum Monte Carlo impurity solver briefly. But, there is still a big gap between the basic principles and the real implementations. Thus in this section, we will dive into the iQIST software package, and introduce the algorithms, strategies, tricks, and optimization that have been implemented in it. Since the topics discussed in this section are irrelevant with each other, you can read them in a random manner.","category":"page"},{"location":"ch09/algo.html","page":"README","title":"README","text":"The topics including in the section are as follows:","category":"page"},{"location":"ch09/algo.html","page":"README","title":"README","text":"Transition probability \nHubbard-Holstein model\nDynamical screening effect\nPhysical observable\nOrthogonal polynomial representation\nKernel polynomial method\nImproved estimator for the self-energy function\nFast matrix update\nGood quantum number, subspace, and symmetry\nKrylov subspace iteration\nNewton-Leja polynomial interpolation\nTruncation approximation\nLazy trace evaluation\nSkip listing algorithm\nDivide-and-conquer algorithm \nSparse matrix tricks\nDelayed update algorithm\nAtomic eigenvalue solver\nSingle particle basis\nSpin-orbit coupling\nCoulomb interaction matrix\nMaximum entropy method\nStochastic analytical continuation","category":"page"}]
}

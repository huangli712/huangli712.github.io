<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solvers · ACFlow</title><meta name="title" content="Solvers · ACFlow"/><meta property="og:title" content="Solvers · ACFlow"/><meta property="twitter:title" content="Solvers · ACFlow"/><meta name="description" content="Documentation for ACFlow."/><meta property="og:description" content="Documentation for ACFlow."/><meta property="twitter:description" content="Documentation for ACFlow."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.png" alt="ACFlow logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">ACFlow</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><span class="tocitem">Introduction</span><ul><li><a class="tocitem" href="../intro/acp.html">Analytic Continuation</a></li><li><a class="tocitem" href="../intro/motivation.html">Motivation</a></li><li><a class="tocitem" href="../intro/ack.html">Acknowledgements</a></li><li><a class="tocitem" href="../intro/cite.html">Citation</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../man/feature.html">Main Features</a></li><li><a class="tocitem" href="../man/impl.html">Implementations</a></li><li><a class="tocitem" href="../man/install.html">Installation</a></li><li><a class="tocitem" href="../man/run.html">Running Modes</a></li><li><a class="tocitem" href="../man/input.html">Input Files</a></li><li><a class="tocitem" href="../man/output.html">Output Files</a></li><li><a class="tocitem" href="../man/param.html">Parameters</a></li><li><a class="tocitem" href="../man/tricks.html">Tricks and tips</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/sigma.html">Matsubara Self-Energy Function</a></li><li><a class="tocitem" href="../examples/green1.html">Matsubara Green&#39;s Function</a></li><li><a class="tocitem" href="../examples/green2.html">Imaginary Time Green&#39;s Function</a></li><li><a class="tocitem" href="../examples/current.html">Current-Current Correlation Function</a></li></ul></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../theory/basic.html">Basic Principles</a></li><li><a class="tocitem" href="../theory/maxent.html">Maximum Entropy Method</a></li><li><a class="tocitem" href="../theory/rfa.html">Barycentric Rational Function</a></li><li><a class="tocitem" href="../theory/nac.html">Nevanlinna Analytical Continuation</a></li><li><a class="tocitem" href="../theory/sac1.html">Stochastic Analytic Continuation 1</a></li><li><a class="tocitem" href="../theory/sac2.html">Stochastic Analytic Continuation 2</a></li><li><a class="tocitem" href="../theory/som.html">Stochastic Optimization Method</a></li><li><a class="tocitem" href="../theory/spx.html">Stochastic Pole Expansion</a></li><li><a class="tocitem" href="../theory/reference.html">References</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="outline.html">Outline</a></li><li><a class="tocitem" href="acflow.html">ACFlow</a></li><li><a class="tocitem" href="global.html">Constants</a></li><li><a class="tocitem" href="type.html">Types</a></li><li><a class="tocitem" href="base.html">Core</a></li><li class="is-active"><a class="tocitem" href="solver.html">Solvers</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Abstract-Structs"><span>Abstract Structs</span></a></li><li><a class="tocitem" href="#MaxEnt-Solver"><span>MaxEnt Solver</span></a></li><li><a class="tocitem" href="#BarRat-Solver"><span>BarRat Solver</span></a></li><li><a class="tocitem" href="#NevanAC-Solver"><span>NevanAC Solver</span></a></li><li><a class="tocitem" href="#StochAC-Solver"><span>StochAC Solver</span></a></li><li><a class="tocitem" href="#StochSK-Solver"><span>StochSK Solver</span></a></li><li><a class="tocitem" href="#StochOM-Solver"><span>StochOM Solver</span></a></li><li><a class="tocitem" href="#StochPX-Solver"><span>StochPX Solver</span></a></li></ul></li><li><a class="tocitem" href="grid.html">Grids</a></li><li><a class="tocitem" href="mesh.html">Meshes</a></li><li><a class="tocitem" href="model.html">Models</a></li><li><a class="tocitem" href="kernel.html">Kernels</a></li><li><a class="tocitem" href="config.html">Configuration</a></li><li><a class="tocitem" href="inout.html">Input and output</a></li><li><a class="tocitem" href="math.html">Math</a></li><li><a class="tocitem" href="util.html">Utilities</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href="solver.html">Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="solver.html">Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/huangli712/ACFlow" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Solvers"><a class="docs-heading-anchor" href="#Solvers">Solvers</a><a id="Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Solvers" title="Permalink"></a></h1><p><em>Define various solvers for the ACFlow toolkit.</em></p><p>Now the ACFlow toolkit supports seven analytic continuation solvers. They are:</p><ul><li><code>MaxEnt</code> (Maximum Entropy Method, see <code>maxent.jl</code>)</li><li><code>BarRat</code> (Barycentric Rational Function Approximation, see <code>rfa.jl</code>)</li><li><code>NevanAC</code> (Nevanlinna Analytical Continuation, see <code>nac.jl</code>)</li><li><code>StochAC</code> (Stochastic Analytic Continuation, see <code>sac.jl</code>)</li><li><code>StochSK</code> (Stochastic Analytic Continuation, see <code>san.jl</code>)</li><li><code>StochOM</code> (Stochastic Optimization Method, see <code>som.jl</code>)</li><li><code>StochPX</code> (Stochastic Pole Expansion, see <code>spx.jl</code>)</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>StochAC</code> solver is based on the Beach&#39;s variant, while the <code>StochSK</code> solver is based on the Sandvik&#39;s variant.</p></div></div><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="solver.html#Solvers">Solvers</a></li><li class="no-marker"><ul><li><a href="solver.html#Contents">Contents</a></li><li><a href="solver.html#Index">Index</a></li><li><a href="solver.html#Abstract-Structs">Abstract Structs</a></li><li><a href="solver.html#MaxEnt-Solver">MaxEnt Solver</a></li><li class="no-marker"><ul><li><a href="solver.html#Structs">Structs</a></li><li><a href="solver.html#Functions">Functions</a></li></ul></li><li><a href="solver.html#BarRat-Solver">BarRat Solver</a></li><li class="no-marker"><ul><li><a href="solver.html#Structs-2">Structs</a></li><li><a href="solver.html#Functions-2">Functions</a></li></ul></li><li><a href="solver.html#NevanAC-Solver">NevanAC Solver</a></li><li class="no-marker"><ul><li><a href="solver.html#Structs-3">Structs</a></li><li><a href="solver.html#Functions-3">Functions</a></li></ul></li><li><a href="solver.html#StochAC-Solver">StochAC Solver</a></li><li class="no-marker"><ul><li><a href="solver.html#Structs-4">Structs</a></li><li><a href="solver.html#Functions-4">Functions</a></li></ul></li><li><a href="solver.html#StochSK-Solver">StochSK Solver</a></li><li class="no-marker"><ul><li><a href="solver.html#Structs-5">Structs</a></li><li><a href="solver.html#Functions-5">Functions</a></li></ul></li><li><a href="solver.html#StochOM-Solver">StochOM Solver</a></li><li class="no-marker"><ul><li><a href="solver.html#Structs-6">Structs</a></li><li><a href="solver.html#Functions-6">Functions</a></li></ul></li><li><a href="solver.html#StochPX-Solver">StochPX Solver</a></li><li class="no-marker"><ul><li><a href="solver.html#Structs-7">Structs</a></li><li><a href="solver.html#Functions-7">Functions</a></li></ul></li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="solver.html#ACFlow.AbstractMC"><code>ACFlow.AbstractMC</code></a></li><li><a href="solver.html#ACFlow.AbstractSolver"><code>ACFlow.AbstractSolver</code></a></li><li><a href="solver.html#ACFlow.BarRatContext"><code>ACFlow.BarRatContext</code></a></li><li><a href="solver.html#ACFlow.BarRatSolver"><code>ACFlow.BarRatSolver</code></a></li><li><a href="solver.html#ACFlow.BarycentricFunction"><code>ACFlow.BarycentricFunction</code></a></li><li><a href="solver.html#ACFlow.Box"><code>ACFlow.Box</code></a></li><li><a href="solver.html#ACFlow.MaxEntContext"><code>ACFlow.MaxEntContext</code></a></li><li><a href="solver.html#ACFlow.MaxEntSolver"><code>ACFlow.MaxEntSolver</code></a></li><li><a href="solver.html#ACFlow.NevanACContext"><code>ACFlow.NevanACContext</code></a></li><li><a href="solver.html#ACFlow.NevanACSolver"><code>ACFlow.NevanACSolver</code></a></li><li><a href="solver.html#ACFlow.PronyApproximation"><code>ACFlow.PronyApproximation</code></a></li><li><a href="solver.html#ACFlow.StochACContext"><code>ACFlow.StochACContext</code></a></li><li><a href="solver.html#ACFlow.StochACElement"><code>ACFlow.StochACElement</code></a></li><li><a href="solver.html#ACFlow.StochACMC"><code>ACFlow.StochACMC</code></a></li><li><a href="solver.html#ACFlow.StochACSolver"><code>ACFlow.StochACSolver</code></a></li><li><a href="solver.html#ACFlow.StochOMContext"><code>ACFlow.StochOMContext</code></a></li><li><a href="solver.html#ACFlow.StochOMElement"><code>ACFlow.StochOMElement</code></a></li><li><a href="solver.html#ACFlow.StochOMMC"><code>ACFlow.StochOMMC</code></a></li><li><a href="solver.html#ACFlow.StochOMSolver"><code>ACFlow.StochOMSolver</code></a></li><li><a href="solver.html#ACFlow.StochPXContext"><code>ACFlow.StochPXContext</code></a></li><li><a href="solver.html#ACFlow.StochPXElement"><code>ACFlow.StochPXElement</code></a></li><li><a href="solver.html#ACFlow.StochPXMC"><code>ACFlow.StochPXMC</code></a></li><li><a href="solver.html#ACFlow.StochPXSolver"><code>ACFlow.StochPXSolver</code></a></li><li><a href="solver.html#ACFlow.StochSKContext"><code>ACFlow.StochSKContext</code></a></li><li><a href="solver.html#ACFlow.StochSKElement"><code>ACFlow.StochSKElement</code></a></li><li><a href="solver.html#ACFlow.StochSKMC"><code>ACFlow.StochSKMC</code></a></li><li><a href="solver.html#ACFlow.StochSKSolver"><code>ACFlow.StochSKSolver</code></a></li><li><a href="solver.html#ACFlow.Pdx"><code>ACFlow.Pdx</code></a></li><li><a href="solver.html#ACFlow.aaa"><code>ACFlow.aaa</code></a></li><li><a href="solver.html#ACFlow.average-Tuple{Float64, StochSKContext}"><code>ACFlow.average</code></a></li><li><a href="solver.html#ACFlow.average-Tuple{StochOMContext}"><code>ACFlow.average</code></a></li><li><a href="solver.html#ACFlow.average-Tuple{StochPXContext}"><code>ACFlow.average</code></a></li><li><a href="solver.html#ACFlow.average-Tuple{Float64, StochACContext}"><code>ACFlow.average</code></a></li><li><a href="solver.html#ACFlow.bc_degree"><code>ACFlow.bc_degree</code></a></li><li><a href="solver.html#ACFlow.bc_nodes"><code>ACFlow.bc_nodes</code></a></li><li><a href="solver.html#ACFlow.bc_poles"><code>ACFlow.bc_poles</code></a></li><li><a href="solver.html#ACFlow.bc_values"><code>ACFlow.bc_values</code></a></li><li><a href="solver.html#ACFlow.bc_weights"><code>ACFlow.bc_weights</code></a></li><li><a href="solver.html#ACFlow.bryan"><code>ACFlow.bryan</code></a></li><li><a href="solver.html#ACFlow.calc_abcd"><code>ACFlow.calc_abcd</code></a></li><li><a href="solver.html#ACFlow.calc_alpha"><code>ACFlow.calc_alpha</code></a></li><li><a href="solver.html#ACFlow.calc_bayes"><code>ACFlow.calc_bayes</code></a></li><li><a href="solver.html#ACFlow.calc_bayes_od"><code>ACFlow.calc_bayes_od</code></a></li><li><a href="solver.html#ACFlow.calc_chi2-Tuple{MaxEntContext, Vector{Float64}}"><code>ACFlow.calc_chi2</code></a></li><li><a href="solver.html#ACFlow.calc_chi2-Tuple{Vector{Float64}, Vector{Float64}}"><code>ACFlow.calc_chi2</code></a></li><li><a href="solver.html#ACFlow.calc_correlator"><code>ACFlow.calc_correlator</code></a></li><li><a href="solver.html#ACFlow.calc_delta"><code>ACFlow.calc_delta</code></a></li><li><a href="solver.html#ACFlow.calc_entropy"><code>ACFlow.calc_entropy</code></a></li><li><a href="solver.html#ACFlow.calc_entropy_od"><code>ACFlow.calc_entropy_od</code></a></li><li><a href="solver.html#ACFlow.calc_error"><code>ACFlow.calc_error</code></a></li><li><a href="solver.html#ACFlow.calc_fmesh-Tuple{StochSKSolver}"><code>ACFlow.calc_fmesh</code></a></li><li><a href="solver.html#ACFlow.calc_fmesh-Tuple{StochACSolver}"><code>ACFlow.calc_fmesh</code></a></li><li><a href="solver.html#ACFlow.calc_fmesh-Tuple{StochPXSolver}"><code>ACFlow.calc_fmesh</code></a></li><li><a href="solver.html#ACFlow.calc_goodness"><code>ACFlow.calc_goodness</code></a></li><li><a href="solver.html#ACFlow.calc_green-Tuple{Array{Complex{BigFloat}, 3}, Matrix{Complex{BigFloat}}, Vector{ComplexF64}}"><code>ACFlow.calc_green</code></a></li><li><a href="solver.html#ACFlow.calc_green-Tuple{Matrix{Float64}, Int64}"><code>ACFlow.calc_green</code></a></li><li><a href="solver.html#ACFlow.calc_green-Tuple{Vector{Int64}, Vector{Float64}, Vector{Float64}, AbstractMesh, AbstractMesh, Float64, Bool}"><code>ACFlow.calc_green</code></a></li><li><a href="solver.html#ACFlow.calc_green-Tuple{Vector{Int64}, Vector{Float64}, Vector{Float64}, Matrix{Float64}}"><code>ACFlow.calc_green</code></a></li><li><a href="solver.html#ACFlow.calc_green-Tuple{Vector{Int64}, Vector{Float64}, Vector{Float64}, AbstractMesh, AbstractMesh}"><code>ACFlow.calc_green</code></a></li><li><a href="solver.html#ACFlow.calc_hamil"><code>ACFlow.calc_hamil</code></a></li><li><a href="solver.html#ACFlow.calc_hbasis"><code>ACFlow.calc_hbasis</code></a></li><li><a href="solver.html#ACFlow.calc_hmatrix"><code>ACFlow.calc_hmatrix</code></a></li><li><a href="solver.html#ACFlow.calc_hmin!"><code>ACFlow.calc_hmin!</code></a></li><li><a href="solver.html#ACFlow.calc_hopt!"><code>ACFlow.calc_hopt!</code></a></li><li><a href="solver.html#ACFlow.calc_htau"><code>ACFlow.calc_htau</code></a></li><li><a href="solver.html#ACFlow.calc_inv_mobius"><code>ACFlow.calc_inv_mobius</code></a></li><li><a href="solver.html#ACFlow.calc_lambda-Tuple{AbstractGrid, AbstractMesh, Float64, Bool}"><code>ACFlow.calc_lambda</code></a></li><li><a href="solver.html#ACFlow.calc_lambda-Tuple{AbstractGrid, AbstractMesh}"><code>ACFlow.calc_lambda</code></a></li><li><a href="solver.html#ACFlow.calc_mobius"><code>ACFlow.calc_mobius</code></a></li><li><a href="solver.html#ACFlow.calc_noptim"><code>ACFlow.calc_noptim</code></a></li><li><a href="solver.html#ACFlow.calc_norm"><code>ACFlow.calc_norm</code></a></li><li><a href="solver.html#ACFlow.calc_phi"><code>ACFlow.calc_phi</code></a></li><li><a href="solver.html#ACFlow.calc_phis"><code>ACFlow.calc_phis</code></a></li><li><a href="solver.html#ACFlow.calc_pick"><code>ACFlow.calc_pick</code></a></li><li><a href="solver.html#ACFlow.calc_theta"><code>ACFlow.calc_theta</code></a></li><li><a href="solver.html#ACFlow.calc_theta-Tuple{Array{Complex{BigFloat}, 3}, Matrix{Complex{BigFloat}}, Vector{ComplexF64}}"><code>ACFlow.calc_theta</code></a></li><li><a href="solver.html#ACFlow.check_causality"><code>ACFlow.check_causality</code></a></li><li><a href="solver.html#ACFlow.check_pick"><code>ACFlow.check_pick</code></a></li><li><a href="solver.html#ACFlow.chi2kink"><code>ACFlow.chi2kink</code></a></li><li><a href="solver.html#ACFlow.classic"><code>ACFlow.classic</code></a></li><li><a href="solver.html#ACFlow.constraints-Tuple{StochSKSolver, AbstractMesh}"><code>ACFlow.constraints</code></a></li><li><a href="solver.html#ACFlow.constraints-Tuple{StochPXSolver, AbstractMesh}"><code>ACFlow.constraints</code></a></li><li><a href="solver.html#ACFlow.constraints-Tuple{StochACSolver, AbstractMesh}"><code>ACFlow.constraints</code></a></li><li><a href="solver.html#ACFlow.constraints-Tuple{Float64, Float64}"><code>ACFlow.constraints</code></a></li><li><a href="solver.html#ACFlow.eval_lambda"><code>ACFlow.eval_lambda</code></a></li><li><a href="solver.html#ACFlow.f_and_J"><code>ACFlow.f_and_J</code></a></li><li><a href="solver.html#ACFlow.f_and_J_od"><code>ACFlow.f_and_J_od</code></a></li><li><a href="solver.html#ACFlow.hardy_optimize!"><code>ACFlow.hardy_optimize!</code></a></li><li><a href="solver.html#ACFlow.historic"><code>ACFlow.historic</code></a></li><li><a href="solver.html#ACFlow.init-Tuple{StochOMSolver, RawData}"><code>ACFlow.init</code></a></li><li><a href="solver.html#ACFlow.init-Tuple{BarRatSolver, RawData}"><code>ACFlow.init</code></a></li><li><a href="solver.html#ACFlow.init-Tuple{NevanACSolver, RawData}"><code>ACFlow.init</code></a></li><li><a href="solver.html#ACFlow.init-Tuple{MaxEntSolver, RawData}"><code>ACFlow.init</code></a></li><li><a href="solver.html#ACFlow.init-Tuple{StochACSolver, RawData}"><code>ACFlow.init</code></a></li><li><a href="solver.html#ACFlow.init-Tuple{StochPXSolver, RawData}"><code>ACFlow.init</code></a></li><li><a href="solver.html#ACFlow.init-Tuple{StochSKSolver, RawData}"><code>ACFlow.init</code></a></li><li><a href="solver.html#ACFlow.init_context-Tuple{StochPXSolver}"><code>ACFlow.init_context</code></a></li><li><a href="solver.html#ACFlow.init_context-Tuple{StochOMSolver, AbstractGrid}"><code>ACFlow.init_context</code></a></li><li><a href="solver.html#ACFlow.init_element-Tuple{StochOMMC, StochOMContext}"><code>ACFlow.init_element</code></a></li><li><a href="solver.html#ACFlow.init_element-Tuple{StochACSolver, AbstractRNG, Vector{Int64}}"><code>ACFlow.init_element</code></a></li><li><a href="solver.html#ACFlow.init_element-Tuple{StochSKSolver, AbstractRNG, Vector{Int64}}"><code>ACFlow.init_element</code></a></li><li><a href="solver.html#ACFlow.init_element-Tuple{StochPXSolver, AbstractRNG, Vector{Int64}}"><code>ACFlow.init_element</code></a></li><li><a href="solver.html#ACFlow.init_iodata-Tuple{StochOMSolver, RawData}"><code>ACFlow.init_iodata</code></a></li><li><a href="solver.html#ACFlow.init_iodata-Tuple{StochACSolver, RawData}"><code>ACFlow.init_iodata</code></a></li><li><a href="solver.html#ACFlow.init_iodata-Tuple{StochSKSolver, RawData}"><code>ACFlow.init_iodata</code></a></li><li><a href="solver.html#ACFlow.init_iodata-Tuple{StochPXSolver, RawData}"><code>ACFlow.init_iodata</code></a></li><li><a href="solver.html#ACFlow.init_mc-Tuple{StochACSolver}"><code>ACFlow.init_mc</code></a></li><li><a href="solver.html#ACFlow.init_mc-Tuple{StochSKSolver}"><code>ACFlow.init_mc</code></a></li><li><a href="solver.html#ACFlow.init_mc-Tuple{StochPXSolver}"><code>ACFlow.init_mc</code></a></li><li><a href="solver.html#ACFlow.init_mc-Tuple{StochOMSolver}"><code>ACFlow.init_mc</code></a></li><li><a href="solver.html#ACFlow.last-Tuple{MaxEntContext, Vector, Dict}"><code>ACFlow.last</code></a></li><li><a href="solver.html#ACFlow.last-Tuple{NevanACContext}"><code>ACFlow.last</code></a></li><li><a href="solver.html#ACFlow.last-Tuple{StochSKContext, Vector{Float64}, Vector{Float64}, Vector{Float64}}"><code>ACFlow.last</code></a></li><li><a href="solver.html#ACFlow.last-Tuple{BarRatContext}"><code>ACFlow.last</code></a></li><li><a href="solver.html#ACFlow.last-Tuple{StochACContext, Matrix{Float64}, Vector{Float64}}"><code>ACFlow.last</code></a></li><li><a href="solver.html#ACFlow.last-Tuple{StochOMContext, Vector{Float64}}"><code>ACFlow.last</code></a></li><li><a href="solver.html#ACFlow.last-Tuple{StochPXContext, Vector{Float64}, Vector{ComplexF64}, Vector{Float64}}"><code>ACFlow.last</code></a></li><li><a href="solver.html#ACFlow.measure-Tuple{StochSKElement, StochSKContext}"><code>ACFlow.measure</code></a></li><li><a href="solver.html#ACFlow.measure-Tuple{StochACElement, StochACContext}"><code>ACFlow.measure</code></a></li><li><a href="solver.html#ACFlow.measure-Tuple{Int64, StochPXElement, StochPXContext}"><code>ACFlow.measure</code></a></li><li><a href="solver.html#ACFlow.optimizer"><code>ACFlow.optimizer</code></a></li><li><a href="solver.html#ACFlow.poles!"><code>ACFlow.poles!</code></a></li><li><a href="solver.html#ACFlow.precompute-Tuple{AbstractGrid, AbstractMesh, Vector{Complex{BigFloat}}}"><code>ACFlow.precompute</code></a></li><li><a href="solver.html#ACFlow.precompute-Tuple{Vector{Float64}, Vector{Float64}, AbstractMesh, Vector{Float64}, Matrix{Float64}}"><code>ACFlow.precompute</code></a></li><li><a href="solver.html#ACFlow.prony_data"><code>ACFlow.prony_data</code></a></li><li><a href="solver.html#ACFlow.prony_gamma"><code>ACFlow.prony_gamma</code></a></li><li><a href="solver.html#ACFlow.prony_idx"><code>ACFlow.prony_idx</code></a></li><li><a href="solver.html#ACFlow.prony_omega"><code>ACFlow.prony_omega</code></a></li><li><a href="solver.html#ACFlow.prony_svd"><code>ACFlow.prony_svd</code></a></li><li><a href="solver.html#ACFlow.prony_v"><code>ACFlow.prony_v</code></a></li><li><a href="solver.html#ACFlow.prun-Tuple{StochACSolver, Dict{String, Vector{Any}}, Dict{String, Vector{Any}}, StochACMC, StochACElement, StochACContext}"><code>ACFlow.prun</code></a></li><li><a href="solver.html#ACFlow.prun-Tuple{StochOMSolver, Dict{String, Vector{Any}}, Dict{String, Vector{Any}}, StochOMMC, StochOMContext}"><code>ACFlow.prun</code></a></li><li><a href="solver.html#ACFlow.prun-Tuple{StochSKSolver, Dict{String, Vector{Any}}, Dict{String, Vector{Any}}, StochSKMC, StochSKElement, StochSKContext}"><code>ACFlow.prun</code></a></li><li><a href="solver.html#ACFlow.prun-Tuple{StochPXSolver, Dict{String, Vector{Any}}, Dict{String, Vector{Any}}, StochPXMC, StochPXElement, StochPXContext}"><code>ACFlow.prun</code></a></li><li><a href="solver.html#ACFlow.reset_context-Tuple{Int64, StochPXElement, StochPXContext}"><code>ACFlow.reset_context</code></a></li><li><a href="solver.html#ACFlow.reset_element-Tuple{AbstractRNG, Vector{Int64}, StochPXElement}"><code>ACFlow.reset_element</code></a></li><li><a href="solver.html#ACFlow.reset_mc-Tuple{StochPXMC}"><code>ACFlow.reset_mc</code></a></li><li><a href="solver.html#ACFlow.run-Tuple{StochACMC, StochACElement, StochACContext}"><code>ACFlow.run</code></a></li><li><a href="solver.html#ACFlow.run-Tuple{StochPXMC, StochPXElement, StochPXContext}"><code>ACFlow.run</code></a></li><li><a href="solver.html#ACFlow.run-Tuple{BarRatContext}"><code>ACFlow.run</code></a></li><li><a href="solver.html#ACFlow.run-Tuple{NevanACContext}"><code>ACFlow.run</code></a></li><li><a href="solver.html#ACFlow.run-Tuple{StochOMMC, StochOMContext}"><code>ACFlow.run</code></a></li><li><a href="solver.html#ACFlow.run-Tuple{StochSKMC, StochSKElement, StochSKContext}"><code>ACFlow.run</code></a></li><li><a href="solver.html#ACFlow.run-Tuple{MaxEntContext}"><code>ACFlow.run</code></a></li><li><a href="solver.html#ACFlow.sample-Tuple{Int64, StochPXMC, StochPXElement, StochPXContext}"><code>ACFlow.sample</code></a></li><li><a href="solver.html#ACFlow.sample-Tuple{StochSKMC, StochSKElement, StochSKContext}"><code>ACFlow.sample</code></a></li><li><a href="solver.html#ACFlow.sample-Tuple{StochACMC, StochACElement, StochACContext}"><code>ACFlow.sample</code></a></li><li><a href="solver.html#ACFlow.shuffle-Tuple{StochSKMC, StochSKElement, StochSKContext}"><code>ACFlow.shuffle</code></a></li><li><a href="solver.html#ACFlow.smooth_norm"><code>ACFlow.smooth_norm</code></a></li><li><a href="solver.html#ACFlow.solve-Tuple{NevanACSolver, RawData}"><code>ACFlow.solve</code></a></li><li><a href="solver.html#ACFlow.solve-Tuple{StochPXSolver, RawData}"><code>ACFlow.solve</code></a></li><li><a href="solver.html#ACFlow.solve-Tuple{MaxEntSolver, RawData}"><code>ACFlow.solve</code></a></li><li><a href="solver.html#ACFlow.solve-Tuple{StochOMSolver, RawData}"><code>ACFlow.solve</code></a></li><li><a href="solver.html#ACFlow.solve-Tuple{StochSKSolver, RawData}"><code>ACFlow.solve</code></a></li><li><a href="solver.html#ACFlow.solve-Tuple{BarRatSolver, RawData}"><code>ACFlow.solve</code></a></li><li><a href="solver.html#ACFlow.solve-Tuple{StochACSolver, RawData}"><code>ACFlow.solve</code></a></li><li><a href="solver.html#ACFlow.svd_to_real"><code>ACFlow.svd_to_real</code></a></li><li><a href="solver.html#ACFlow.svd_to_real_od"><code>ACFlow.svd_to_real_od</code></a></li><li><a href="solver.html#ACFlow.try_height"><code>ACFlow.try_height</code></a></li><li><a href="solver.html#ACFlow.try_insert"><code>ACFlow.try_insert</code></a></li><li><a href="solver.html#ACFlow.try_merge"><code>ACFlow.try_merge</code></a></li><li><a href="solver.html#ACFlow.try_move_a-Tuple{Int64, StochACMC, StochACElement, StochACContext}"><code>ACFlow.try_move_a</code></a></li><li><a href="solver.html#ACFlow.try_move_a-Tuple{Int64, StochPXMC, StochPXElement, StochPXContext}"><code>ACFlow.try_move_a</code></a></li><li><a href="solver.html#ACFlow.try_move_p-Tuple{StochSKMC, StochSKElement, StochSKContext}"><code>ACFlow.try_move_p</code></a></li><li><a href="solver.html#ACFlow.try_move_p-Tuple{Int64, StochACMC, StochACElement, StochACContext}"><code>ACFlow.try_move_p</code></a></li><li><a href="solver.html#ACFlow.try_move_p-Tuple{Int64, StochPXMC, StochPXElement, StochPXContext}"><code>ACFlow.try_move_p</code></a></li><li><a href="solver.html#ACFlow.try_move_q-Tuple{StochSKMC, StochSKElement, StochSKContext}"><code>ACFlow.try_move_q</code></a></li><li><a href="solver.html#ACFlow.try_move_s-Tuple{Int64, StochPXMC, StochPXElement, StochPXContext}"><code>ACFlow.try_move_s</code></a></li><li><a href="solver.html#ACFlow.try_move_s-Tuple{StochSKMC, StochSKElement, StochSKContext}"><code>ACFlow.try_move_s</code></a></li><li><a href="solver.html#ACFlow.try_move_x-Tuple{Int64, StochPXMC, StochPXElement, StochPXContext}"><code>ACFlow.try_move_x</code></a></li><li><a href="solver.html#ACFlow.try_move_x-Tuple{StochACMC, StochACElement, StochACContext}"><code>ACFlow.try_move_x</code></a></li><li><a href="solver.html#ACFlow.try_remove"><code>ACFlow.try_remove</code></a></li><li><a href="solver.html#ACFlow.try_shift"><code>ACFlow.try_shift</code></a></li><li><a href="solver.html#ACFlow.try_split"><code>ACFlow.try_split</code></a></li><li><a href="solver.html#ACFlow.try_width"><code>ACFlow.try_width</code></a></li><li><a href="solver.html#ACFlow.update-Tuple{StochOMMC, StochOMElement, StochOMContext}"><code>ACFlow.update</code></a></li><li><a href="solver.html#ACFlow.warmup-Tuple{StochSKMC, StochSKElement, StochSKContext}"><code>ACFlow.warmup</code></a></li><li><a href="solver.html#ACFlow.warmup-Tuple{StochACMC, StochACElement, StochACContext}"><code>ACFlow.warmup</code></a></li></ul><h2 id="Abstract-Structs"><a class="docs-heading-anchor" href="#Abstract-Structs">Abstract Structs</a><a id="Abstract-Structs-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-Structs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.AbstractSolver" href="#ACFlow.AbstractSolver"><code>ACFlow.AbstractSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractSolver</code></pre><p>An abstract type representing the solver for analytic continuation problem. It is used to build the internal type system. All the other solvers are its sub-types.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.AbstractMC" href="#ACFlow.AbstractMC"><code>ACFlow.AbstractMC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractMC</code></pre><p>An abstract type representing the Monte Carlo engine. It is used to build the internal type system.</p></div></section></article><h2 id="MaxEnt-Solver"><a class="docs-heading-anchor" href="#MaxEnt-Solver">MaxEnt Solver</a><a id="MaxEnt-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#MaxEnt-Solver" title="Permalink"></a></h2><h3 id="Structs"><a class="docs-heading-anchor" href="#Structs">Structs</a><a id="Structs-1"></a><a class="docs-heading-anchor-permalink" href="#Structs" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.MaxEntSolver" href="#ACFlow.MaxEntSolver"><code>ACFlow.MaxEntSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MaxEntSolver</code></pre><p>It represents the analytic continuation solver that implements the maximum entropy method.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.MaxEntContext" href="#ACFlow.MaxEntContext"><code>ACFlow.MaxEntContext</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MaxEntContext</code></pre><p>Mutable struct. It is used within the MaxEnt solver only.</p><p><strong>Members</strong></p><ul><li>Gᵥ     -&gt; Input data for correlator.</li><li>σ²     -&gt; Actually 1.0 / σ².</li><li>grid   -&gt; Grid for input data.</li><li>mesh   -&gt; Mesh for output spectrum.</li><li>model  -&gt; Default model function.</li><li>kernel -&gt; Default kernel function.</li><li>Vₛ     -&gt; Matrix from singular value decomposition.</li><li>W₂     -&gt; Precomputed array.</li><li>W₃     -&gt; Precomputed array.</li><li>Bₘ     -&gt; Precomputed array.</li></ul></div></section></article><h3 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.solve-Tuple{MaxEntSolver, RawData}" href="#ACFlow.solve-Tuple{MaxEntSolver, RawData}"><code>ACFlow.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve(S::MaxEntSolver, rd::RawData)</code></pre><p>Solve the analytic continuation problem by the maximum entropy method.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.init-Tuple{MaxEntSolver, RawData}" href="#ACFlow.init-Tuple{MaxEntSolver, RawData}"><code>ACFlow.init</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init(S::MaxEntSolver, rd::RawData)</code></pre><p>Initialize the MaxEnt solver and return a MaxEntContext struct.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.run-Tuple{MaxEntContext}" href="#ACFlow.run-Tuple{MaxEntContext}"><code>ACFlow.run</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">run(mec::MaxEntContext)</code></pre><p>Perform maximum entropy simulation with different algorithms. Now it supports the <code>historic</code>, <code>classic</code>, <code>bryan</code>, and <code>chi2kink</code> algorithms.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.last-Tuple{MaxEntContext, Vector, Dict}" href="#ACFlow.last-Tuple{MaxEntContext, Vector, Dict}"><code>ACFlow.last</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">last(mec::MaxEntContext, svec::Vector, sol::Dict)</code></pre><p>Postprocess the results generated during the maximum entropy simulations. Here <code>sol</code> is the final solution for the analytic continuation problem, while <code>svec</code> contains all the intermediate results (it is a vector of dictionary actually).</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.historic" href="#ACFlow.historic"><code>ACFlow.historic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">historic(mec::MaxEntContext)</code></pre><p>Apply the historic algorithm to solve the analytic continuation problem. It choose α in a way that χ² ≈ N.</p><p>For the historic algorithm, <code>alpha</code> is usually 10⁶, and <code>ratio</code> is 10.0. It is compatible with the Bayesian Reconstruction entropy.</p><p>See also: <a href="solver.html#ACFlow.MaxEntContext"><code>MaxEntContext</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.classic" href="#ACFlow.classic"><code>ACFlow.classic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">classic(mec::MaxEntContext)</code></pre><p>Apply the classic algorithm to solve the analytic continuation problem.</p><p>Classic algorithm uses Bayes statistics to approximately determine the most probable value of α. We always start at a large value of α, where the optimization yields basically the default model, therefore <code>u_vec</code> is only a few steps away from 0 (= default model). And then we gradually decrease α, step by step moving away from the default model towards data fitting. Using <code>u_vec</code> as start for the next (smaller) α brings a great speedup into this procedure.</p><p>For the classic algorithm, <code>alpha</code> is usually 10⁶, and <code>ratio</code> is 10.0. It is incompatible with the Bayesian Reconstruction entropy.</p><p>See also: <a href="solver.html#ACFlow.MaxEntContext"><code>MaxEntContext</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.bryan" href="#ACFlow.bryan"><code>ACFlow.bryan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bryan(mec::MaxEntContext)</code></pre><p>Apply the bryan algorithm to solve the analytic continuation problem.</p><p>Bryan&#39;s maxent calculates an average of spectral functions, weighted by their Bayesian probability.</p><p>For the bryan algorithm, <code>alpha</code> is usually 500, and <code>ratio</code> is 1.1. It is incompatible with the Bayesian Reconstruction entropy.</p><p>See also: <a href="solver.html#ACFlow.MaxEntContext"><code>MaxEntContext</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.chi2kink" href="#ACFlow.chi2kink"><code>ACFlow.chi2kink</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">chi2kink(mec::MaxEntContext)</code></pre><p>Apply the chi2kink algorithm to solve the analytic continuation problem.</p><p>We start with an optimization at a large value of α, where we should get only the default model. And then, α is decreased step-by-step, until the minimal value of α is reached. Then, we fit a function</p><p><code>ϕ(x; a, b, c, d) = a + b / [1 + exp(-d*(x-c))]</code>,</p><p>from which the optimal α is determined by</p><p><code>x_opt = c - fit_position / d</code>,</p><p>and</p><p><code>alpha_opt = 10^x_opt</code>.</p><p>For the chi2kink algorithm, <code>alpha</code> is usually 10⁹, <code>ratio</code> is 10.0, the number of alpha parameters is 12. It is compatible with the Bayesian Reconstruction entropy.</p><p>See also: <a href="solver.html#ACFlow.MaxEntContext"><code>MaxEntContext</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.optimizer" href="#ACFlow.optimizer"><code>ACFlow.optimizer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">optimizer(
    mec::MaxEntContext,
    α::F64,
    us::Vector{F64},
    use_bayes::Bool
    )</code></pre><p>Optimization of maxent functional for a given value of <code>α</code>. Since a priori the best value of <code>α</code> is unknown, this function has to be called several times in order to find a good value.</p><p><code>α</code> means a weight factor of the entropy. <code>us</code> is a vector in singular space. It is used as a starting value for the optimization. For the very first optimization, done at large α, we use zeros, which corresponds to the default model. Then we use the result of the previous optimization as a starting value. <code>use_bayes</code> determines whether to use the Bayesian inference parameters for <code>α</code>.</p><p>This function will return a dictionary object that holds the results of the optimization, e.g. spectral function, χ² deviation.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.precompute-Tuple{Vector{Float64}, Vector{Float64}, AbstractMesh, Vector{Float64}, Matrix{Float64}}" href="#ACFlow.precompute-Tuple{Vector{Float64}, Vector{Float64}, AbstractMesh, Vector{Float64}, Matrix{Float64}}"><code>ACFlow.precompute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">precompute(
    Gᵥ::Vector{F64},
    σ²::Vector{F64},
    am::AbstractMesh,
    D::Vector{F64},
    K::Matrix{F64}
    )</code></pre><p>Precompute some key coefficients. Here <code>Gᵥ</code> and <code>σ²</code> are input data, <code>am</code> is the mesh for spectrum, <code>D</code> is the default model, and <code>K</code> is the kernel function.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.f_and_J" href="#ACFlow.f_and_J"><code>ACFlow.f_and_J</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">f_and_J(u::Vector{F64}, mec::MaxEntContext, α::F64)</code></pre><p>This function evaluates the function whose root we want to find. Here <code>u</code> is a singular space vector that parametrizes the spectral function, and <code>α</code> is a (positive) weight factor of the entropy.</p><p>It returns <code>f</code>, value of the function whose zero we want to find, and <code>J</code>, jacobian at the current position.</p><p>See also: <a href="solver.html#ACFlow.f_and_J_od"><code>f_and_J_od</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.f_and_J_od" href="#ACFlow.f_and_J_od"><code>ACFlow.f_and_J_od</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">f_and_J_od(u::Vector{F64}, mec::MaxEntContext, α::F64)</code></pre><p>This function evaluates the function whose root we want to find. Here <code>u</code> is a singular space vector that parametrizes the spectral function, and <code>α</code> is a (positive) weight factor of the entropy.</p><p>It returns <code>f</code>, value of the function whose zero we want to find, and <code>J</code>, jacobian at the current position.</p><p>This function is similar to <code>f_and_J</code>, but for offdiagonal elements.</p><p>See also: <a href="solver.html#ACFlow.f_and_J"><code>f_and_J</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.svd_to_real" href="#ACFlow.svd_to_real"><code>ACFlow.svd_to_real</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">svd_to_real(mec::MaxEntContext, u::Vector{F64})</code></pre><p>Go from singular value space to real space. It will transform the singular space vector <code>u</code> into real-frequency space (to get the spectral function) by <code>A(ω) = D(ω) eⱽᵘ</code>, where <code>D(ω)</code> is the default model <code>V</code> is the matrix from the singular value decomposition. The argument <code>u</code> means a singular space vector that parametrizes the spectral function.</p><p>See also: <a href="solver.html#ACFlow.svd_to_real_od"><code>svd_to_real_od</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.svd_to_real_od" href="#ACFlow.svd_to_real_od"><code>ACFlow.svd_to_real_od</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">svd_to_real_od(mec::MaxEntContext, u::Vector{F64})</code></pre><p>Go from singular value space to real space. It will transform the singular space vector <code>u</code> into real-frequency space in the case of an offdiagonal element. It will return the spectral function.</p><p>See also: <a href="solver.html#ACFlow.svd_to_real"><code>svd_to_real</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_entropy" href="#ACFlow.calc_entropy"><code>ACFlow.calc_entropy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calc_entropy(mec::MaxEntContext, A::Vector{F64}, u::Vector{F64})</code></pre><p>It computes entropy for positive definite spectral function. Here the arguments <code>A</code> means spectral function and <code>u</code> means a singular space vector that parametrizes the spectral function.</p><p>See also: <a href="solver.html#ACFlow.calc_entropy_od"><code>calc_entropy_od</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_entropy_od" href="#ACFlow.calc_entropy_od"><code>ACFlow.calc_entropy_od</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calc_entropy_od(mec::MaxEntContext, A::Vector{F64})</code></pre><p>It compute <em>positive-negative entropy</em> for spectral function with norm 0. Here the argument <code>A</code> means spectral function.</p><p>See also: <a href="solver.html#ACFlow.calc_entropy"><code>calc_entropy</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_bayes" href="#ACFlow.calc_bayes"><code>ACFlow.calc_bayes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calc_bayes(
    mec::MaxEntContext,
    A::Vector{F64},
    S::F64,
    χ²::F64,
    α::F64
    )</code></pre><p>It calculates Bayesian convergence criterion (<code>ng</code>, <code>tr</code>, and <code>conv</code>) for classic maxent (maximum of probablility distribution) and then Bayesian a-posteriori probability (<code>log_prob</code>) for <code>α</code> after optimization of <code>A</code>.</p><p>Here, <code>A</code> is the spectral function, <code>S</code> the entropy, <code>χ²</code> the deviation, and <code>α</code> weight factor of the entropy.</p><p>See also: <a href="solver.html#ACFlow.calc_bayes_od"><code>calc_bayes_od</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_bayes_od" href="#ACFlow.calc_bayes_od"><code>ACFlow.calc_bayes_od</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calc_bayes_od(
    mec::MaxEntContext,
    A::Vector{F64},
    S::F64,
    χ²::F64,
    α::F64
    )</code></pre><p>It calculates Bayesian convergence criterion (<code>ng</code>, <code>tr</code>, and <code>conv</code>) for classic maxent (maximum of probablility distribution) and then Bayesian a-posteriori probability (<code>log_prob</code>) for <code>α</code> after optimization of <code>A</code>.</p><p>Here, <code>A</code> is the spectral function, <code>S</code> the entropy, <code>χ²</code> the deviation, and <code>α</code> weight factor of the entropy.</p><p>It is just a offdiagonal version of <code>calc_bayes()</code>.</p><p>See also: <a href="solver.html#ACFlow.calc_bayes"><code>calc_bayes</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_chi2-Tuple{MaxEntContext, Vector{Float64}}" href="#ACFlow.calc_chi2-Tuple{MaxEntContext, Vector{Float64}}"><code>ACFlow.calc_chi2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_chi2(mec::MaxEntContext, A::Vector{F64})</code></pre><p>It computes the χ²-deviation of the spectral function <code>A</code>.</p></div></section></article><h2 id="BarRat-Solver"><a class="docs-heading-anchor" href="#BarRat-Solver">BarRat Solver</a><a id="BarRat-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#BarRat-Solver" title="Permalink"></a></h2><h3 id="Structs-2"><a class="docs-heading-anchor" href="#Structs-2">Structs</a><a class="docs-heading-anchor-permalink" href="#Structs-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.BarRatSolver" href="#ACFlow.BarRatSolver"><code>ACFlow.BarRatSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BarRatSolver</code></pre><p>It represents the analytic continuation solver that implements the barycentric rational function method.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.BarRatContext" href="#ACFlow.BarRatContext"><code>ACFlow.BarRatContext</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BarRatContext</code></pre><p>Mutable struct. It is used within the BarRat solver only.</p><p><strong>Members</strong></p><ul><li>Gᵥ   -&gt; Input data for correlator.</li><li>grid -&gt; Grid for input data.</li><li>mesh -&gt; Mesh for output spectrum.</li><li>𝒫    -&gt; Prony approximation for the input data.</li><li>ℬ    -&gt; Barycentric rational function approximation for the input data.</li><li>ℬP   -&gt; It means the positions of the poles.</li><li>ℬA   -&gt; It means the weights / amplitudes of the poles.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.BarycentricFunction" href="#ACFlow.BarycentricFunction"><code>ACFlow.BarycentricFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BarycentricFunction</code></pre><p>Mutable struct. Barycentric representation of a rational function.</p><p><strong>Members</strong></p><ul><li>nodes     -&gt; Nodes of the rational function, <span>$z_i$</span>.</li><li>values    -&gt; Values of the rational function, <span>$r(z_i)$</span>.</li><li>weights   -&gt; Weights of the rational function, <span>$w_i$</span>.</li><li>w<em>times</em>f -&gt; Weighted values of the rational function, <span>$w_i f_i$</span>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.PronyApproximation" href="#ACFlow.PronyApproximation"><code>ACFlow.PronyApproximation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PronyApproximation</code></pre><p>Mutable struct. Prony approximation to a complex-valued Matsubara function.</p><p><strong>Members</strong></p><ul><li>𝑁ₚ -&gt; Number of nodes for Prony approximation.</li><li>ωₚ -&gt; Non-negative Matsubara frequency.</li><li>𝐺ₚ -&gt; Complex values at ωₚ.</li><li>Γₚ -&gt; Nodes for Prony approximation, <span>$γ_i$</span>.</li><li>Ωₚ -&gt; Weights for Prony approximation, <span>$w_i$</span>.</li></ul></div></section></article><h3 id="Functions-2"><a class="docs-heading-anchor" href="#Functions-2">Functions</a><a class="docs-heading-anchor-permalink" href="#Functions-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.solve-Tuple{BarRatSolver, RawData}" href="#ACFlow.solve-Tuple{BarRatSolver, RawData}"><code>ACFlow.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve(S::BarRatSolver, rd::RawData)</code></pre><p>Solve the analytic continuation problem by the barycentric rational function method.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.init-Tuple{BarRatSolver, RawData}" href="#ACFlow.init-Tuple{BarRatSolver, RawData}"><code>ACFlow.init</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init(S::BarRatSolver, rd::RawData)</code></pre><p>Initialize the BarRat solver and return a BarRatContext struct.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.run-Tuple{BarRatContext}" href="#ACFlow.run-Tuple{BarRatContext}"><code>ACFlow.run</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">run(brc::BarRatContext)</code></pre><p>At first, it will try to construct a Prony approximation for the input Matsubara data. Then the Prony approximation is used to build smooth data set (data denoising). Finally, the barycentric rational function for this data set is constructed. The member <code>ℬ</code> of the BarRatContext object (<code>brc</code>) should be updated in this function.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.last-Tuple{BarRatContext}" href="#ACFlow.last-Tuple{BarRatContext}"><code>ACFlow.last</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">last(brc::BarRatContext)</code></pre><p>It will process and write the calculated results by the BarRat solver, including correlator at real axis, final spectral function, reproduced correlator. The information about Prony approximation and barycentric rational function approximation will be written as well.</p><p><strong>Arguments</strong></p><ul><li>brc -&gt; A BarRatContext object.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.aaa" href="#ACFlow.aaa"><code>ACFlow.aaa</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">aaa(z, y)</code></pre><p>Adaptively compute a barycentric rational interpolant.</p><p><strong>Arguments</strong></p><ul><li>z::AbstractVector{&lt;:Number} -&gt; Interpolation nodes.</li><li>y::AbstractVector{&lt;:Number} -&gt; Values at nodes.</li><li>max_degree::Integer=150 -&gt; Maximum numerator/denominator degree to use.</li><li>float_type::Type=F64 -&gt; Floating point type to use for the computation.</li><li>tol::Real=1000*eps(float_type) -&gt; Tolerance for stopping.</li><li>lookahead::Integer=10 -&gt; Number of iterations to determines stagnation.</li><li>stats::Bool=false -&gt; Return convergence statistics.</li></ul><p><strong>Returns</strong></p><ul><li>r::BarycentricFunction -&gt; The rational interpolant.</li><li>stats::NamedTuple -&gt; Convergence statistics, if keyword <code>stats = true</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; z = 1im * range(-10, 10, 500);

julia&gt; y = @. exp(z);

julia&gt; r = aaa(z, y);

julia&gt; bc_degree(r) # both numerator and denominator
12

julia&gt; first(nodes(r), 4)
4-element Vector{ComplexF64}:
 0.0 - 6.272545090180361im
 0.0 + 9.43887775551102im
 0.0 - 1.1022044088176353im
 0.0 + 4.909819639278557im

julia&gt; r(1im * π / 2)
-2.637151617496356e-15 + 1.0000000000000002im</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.poles!" href="#ACFlow.poles!"><code>ACFlow.poles!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">poles!(brc::BarRatContext)</code></pre><p>Convert the barycentric rational function approximation to the classic pole representation. Note that this feature is only suitable for the <code>atype</code> = &quot;delta&quot; case. In such case, the barycenteric algorithm can find the accurate positions for the poles via the <code>bc_poles()</code> function. But it seems that the weights for these poles are wrong. In this function, we just use the BFGS method to solve this optimization problem to get the correct weights for the poles. And then the positions and weights of these poles will be stored in <code>brc</code>, a BarRatContext object.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.bc_nodes" href="#ACFlow.bc_nodes"><code>ACFlow.bc_nodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bc_nodes(r::BarycentricFunction)</code></pre><p>Returns the nodes of the rational interpolant <code>r</code> as a vector. Actually, they are <span>$z_i$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.bc_values" href="#ACFlow.bc_values"><code>ACFlow.bc_values</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bc_values(r::BarycentricFunction)</code></pre><p>Returns the nodal values of the rational interpolant <code>r</code> as a vector. They are <span>$r(z_i) = f_i$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.bc_weights" href="#ACFlow.bc_weights"><code>ACFlow.bc_weights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bc_weights(r::BarycentricFunction)</code></pre><p>Returns the weights of the rational interpolant <code>r</code> as a vector. Actually, they are <span>$w_i$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.bc_degree" href="#ACFlow.bc_degree"><code>ACFlow.bc_degree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bc_degree(r::BarycentricFunction)</code></pre><p>Returns the degree of the numerator and denominator of the rational <code>r</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.bc_poles" href="#ACFlow.bc_poles"><code>ACFlow.bc_poles</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bc_poles(r::BarycentricFunction)</code></pre><p>Return the poles of the rational function <code>r</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.prony_data" href="#ACFlow.prony_data"><code>ACFlow.prony_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prony_data(ω₁::Vector{F64}, 𝐺₁::Vector{C64})</code></pre><p>Prepare essential data for the later Prony approximation. It will return the number of nodes, frequency mesh ωₚ, and Green&#39;s function data 𝐺ₚ at this mesh.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.prony_svd" href="#ACFlow.prony_svd"><code>ACFlow.prony_svd</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prony_svd(𝑁ₚ::I64, 𝐺ₚ::Vector{C64})</code></pre><p>Perform singular value decomposition for the matrix ℋ that is constructed from 𝐺ₚ. It will return the singular values <code>S</code> and orthogonal matrix <code>V</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.prony_idx" href="#ACFlow.prony_idx"><code>ACFlow.prony_idx</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prony_idx(S::Vector{F64}, ε::F64)</code></pre><p>The diagonal matrix (singular values) <code>S</code> is used to test whether the threshold <code>ε</code> is reasonable and figure out the index for extracting <code>v</code> from <code>V</code>.</p><p>See also: <a href="solver.html#ACFlow.prony_v"><code>prony_v</code></a>.</p></div></section><section><div><pre><code class="language-julia hljs">prony_idx(S::Vector{F64})</code></pre><p>The diagonal matrix (singular values) <code>S</code> is used to figure out the index for extracting <code>v</code> from <code>V</code>. This function is try to evaluate the maximum index for the exponentially decaying region of <code>S</code>.</p><p>See also: <a href="solver.html#ACFlow.prony_v"><code>prony_v</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.prony_v" href="#ACFlow.prony_v"><code>ACFlow.prony_v</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prony_v(V::Adjoint{C64, Matrix{C64}}, idx::I64)</code></pre><p>Extract suitable vector <code>v</code> from orthogonal matrix <code>V</code> according to the threshold <code>ε</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.prony_gamma" href="#ACFlow.prony_gamma"><code>ACFlow.prony_gamma</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prony_gamma(v::Vector{C64}, Λ::F64)</code></pre><p>Try to calculate Γₚ. Actually, Γₚ are eigenvalues of a matrix constructed by <code>v</code>. <code>Λ</code> is a cutoff for Γₚ. Only those Γₚ that are smaller than <code>Λ</code> are kept.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.prony_omega" href="#ACFlow.prony_omega"><code>ACFlow.prony_omega</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prony_omega(𝐺ₚ::Vector{C64}, Γₚ::Vector{C64})</code></pre><p>Try to calculate Ωₚ.</p></div></section></article><h2 id="NevanAC-Solver"><a class="docs-heading-anchor" href="#NevanAC-Solver">NevanAC Solver</a><a id="NevanAC-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#NevanAC-Solver" title="Permalink"></a></h2><h3 id="Structs-3"><a class="docs-heading-anchor" href="#Structs-3">Structs</a><a class="docs-heading-anchor-permalink" href="#Structs-3" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.NevanACSolver" href="#ACFlow.NevanACSolver"><code>ACFlow.NevanACSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NevanACSolver</code></pre><p>It represents the analytic continuation solver that implements the Nevanlinna analytical continuation (It doesn&#39;t support the analytic confinuations for matrix-valued Green&#39;s functions).</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.NevanACContext" href="#ACFlow.NevanACContext"><code>ACFlow.NevanACContext</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NevanACContext</code></pre><p>Mutable struct. It is used within the NevanAC solver only.</p><p><strong>Members</strong></p><ul><li>Gᵥ   -&gt; Input data for correlator.</li><li>grid -&gt; Grid for input data.</li><li>mesh -&gt; Mesh for output spectrum.</li><li>Φ    -&gt; <code>Φ</code> vector in Schur algorithm.</li><li>𝒜    -&gt; Coefficients matrix <code>abcd</code> in Schur algorithm.</li><li>ℋ    -&gt; Hardy matrix for Hardy basis optimization.</li><li>𝑎𝑏   -&gt; Coefficients matrix for expanding <code>θ</code> with Hardy basis.</li><li>hmin -&gt; Minimal value of the order of Hardy basis functions.</li><li>hopt -&gt; Optimal value of the order of Hardy basis functions.</li></ul></div></section></article><h3 id="Functions-3"><a class="docs-heading-anchor" href="#Functions-3">Functions</a><a class="docs-heading-anchor-permalink" href="#Functions-3" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.solve-Tuple{NevanACSolver, RawData}" href="#ACFlow.solve-Tuple{NevanACSolver, RawData}"><code>ACFlow.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve(S::NevanACSolver, rd::RawData)</code></pre><p>Solve the analytic continuation problem by the Nevanlinna analytical continuation method.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.init-Tuple{NevanACSolver, RawData}" href="#ACFlow.init-Tuple{NevanACSolver, RawData}"><code>ACFlow.init</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init(S::NevanACSolver, rd::RawData)</code></pre><p>Initialize the NevanAC solver and return a NevanACContext struct.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.run-Tuple{NevanACContext}" href="#ACFlow.run-Tuple{NevanACContext}"><code>ACFlow.run</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">run(nac::NevanACContext)</code></pre><p>Perform Hardy basis optimization to smooth the spectrum. the members <code>ℋ</code>, <code>𝑎𝑏</code>, <code>hmin</code>, and <code>hopt</code> of the NevanACContext object (<code>nac</code>) should be updated in this function.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.last-Tuple{NevanACContext}" href="#ACFlow.last-Tuple{NevanACContext}"><code>ACFlow.last</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">last(nac::NevanACContext)</code></pre><p>Postprocess the results generated during the Nevanlinna analytical continuation simulations.</p><p><strong>Arguments</strong></p><ul><li>nac -&gt; A NevanACContext object.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.precompute-Tuple{AbstractGrid, AbstractMesh, Vector{Complex{BigFloat}}}" href="#ACFlow.precompute-Tuple{AbstractGrid, AbstractMesh, Vector{Complex{BigFloat}}}"><code>ACFlow.precompute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">precompute(
    grid::AbstractGrid,
    mesh::AbstractMesh,
    Gᵥ::Vector{APC}
    )</code></pre><p>Precompute some key quantities, such as <code>Φ</code>, <code>𝒜</code>, <code>ℋ</code>, and <code>𝑎𝑏</code>. Note that <code>Φ</code> and <code>𝒜</code> won&#39;t be changed any more. But <code>ℋ</code> and <code>𝑎𝑏</code> should be updated by the Hardy basis optimization to get a smooth spectrum. Here <code>Gᵥ</code> is input data, <code>grid</code> is the grid for input data, and <code>mesh</code> is the mesh for output spectrum.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_mobius" href="#ACFlow.calc_mobius"><code>ACFlow.calc_mobius</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calc_mobius(z::Vector{APC})</code></pre><p>A direct Mobius transformation.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_inv_mobius" href="#ACFlow.calc_inv_mobius"><code>ACFlow.calc_inv_mobius</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calc_inv_mobius(z::Vector{APC})</code></pre><p>An inverse Mobius transformation.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_pick" href="#ACFlow.calc_pick"><code>ACFlow.calc_pick</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calc_pick(k::I64, ℎ::Vector{APC}, λ::Vector{APC})</code></pre><p>Try to calculate the Pick matrix, anc check whether it is a positive semidefinite matrix. See Eq. (5) in Fei&#39;s NAC paper.</p><p><strong>Arguments</strong></p><ul><li>k -&gt; Size of the Pick matrix.</li><li>ℎ -&gt; Vector ℎ. It is actually 𝑧.</li><li>λ -&gt; Vector λ. It is actually 𝒢(𝑧).</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_phis" href="#ACFlow.calc_phis"><code>ACFlow.calc_phis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calc_phis(grid::AbstractGrid, Gᵥ::Vector{APC})</code></pre><p>Try to calculate the Φ vector, which is used to calculate the 𝒜 matrix. Note that Φ should not be changed anymore once it has been established.</p><p><strong>Arguments</strong></p><ul><li>grid -&gt; Grid in imaginary axis for input Green&#39;s function.</li><li>Gᵥ   -&gt; Input Green&#39;s function.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_abcd" href="#ACFlow.calc_abcd"><code>ACFlow.calc_abcd</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calc_abcd(grid::AbstractGrid, mesh::AbstractMesh, Φ::Vector{APC})</code></pre><p>Try to calculate the coefficients matrix abcd (here it is called 𝒜), which is then used to calculate θ. See Eq. (8) in Fei&#39;s NAC paper.</p><p><strong>Arguments</strong></p><ul><li>grid -&gt; Grid in imaginary axis for input Green&#39;s function.</li><li>mesh -&gt; Real frequency mesh.</li><li>Φ    -&gt; Φ vector calculated by <code>calc_phis()</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_hbasis" href="#ACFlow.calc_hbasis"><code>ACFlow.calc_hbasis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calc_hbasis(z::APC, k::I64)</code></pre><p>Try to calculate the Hardy basis <span>$f^k(z)$</span>.</p><p><strong>Arguments</strong></p><ul><li>z -&gt; A complex variable.</li><li>k -&gt; Current order for the Hardy basis.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_hmatrix" href="#ACFlow.calc_hmatrix"><code>ACFlow.calc_hmatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calc_hmatrix(mesh::AbstractMesh, H::I64)</code></pre><p>Try to calculate <span>$[f^k(z), f^k(z)^*]$</span> for 0 ≤ 𝑘 ≤ 𝐻-1, which is called the hardy matrix (ℋ) and is used to evaluate θₘ₊₁.</p><p><strong>Arguments</strong></p><ul><li>mesh -&gt; Real frequency mesh.</li><li>H    -&gt; Maximum order for the Hardy basis.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_theta-Tuple{Array{Complex{BigFloat}, 3}, Matrix{Complex{BigFloat}}, Vector{ComplexF64}}" href="#ACFlow.calc_theta-Tuple{Array{Complex{BigFloat}, 3}, Matrix{Complex{BigFloat}}, Vector{ComplexF64}}"><code>ACFlow.calc_theta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_theta(𝒜::Array{APC,3}, ℋ::Array{APC,2}, 𝑎𝑏::Vector{C64})</code></pre><p>Try to calculate the contractive function θ(z). 𝒜 is the coefficients matrix abcd, ℋ is the Hardy matrix, and 𝑎𝑏 are complex coefficients for expanding θₘ₊₁. See Eq. (7) in Fei&#39;s NAC paper.</p><p><strong>Arguments</strong></p><ul><li>𝒜  -&gt; Matrix 𝑎𝑏𝑐𝑑.</li><li>ℋ  -&gt; Hardy matrix.</li><li>𝑎𝑏 -&gt; Expansion coefficients 𝑎 and 𝑏 for the contractive function θ.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_green-Tuple{Array{Complex{BigFloat}, 3}, Matrix{Complex{BigFloat}}, Vector{ComplexF64}}" href="#ACFlow.calc_green-Tuple{Array{Complex{BigFloat}, 3}, Matrix{Complex{BigFloat}}, Vector{ComplexF64}}"><code>ACFlow.calc_green</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_green(𝒜::Array{APC,3}, ℋ::Array{APC,2}, 𝑎𝑏::Vector{C64})</code></pre><p>Firstly we try to calculate θ. Then θ is back transformed to a Nevanlinna interpolant via the inverse Mobius transform. Here, <code>𝒜</code> (<code>abcd</code> matrix), <code>ℋ</code> (Hardy matrix), and <code>𝑎𝑏</code> are used to evaluate θ.</p><p><strong>Arguments</strong></p><ul><li>𝒜  -&gt; Matrix 𝑎𝑏𝑐𝑑.</li><li>ℋ  -&gt; Hardy matrix.</li><li>𝑎𝑏 -&gt; Expansion coefficients 𝑎 and 𝑏 for the contractive function θ.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_noptim" href="#ACFlow.calc_noptim"><code>ACFlow.calc_noptim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calc_noptim(ωₙ::Vector{APC}, Gₙ::Vector{APC})</code></pre><p>Evaluate the optimal value for the size of input data (how may frequency points are actually used in the analytic continuation simulations) via the Pick criterion.</p><p><strong>Arguments</strong></p><ul><li>ωₙ -&gt; Matsubara frequency points (the 𝑖 unit is not included).</li><li>Gₙ -&gt; Matsubara Green&#39;s function.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_hmin!" href="#ACFlow.calc_hmin!"><code>ACFlow.calc_hmin!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calc_hmin!(nac::NevanACContext)</code></pre><p>Try to perform Hardy basis optimization. Such that the Hardy matrix ℋ and the corresponding coefficients 𝑎𝑏 are updated. They are used to calculate θ, which is then back transformed to generate smooth G (i.e., the spectrum) at real axis.</p><p>This function will determine the minimal value of H (hmin). Of course, ℋ and 𝑎𝑏 in NevanACContext object are also changed.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_hopt!" href="#ACFlow.calc_hopt!"><code>ACFlow.calc_hopt!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calc_hopt!(nac::NevanACContext)</code></pre><p>Try to perform Hardy basis optimization. Such that the Hardy matrix ℋ and the corresponding coefficients 𝑎𝑏 are updated. They are used to calculate θ, which is then back transformed to generate smooth G (i.e., the spectrum) at real axis.</p><p>This function will determine the optimal value of H (hopt). Of course, ℋ and 𝑎𝑏 in NevanACContext object are also changed.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.hardy_optimize!" href="#ACFlow.hardy_optimize!"><code>ACFlow.hardy_optimize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hardy_optimize!(
    nac::NevanACContext,
    ℋ::Array{APC,2},
    𝑎𝑏::Vector{C64},
    H::I64
    )</code></pre><p>For given Hardy matrix ℋ, try to update the expanding coefficients 𝑎𝑏 by minimizing the smooth norm.</p><p><strong>Arguments</strong></p><ul><li>nac -&gt; A NevanACContext object.</li><li>ℋ   -&gt; Hardy matrix, which contains the Hardy basis.</li><li>𝑎𝑏  -&gt; Expansion coefficients 𝑎 and 𝑏 for the contractive function θ.</li><li>H   -&gt; Maximum order of the Hardy basis.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.smooth_norm" href="#ACFlow.smooth_norm"><code>ACFlow.smooth_norm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">smooth_norm(nac::NevanACContext, ℋ::Array{APC,2}, 𝑎𝑏::Vector{C64})</code></pre><p>Establish the smooth norm, which is used to improve the smoothness of the output spectrum.</p><p><strong>Arguments</strong></p><ul><li>nac -&gt; A NevanACContext object.</li><li>ℋ   -&gt; Hardy matrix, which contains the Hardy basis.</li><li>𝑎𝑏  -&gt; Expansion coefficients 𝑎 and 𝑏 for the contractive function θ.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.check_pick" href="#ACFlow.check_pick"><code>ACFlow.check_pick</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_pick(wn::Vector{APC}, gw::Vector{APC}, Nopt::I64)</code></pre><p>Check whether the input data are valid (the Pick criterion is satisfied). Here, <code>wn</code> is the Matsubara frequency, <code>gw</code> is the Matsubara function, and <code>Nopt</code> is the optimized number of Matsubara data points.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.check_causality" href="#ACFlow.check_causality"><code>ACFlow.check_causality</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_causality(ℋ::Array{APC,2}, 𝑎𝑏::Vector{C64})</code></pre><p>Check causality of the Hardy coefficients <code>𝑎𝑏</code>.</p></div></section></article><h2 id="StochAC-Solver"><a class="docs-heading-anchor" href="#StochAC-Solver">StochAC Solver</a><a id="StochAC-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#StochAC-Solver" title="Permalink"></a></h2><h3 id="Structs-4"><a class="docs-heading-anchor" href="#Structs-4">Structs</a><a class="docs-heading-anchor-permalink" href="#Structs-4" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.StochACSolver" href="#ACFlow.StochACSolver"><code>ACFlow.StochACSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StochACSolver</code></pre><p>It represents the analytic continuation solver that implements the stochastic analytic continuation method (K. S. D. Beach&#39;s version).</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.StochACMC" href="#ACFlow.StochACMC"><code>ACFlow.StochACMC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StochACMC</code></pre><p>Mutable struct. It is used within the StochAC solver. It includes random number generator and some counters.</p><p><strong>Members</strong></p><ul><li>rng  -&gt; Random number generator.</li><li>Macc -&gt; Counter for move operation (accepted).</li><li>Mtry -&gt; Counter for move operation (tried).</li><li>Sacc -&gt; Counter for swap operation (accepted).</li><li>Stry -&gt; Counter for swap operation (tried).</li></ul><p>See also: <a href="solver.html#ACFlow.StochACSolver"><code>StochACSolver</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.StochACElement" href="#ACFlow.StochACElement"><code>ACFlow.StochACElement</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StochACElement</code></pre><p>Mutable struct. It is used to record the field configurations, which will be sampled by  Monte Carlo sweeping procedure.</p><p><strong>Members</strong></p><ul><li>Γₚ -&gt; It means the positions of the δ functions.</li><li>Γₐ -&gt; It means the weights / amplitudes of the δ functions.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.StochACContext" href="#ACFlow.StochACContext"><code>ACFlow.StochACContext</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StochACContext</code></pre><p>Mutable struct. It is used within the StochAC solver only.</p><p><strong>Members</strong></p><ul><li>Gᵥ     -&gt; Input data for correlator.</li><li>σ¹     -&gt; Actually 1.0 / σ¹.</li><li>allow  -&gt; Allowable indices.</li><li>grid   -&gt; Grid for input data.</li><li>mesh   -&gt; Mesh for output spectrum.</li><li>model  -&gt; Default model function.</li><li>kernel -&gt; Default kernel function.</li><li>Aout   -&gt; Calculated spectral function, it is actually ⟨n(x)⟩.</li><li>Δ      -&gt; Precomputed δ functions.</li><li>hτ     -&gt; α-resolved h(τ).</li><li>Hα     -&gt; α-resolved Hc.</li><li>Uα     -&gt; α-resolved internal energy, it is actually ⟨Hα⟩.</li><li>αₗ     -&gt; Vector of the α parameters.</li></ul></div></section></article><h3 id="Functions-4"><a class="docs-heading-anchor" href="#Functions-4">Functions</a><a class="docs-heading-anchor-permalink" href="#Functions-4" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.solve-Tuple{StochACSolver, RawData}" href="#ACFlow.solve-Tuple{StochACSolver, RawData}"><code>ACFlow.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve(S::StochACSolver, rd::RawData)</code></pre><p>Solve the analytic continuation problem by the stochastic analytic continuation algorithm (K. S. D. Beach&#39;s version).</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.init-Tuple{StochACSolver, RawData}" href="#ACFlow.init-Tuple{StochACSolver, RawData}"><code>ACFlow.init</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init(S::StochACSolver, rd::RawData)</code></pre><p>Initialize the StochAC solver and return the StochACMC, StochACElement, and StochACContext structs.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.run-Tuple{StochACMC, StochACElement, StochACContext}" href="#ACFlow.run-Tuple{StochACMC, StochACElement, StochACContext}"><code>ACFlow.run</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">run(MC::StochACMC, SE::StochACElement, SC::StochACContext)</code></pre><p>Perform stochastic analytic continuation simulation, sequential version.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.prun-Tuple{StochACSolver, Dict{String, Vector{Any}}, Dict{String, Vector{Any}}, StochACMC, StochACElement, StochACContext}" href="#ACFlow.prun-Tuple{StochACSolver, Dict{String, Vector{Any}}, Dict{String, Vector{Any}}, StochACMC, StochACElement, StochACContext}"><code>ACFlow.prun</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prun(
    S::StochACSolver,
    p1::Dict{String,Vector{Any}},
    p2::Dict{String,Vector{Any}},
    MC::StochACMC,
    SE::StochACElement,
    SC::StochACContext
    )</code></pre><p>Perform stochastic analytic continuation simulation, parallel version. The arguments <code>p1</code> and <code>p2</code> are copies of PBASE and PStochAC, respectively.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.average-Tuple{Float64, StochACContext}" href="#ACFlow.average-Tuple{Float64, StochACContext}"><code>ACFlow.average</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">average(step::F64, SC::StochACContext)</code></pre><p>Postprocess the results generated during the stochastic analytic continuation simulations. It will calculate the spectral functions, and internal energies.</p><p><strong>Arguments</strong></p><ul><li>step -&gt; How many steps are there in the Monte Carlo samplings.</li><li>SC   -&gt; A StochACContext object.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.last-Tuple{StochACContext, Matrix{Float64}, Vector{Float64}}" href="#ACFlow.last-Tuple{StochACContext, Matrix{Float64}, Vector{Float64}}"><code>ACFlow.last</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">last(SC::StochACContext, Aout::Array{F64,2}, Uα::Vector{F64})</code></pre><p>It will process and write the calculated results by the StochAC solver, including effective hamiltonian, final spectral function, reproduced correlator.</p><p><strong>Arguments</strong></p><ul><li>SC   -&gt; A StochACContext object.</li><li>Aout -&gt; α-dependent spectral functions.</li><li>Uα   -&gt; α-dependent internal energies.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.warmup-Tuple{StochACMC, StochACElement, StochACContext}" href="#ACFlow.warmup-Tuple{StochACMC, StochACElement, StochACContext}"><code>ACFlow.warmup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">warmup(MC::StochACMC, SE::StochACElement, SC::StochACContext)</code></pre><p>Warmup the Monte Carlo engine to acheieve thermalized equilibrium.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.sample-Tuple{StochACMC, StochACElement, StochACContext}" href="#ACFlow.sample-Tuple{StochACMC, StochACElement, StochACContext}"><code>ACFlow.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample(MC::StochACMC, SE::StochACElement, SC::StochACContext)</code></pre><p>Perform Monte Carlo sweeps and sample the field configurations.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.measure-Tuple{StochACElement, StochACContext}" href="#ACFlow.measure-Tuple{StochACElement, StochACContext}"><code>ACFlow.measure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">measure(SE::StochACElement, SC::StochACContext)</code></pre><p>Measure the spectral functions and internal energies.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.init_mc-Tuple{StochACSolver}" href="#ACFlow.init_mc-Tuple{StochACSolver}"><code>ACFlow.init_mc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_mc(S::StochACSolver)</code></pre><p>Try to create a StochACMC struct.</p><p>See also: <a href="solver.html#ACFlow.StochACMC"><code>StochACMC</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.init_element-Tuple{StochACSolver, AbstractRNG, Vector{Int64}}" href="#ACFlow.init_element-Tuple{StochACSolver, AbstractRNG, Vector{Int64}}"><code>ACFlow.init_element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_element(S::StochACSolver, rng::AbstractRNG, allow::Vector{I64})</code></pre><p>Randomize the configurations for future Monte Carlo sampling. It will return a StochACElement object.</p><p><strong>Arguments</strong></p><ul><li>S     -&gt; A StochACSolver object.</li><li>rng   -&gt; Random number generator.</li><li>allow -&gt; Allowed positions for the δ peaks.</li></ul><p>See also: <a href="solver.html#ACFlow.StochACElement"><code>StochACElement</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.init_iodata-Tuple{StochACSolver, RawData}" href="#ACFlow.init_iodata-Tuple{StochACSolver, RawData}"><code>ACFlow.init_iodata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_iodata(S::StochACSolver, rd::RawData)</code></pre><p>Preprocess the input data (<code>rd</code>), then allocate memory for the α-resolved spectral functions.</p><p>See also: <a href="type.html#ACFlow.RawData"><code>RawData</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_fmesh-Tuple{StochACSolver}" href="#ACFlow.calc_fmesh-Tuple{StochACSolver}"><code>ACFlow.calc_fmesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_fmesh(S::StochACSolver)</code></pre><p>Try to calculate very fine (dense) mesh in [wmin, wmax], which is used internally to build the kernel function. Note that this mesh could be non-uniform. If the file <code>fmesh.inp</code> exists, the code will try to load it to initialize the mesh. Or else the code will try to create a linear mesh automatically.</p><p>See also: <a href="mesh.html#ACFlow.LinearMesh"><code>LinearMesh</code></a>, <a href="mesh.html#ACFlow.DynamicMesh"><code>DynamicMesh</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_phi" href="#ACFlow.calc_phi"><code>ACFlow.calc_phi</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calc_phi(am::AbstractMesh, model::Vector{F64})</code></pre><p>Try to calculate ϕ(ω) function. <code>am</code> is the mesh for calculated spectrum, and <code>model</code> means the default model function.</p><p>See also: <a href="mesh.html#ACFlow.AbstractMesh"><code>AbstractMesh</code></a>, <a href="solver.html#ACFlow.calc_delta"><code>calc_delta</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_delta" href="#ACFlow.calc_delta"><code>ACFlow.calc_delta</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calc_delta(fmesh::AbstractMesh, ϕ::Vector{F64})</code></pre><p>Precompute the δ functions. <code>fmesh</code> is a very dense mesh in [wmin, wmax] and <code>ϕ</code> is the ϕ function.</p><p>See also: <a href="solver.html#ACFlow.calc_phi"><code>calc_phi</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_hamil" href="#ACFlow.calc_hamil"><code>ACFlow.calc_hamil</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calc_hamil(
    Γₚ::Array{I64,2},
    Γₐ::Array{I64,2},
    kernel::Matrix{F64},
    Gᵥ::Vector{F64}
    )</code></pre><p>Initialize h(τ) and H(α) using Eq.(35) and Eq.(36), respectively. <code>Γₚ</code> and <code>Γₐ</code> represent n(x), <code>kernel</code> means the kernel function, <code>Gᵥ</code> is the correlator. Note that <code>kernel</code> and <code>Gᵥ</code> have been rotated into singular space. Please see comments in <code>init()</code> for more details.</p><p>See also: <a href="solver.html#ACFlow.calc_htau"><code>calc_htau</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_htau" href="#ACFlow.calc_htau"><code>ACFlow.calc_htau</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calc_htau(Γₚ, Γₐ, kernel, Gᵥ)</code></pre><p>Try to calculate α-dependent h(τ) via Eq.(36). <code>Γₚ</code> and <code>Γₐ</code> represent n(x), <code>kernel</code> means the kernel function, <code>Gᵥ</code> is the correlator. Note that <code>kernel</code> and <code>Gᵥ</code> have been rotated into singular space. Please see comments in <code>init()</code> for more details.</p><p>See also: <a href="solver.html#ACFlow.calc_hamil"><code>calc_hamil</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_alpha" href="#ACFlow.calc_alpha"><code>ACFlow.calc_alpha</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calc_alpha()</code></pre><p>Generate a list for the α parameters</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.constraints-Tuple{StochACSolver, AbstractMesh}" href="#ACFlow.constraints-Tuple{StochACSolver, AbstractMesh}"><code>ACFlow.constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraints(S::StochACSolver, fmesh::AbstractMesh)</code></pre><p>Try to implement the constrained stochastic analytic continuation method. This function will return a collection. It contains all the allowable indices. Be careful, the constrained stochastic analytic continuation method is compatible with the self-adaptive mesh.</p><p><strong>Arguments</strong></p><ul><li>S     -&gt; A StochACSolver object.</li><li>fmesh -&gt; Very dense mesh for the δ peaks.</li></ul><p>See also: <a href="solver.html#ACFlow.StochACSolver"><code>StochACSolver</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.try_move_a-Tuple{Int64, StochACMC, StochACElement, StochACContext}" href="#ACFlow.try_move_a-Tuple{Int64, StochACMC, StochACElement, StochACContext}"><code>ACFlow.try_move_a</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">try_move_a(
    i::I64,
    MC::StochACMC,
    SE::StochACElement,
    SC::StochACContext
    )</code></pre><p>Select two δ functions randomly and then change their weights. Here <code>i</code> means the index for α parameters.</p><p>See also: <a href="solver.html#ACFlow.try_move_p-Tuple{Int64, StochACMC, StochACElement, StochACContext}"><code>try_move_p</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.try_move_p-Tuple{Int64, StochACMC, StochACElement, StochACContext}" href="#ACFlow.try_move_p-Tuple{Int64, StochACMC, StochACElement, StochACContext}"><code>ACFlow.try_move_p</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">try_move_p(
    i::I64,
    MC::StochACMC,
    SE::StochACElement,
    SC::StochACContext
    )</code></pre><p>Select two δ functions randomly and then change their positions. Here <code>i</code> means the index for α parameters.</p><p>See also: <a href="solver.html#ACFlow.try_move_a-Tuple{Int64, StochACMC, StochACElement, StochACContext}"><code>try_move_a</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.try_move_x-Tuple{StochACMC, StochACElement, StochACContext}" href="#ACFlow.try_move_x-Tuple{StochACMC, StochACElement, StochACContext}"><code>ACFlow.try_move_x</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">try_move_x(
    MC::StochACMC,
    SE::StochACElement,
    SC::StochACContext
    )</code></pre><p>Try to exchange field configurations between two adjacent layers. Because this function involves two layers, so it doesn&#39;t need the argument <code>i</code>.</p></div></section></article><h2 id="StochSK-Solver"><a class="docs-heading-anchor" href="#StochSK-Solver">StochSK Solver</a><a id="StochSK-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#StochSK-Solver" title="Permalink"></a></h2><h3 id="Structs-5"><a class="docs-heading-anchor" href="#Structs-5">Structs</a><a class="docs-heading-anchor-permalink" href="#Structs-5" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.StochSKSolver" href="#ACFlow.StochSKSolver"><code>ACFlow.StochSKSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StochSKSolver</code></pre><p>It represents the analytic continuation solver that implements the stochastic analytic continuation method (A. W. Sandvik&#39;s version).</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.StochSKMC" href="#ACFlow.StochSKMC"><code>ACFlow.StochSKMC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StochSKMC</code></pre><p>Mutable struct. It is used within the StochSK solver. It includes random number generator and some counters.</p><p><strong>Members</strong></p><ul><li>rng  -&gt; Random number generator.</li><li>Sacc -&gt; Counter for single-updated operation (accepted).</li><li>Stry -&gt; Counter for single-updated operation (tried).</li><li>Pacc -&gt; Counter for pair-updated operation (accepted).</li><li>Ptry -&gt; Counter for pair-updated operation (tried).</li><li>Qacc -&gt; Counter for quadruple-updated operation (accepted).</li><li>Qtry -&gt; Counter for quadruple-updated operation (tried).</li></ul><p>See also: <a href="solver.html#ACFlow.StochSKSolver"><code>StochSKSolver</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.StochSKElement" href="#ACFlow.StochSKElement"><code>ACFlow.StochSKElement</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StochSKElement</code></pre><p>Mutable struct. It is used to record the field configurations, which will be sampled by Monte Carlo sweeping procedure.</p><p>In the present implementation of StochSK solver, the amplitudes of the δ functions are fixed. But in principles, they could be sampled in the Monte Carlo procedure.</p><p><strong>Members</strong></p><ul><li>P -&gt; It means the positions of the δ functions.</li><li>A -&gt; It means the weights / amplitudes of the δ functions.</li><li>W -&gt; It denotes the window that is used to shift the δ functions.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.StochSKContext" href="#ACFlow.StochSKContext"><code>ACFlow.StochSKContext</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StochSKContext</code></pre><p>Mutable struct. It is used within the StochSK solver only.</p><p><strong>Members</strong></p><ul><li>Gᵥ     -&gt; Input data for correlator.</li><li>Gᵧ     -&gt; Generated correlator.</li><li>σ¹     -&gt; Actually 1.0 / σ¹.</li><li>allow  -&gt; Allowable indices.</li><li>grid   -&gt; Imaginary axis grid for input data.</li><li>mesh   -&gt; Real frequency mesh for output spectrum.</li><li>kernel -&gt; Default kernel function.</li><li>Aout   -&gt; Calculated spectral function.</li><li>χ²     -&gt; Current goodness function.</li><li>χ²min  -&gt; Mininum goodness function.</li><li>χ²vec  -&gt; Vector of goodness function.</li><li>Θ      -&gt; Current Θ parameter.</li><li>Θvec   -&gt; Vector of Θ parameter.</li></ul></div></section></article><h3 id="Functions-5"><a class="docs-heading-anchor" href="#Functions-5">Functions</a><a class="docs-heading-anchor-permalink" href="#Functions-5" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.solve-Tuple{StochSKSolver, RawData}" href="#ACFlow.solve-Tuple{StochSKSolver, RawData}"><code>ACFlow.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve(S::StochSKSolver, rd::RawData)</code></pre><p>Solve the analytic continuation problem by the stochastic analytic continuation algorithm (A. W. Sandvik&#39;s version).</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.init-Tuple{StochSKSolver, RawData}" href="#ACFlow.init-Tuple{StochSKSolver, RawData}"><code>ACFlow.init</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init(S::StochSKSolver, rd::RawData)</code></pre><p>Initialize the StochSK solver and return the StochSKMC, StochSKElement, and StochSKContext structs.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.run-Tuple{StochSKMC, StochSKElement, StochSKContext}" href="#ACFlow.run-Tuple{StochSKMC, StochSKElement, StochSKContext}"><code>ACFlow.run</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">run(MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)</code></pre><p>Perform stochastic analytic continuation simulation, sequential version.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.prun-Tuple{StochSKSolver, Dict{String, Vector{Any}}, Dict{String, Vector{Any}}, StochSKMC, StochSKElement, StochSKContext}" href="#ACFlow.prun-Tuple{StochSKSolver, Dict{String, Vector{Any}}, Dict{String, Vector{Any}}, StochSKMC, StochSKElement, StochSKContext}"><code>ACFlow.prun</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prun(
    S::StochSKSolver,
    p1::Dict{String,Vector{Any}},
    p2::Dict{String,Vector{Any}},
    MC::StochSKMC,
    SE::StochSKElement,
    SC::StochSKContext
    )</code></pre><p>Perform stochastic analytic continuation simulation, parallel version. The arguments <code>p1</code> and <code>p2</code> are copies of PBASE and PStochSK, respectively.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.average-Tuple{Float64, StochSKContext}" href="#ACFlow.average-Tuple{Float64, StochSKContext}"><code>ACFlow.average</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">average(step::F64, SC::StochSKContext)</code></pre><p>Postprocess the results generated during the stochastic analytic continuation simulations. It will generate the spectral functions.</p><p><strong>Arguments</strong></p><ul><li>step -&gt; Number of Monte Carlo samplings.</li><li>SC   -&gt; A StochSKContext object.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.last-Tuple{StochSKContext, Vector{Float64}, Vector{Float64}, Vector{Float64}}" href="#ACFlow.last-Tuple{StochSKContext, Vector{Float64}, Vector{Float64}, Vector{Float64}}"><code>ACFlow.last</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">last(
    SC::StochSKContext,
    Asum::Vector{F64},
    χ²vec::Vector{F64},
    Θvec::Vector{F64}
    )</code></pre><p>It will process and write the calculated results by the StochSK solver, including final spectral function and reproduced correlator.</p><p><strong>Arguments</strong></p><ul><li>SC    -&gt; A StochSKContext object.</li><li>Asum  -&gt; Spectral function.</li><li>χ²vec -&gt; Θ-dependent χ².</li><li>Θvec  -&gt; List of the Θ parameters.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.warmup-Tuple{StochSKMC, StochSKElement, StochSKContext}" href="#ACFlow.warmup-Tuple{StochSKMC, StochSKElement, StochSKContext}"><code>ACFlow.warmup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">warmup(MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)</code></pre><p>Warmup the Monte Carlo engine to acheieve thermalized equilibrium. Then it will try to figure out the optimized Θ and the corresponding Monte Carlo field configuration.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.sample-Tuple{StochSKMC, StochSKElement, StochSKContext}" href="#ACFlow.sample-Tuple{StochSKMC, StochSKElement, StochSKContext}"><code>ACFlow.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample(MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)</code></pre><p>Perform Monte Carlo sweeps and sample the field configurations.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.measure-Tuple{StochSKElement, StochSKContext}" href="#ACFlow.measure-Tuple{StochSKElement, StochSKContext}"><code>ACFlow.measure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">measure(SE::StochSKElement, SC::StochSKContext)</code></pre><p>Measure the final spectral functions.</p><p>See also: <a href="mesh.html#ACFlow.nearest"><code>nearest</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.shuffle-Tuple{StochSKMC, StochSKElement, StochSKContext}" href="#ACFlow.shuffle-Tuple{StochSKMC, StochSKElement, StochSKContext}"><code>ACFlow.shuffle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shuffle(MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)</code></pre><p>Try to shuffle the Monte Carlo field configuration via the Metropolis algorithm. Then the window for shifting the δ functions is adjusted.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.init_mc-Tuple{StochSKSolver}" href="#ACFlow.init_mc-Tuple{StochSKSolver}"><code>ACFlow.init_mc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_mc(S::StochSKSolver)</code></pre><p>Try to create a StochSKMC struct.</p><p>See also: <a href="solver.html#ACFlow.StochSKMC"><code>StochSKMC</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.init_element-Tuple{StochSKSolver, AbstractRNG, Vector{Int64}}" href="#ACFlow.init_element-Tuple{StochSKSolver, AbstractRNG, Vector{Int64}}"><code>ACFlow.init_element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_element(
    S::StochSKSolver,
    rng::AbstractRNG,
    allow::Vector{I64}
    )</code></pre><p>Randomize the configurations for future Monte Carlo sampling. It will return a StochSKElement object.</p><p><strong>Arguments</strong></p><ul><li>S     -&gt; A StochSKSolver object.</li><li>rng   -&gt; Random number generator.</li><li>allow -&gt; Allowed positions for the δ peaks.</li></ul><p>See also: <a href="solver.html#ACFlow.StochSKElement"><code>StochSKElement</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.init_iodata-Tuple{StochSKSolver, RawData}" href="#ACFlow.init_iodata-Tuple{StochSKSolver, RawData}"><code>ACFlow.init_iodata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_iodata(S::StochSKSolver, rd::RawData)</code></pre><p>Preprocess the input data (<code>rd</code>), then allocate memory for the calculated spectral functions.</p><p>See also: <a href="type.html#ACFlow.RawData"><code>RawData</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_fmesh-Tuple{StochSKSolver}" href="#ACFlow.calc_fmesh-Tuple{StochSKSolver}"><code>ACFlow.calc_fmesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_fmesh(S::StochSKSolver)</code></pre><p>Try to calculate very fine (dense) linear mesh in [wmin, wmax], which is used internally to build the kernel function. Note that the stochastic analytic continuation method (A. W. Sandvik&#39;s version) does not support the self-adaptive mesh.</p><p>See also: <a href="mesh.html#ACFlow.LinearMesh"><code>LinearMesh</code></a>, <a href="mesh.html#ACFlow.DynamicMesh"><code>DynamicMesh</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_correlator" href="#ACFlow.calc_correlator"><code>ACFlow.calc_correlator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calc_correlator(SE::StochSKElement, kernel::Array{F64,2})</code></pre><p>Try to calculate correlator with the kernel function and the Monte Carlo field configuration. This correlator will then be used to evaluate the goodness function.</p><p><strong>Arguments</strong></p><ul><li>SE     -&gt; A StochSKElement object.</li><li>kernel -&gt; The fermionic or bosonic kernel.</li></ul><p>See also: <a href="solver.html#ACFlow.calc_goodness"><code>calc_goodness</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_goodness" href="#ACFlow.calc_goodness"><code>ACFlow.calc_goodness</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calc_goodness(Gₙ::Vector{F64}, Gᵥ::Vector{F64})</code></pre><p>Try to calculate the goodness function (i.e, χ²), which measures the distance between input and regenerated correlators.</p><p><strong>Arguments</strong></p><ul><li>Gₙ -&gt; Reconstructed correlators.</li><li>Gᵥ -&gt; Input (original) correlators.</li></ul><p>See also: <a href="solver.html#ACFlow.calc_correlator"><code>calc_correlator</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_theta" href="#ACFlow.calc_theta"><code>ACFlow.calc_theta</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calc_theta(𝒜::Array{APC,3}, ℋ::Array{APC,2}, 𝑎𝑏::Vector{C64})</code></pre><p>Try to calculate the contractive function θ(z). 𝒜 is the coefficients matrix abcd, ℋ is the Hardy matrix, and 𝑎𝑏 are complex coefficients for expanding θₘ₊₁. See Eq. (7) in Fei&#39;s NAC paper.</p><p><strong>Arguments</strong></p><ul><li>𝒜  -&gt; Matrix 𝑎𝑏𝑐𝑑.</li><li>ℋ  -&gt; Hardy matrix.</li><li>𝑎𝑏 -&gt; Expansion coefficients 𝑎 and 𝑏 for the contractive function θ.</li></ul></div></section><section><div><pre><code class="language-julia hljs">calc_theta(len::I64, SC::StochSKContext)</code></pre><p>Try to locate the optimal Θ and χ². This function implements the <code>chi2min</code> and <code>chi2kink</code> algorithms. Note that the <code>chi2min</code> algorithm is preferred.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.constraints-Tuple{StochSKSolver, AbstractMesh}" href="#ACFlow.constraints-Tuple{StochSKSolver, AbstractMesh}"><code>ACFlow.constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraints(S::StochSKSolver, fmesh::AbstractMesh)</code></pre><p>Try to implement the constrained stochastic analytic continuation method. This function will return a collection. It contains all the allowable indices. Be careful, <code>fmesh</code> should be a fine linear mesh.</p><p><strong>Arguments</strong></p><ul><li>S     -&gt; A StochSKSolver object.</li><li>fmesh -&gt; Very dense mesh for the δ peaks.</li></ul><p>See also: <a href="solver.html#ACFlow.StochSKSolver"><code>StochSKSolver</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.try_move_s-Tuple{StochSKMC, StochSKElement, StochSKContext}" href="#ACFlow.try_move_s-Tuple{StochSKMC, StochSKElement, StochSKContext}"><code>ACFlow.try_move_s</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">try_move_s(MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)</code></pre><p>Try to update the Monte Carlo field configurations via the Metropolis algorithm. In each update, only single δ function is shifted.</p><p>See also: <a href="solver.html#ACFlow.try_move_p-Tuple{Int64, StochACMC, StochACElement, StochACContext}"><code>try_move_p</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.try_move_p-Tuple{StochSKMC, StochSKElement, StochSKContext}" href="#ACFlow.try_move_p-Tuple{StochSKMC, StochSKElement, StochSKContext}"><code>ACFlow.try_move_p</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">try_move_p(MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)</code></pre><p>Try to update the Monte Carlo field configurations via the Metropolis algorithm. In each update, only a pair of δ functions are shifted.</p><p>See also: <a href="solver.html#ACFlow.try_move_s-Tuple{StochSKMC, StochSKElement, StochSKContext}"><code>try_move_s</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.try_move_q-Tuple{StochSKMC, StochSKElement, StochSKContext}" href="#ACFlow.try_move_q-Tuple{StochSKMC, StochSKElement, StochSKContext}"><code>ACFlow.try_move_q</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">try_move_q(MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)</code></pre><p>Try to update the Monte Carlo field configurations via the Metropolis algorithm. In each update, four different δ functions are shifted.</p><p>See also: <a href="solver.html#ACFlow.try_move_s-Tuple{StochSKMC, StochSKElement, StochSKContext}"><code>try_move_s</code></a>.</p></div></section></article><h2 id="StochOM-Solver"><a class="docs-heading-anchor" href="#StochOM-Solver">StochOM Solver</a><a id="StochOM-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#StochOM-Solver" title="Permalink"></a></h2><h3 id="Structs-6"><a class="docs-heading-anchor" href="#Structs-6">Structs</a><a class="docs-heading-anchor-permalink" href="#Structs-6" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.StochOMSolver" href="#ACFlow.StochOMSolver"><code>ACFlow.StochOMSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StochOMSolver</code></pre><p>It represents the analytic continuation solver that implements the stochastic optimization method.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.StochOMMC" href="#ACFlow.StochOMMC"><code>ACFlow.StochOMMC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StochOMMC</code></pre><p>Mutable struct. It is used within the StochOM solver. It includes random number generator and some counters.</p><p><strong>Members</strong></p><ul><li>rng  -&gt; Random number generator.</li><li>Macc -&gt; Counter for move operation (accepted).</li><li>Mtry -&gt; Counter for move operation (tried).</li></ul><p>See also: <a href="solver.html#ACFlow.StochOMSolver"><code>StochOMSolver</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.Box" href="#ACFlow.Box"><code>ACFlow.Box</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Box</code></pre><p>Rectangle. The field configuration consists of many boxes. They exhibit various areas (width × height). We use the Metropolis important sampling algorithm to sample them and evaluate their contributions to the spectrum.</p><p><strong>Members</strong></p><ul><li>h -&gt; Height of the box.</li><li>w -&gt; Width of the box.</li><li>c -&gt; Position of the box.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.StochOMElement" href="#ACFlow.StochOMElement"><code>ACFlow.StochOMElement</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StochOMElement</code></pre><p>Mutable struct. It is used to record the field configurations, which will be sampled by Monte Carlo sweeping procedure.</p><p><strong>Members</strong></p><ul><li>C -&gt; Field configuration.</li><li>Λ -&gt; Contributions of the field configuration to the correlator.</li><li>G -&gt; Reproduced correlator.</li><li>Δ -&gt; Difference between reproduced and raw correlators.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.StochOMContext" href="#ACFlow.StochOMContext"><code>ACFlow.StochOMContext</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StochOMContext</code></pre><p>Mutable struct. It is used within the StochOM solver only.</p><p><strong>Members</strong></p><ul><li>Gᵥ    -&gt; Input data for correlator.</li><li>σ¹    -&gt; Actually 1.0 / σ¹.</li><li>grid  -&gt; Grid for input data.</li><li>mesh  -&gt; Mesh for output spectrum.</li><li>Cᵥ    -&gt; It is used to record the field configurations for all attempts.</li><li>Δᵥ    -&gt; It is used to record the errors for all attempts.</li><li>𝕊ᵥ    -&gt; It is used to interpolate the Λ functions.</li></ul></div></section></article><h3 id="Functions-6"><a class="docs-heading-anchor" href="#Functions-6">Functions</a><a class="docs-heading-anchor-permalink" href="#Functions-6" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.solve-Tuple{StochOMSolver, RawData}" href="#ACFlow.solve-Tuple{StochOMSolver, RawData}"><code>ACFlow.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve(S::StochOMSolver, rd::RawData)</code></pre><p>Solve the analytic continuation problem by the stochastic optimization method.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.init-Tuple{StochOMSolver, RawData}" href="#ACFlow.init-Tuple{StochOMSolver, RawData}"><code>ACFlow.init</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init(S::StochOMSolver, rd::RawData)</code></pre><p>Initialize the StochOM solver and return the StochOMMC and StochOMContext structs.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.run-Tuple{StochOMMC, StochOMContext}" href="#ACFlow.run-Tuple{StochOMMC, StochOMContext}"><code>ACFlow.run</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">run(MC::StochOMMC, SC::StochOMContext)</code></pre><p>Perform stochastic optimization simulation, sequential version.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.prun-Tuple{StochOMSolver, Dict{String, Vector{Any}}, Dict{String, Vector{Any}}, StochOMMC, StochOMContext}" href="#ACFlow.prun-Tuple{StochOMSolver, Dict{String, Vector{Any}}, Dict{String, Vector{Any}}, StochOMMC, StochOMContext}"><code>ACFlow.prun</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prun(
    S::StochOMSolver,
    p1::Dict{String,Vector{Any}},
    p2::Dict{String,Vector{Any}},
    MC::StochOMMC,
    SC::StochOMContext
    )</code></pre><p>Perform stochastic optimization simulation, parallel version. The arguments <code>p1</code> and <code>p2</code> are copies of PBASE and PStochOM, respectively.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.average-Tuple{StochOMContext}" href="#ACFlow.average-Tuple{StochOMContext}"><code>ACFlow.average</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">average(SC::StochOMContext)</code></pre><p>Postprocess the collected results after the stochastic optimization simulations. It will generate the spectral functions.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.last-Tuple{StochOMContext, Vector{Float64}}" href="#ACFlow.last-Tuple{StochOMContext, Vector{Float64}}"><code>ACFlow.last</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">last(SC::StochOMContext, Aout::Vector{F64})</code></pre><p>It will process and write the calculated results by the StochOM solver, including final spectral function and reproduced correlator.</p><p><strong>Arguments</strong></p><ul><li>SC   -&gt; A StochOMContext object.</li><li>Aout -&gt; Spectral function.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.update-Tuple{StochOMMC, StochOMElement, StochOMContext}" href="#ACFlow.update-Tuple{StochOMMC, StochOMElement, StochOMContext}"><code>ACFlow.update</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update(MC::StochOMMC, SE::StochOMElement, SC::StochOMContext)</code></pre><p>Using the Metropolis algorithm to update the field configuration, i.e, a collection of hundreds of boxes.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.init_mc-Tuple{StochOMSolver}" href="#ACFlow.init_mc-Tuple{StochOMSolver}"><code>ACFlow.init_mc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_mc(S::StochOMSolver)</code></pre><p>Try to create a StochOMMC struct.</p><p>See also: <a href="solver.html#ACFlow.StochOMMC"><code>StochOMMC</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.init_element-Tuple{StochOMMC, StochOMContext}" href="#ACFlow.init_element-Tuple{StochOMMC, StochOMContext}"><code>ACFlow.init_element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_element(MC::StochOMMC, SC::StochOMContext)</code></pre><p>Try to initialize a StochOMElement struct.</p><p>See also: <a href="solver.html#ACFlow.StochOMElement"><code>StochOMElement</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.init_iodata-Tuple{StochOMSolver, RawData}" href="#ACFlow.init_iodata-Tuple{StochOMSolver, RawData}"><code>ACFlow.init_iodata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_iodata(S::StochOMSolver, rd::RawData)</code></pre><p>Preprocess the input data (<code>rd</code>).</p><p>See also: <a href="type.html#ACFlow.RawData"><code>RawData</code></a>, <a href="type.html#ACFlow.GreenData"><code>GreenData</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.init_context-Tuple{StochOMSolver, AbstractGrid}" href="#ACFlow.init_context-Tuple{StochOMSolver, AbstractGrid}"><code>ACFlow.init_context</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_context(S::StochOMSolver, grid::AbstractGrid)</code></pre><p>Try to initialize the key members of a StochOMContext struct.</p><p>See also: <a href="solver.html#ACFlow.StochOMContext"><code>StochOMContext</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.eval_lambda" href="#ACFlow.eval_lambda"><code>ACFlow.eval_lambda</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eval_lambda(
    r::Box,
    grid::FermionicMatsubaraGrid,
    𝕊::Vector{&lt;:AbstractInterpolation}
    )</code></pre><p>Try to calculate the contribution of a given box <code>r</code> to the Λ function. This function works for FermionicMatsubaraGrid only. Because there is an analytic expression for this case, 𝕊 is useless.</p><p>Actually, 𝕊 is undefined here. See init_context().</p><p><strong>Arguments</strong></p><ul><li>r    -&gt; A box or rectangle.</li><li>grid -&gt; Imaginary axis grid for input data.</li><li>𝕊    -&gt; An interpolant.</li></ul><p>See also: <a href="grid.html#ACFlow.FermionicMatsubaraGrid"><code>FermionicMatsubaraGrid</code></a>.</p></div></section><section><div><pre><code class="language-julia hljs">eval_lambda(
    r::Box,
    grid::FermionicFragmentMatsubaraGrid,
    𝕊::Vector{&lt;:AbstractInterpolation}
    )</code></pre><p>Try to calculate the contribution of a given box <code>r</code> to the Λ function. This function works for FermionicFragmentMatsubaraGrid only. Because there is an analytic expression for this case, 𝕊 is useless.</p><p>Actually, 𝕊 is undefined here. See init_context().</p><p><strong>Arguments</strong></p><ul><li>r    -&gt; A box or rectangle.</li><li>grid -&gt; Imaginary axis grid for input data.</li><li>𝕊    -&gt; An interpolant.</li></ul><p>See also: <a href="grid.html#ACFlow.FermionicFragmentMatsubaraGrid"><code>FermionicFragmentMatsubaraGrid</code></a>.</p></div></section><section><div><pre><code class="language-julia hljs">eval_lambda(
    r::Box,
    grid::FermionicImaginaryTimeGrid,
    𝕊::Vector{&lt;:AbstractInterpolation}
    )</code></pre><p>Try to calculate the contribution of a given box <code>r</code> to the Λ function. This function works for FermionicImaginaryTimeGrid only. Since there is not analytic expressions for this case, the cubic spline interpolation algorithm is adopted. Here, 𝕊 is initialized in init_context().</p><p><strong>Arguments</strong></p><ul><li>r    -&gt; A box or rectangle.</li><li>grid -&gt; Imaginary axis grid for input data.</li><li>𝕊    -&gt; An interpolant.</li></ul><p>See also: <a href="grid.html#ACFlow.FermionicImaginaryTimeGrid"><code>FermionicImaginaryTimeGrid</code></a>.</p></div></section><section><div><pre><code class="language-julia hljs">eval_lambda(
    r::Box,
    grid::FermionicFragmentTimeGrid,
    𝕊::Vector{&lt;:AbstractInterpolation}
    )</code></pre><p>Try to calculate the contribution of a given box <code>r</code> to the Λ function. This function works for FermionicFragmentTimeGrid only. Since there is not analytic expressions for this case, the cubic spline interpolation algorithm is adopted. Here, 𝕊 is initialized in init_context().</p><p><strong>Arguments</strong></p><ul><li>r    -&gt; A box or rectangle.</li><li>grid -&gt; Imaginary axis grid for input data.</li><li>𝕊    -&gt; An interpolant.</li></ul><p>See also: <a href="grid.html#ACFlow.FermionicFragmentTimeGrid"><code>FermionicFragmentTimeGrid</code></a>.</p></div></section><section><div><pre><code class="language-julia hljs">eval_lambda(
    r::Box,
    grid::BosonicMatsubaraGrid,
    𝕊::Vector{&lt;:AbstractInterpolation}
    )</code></pre><p>Try to calculate the contribution of a given box <code>r</code> to the Λ function. This function works for BosonicMatsubaraGrid only. Because there is an analytic expression for this case, 𝕊 is useless.</p><p>Actually, 𝕊 is undefined here. See init_context().</p><p><strong>Arguments</strong></p><ul><li>r    -&gt; A box or rectangle.</li><li>grid -&gt; Imaginary axis grid for input data.</li><li>𝕊    -&gt; An interpolant.</li></ul><p>See also: <a href="grid.html#ACFlow.BosonicMatsubaraGrid"><code>BosonicMatsubaraGrid</code></a>.</p></div></section><section><div><pre><code class="language-julia hljs">eval_lambda(
    r::Box,
    grid::BosonicFragmentMatsubaraGrid,
    𝕊::Vector{&lt;:AbstractInterpolation}
    )</code></pre><p>Try to calculate the contribution of a given box <code>r</code> to the Λ function. This function works for BosonicFragmentMatsubaraGrid only. Because there is an analytic expression for this case, 𝕊 is useless.</p><p>Actually, 𝕊 is undefined here. See init_context().</p><p><strong>Arguments</strong></p><ul><li>r    -&gt; A box or rectangle.</li><li>grid -&gt; Imaginary axis grid for input data.</li><li>𝕊    -&gt; An interpolant.</li></ul><p>See also: <a href="grid.html#ACFlow.BosonicFragmentMatsubaraGrid"><code>BosonicFragmentMatsubaraGrid</code></a>.</p></div></section><section><div><pre><code class="language-julia hljs">eval_lambda(
    r::Box,
    grid::BosonicImaginaryTimeGrid,
    𝕊::Vector{&lt;:AbstractInterpolation}
    )</code></pre><p>Try to calculate the contribution of a given box <code>r</code> to the Λ function. This function works for BosonicImaginaryTimeGrid only. Since there is not analytic expressions for this case, the cubic spline interpolation algorithm is adopted. Here, 𝕊 is initialized in init_context().</p><p><strong>Arguments</strong></p><ul><li>r    -&gt; A box or rectangle.</li><li>grid -&gt; Imaginary axis grid for input data.</li><li>𝕊    -&gt; An interpolant.</li></ul><p>See also: <a href="grid.html#ACFlow.BosonicImaginaryTimeGrid"><code>BosonicImaginaryTimeGrid</code></a>.</p></div></section><section><div><pre><code class="language-julia hljs">eval_lambda(
    r::Box,
    grid::BosonicFragmentTimeGrid,
    𝕊::Vector{&lt;:AbstractInterpolation}
    )</code></pre><p>Try to calculate the contribution of a given box <code>r</code> to the Λ function. This function works for BosonicFragmentTimeGrid only. Since there is not analytic expressions for this case, the cubic spline interpolation algorithm is adopted. Here, 𝕊 is initialized in init_context().</p><p><strong>Arguments</strong></p><ul><li>r    -&gt; A box or rectangle.</li><li>grid -&gt; Imaginary axis grid for input data.</li><li>𝕊    -&gt; An interpolant.</li></ul><p>See also: <a href="grid.html#ACFlow.BosonicFragmentTimeGrid"><code>BosonicFragmentTimeGrid</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_error" href="#ACFlow.calc_error"><code>ACFlow.calc_error</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calc_error(G::Vector{F64}, Gᵥ::Vector{F64}, σ¹::Vector{F64})</code></pre><p>Try to calculate χ². Here <code>Gᵥ</code> and <code>σ¹</code> denote the raw correlator and related standard deviation. <code>G</code> means the reproduced correlator.</p><p>See also: <a href="solver.html#ACFlow.calc_green-Tuple{Array{Complex{BigFloat}, 3}, Matrix{Complex{BigFloat}}, Vector{ComplexF64}}"><code>calc_green</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_green-Tuple{Matrix{Float64}, Int64}" href="#ACFlow.calc_green-Tuple{Matrix{Float64}, Int64}"><code>ACFlow.calc_green</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_green(Λ::Array{F64,2}, nk::I64)</code></pre><p>Try to reconstruct the correlator via the field configuration.</p><p>See also: <a href="solver.html#ACFlow.calc_error"><code>calc_error</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_norm" href="#ACFlow.calc_norm"><code>ACFlow.calc_norm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calc_norm(C::Vector{Box})</code></pre><p>Calculate the total area of all boxes.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.constraints-Tuple{Float64, Float64}" href="#ACFlow.constraints-Tuple{Float64, Float64}"><code>ACFlow.constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraints(e₁::F64, e₂::F64)</code></pre><p>This function is used to judege whether a given box overlapes with the forbidden zone. Here <code>e₁</code> and <code>e₂</code> denote the left and right boundaries of the box.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.try_insert" href="#ACFlow.try_insert"><code>ACFlow.try_insert</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">try_insert(
    MC::StochOMMC,
    SE::StochOMElement,
    SC::StochOMContext,
    dacc::F64
    )</code></pre><p>Insert a new box into the field configuration.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.try_remove" href="#ACFlow.try_remove"><code>ACFlow.try_remove</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">try_remove(
    MC::StochOMMC,
    SE::StochOMElement,
    SC::StochOMContext,
    dacc::F64
    )</code></pre><p>Remove an old box from the field configuration.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.try_shift" href="#ACFlow.try_shift"><code>ACFlow.try_shift</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">try_shift(
    MC::StochOMMC,
    SE::StochOMElement,
    SC::StochOMContext,
    dacc::F64
    )</code></pre><p>Change the position of given box in the field configuration.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.try_width" href="#ACFlow.try_width"><code>ACFlow.try_width</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">try_width(
    MC::StochOMMC,
    SE::StochOMElement,
    SC::StochOMContext,
    dacc::F64
    )</code></pre><p>Change the width and height of given box in the field configuration. Note that the box&#39;s area is kept.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.try_height" href="#ACFlow.try_height"><code>ACFlow.try_height</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">try_height(
    MC::StochOMMC,
    SE::StochOMElement,
    SC::StochOMContext,
    dacc::F64
    )</code></pre><p>Change the heights of two given boxes in the field configuration.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.try_split" href="#ACFlow.try_split"><code>ACFlow.try_split</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">try_split(
    MC::StochOMMC,
    SE::StochOMElement,
    SC::StochOMContext,
    dacc::F64
    )</code></pre><p>Split a given box into two boxes in the field configuration.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.try_merge" href="#ACFlow.try_merge"><code>ACFlow.try_merge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">try_merge(
    MC::StochOMMC,
    SE::StochOMElement,
    SC::StochOMContext,
    dacc::F64
    )</code></pre><p>Merge two given boxes into one box in the field configuration.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.Pdx" href="#ACFlow.Pdx"><code>ACFlow.Pdx</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Pdx(xmin::F64, xmax::F64, rng::AbstractRNG)</code></pre><p>Try to calculate the probability density function.</p></div></section></article><h2 id="StochPX-Solver"><a class="docs-heading-anchor" href="#StochPX-Solver">StochPX Solver</a><a id="StochPX-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#StochPX-Solver" title="Permalink"></a></h2><h3 id="Structs-7"><a class="docs-heading-anchor" href="#Structs-7">Structs</a><a class="docs-heading-anchor-permalink" href="#Structs-7" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.StochPXSolver" href="#ACFlow.StochPXSolver"><code>ACFlow.StochPXSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StochPXSolver</code></pre><p>It represents the analytic continuation solver that implements the stochastic pole expansion.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.StochPXMC" href="#ACFlow.StochPXMC"><code>ACFlow.StochPXMC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StochPXMC</code></pre><p>Mutable struct. It is used within the StochPX solver. It includes random number generator and some counters.</p><p><strong>Members</strong></p><ul><li>rng  -&gt; Random number generator.</li><li>Sacc -&gt; Counter for position-updated (type 1) operation (accepted).</li><li>Stry -&gt; Counter for position-updated (type 1) operation (tried).</li><li>Pacc -&gt; Counter for position-updated (type 2) operation (accepted).</li><li>Ptry -&gt; Counter for position-updated (type 2) operation (tried).</li><li>Aacc -&gt; Counter for amplitude-updated operation (accepted).</li><li>Atry -&gt; Counter for amplitude-updated operation (tried).</li><li>Xacc -&gt; Counter for exchange operation (accepted).</li><li>Xtry -&gt; Counter for exchange operation (tried).</li></ul><p>See also: <a href="solver.html#ACFlow.StochPXSolver"><code>StochPXSolver</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.StochPXElement" href="#ACFlow.StochPXElement"><code>ACFlow.StochPXElement</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StochPXElement</code></pre><p>Mutable struct. It is used to record the field configurations, which will be sampled by Monte Carlo sweeping procedure.</p><p>For the off-diagonal elements of the matrix-valued Green&#39;s function, the signs of the poles (𝕊) could be negative (-1.0). However, for the other cases, 𝕊 is always positive (+1.0).</p><p><strong>Members</strong></p><ul><li>P -&gt; It means the positions of the poles.</li><li>A -&gt; It means the weights / amplitudes of the poles.</li><li>𝕊 -&gt; It means the signs of the poles.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.StochPXContext" href="#ACFlow.StochPXContext"><code>ACFlow.StochPXContext</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StochPXContext</code></pre><p>Mutable struct. It is used within the StochPX solver only.</p><p><strong>Members</strong></p><ul><li>Gᵥ     -&gt; Input data for correlator.</li><li>Gᵧ     -&gt; Generated correlator.</li><li>σ¹     -&gt; Actually 1.0 / σ¹.</li><li>allow  -&gt; Allowable indices.</li><li>grid   -&gt; Grid for input data.</li><li>mesh   -&gt; Mesh for output spectrum.</li><li>fmesh  -&gt; Very dense mesh for the poles.</li><li>Λ      -&gt; Precomputed kernel matrix.</li><li>Θ      -&gt; Artificial inverse temperature.</li><li>χ²min  -&gt; Minimum of χ²min.</li><li>χ²     -&gt; Vector of goodness function.</li><li>Pᵥ     -&gt; Vector of poles&#39; positions.</li><li>Aᵥ     -&gt; Vector of poles&#39; amplitudes.</li><li>𝕊ᵥ     -&gt; Vector of poles&#39; signs.</li></ul></div></section></article><h3 id="Functions-7"><a class="docs-heading-anchor" href="#Functions-7">Functions</a><a class="docs-heading-anchor-permalink" href="#Functions-7" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.solve-Tuple{StochPXSolver, RawData}" href="#ACFlow.solve-Tuple{StochPXSolver, RawData}"><code>ACFlow.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve(S::StochPXSolver, rd::RawData)</code></pre><p>Solve the analytic continuation problem by the stochastic pole expansion. Note that this solver is still <code>experimental</code>. It is useful for analytic continuation of Matsubara data.</p><p><strong>Arguments</strong></p><ul><li>S -&gt; A StochPXSolver struct.</li><li>rd -&gt; A RawData struct, containing raw data for input correlator.</li></ul><p><strong>Returns</strong></p><ul><li>mesh -&gt; Real frequency mesh, ω.</li><li>Aout -&gt; Spectral function, A(ω).</li><li>Gout -&gt; Retarded Green&#39;s function, G(ω).</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.init-Tuple{StochPXSolver, RawData}" href="#ACFlow.init-Tuple{StochPXSolver, RawData}"><code>ACFlow.init</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init(S::StochPXSolver, rd::RawData)</code></pre><p>Initialize the StochPX solver and return the StochPXMC, StochPXElement, and StochPXContext structs. Please don&#39;t call this function directly.</p><p><strong>Arguments</strong></p><ul><li>S -&gt; A StochPXSolver struct.</li><li>rd -&gt; A RawData struct, containing raw data for input correlator.</li></ul><p><strong>Returns</strong></p><ul><li>MC -&gt; A StochPXMC struct.</li><li>SE -&gt; A StochPXElement struct.</li><li>SC -&gt; A StochPXContext struct.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.run-Tuple{StochPXMC, StochPXElement, StochPXContext}" href="#ACFlow.run-Tuple{StochPXMC, StochPXElement, StochPXContext}"><code>ACFlow.run</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">run(MC::StochPXMC, SE::StochPXElement, SC::StochPXContext)</code></pre><p>Perform stochastic pole expansion simulation, sequential version.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.prun-Tuple{StochPXSolver, Dict{String, Vector{Any}}, Dict{String, Vector{Any}}, StochPXMC, StochPXElement, StochPXContext}" href="#ACFlow.prun-Tuple{StochPXSolver, Dict{String, Vector{Any}}, Dict{String, Vector{Any}}, StochPXMC, StochPXElement, StochPXContext}"><code>ACFlow.prun</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prun(
    S::StochPXSolver,
    p1::Dict{String,Vector{Any}},
    p2::Dict{String,Vector{Any}},
    MC::StochPXMC,
    SE::StochPXElement,
    SC::StochPXContext
    )</code></pre><p>Perform stochastic pole expansion simulation, parallel version. The arguments <code>p1</code> and <code>p2</code> are copies of PBASE and PStochPX, respectively.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.average-Tuple{StochPXContext}" href="#ACFlow.average-Tuple{StochPXContext}"><code>ACFlow.average</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">average(SC::StochPXContext)</code></pre><p>Postprocess the results generated during the stochastic pole expansion simulations. It will generate the spectral functions, real frequency Green&#39;s function, and imaginary frequency Green&#39;s function.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.last-Tuple{StochPXContext, Vector{Float64}, Vector{ComplexF64}, Vector{Float64}}" href="#ACFlow.last-Tuple{StochPXContext, Vector{Float64}, Vector{ComplexF64}, Vector{Float64}}"><code>ACFlow.last</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">last(
    SC::StochPXContext,
    Aout::Vector{F64},
    Gout::Vector{C64},
    Gᵣ::Vector{F64}
    )</code></pre><p>It will write the calculated results by the StochPX solver, including final spectral function and reproduced correlator.</p><p><strong>Arguments</strong></p><ul><li>SC   -&gt; A StochPXContext object.</li><li>Aout -&gt; Spectral function.</li><li>Gout -&gt; Retarded Green&#39;s function.</li><li>Gᵣ   -&gt; Reconstructed Green&#39;s function.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.sample-Tuple{Int64, StochPXMC, StochPXElement, StochPXContext}" href="#ACFlow.sample-Tuple{Int64, StochPXMC, StochPXElement, StochPXContext}"><code>ACFlow.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample(
    t::I64,
    MC::StochPXMC,
    SE::StochPXElement,
    SC::StochPXContext
    )</code></pre><p>Try to search the configuration space to locate the minimum by using the simulated annealing algorithm. Here, <code>t</code> means the t-th attempt.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.measure-Tuple{Int64, StochPXElement, StochPXContext}" href="#ACFlow.measure-Tuple{Int64, StochPXElement, StochPXContext}"><code>ACFlow.measure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">measure(t::I64, SE::StochPXElement, SC::StochPXContext)</code></pre><p>Store Monte Carlo field configurations (positions, amplitudes, and signs of many poles) for the <code>t</code>-th attempt.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.init_mc-Tuple{StochPXSolver}" href="#ACFlow.init_mc-Tuple{StochPXSolver}"><code>ACFlow.init_mc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_mc(S::StochPXSolver)</code></pre><p>Try to create a StochPXMC struct.</p><p>See also: <a href="solver.html#ACFlow.StochPXMC"><code>StochPXMC</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.init_element-Tuple{StochPXSolver, AbstractRNG, Vector{Int64}}" href="#ACFlow.init_element-Tuple{StochPXSolver, AbstractRNG, Vector{Int64}}"><code>ACFlow.init_element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_element(
    S::StochPXSolver,
    rng::AbstractRNG,
    allow::Vector{I64}
    )</code></pre><p>Randomize the configurations for future Monte Carlo sampling. It will return a StochPXElement object.</p><p><strong>Arguments</strong></p><ul><li>S     -&gt; A StochPXSolver object.</li><li>rng   -&gt; Random number generator.</li><li>allow -&gt; Allowed positions for the poles.</li></ul><p>See also: <a href="solver.html#ACFlow.StochPXElement"><code>StochPXElement</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.init_iodata-Tuple{StochPXSolver, RawData}" href="#ACFlow.init_iodata-Tuple{StochPXSolver, RawData}"><code>ACFlow.init_iodata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_iodata(S::StochPXSolver, rd::RawData)</code></pre><p>Preprocess the input data (<code>rd</code>).</p><p>See also: <a href="type.html#ACFlow.RawData"><code>RawData</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.init_context-Tuple{StochPXSolver}" href="#ACFlow.init_context-Tuple{StochPXSolver}"><code>ACFlow.init_context</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_context(S::StochPXSolver)</code></pre><p>Try to initialize the key members of a StochPXContext struct.</p><p>See also: <a href="solver.html#ACFlow.StochPXContext"><code>StochPXContext</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.reset_mc-Tuple{StochPXMC}" href="#ACFlow.reset_mc-Tuple{StochPXMC}"><code>ACFlow.reset_mc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reset_mc(MC::StochPXMC)</code></pre><p>Reset the counters in StochPXMC struct.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.reset_element-Tuple{AbstractRNG, Vector{Int64}, StochPXElement}" href="#ACFlow.reset_element-Tuple{AbstractRNG, Vector{Int64}, StochPXElement}"><code>ACFlow.reset_element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reset_element(
    rng::AbstractRNG,
    allow::Vector{I64},
    SE::StochPXElement
    )</code></pre><p>Reset the Monte Carlo field configurations (i.e. positions and amplitudes of the poles). Note that the signs of the poles should not be changed.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.reset_context-Tuple{Int64, StochPXElement, StochPXContext}" href="#ACFlow.reset_context-Tuple{Int64, StochPXElement, StochPXContext}"><code>ACFlow.reset_context</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reset_context(t::I64, SE::StochPXElement, SC::StochPXContext)</code></pre><p>Recalculate imaginary frequency Green&#39;s function and goodness-of-fit function by new Monte Carlo field configurations for the t-th attempts.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_fmesh-Tuple{StochPXSolver}" href="#ACFlow.calc_fmesh-Tuple{StochPXSolver}"><code>ACFlow.calc_fmesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_fmesh(S::StochPXSolver)</code></pre><p>Try to calculate very fine (dense) mesh in [wmin, wmax], which is used internally to represent the possible positions of poles. Note that this mesh could be non-uniform. If the file <code>fmesh.inp</code> exists, the code will try to load it to initialize the mesh. Or else the code will generate a linear mesh automatically.</p><p>See also: <a href="mesh.html#ACFlow.LinearMesh"><code>LinearMesh</code></a>, <a href="mesh.html#ACFlow.DynamicMesh"><code>DynamicMesh</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_lambda-Tuple{AbstractGrid, AbstractMesh}" href="#ACFlow.calc_lambda-Tuple{AbstractGrid, AbstractMesh}"><code>ACFlow.calc_lambda</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_lambda(grid::AbstractGrid, fmesh::AbstractMesh)</code></pre><p>Precompute the kernel matrix Λ (Λ ≡ 1 / (iωₙ - ϵ)). It is for the fermionic systems.</p><p><strong>Arguments</strong></p><ul><li>grid  -&gt; Imaginary axis grid for input data. </li><li>fmesh -&gt; Very dense mesh in [wmin, wmax].</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_lambda-Tuple{AbstractGrid, AbstractMesh, Float64, Bool}" href="#ACFlow.calc_lambda-Tuple{AbstractGrid, AbstractMesh, Float64, Bool}"><code>ACFlow.calc_lambda</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_lambda(
    grid::AbstractGrid,
    fmesh::AbstractMesh,
    χ₀::F64,
    bsymm::Bool
    )</code></pre><p>Precompute the kernel matrix Λ. Here, <code>χ₀</code> is actually -G(iωₙ = 0). And the argument <code>bsymm</code> is used to distinguish two different bosonic kernels. If <code>bsymm</code> is false, it means that the kernel is <code>boson</code>. If <code>bsymm</code> is true, the kernel is <code>bsymm</code>. This function is for the bosonic systems.</p><p><strong>Arguments</strong></p><ul><li>grid  -&gt; Imaginary axis grid for input data. </li><li>fmesh -&gt; Very dense mesh in [wmin, wmax].</li><li>χ₀    -&gt; -G(0).</li><li>bsymm -&gt; Type of bosonic kernel.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_green-Tuple{Vector{Int64}, Vector{Float64}, Vector{Float64}, Matrix{Float64}}" href="#ACFlow.calc_green-Tuple{Vector{Int64}, Vector{Float64}, Vector{Float64}, Matrix{Float64}}"><code>ACFlow.calc_green</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_green(
    P::Vector{I64},
    A::Vector{F64},
    𝕊::Vector{F64},
    Λ::Array{F64,2}
    )</code></pre><p>Reconstruct Green&#39;s function at imaginary axis by the pole expansion.</p><p><strong>Arguments</strong></p><ul><li>P -&gt; Positions of poles.</li><li>A -&gt; Amplitudes of poles.</li><li>𝕊 -&gt; Signs of poles.</li><li>Λ -&gt; Kernel matrix Λ.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_green-Tuple{Vector{Int64}, Vector{Float64}, Vector{Float64}, AbstractMesh, AbstractMesh}" href="#ACFlow.calc_green-Tuple{Vector{Int64}, Vector{Float64}, Vector{Float64}, AbstractMesh, AbstractMesh}"><code>ACFlow.calc_green</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_green(
    P::Vector{I64},
    A::Vector{F64},
    𝕊::Vector{F64},
    mesh::AbstractMesh,
    fmesh::AbstractMesh
    )</code></pre><p>Reconstruct Green&#39;s function at real axis by the pole expansion. It is for the fermionic systems only.</p><p><strong>Arguments</strong></p><ul><li>P     -&gt; Positions of poles.</li><li>A     -&gt; Amplitudes of poles.</li><li>𝕊     -&gt; Signs of poles.</li><li>mesh  -&gt; Real frequency mesh for spectral functions.</li><li>fmesh -&gt; Very dense real frequency mesh for poles.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_green-Tuple{Vector{Int64}, Vector{Float64}, Vector{Float64}, AbstractMesh, AbstractMesh, Float64, Bool}" href="#ACFlow.calc_green-Tuple{Vector{Int64}, Vector{Float64}, Vector{Float64}, AbstractMesh, AbstractMesh, Float64, Bool}"><code>ACFlow.calc_green</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_green(
    P::Vector{I64},
    A::Vector{F64},
    𝕊::Vector{F64},
    mesh::AbstractMesh,
    fmesh::AbstractMesh,
    χ₀::F64,
    bsymm::Bool
    )</code></pre><p>Reconstruct Green&#39;s function at real axis by the pole expansion. Here, <code>χ₀</code> is actually -G(iωₙ = 0). And the argument <code>bsymm</code> is used to distinguish two different bosonic kernels. If <code>bsymm</code> is false, it means that the kernel is <code>boson</code>. If <code>bsymm</code> is true, the kernel is <code>bsymm</code>. It is for the bosonic systems only.</p><p><strong>Arguments</strong></p><ul><li>P     -&gt; Positions of poles.</li><li>A     -&gt; Amplitudes of poles.</li><li>𝕊     -&gt; Signs of poles.</li><li>mesh  -&gt; Real frequency mesh for spectral functions.</li><li>fmesh -&gt; Very dense real frequency mesh for poles.</li><li>χ₀    -&gt; -G(0).</li><li>bsymm -&gt; Type of bosonic kernel.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.calc_chi2-Tuple{Vector{Float64}, Vector{Float64}}" href="#ACFlow.calc_chi2-Tuple{Vector{Float64}, Vector{Float64}}"><code>ACFlow.calc_chi2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_chi2(Gₙ::Vector{F64}, Gᵥ::Vector{F64})</code></pre><p>Try to calculate the goodness function (i.e, χ²), which measures the distance between input and regenerated correlators.</p><p><strong>Arguments</strong></p><ul><li>Gₙ -&gt; Reconstructed Green&#39;s function.</li><li>Gᵥ -&gt; Original Green&#39;s function.</li></ul><p>See also: <a href="solver.html#ACFlow.calc_green-Tuple{Array{Complex{BigFloat}, 3}, Matrix{Complex{BigFloat}}, Vector{ComplexF64}}"><code>calc_green</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.constraints-Tuple{StochPXSolver, AbstractMesh}" href="#ACFlow.constraints-Tuple{StochPXSolver, AbstractMesh}"><code>ACFlow.constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraints(S::StochPXSolver, fmesh::AbstractMesh)</code></pre><p>Try to implement the constrained stochastic pole expansion. This function will return a collection. It contains all the allowable indices. Be careful, the constrained stochastic pole expansion method is compatible with the self-adaptive mesh.</p><p><strong>Arguments</strong></p><ul><li>S     -&gt; A StochPXSolver object.</li><li>fmesh -&gt; Very dense mesh for the poles.</li></ul><p>See also: <a href="solver.html#ACFlow.StochPXSolver"><code>StochPXSolver</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.try_move_s-Tuple{Int64, StochPXMC, StochPXElement, StochPXContext}" href="#ACFlow.try_move_s-Tuple{Int64, StochPXMC, StochPXElement, StochPXContext}"><code>ACFlow.try_move_s</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">try_move_s(
    t::I64,
    MC::StochPXMC,
    SE::StochPXElement,
    SC::StochPXContext
    )</code></pre><p>Change the position of one randomly selected pole.</p><p>See also: <a href="solver.html#ACFlow.try_move_p-Tuple{Int64, StochACMC, StochACElement, StochACContext}"><code>try_move_p</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.try_move_p-Tuple{Int64, StochPXMC, StochPXElement, StochPXContext}" href="#ACFlow.try_move_p-Tuple{Int64, StochPXMC, StochPXElement, StochPXContext}"><code>ACFlow.try_move_p</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">try_move_p(
    t::I64,
    MC::StochPXMC,
    SE::StochPXElement,
    SC::StochPXContext
    )</code></pre><p>Change the positions of two randomly selected poles.</p><p>See also: <a href="solver.html#ACFlow.try_move_s-Tuple{StochSKMC, StochSKElement, StochSKContext}"><code>try_move_s</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.try_move_a-Tuple{Int64, StochPXMC, StochPXElement, StochPXContext}" href="#ACFlow.try_move_a-Tuple{Int64, StochPXMC, StochPXElement, StochPXContext}"><code>ACFlow.try_move_a</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">try_move_a(
    t::I64,
    MC::StochPXMC,
    SE::StochPXElement,
    SC::StochPXContext
    )</code></pre><p>Change the amplitudes of two randomly selected poles.</p><p>See also: <a href="solver.html#ACFlow.try_move_x-Tuple{StochACMC, StochACElement, StochACContext}"><code>try_move_x</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACFlow.try_move_x-Tuple{Int64, StochPXMC, StochPXElement, StochPXContext}" href="#ACFlow.try_move_x-Tuple{Int64, StochPXMC, StochPXElement, StochPXContext}"><code>ACFlow.try_move_x</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">try_move_x(
    t::I64,
    MC::StochPXMC,
    SE::StochPXElement,
    SC::StochPXContext
    )</code></pre><p>Exchange the amplitudes of two randomly selected poles.</p><p>See also: <a href="solver.html#ACFlow.try_move_a-Tuple{Int64, StochACMC, StochACElement, StochACContext}"><code>try_move_a</code></a>.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="base.html">« Core</a><a class="docs-footer-nextpage" href="grid.html">Grids »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Saturday 24 August 2024 16:35">Saturday 24 August 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

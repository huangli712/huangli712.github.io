var documenterSearchIndex = {"docs":
[{"location":"theory/reference.html#References","page":"References","title":"References","text":"","category":"section"},{"location":"theory/reference.html","page":"References","title":"References","text":"Maximum entropy method","category":"page"},{"location":"theory/reference.html","page":"References","title":"References","text":"","category":"page"},{"location":"theory/reference.html","page":"References","title":"References","text":"[1] J. E. Gubernatis, M. Jarrell, R. N. Silver, D. S. Sivia, Quantum monte carlo simulations and maximum entropy: Dynamics from imaginary-time data, Phys. Rev. B 44, 6011 (1991).","category":"page"},{"location":"theory/reference.html","page":"References","title":"References","text":"[2] M. Jarrell, J. Gubernatis, Bayesian inference and the analytic continuation of imaginary-time quantum monte carlo data, Phys. Rep. 269, 133 (1996).","category":"page"},{"location":"theory/reference.html","page":"References","title":"References","text":"Stochastic analytic continuation","category":"page"},{"location":"theory/reference.html","page":"References","title":"References","text":"","category":"page"},{"location":"theory/reference.html","page":"References","title":"References","text":"[1] A. W. Sandvik, Stochastic method for analytic continuation of quantum monte carlo data, Phys. Rev. B 57, 10287 (1998)","category":"page"},{"location":"theory/reference.html","page":"References","title":"References","text":"[2] K. S. D. Beach, Identifying the maximum entropy method as a special limit of stochastic analytic continuation, arXiv:0403055 (2004).","category":"page"},{"location":"theory/reference.html","page":"References","title":"References","text":"[3] A. W. Sandvik, Constrained sampling method for analytic continuation, Phys. Rev. E 94, 063308 (2016).","category":"page"},{"location":"theory/reference.html","page":"References","title":"References","text":"[4] H. Shao, Y. Q. Qin, S. Capponi, S. Chesi, Z. Y. Meng, A. W. Sandvik, Nearly deconfined spinon excitations in the square-lattice spin-1/2 heisenberg antiferromagnet, Phys. Rev. X 7, 041072 (2017).","category":"page"},{"location":"theory/reference.html","page":"References","title":"References","text":"[5] H. Shao, A. W. Sandvik, Progress on stochastic analytic continuation of quantum monte carlo data, Phys. Rep. 1003, 1 (2023).","category":"page"},{"location":"theory/reference.html","page":"References","title":"References","text":"Stochastic optimization method","category":"page"},{"location":"theory/reference.html","page":"References","title":"References","text":"","category":"page"},{"location":"theory/reference.html","page":"References","title":"References","text":"[1] A. S. Mishchenko, N. V. Prokof’ev, A. Sakamoto, B. V. Svistunov, Diagrammatic quantum monte carlo study of the frohlich polaron, Phys. Rev. B 62, 6317 (2000).","category":"page"},{"location":"theory/reference.html","page":"References","title":"References","text":"[2] I. Krivenko, M. Harland, Triqs/som: Implementation of the stochastic optimization method for analytic continuation, Comput. Phys. Commun. 239, 166 (2019).","category":"page"},{"location":"theory/reference.html","page":"References","title":"References","text":"Stochastic pole expansion","category":"page"},{"location":"theory/reference.html","page":"References","title":"References","text":"","category":"page"},{"location":"theory/reference.html","page":"References","title":"References","text":"[1] Li Huang, Shuang Liang, Stochastic pole expansion method for analytic continuation of the Green's function, Phys. Rev. B 108, 235143 (2023).","category":"page"},{"location":"theory/reference.html","page":"References","title":"References","text":"[2] Li Huang, Shuang Liang, Reconstructing lattice QCD spectral functions with stochastic pole expansion and Nevanlinna analytic continuation, Phys. Rev. D 109, 054508 (2024).","category":"page"},{"location":"library/config.html#Configuration","page":"Configuration","title":"Configuration","text":"","category":"section"},{"location":"library/config.html","page":"Configuration","title":"Configuration","text":"Read, parse, and extract the configuration parameters.","category":"page"},{"location":"library/config.html#Contents","page":"Configuration","title":"Contents","text":"","category":"section"},{"location":"library/config.html","page":"Configuration","title":"Configuration","text":"Pages = [\"config.md\"]\nDepth = 2","category":"page"},{"location":"library/config.html#Index","page":"Configuration","title":"Index","text":"","category":"section"},{"location":"library/config.html","page":"Configuration","title":"Configuration","text":"Pages = [\"config.md\"]","category":"page"},{"location":"library/config.html#Parser","page":"Configuration","title":"Parser","text":"","category":"section"},{"location":"library/config.html","page":"Configuration","title":"Configuration","text":"inp_toml\nfil_dict\nrev_dict_b\nrev_dict_m\nrev_dict_n\nrev_dict_a\nrev_dict_k\nrev_dict_s\nrev_dict_x","category":"page"},{"location":"library/config.html#ACFlow.inp_toml","page":"Configuration","title":"ACFlow.inp_toml","text":"inp_toml(f::String, key::String, necessary::Bool)\n\nParse the configuration file (in toml format). It reads only parts of the configuration file, which depends on the value of key.\n\n\n\n\n\ninp_toml(f::String, necessary::Bool)\n\nParse the configuration file (in toml format). It reads the whole file.\n\n\n\n\n\n","category":"function"},{"location":"library/config.html#ACFlow.fil_dict","page":"Configuration","title":"ACFlow.fil_dict","text":"fil_dict(cfg::Dict{String,Any})\n\nTransfer configurations from dict cfg to internal dicts (including PBASE, PMaxEnt, PNevanAC, PStochAC, PStochSK, PStochOM and PStochPX etc).\n\n\n\n\n\n","category":"function"},{"location":"library/config.html#ACFlow.rev_dict_b","page":"Configuration","title":"ACFlow.rev_dict_b","text":"rev_dict_b(BASE::Dict{String,Any})\n\nSetup the configuration dictionary: PBASE.\n\nSee also: PBASE.\n\n\n\n\n\nrev_dict_b(BASE::Dict{String,Vector{Any}})\n\nSetup the configuration dictionary: PBASE.\n\nSee also: PBASE.\n\n\n\n\n\n","category":"function"},{"location":"library/config.html#ACFlow.rev_dict_m","page":"Configuration","title":"ACFlow.rev_dict_m","text":"rev_dict_m(S::MaxEntSolver, MaxEnt::Dict{String,Any})\n\nSetup the configuration dictionary: PMaxEnt.\n\nSee also: PMaxEnt.\n\n\n\n\n\nrev_dict_m(S::MaxEntSolver, MaxEnt::Dict{String,Vector{Any}})\n\nSetup the configuration dictionary: PMaxEnt.\n\nSee also: PMaxEnt.\n\n\n\n\n\n","category":"function"},{"location":"library/config.html#ACFlow.rev_dict_n","page":"Configuration","title":"ACFlow.rev_dict_n","text":"rev_dict_n(S::NevanACSolver, NevanAC::Dict{String,Any})\n\nSetup the configuration dictionary: PNevanAC.\n\nSee also: PNevanAC.\n\n\n\n\n\nrev_dict_n(S::NevanACSolver, NevanAC::Dict{String,Vector{Any}})\n\nSetup the configuration dictionary: PNevanAC.\n\nSee also: PNevanAC.\n\n\n\n\n\n","category":"function"},{"location":"library/config.html#ACFlow.rev_dict_a","page":"Configuration","title":"ACFlow.rev_dict_a","text":"rev_dict_a(S::StochACSolver, StochAC::Dict{String,Any})\n\nSetup the configuration dictionary: PStochAC.\n\nSee also: PStochAC.\n\n\n\n\n\nrev_dict_a(S::StochACSolver, StochAC::Dict{String,Vector{Any}})\n\nSetup the configuration dictionary: PStochAC.\n\nSee also: PStochAC.\n\n\n\n\n\n","category":"function"},{"location":"library/config.html#ACFlow.rev_dict_k","page":"Configuration","title":"ACFlow.rev_dict_k","text":"rev_dict_k(S::StochSKSolver, StochSK::Dict{String,Any})\n\nSetup the configuration dictionary: PStochSK.\n\nSee also: PStochSK.\n\n\n\n\n\nrev_dict_k(S::StochSKSolver, StochSK::Dict{String,Vector{Any}})\n\nSetup the configuration dictionary: PStochSK.\n\nSee also: PStochSK.\n\n\n\n\n\n","category":"function"},{"location":"library/config.html#ACFlow.rev_dict_s","page":"Configuration","title":"ACFlow.rev_dict_s","text":"rev_dict_s(S::StochOMSolver, StochOM::Dict{String,Any})\n\nSetup the configuration dictionary: PStochOM.\n\nSee also: PStochOM.\n\n\n\n\n\nrev_dict_s(S::StochOMSolver, StochOM::Dict{String,Vector{Any}})\n\nSetup the configuration dictionary: PStochOM.\n\nSee also: PStochOM.\n\n\n\n\n\n","category":"function"},{"location":"library/config.html#ACFlow.rev_dict_x","page":"Configuration","title":"ACFlow.rev_dict_x","text":"rev_dict_x(S::StochPXSolver, StochPX::Dict{String,Any})\n\nSetup the configuration dictionary: PStochPX.\n\nSee also: PStochPX.\n\n\n\n\n\nrev_dict_x(S::StochPXSolver, StochPX::Dict{String,Vector{Any}})\n\nSetup the configuration dictionary: PStochPX.\n\nSee also: PStochPX.\n\n\n\n\n\n","category":"function"},{"location":"library/config.html#Validation","page":"Configuration","title":"Validation","text":"","category":"section"},{"location":"library/config.html","page":"Configuration","title":"Configuration","text":"chk_dict\n_v","category":"page"},{"location":"library/config.html#ACFlow.chk_dict","page":"Configuration","title":"ACFlow.chk_dict","text":"chk_dict()\n\nValidate the correctness and consistency of configurations.\n\nSee also: fil_dict, _v.\n\n\n\n\n\n","category":"function"},{"location":"library/config.html#ACFlow._v","page":"Configuration","title":"ACFlow._v","text":"_v(key::String, val::Array{Any,1})\n\nVerify the value array. Called by chk_dict() function only.\n\nSee also: chk_dict.\n\n\n\n\n\n","category":"function"},{"location":"library/config.html#Extraction","page":"Configuration","title":"Extraction","text":"","category":"section"},{"location":"library/config.html","page":"Configuration","title":"Configuration","text":"get_b\nget_m\nget_n\nget_a\nget_k\nget_s\nget_x","category":"page"},{"location":"library/config.html#ACFlow.get_b","page":"Configuration","title":"ACFlow.get_b","text":"get_b(key::String)\n\nExtract configurations from dict: PBASE.\n\nSee also: PBASE.\n\n\n\n\n\n","category":"function"},{"location":"library/config.html#ACFlow.get_m","page":"Configuration","title":"ACFlow.get_m","text":"get_m(key::String)\n\nExtract configurations from dict: PMaxEnt.\n\nSee also: PMaxEnt.\n\n\n\n\n\n","category":"function"},{"location":"library/config.html#ACFlow.get_n","page":"Configuration","title":"ACFlow.get_n","text":"get_n(key::String)\n\nExtract configurations from dict: PNevanAC.\n\nSee also: PNevanAC.\n\n\n\n\n\n","category":"function"},{"location":"library/config.html#ACFlow.get_a","page":"Configuration","title":"ACFlow.get_a","text":"get_a(key::String)\n\nExtract configurations from dict: PStochAC.\n\nSee also: PStochAC.\n\n\n\n\n\n","category":"function"},{"location":"library/config.html#ACFlow.get_k","page":"Configuration","title":"ACFlow.get_k","text":"get_k(key::String)\n\nExtract configurations from dict: PStochSK.\n\nSee also: PStochSK.\n\n\n\n\n\n","category":"function"},{"location":"library/config.html#ACFlow.get_s","page":"Configuration","title":"ACFlow.get_s","text":"get_s(key::String)\n\nExtract configurations from dict: PStochOM.\n\nSee also: PStochOM.\n\n\n\n\n\n","category":"function"},{"location":"library/config.html#ACFlow.get_x","page":"Configuration","title":"ACFlow.get_x","text":"get_x(key::String)\n\nExtract configurations from dict: PStochPX.\n\nSee also: PStochPX.\n\n\n\n\n\n","category":"function"},{"location":"theory/sac1.html#san","page":"Stochastic Analytic Continuation 1","title":"Stochastic Analytic Continuation 1","text":"","category":"section"},{"location":"theory/sac1.html","page":"Stochastic Analytic Continuation 1","title":"Stochastic Analytic Continuation 1","text":"info: Info\nIn principle, for given Green's function G, there exists infinitely many spectral densities A(omega) that can be used to reproduce G via mathbfG = mathbfKA. The maximum entropy method tries to pick up the most likely spectral function which maximizes PAbarG (It actually maximizes Q). Here, we would like to introduce an alternative approach, namely the stochastic analytic continuation. It is argued that the weights for all the possible spectral densities are the same if they can give rise to the same chi^2. At first, a sequence of spectral densities will be generated by stochastic method. Then an unbiased thermal average of all possible spectra, Boltzmann weighted according to goodness-of-fit function chi^2, produces an average spectrum. Thus sometimes the method was named as average spectrum method or stochastic sampling method in the references. There are several variants for the stochastic analytic continuation. Next we will introduce two representative algorithms as proposed by A. W. Sandvik and K. S. D. Beach, respectively.","category":"page"},{"location":"theory/sac1.html#Sandvik's-Algorithm","page":"Stochastic Analytic Continuation 1","title":"Sandvik's Algorithm","text":"","category":"section"},{"location":"theory/sac1.html","page":"Stochastic Analytic Continuation 1","title":"Stochastic Analytic Continuation 1","text":"It was early on realized that a different way to achieve a smooth spectrum is to average over many solutions with reasonable chi^2 values. Several years later, A. W. Sandvik introduced the stochastic analytic continuation in a slightly different form. He suggested that the spectral function A(omega) can be parameterized using N delta functions (Please see Fig.1 for schematic diagram):","category":"page"},{"location":"theory/sac1.html","page":"Stochastic Analytic Continuation 1","title":"Stochastic Analytic Continuation 1","text":"beginequation\nA(omega) = sum^N_i = 1 gamma_i delta(omega - omega_i)\nendequation","category":"page"},{"location":"theory/sac1.html","page":"Stochastic Analytic Continuation 1","title":"Stochastic Analytic Continuation 1","text":"where gamma_i and omega_i denote the amplitude and position of the i-th delta function, respectively. Next, the Metropolis important sampling algorithm is employed to sample the configuration space mathcalC = omega_i gamma_i. In practice, there are two elementary Monte Carlo updates. One is to change the amplitudes of a pair of delta functions under the constraint sum_i gamma_i = 1. Another one is to shift position of a randomly chosen delta function. Of course, block or global updates can be implemented to improve ergodicity and sampling efficiency.","category":"page"},{"location":"theory/sac1.html","page":"Stochastic Analytic Continuation 1","title":"Stochastic Analytic Continuation 1","text":"(Image: san.png)","category":"page"},{"location":"theory/sac1.html","page":"Stochastic Analytic Continuation 1","title":"Stochastic Analytic Continuation 1","text":"Figure 1 | Typical Monte Carlo field configurations for stochastic analytic continuation (A. W. Sandvik's version). Here, the delta functions reside at unrestricted frequencies omega_i, but their amplitudes gamma_i are equal and fixed. Note that different parameterizations are also possible.","category":"page"},{"location":"theory/sac1.html","page":"Stochastic Analytic Continuation 1","title":"Stochastic Analytic Continuation 1","text":"The transition probability of Monte Carlo updates reads:","category":"page"},{"location":"theory/sac1.html","page":"Stochastic Analytic Continuation 1","title":"Stochastic Analytic Continuation 1","text":"beginequation\np(mathcalC to mathcalC) = expleft(-fracDeltachi^22Thetaright)\nendequation","category":"page"},{"location":"theory/sac1.html","page":"Stochastic Analytic Continuation 1","title":"Stochastic Analytic Continuation 1","text":"where chi^2 is the goodness-of-fit function, Theta is a regulation parameter which is similar to the alpha parameter appeared in the maximum entropy method. Well, the remaining problem is how to fix Theta. Sandvik suggested to measure the following entropic term for some Theta:","category":"page"},{"location":"theory/sac1.html","page":"Stochastic Analytic Continuation 1","title":"Stochastic Analytic Continuation 1","text":"beginequation\nS(Theta) = - sum^N_i = 1 gamma_i log(gamma_i) K(0omega_i)\nendequation","category":"page"},{"location":"theory/sac1.html","page":"Stochastic Analytic Continuation 1","title":"Stochastic Analytic Continuation 1","text":"where K is the kernel function as defined above. Then make a plot of S with respect to log(Theta^-1). Overall, when Theta is large, S exhibits large fluctuations. When Theta is small, S will approach its global minimum steadily. A sharp drop in S before the approach to a constant value has been observed, and there is a local maximum at some Theta = hatTheta preceding the drop. Thus, Sandvik postulated that hatTheta was the optimum value at which to accumulate and average the spectral function. Syljuasen et al. suggested that let Theta = 1. Fuchs et al. tried to fix Theta by using Bayesian inference. Such that their approach was named as stochastic analytic inference. Very recently, Shao and Sandvik et al. proposed a smart method to determine the optimal value of Theta. Theta is adjusted so that","category":"page"},{"location":"theory/sac1.html","page":"Stochastic Analytic Continuation 1","title":"Stochastic Analytic Continuation 1","text":"beginequation\nlangle chi^2(Theta) rangle approx chi^2_textmin + c sqrt2chi^2_textmin\nendequation","category":"page"},{"location":"theory/sac1.html","page":"Stochastic Analytic Continuation 1","title":"Stochastic Analytic Continuation 1","text":"where c is a constant of order 1, chi^2_textmin is the minimum value of chi^2 at given Theta. Note that chi^2_textmin can be obtained in a simulated annealing process to very low Theta.","category":"page"},{"location":"theory/sac1.html#Relevant-parameters","page":"Stochastic Analytic Continuation 1","title":"Relevant parameters","text":"","category":"section"},{"location":"theory/sac1.html","page":"Stochastic Analytic Continuation 1","title":"Stochastic Analytic Continuation 1","text":"See [StochSK] Block","category":"page"},{"location":"library/inout.html#Input-and-output","page":"Input and output","title":"Input and output","text":"","category":"section"},{"location":"library/inout.html","page":"Input and output","title":"Input and output","text":"Define input and output functions for the ACFlow toolkit.","category":"page"},{"location":"library/inout.html#Contents","page":"Input and output","title":"Contents","text":"","category":"section"},{"location":"library/inout.html","page":"Input and output","title":"Input and output","text":"Pages = [\"inout.md\"]\nDepth = 2","category":"page"},{"location":"library/inout.html#Index","page":"Input and output","title":"Index","text":"","category":"section"},{"location":"library/inout.html","page":"Input and output","title":"Input and output","text":"Pages = [\"inout.md\"]","category":"page"},{"location":"library/inout.html#Read-Data","page":"Input and output","title":"Read Data","text":"","category":"section"},{"location":"library/inout.html","page":"Input and output","title":"Input and output","text":"read_real_data\nread_cmplx_data","category":"page"},{"location":"library/inout.html#ACFlow.read_real_data","page":"Input and output","title":"ACFlow.read_real_data","text":"read_real_data(finput::AbstractString, ngrid::I64)\n\nRead input data. This function is used for imaginary time data. The input file should contain three columns. The first column is the imaginary time grid, the second column is the value, the third column is the standard deviation σ. Here, ngrid specifies the number of grid points.\n\nSee also: read_cmplx_data.\n\n\n\n\n\n","category":"function"},{"location":"library/inout.html#ACFlow.read_cmplx_data","page":"Input and output","title":"ACFlow.read_cmplx_data","text":"read_cmplx_data(finput::AbstractString, ngrid::I64)\n\nRead input data. This function is used for Matsubara frequency data. The input should contain four columns or five columns. The first column is the Matsubara freqency grid, the second and third columns are the values (real part and imaginary part), the four and fifth columns are the standard deviations σ for the real and imaginary parts, respectively. If there are only four columns, it means that the real and imaginary parts share the same standard deviations.\n\nSee also: read_real_data.\n\n\n\n\n\nread_cmplx_data(finput::AbstractString, ngrid::I64, only_real_part::Bool)\n\nRead input data. This function is used for Matsubara frequency data. The input file only contains three columns. The first column is the Matsubara frequency grid, the second column is the real part or imaginary part of the data (which is specified by the argument only_real_part), and the third column is the standard deviation σ. This function is for bosonic correlation function.\n\nSee also: read_real_data.\n\n\n\n\n\n","category":"function"},{"location":"library/inout.html#Write-Data","page":"Input and output","title":"Write Data","text":"","category":"section"},{"location":"library/inout.html","page":"Input and output","title":"Input and output","text":"write_spectrum\nwrite_backward\nwrite_complete\nwrite_misfit\nwrite_goodness\nwrite_model\nwrite_hamiltonian\nwrite_passed\nwrite_pole\nwrite_probability\nwrite_statistics","category":"page"},{"location":"library/inout.html#ACFlow.write_spectrum","page":"Input and output","title":"ACFlow.write_spectrum","text":"write_spectrum(am::AbstractMesh, Aout::Vector{F64})\n\nWrite spectrum A(ω) to Aout.data. The grid is defined in am, and the spectral data are contained in Aout.\n\n\n\n\n\nwrite_spectrum(am::AbstractMesh, αₗ::Vector{F64}, Aout::Array{F64,2})\n\nWrite α-resolved spectrum A(ω) to Aout.data.alpha. The grid is defined in am, the α-resolved spectrum is contained in Aout, αₗ is the list for the α parameters. This function is called by the StochAC solver.\n\n\n\n\n\n","category":"function"},{"location":"library/inout.html#ACFlow.write_backward","page":"Input and output","title":"ACFlow.write_backward","text":"write_backward(ag::AbstractGrid, G::Vector{F64})\n\nWe can use the calculated spectrum in real axis to reproduce the input data in imaginary axis. This function will write the reproduced data to repr.data, which can be compared with the original data. Here, G is the reproduced data.\n\nSee also: reprod.\n\n\n\n\n\n","category":"function"},{"location":"library/inout.html#ACFlow.write_complete","page":"Input and output","title":"ACFlow.write_complete","text":"write_complete(am::AbstractMesh, G::Vector{C64})\n\nWrite the full data at real axis to Gout.data. am denotes the real axis, G is the calculated green's function data. Note that its real part is obtained via the so-called Kramers-Kronig transformation.\n\nSee also: kramers.\n\n\n\n\n\n","category":"function"},{"location":"library/inout.html#ACFlow.write_misfit","page":"Input and output","title":"ACFlow.write_misfit","text":"write_misfit(α_vec::Vector{F64}, χ²_vec::Vector{F64})\n\nWrite log10(α)-log10(χ²) data to chi2.data, which could be used to judge whether the obtained optimal α parameter is reasonable.\n\nSee also: write_goodness.\n\n\n\n\n\n","category":"function"},{"location":"library/inout.html#ACFlow.write_goodness","page":"Input and output","title":"ACFlow.write_goodness","text":"write_goodness(Θ_vec::Vector{F64}, χ²_vec::Vector{F64})\n\nWrite log10(Θ)-log10(χ²) data to goodness.data, which could be used to judge whether the obtained optimal Θ parameter is reasonable. This function is only useful for the StochSK solver.\n\nSee also: write_misfit.\n\n\n\n\n\n","category":"function"},{"location":"library/inout.html#ACFlow.write_model","page":"Input and output","title":"ACFlow.write_model","text":"write_model(am::AbstractMesh, D::Vector{F64})\n\nWrite the default model function to model.data.\n\n\n\n\n\n","category":"function"},{"location":"library/inout.html#ACFlow.write_hamiltonian","page":"Input and output","title":"ACFlow.write_hamiltonian","text":"write_hamiltonian(α_vec::Vector{F64}, Uα::Vector{F64})\n\nWrite α-U(α) data to hamil.data, which could be used to judge whether the obtained optimal α parameter is reasonable. This function is only useful for the StochAC solver.\n\n\n\n\n\n","category":"function"},{"location":"library/inout.html#ACFlow.write_passed","page":"Input and output","title":"ACFlow.write_passed","text":"write_passed(passed::Vector{I64}, med::F64, αgood::F64)\n\nWrite indices of selected solutions which should be used to calculate the averaged spectrum. Here, passed means the indices, med is the median value of χ², and αgood is the factor that is used to filter the solutions. This function is only useful for the StochOM and the StochPX solvers.\n\n\n\n\n\n","category":"function"},{"location":"library/inout.html#ACFlow.write_pole","page":"Input and output","title":"ACFlow.write_pole","text":"write_pole(Pᵥ::Vector{Vector{I64}},\n           Aᵥ::Vector{Vector{F64}},\n           𝕊ᵥ::Vector{Vector{F64}},\n           χ²::Vector{F64},\n           fmesh::AbstractMesh)\n\nWrite positions, amplitudes, and signs of poles to pole.data. This function is only useful for the StochPX solver.\n\n\n\n\n\n","category":"function"},{"location":"library/inout.html#ACFlow.write_probability","page":"Input and output","title":"ACFlow.write_probability","text":"write_probability(α_vec::Vector{F64}, p_vec::Vector{F64})\n\nWrite p(α) data to prob.data. This function is only useful for the MaxEnt solver (bryan algorithm).\n\n\n\n\n\n","category":"function"},{"location":"library/inout.html#ACFlow.write_statistics","page":"Input and output","title":"ACFlow.write_statistics","text":"write_statistics(MC::StochACMC)\n\nWrite Monte Carlo statistical information for the StochAC solver. Note that the StochAC solver is based on a stochastic approach.\n\nSee also: PStochAC, StochACMC.\n\n\n\n\n\nwrite_statistics(MC::StochSKMC)\n\nWrite Monte Carlo statistical information for the StochSK solver. Note that the StochSK solver is based on a stochastic approach.\n\nSee also: PStochSK, StochSKMC.\n\n\n\n\n\nwrite_statistics(MC::StochOMMC)\n\nWrite Monte Carlo statistical information for the StochOM solver. Note that the StochOM solver is based on a stochastic approach.\n\nSee also: PStochOM, StochOMMC.\n\n\n\n\n\nwrite_statistics(MC::StochPXMC)\n\nWrite Monte Carlo statistical information for the StochPX solver. Note that the StochPX solver is based on a stochastic approach.\n\nSee also: PStochPX, StochPXMC.\n\n\n\n\n\n","category":"function"},{"location":"man/run.html#Running-Modes","page":"Running Modes","title":"Running Modes","text":"","category":"section"},{"location":"man/run.html","page":"Running Modes","title":"Running Modes","text":"The ACFlow toolkit is designed to be flexible and easy-to-use. It provides three running modes to facilitate analytic continuation calculations, namely the interactive, script, and standard modes.","category":"page"},{"location":"man/run.html#Interactive-Mode","page":"Running Modes","title":"Interactive Mode","text":"","category":"section"},{"location":"man/run.html","page":"Running Modes","title":"Running Modes","text":"With the ACFlow toolkit, the users can configure and carry out analytic continuation simulations interactively in Julia's REPL (Read-Eval-Print Loop) environment. For example,","category":"page"},{"location":"man/run.html","page":"Running Modes","title":"Running Modes","text":"julia> using ACFlow\njulia> setup_args(\"ac.toml\")\njulia> read_param()\njulia> mesh, Aout, Gout = solve(read_data())","category":"page"},{"location":"man/run.html","page":"Running Modes","title":"Running Modes","text":"Here, ac.toml is a configuration file, which contains essential computational parameters. The return values of the solve() function (i.e., mesh, Aout, and Gout) are mesh at real axis omega, spectral density A(omega), and reproduced Green's function tildeG, respectively. They can be further analyzed or visualized by the users.","category":"page"},{"location":"man/run.html#Script-Mode","page":"Running Modes","title":"Script Mode","text":"","category":"section"},{"location":"man/run.html","page":"Running Modes","title":"Running Modes","text":"The core functionalities of the ACFlow toolkit are exposed to the users via a simple application programming interface. So, the users can write Julia scripts easily by themselves to perform analytic continuation simulations. A minimal Julia script (acrun.jl) is listed as follows:","category":"page"},{"location":"man/run.html","page":"Running Modes","title":"Running Modes","text":"#!/usr/bin/env julia\n\nusing ACFlow\n\nsetup_args(\"ac.toml\")\nread_param()\nmesh, Aout, Gout = solve(read_data())","category":"page"},{"location":"man/run.html","page":"Running Modes","title":"Running Modes","text":"Of course, this script can be extended to finish complex tasks. Later, a realistic example will be provided to show how to complete an analytic continuation of Matsubara self-energy function via the script mode.","category":"page"},{"location":"man/run.html#Standard-Mode","page":"Running Modes","title":"Standard Mode","text":"","category":"section"},{"location":"man/run.html","page":"Running Modes","title":"Running Modes","text":"In the standard mode, the users have to prepare the input data manually. In addition, a configuration file must be provided. Supposed that the configuration file is ac.toml, then the analytic continuation calculation is launched as follows:","category":"page"},{"location":"man/run.html","page":"Running Modes","title":"Running Modes","text":"$ /home/your_home/acflow/util/acrun.jl ac.toml","category":"page"},{"location":"man/run.html","page":"Running Modes","title":"Running Modes","text":"or","category":"page"},{"location":"man/run.html","page":"Running Modes","title":"Running Modes","text":"$ /home/your_home/acflow/util/Pacrun.jl ac.toml","category":"page"},{"location":"man/run.html","page":"Running Modes","title":"Running Modes","text":"Noted that the acrun.jl script runs sequentially, while the Pacrun.jl script supports parallel and distributed computing. The two scripts are in the acflow/util folder. As we can conclude from the filename extension of configuration file (ac.toml), it adopts the TOML specification. The users may edit it with any text-based editors. Next we will introduce syntax and format of the input data files and configuration files.","category":"page"},{"location":"man/run.html#Parallel-calculations","page":"Running Modes","title":"Parallel calculations","text":"","category":"section"},{"location":"man/run.html","page":"Running Modes","title":"Running Modes","text":"Besides the MaxEnt solver, the computational efficiencies of the StochAC, StochSK, StochOM, and StochPX solvers are rather low. So, these solvers are parallelized to accelerate the analytic continuation simulations. The ACFlow toolkit provides a script, namely Pacrun.jl, to drive parallel calculations. Now the users should specify the number of parallel workers in this script:","category":"page"},{"location":"man/run.html","page":"Running Modes","title":"Running Modes","text":"#!/usr/bin/env julia\n...\nusing Distributed # Julia's package to support distributed computing\n...\naddprocs(8)       # Now the number of parallel workers is 8. A total of 9\n                  # processes are launched (8 workers + 1 master process).\n...","category":"page"},{"location":"man/run.html","page":"Running Modes","title":"Running Modes","text":"It is limited by the available computational resources. A minimal PBS script is shown as follows:","category":"page"},{"location":"man/run.html","page":"Running Modes","title":"Running Modes","text":"#!/bin/bash\n#PBS -N ACFlow\n#PBS -l nodes=1:ppn=9\n#PBS -q score\n...\n/home/your_home/acflow/util/Pacrun.jl ac.toml > nohup.dat 2>&1 # Please fix Pacrun.jl's path.","category":"page"},{"location":"man/run.html","page":"Running Modes","title":"Running Modes","text":"It is used to submit parallel jobs to computer clusters. Be careful, in order to maintain load balancing, the number of allocated CPUs should be larger than the number of parallel workers.","category":"page"},{"location":"library/acflow.html#ACFlow.jl","page":"ACFlow","title":"ACFlow.jl","text":"","category":"section"},{"location":"library/acflow.html","page":"ACFlow","title":"ACFlow","text":"Declare the module and public members.","category":"page"},{"location":"library/acflow.html#Modules","page":"ACFlow","title":"Modules","text":"","category":"section"},{"location":"library/acflow.html","page":"ACFlow","title":"ACFlow","text":"ACFlow","category":"page"},{"location":"library/acflow.html#ACFlow","page":"ACFlow","title":"ACFlow","text":"ACFlow\n\nACFlow is a modern software toolkit for solving the many-body analytic continuation problem. It is usually used to convert the single-particle or two-particle correlators from imaginary axis to real axis. Now this toolkit is under heavy development. PLEASE USE IT AT YOUR OWN RISK.\n\nNowadays the ACFlow toolkit supports the following algorithms:\n\nMaximum Entropy Method (MaxEnt solver, recommended)\nNevanlinna Analytical Continuation (NevanAC solver, experimental)\nStochastic Analytic Continuation (StochAC and StochSK solvers)\nStochastic Optimization Method (StochOM solver)\nStochastic Pole eXpansion (StochPX solver, recommended)\n\nMore algorithms will be implemented in the future.\n\nNote that ACFlow toolkit has been designed to be integrated into the Zen package. Actually, it is also compatible with the iQIST toolkit. In the other words, the end user can use it to analytically continue the imaginary time (or Matsubara frequency) data generated by the various quantum impurity solvers in the iQIST toolkit. Of course, it is quite easy to implement some kinds of interfaces for the other quantum impurity solvers.\n\nFor more details about how to obtain, install and use the ACFlow toolkit, please visit the following website:\n\nhttps://huangli712.github.io/projects/acflow/index.html\n\nAny suggestions, comments, and feedbacks are welcome. Enjoy it!\n\n\n\n\n\n","category":"module"},{"location":"library/acflow.html#Initialization","page":"ACFlow","title":"Initialization","text":"","category":"section"},{"location":"library/acflow.html","page":"ACFlow","title":"ACFlow","text":"_precompile\nACFlow.__init__","category":"page"},{"location":"library/acflow.html#ACFlow._precompile","page":"ACFlow","title":"ACFlow._precompile","text":"_precompile()\n\nHere, we would like to precompile the whole ACFlow toolkit to reduce the runtime latency and speed up the successive calculations.\n\n\n\n\n\n","category":"function"},{"location":"library/acflow.html#ACFlow.__init__","page":"ACFlow","title":"ACFlow.__init__","text":"__init__()\n\nThis function would be executed immediately after the module is loaded at runtime for the first time. It works at the REPL mode only.\n\n\n\n\n\n","category":"function"},{"location":"intro/cite.html#Citation","page":"Citation","title":"Citation","text":"","category":"section"},{"location":"intro/cite.html","page":"Citation","title":"Citation","text":"Please cite the following papers:","category":"page"},{"location":"intro/cite.html","page":"Citation","title":"Citation","text":"","category":"page"},{"location":"intro/cite.html","page":"Citation","title":"Citation","text":"[1] Li Huang, ACFlow: An open source toolkit for analytical continuation of quantum Monte Carlo data, Comput. Phys. Commun. 292, 108863 (2023).","category":"page"},{"location":"intro/cite.html","page":"Citation","title":"Citation","text":"[2] Li Huang, Shuang Liang, Stochastic pole expansion method for analytic continuation of the Green's function, Phys. Rev. B 108, 235143 (2023).","category":"page"},{"location":"intro/cite.html","page":"Citation","title":"Citation","text":"[3] Li Huang, Shuang Liang, Reconstructing lattice QCD spectral functions with stochastic pole expansion and Nevanlinna analytic continuation, Phys. Rev. D 109, 054508 (2024).","category":"page"},{"location":"theory/som.html#som","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"","category":"section"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"A. O. Mishchenko et al. proposed the stochastic optimization method. Though it looks like the stochastic analytic continuation, their differences are quite apparent. The stochastic optimization method does not need any likelihood function or Boltzmann distribution to weight the candidate spectral functions. It generates a lot of spectral functions through Monte Carlo samplings. For each candidate spectral function, the deviation D between the reconstructed Green's function tildeG and original Green's function barG is measured. Those spectral functions with small deviations D are selected and averaged. Such that the desired spectral function is obtained.","category":"page"},{"location":"theory/som.html#Deviation-Function","page":"Stochastic Optimization Method","title":"Deviation Function","text":"","category":"section"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"In the stochastic optimization method, the deviation between reconstructed data tildeG and input data barG is described by:","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"beginequation\nDA = sum^M_m=1 Delta(m)\nendequation","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"where M is the number of input data, and Delta(m) is the deviation function,","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"beginequation\nDelta(m) = fracbarG(m) - tildeG(m)S(m)\nendequation","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"Here, S(m) = G(m)^d (where 0 le d le 1). Recently, Krivenko et al. suggested that it would be better to use the goodness-of-fit functional chi^2A to replace DA.","category":"page"},{"location":"theory/som.html#Spectral-Density","page":"Stochastic Optimization Method","title":"Spectral Density","text":"","category":"section"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"The stochastic optimization method will try to accumulate the candidate spectral functions that manifest small DA. Supposed the Monte Carlo simulations are repeated for L times. For the i-th Monte Carlo simulation, the spectral density A_i(omega) and deviation DA_i are recorded. The minimum value of deviation is minDA_i. Thus, the final spectral density reads:","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"beginequation\nA(omega) = frac1L_textgood sum^L_i = 1\ntheta(alpha_textgood minDA_i - DA_i) A_i(omega)\nendequation","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"Here, theta(x) is the Heaviside step function, and alpha_textgood is a adjustable parameter. L_textgood denotes the number of good spectral functions:","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"beginequation\nL_textgood = sum^L_i = 1\ntheta(alpha_textgood minDA_i - DA_i)\nendequation","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"That is to say, only those spectral functions who satisfy the following condition will be selected:","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"beginequation\nDA_i le alpha_textgood minDA_i\nendequation","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"Clearly, the larger alpha_textgood is, the more spectral functions are included. It is usually set to 2.","category":"page"},{"location":"theory/som.html#Rectangle-Representation","page":"Stochastic Optimization Method","title":"Rectangle Representation","text":"","category":"section"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"Similar to the stochastic analytic continuation, the stochastic optimization method usually employs a few rectangle functions to parameterize the spectral function:","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"beginequation\nA(omega) = sum_i R_c_i w_i h_i (omega)\nendequation","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"where i is the index of rectangle function. The definition of rectangle function R_c_i w_i h_i (omega) reads:","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"beginequation\nR_c_i w_i h_i (omega) =\nh_i\nthetaomega - (c_i - w_i2)\ntheta(c_i + w_i2) - omega\nendequation","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"where c_i, w_i, h_i denote the center, width, and height of the i-th rectangle, respectively. Pay attention to that the area of all rectangles must be normalized to 1:","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"beginequation\nsum_i h_i w_i = 1\nendequation","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"(Image: som.png)","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"Figure 1 | Typical Monte Carlo field configurations for stochastic optimization method. The spectral function is parameterized by multiple rectangle functions. Here, c_i, w_i, and h_i denote the center, width, and height of the i-th rectangle, respectively.","category":"page"},{"location":"theory/som.html#Monte-Carlo-Sampling","page":"Stochastic Optimization Method","title":"Monte Carlo Sampling","text":"","category":"section"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"The parameters of all rectangle functions create a configuration space:","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"beginequation\nmathcalC = c_i w_i h_i\nendequation","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"Then the Metropolis algorithm is utilized to sample this configuration space. Mishchenko et al. introduces seven Monte Carlo updates, including: (a) Insert a new rectangle, change width and height of another rectangle; (b) Remove an existing rectangle, change width and height of another rectangle; (c) Shift position of any rectangles; (d) Change widths of any two rectangles; (e) Change heights of any two rectangles; (f) Split a rectangle into two new rectangles; (g) Merge two adjacent rectangles into a new rectangle. The transition probability of these Monte Carlo updates is:","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"beginequation\np(mathcalC to mathcalC) = left(fracDA_mathcalCDA_mathcalCright)^1+d\nendequation","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"As compared to the maximum entropy method, the likelihood function, entropic term, and model function are absent in the stochastic optimization method. As compared to the stochastic analytic continuation, there are no adjustable parameters, such as Theta in Sandvik's algorithm and alpha in Beach's algorithm. Thus, the simulated results of the stochastic optimization method are less affected by artificial parameters.","category":"page"},{"location":"theory/som.html#Relevant-parameters","page":"Stochastic Optimization Method","title":"Relevant parameters","text":"","category":"section"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"See [StochOM] Block","category":"page"},{"location":"theory/sac2.html#sac","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"","category":"section"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"info: Info\nIn principle, for given Green's function G, there exists infinitely many spectral densities A(omega) that can be used to reproduce G via mathbfG = mathbfKA. The maximum entropy method tries to pick up the most likely spectral function which maximizes PAbarG (It actually maximizes Q). Here, we would like to introduce an alternative approach, namely the stochastic analytic continuation. It is argued that the weights for all the possible spectral densities are the same if they can give rise to the same chi^2. At first, a sequence of spectral densities will be generated by stochastic method. Then an unbiased thermal average of all possible spectra, Boltzmann weighted according to goodness-of-fit function chi^2, produces an average spectrum. Thus sometimes the method was named as average spectrum method or stochastic sampling method in the references. There are several variants for the stochastic analytic continuation. Next we will introduce two representative algorithms as proposed by A. W. Sandvik and K. S. D. Beach, respectively.","category":"page"},{"location":"theory/sac2.html#Beach's-Algorithm","page":"Stochastic Analytic Continuation 2","title":"Beach's Algorithm","text":"","category":"section"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"K. S. D. Beach proposed another variant of stochastic analytic continuation in 2004. In his approach, the analytic continuation problem is mapped into a system of interacting classic fields at first. Then the classic field is sampled using Monte Carlo method to obtain the final solution. He concluded that the maximum entropy method is simply the mean field limit of the stochastic analytic continuation. Next, this algorithm will be explained concisely.","category":"page"},{"location":"theory/sac2.html#Classic-Fields","page":"Stochastic Analytic Continuation 2","title":"Classic Fields","text":"","category":"section"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"Recalled that the goodness-of-fit functional chi^2A measures how closely the Green's function generated from A(omega) matches the raw input data. Its expression is rewritten as follows:","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"beginequation\nchi^2A = int^beta_0 frac1sigma(tau)^2\nleftint domegaK(tauomega) A(omega) - barG(tau)right^2 dtau\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"At first, a new variable x is introduced. The relation between x and omega is:","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"beginequation\nx = phi(omega) = int^omega_-infty domegam(omega)\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"where m(omega) denotes default model function. Clearly, the phi(omega) function defines a smooth mapping from mathbfR to 01. Since omega = phi^-1(x), a dimensionless classic field n(x) is created:","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"beginequation\nn(x) = fracA(phi^-1(x))m(phi^-1(x))\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"It is easy to prove that both n(x) and A(omega) obey similar normalization condition:","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"beginequation\nint domegaA(omega) = int^1_0 dxn(x) = 1\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"Next, in analogy with the goodness-of-fit functional chi^2A, the Hamiltonian for the system of classic field n(x) can be defined as follows:","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"beginequation\nHn(x) = int^beta_0 fracdtausigma(tau)^2\nleft\nint^1_0 dxK(taux) n(x) - barG(tau)\nright\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"Supposing alpha is an inverse temperature of the system, then the partition function Z is:","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"beginequation\nZ = int mathcalDne^-alpha Hn\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"where","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"beginequation\nint mathcalDn =\nint^infty_0 leftprod_x dn(x)right\ndeltaleft(int^1_0 dxn(x) - 1right)\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"The thermally averaged value of the classic field is:","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"beginequation\nlangle n(x) rangle = frac1Z int mathcalDnn(x) e^-alpha Hn\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"Finally, according to the definition of the classic field, the averaged spectral density langle A(omega) rangle can be expressed as:","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"beginequation\nlangle A(omega) rangle = langle n(phi(omega)) rangle m(omega)\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"So, by introducing the classic field n(x), the analytic continuation problem is converted into a statistical sampling of the classic field, which is easily solved by using the Monte Carlo method.","category":"page"},{"location":"theory/sac2.html#Monte-Carlo-Sampling","page":"Stochastic Analytic Continuation 2","title":"Monte Carlo Sampling","text":"","category":"section"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"Next we clarify how to sample the classic field. Similar to Sandvik's algorithm, n(x) is parameterized as a superposition of many delta functions (see Fig.1 for schematic diagram):","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"beginequation\nn_mathcalC (x) = sum_i gamma_i delta(x - r_i)\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"where gamma_i and r_i denote amplitude (weight) and position of the i-th delta function, respectively. And mathcalC means a configuration space formed by a set of r_i and gamma_i,","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"beginequation\nmathcalC = r_i gamma_i\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"Note that gamma_i and r_i satisfy the following constraints:","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"beginequation\nforall igamma_i  0sum_i gamma_i = 1 0 le r_i le 1\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"Supposed that there is a transition from mathcalC to mathcalC (r_i gamma_i to r_i gamma_i):","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"beginequation\nr_i to r_i =\nr_i + sum_lambda in Lambda delta_ilambda Delta r_lambda\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"beginequation\ngamma_i to gamma_i =\ngamma_i + sum_lambda in Lambda delta_ilambda Delta gamma_lambda\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"where Lambda means a subset of the delta functions, then the Hamiltonian of the system is changed from H_mathcalC to H_mathcalC. According to Eq.(5), H_mathcalC, H_mathcalC, and their difference Delta H can be calculated by:","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"beginequation\nH_mathcalC = int^beta_0 dtauh_mathcalC(tau)^2\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"beginequation\nH_mathcalC = int^beta_0 dtau\nlefth_mathcalC(tau) + Delta h(tau)right^2\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"beginequation\nDelta H = H_mathcalC - H_mathcalC =\nint^beta_0 dtauDelta h(tau)\n2h_mathcalC(tau) + Delta h(tau)\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"Here,","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"beginequation\nh(tau) = frac1sigma(tau) leftint^1_0 dxK(tau x)n(x) - barG(tau)right\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"and","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"beginequation\nDelta h(tau) = frac1sigma(tau)\nsum_lambda in Lambda\nleft\ngamma_lambda K(taur_lambda) - gamma_lambda K(taur_lambda)\nright\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"Finally, the transition probability from mathcalC to mathcalC reads","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"beginequation\np(C to C) = exp(-alpha Delta H)\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"(Image: sac.png)","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"Figure 1 | Typical Monte Carlo field configurations for stochastic analytic continuation (K. S. D. Beach's version). Note that the amplitudes gamma_i of all the delta functions are not identical. Both amplitudes gamma_i and positions r_i (00  r_i  10) can be sampled by Monte Carlo method.","category":"page"},{"location":"theory/sac2.html#Parallel-Tempering","page":"Stochastic Analytic Continuation 2","title":"Parallel Tempering","text":"","category":"section"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"The parallel tempering trick is adopted to improve the Monte Carlo algorithm as described above. It is possible to proceed multiple simulations simultaneously for a sequence of inverse temperature parameters alpha_1 alpha_2 cdots alpha_N . The ratio for two adjacent alpha parameters is a constant: alpha_p+1  alpha_p = R. Note that the field configurations in all simulations evolve in parallel but not independently. We can swap the field configurations between two adjacent layers. Of course, the detailed balance is always preserved, and each simulation will eventually settle into thermal equilibrium at given alpha. The transition probability of such a global Monte Carlo update is:","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"beginequation\np(mathcalC to mathcalC) = exp(alpha_p - alpha_q)(H_p - H_q)\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"where p and q are layer indices, and p = q pm 1. Parallel tempering eliminates the need for an initial annealing stage. Another advantage of parallel tempering is that it yields a complete temperature profile of all the important thermodynamic variables (such as specific heat and internal energy), which can be used to estimate the critical alpha and final spectral function langle A(omega) rangle.","category":"page"},{"location":"theory/sac2.html#Critical-Inverse-Temperature","page":"Stochastic Analytic Continuation 2","title":"Critical Inverse Temperature","text":"","category":"section"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"Clearly, langle n(x) rangle strongly depends on the inverse temperature alpha. How to use these alpha-dependent langle n(x) rangle to construct the final spectral function? Beach proposed a new algorithm. During parallel tempering process, the internal energy of the system is also measured in addition to langle n(x) rangle:","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"beginequation\nU(alpha_p) = langle H n rangle_alpha_p\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"Let us plot log_10U(alpha) as a function of log_10 (alpha). We find that log_10U(alpha) drops quickly at first when log_10 (alpha) increases, and then it approaches to a constant value slowly. The knee in log_10U(alpha) function, occurring in the vicinity of alpha = alpha^* (the corresponding layer index p = p^*), signals a jump in specific heat (a thermodynamic phase transition). Then the averaged spectral function is constructed by:","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"beginequation\nlangle langle n(x) rangle rangle =\nfracsum^N-1_p = p* U(alpha_p) - U(alpha_p+1) langle n(x) rangle_alpha_p\nU(alpha_p*) - U(alpha_N)\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"where N is the total number of alpha, and alpha_p* (equiv alpha^*) is the critical inverse temperature.","category":"page"},{"location":"theory/sac2.html#Likelihood-Function","page":"Stochastic Analytic Continuation 2","title":"Likelihood Function","text":"","category":"section"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"Neither of the Sandvik's and Beach's algorithms needs extra entropic term to regulate spectral density. All the stochastically generated spectra are treated on the same footing. Thus, the calculated spectral function retains more subtle structures than that obtained by the maximum entropy method. Actually, in stochastic analytic continuation,","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"beginequation\nlangle A rangle = int mathcalD APAbarG A\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"The weight of the candidate spectral function A is given by the likelihood function PAbarG. Eq.(20) can be viewed as likelihood functions in stochastic analytic continuation.","category":"page"},{"location":"theory/sac2.html#Relevant-parameters","page":"Stochastic Analytic Continuation 2","title":"Relevant parameters","text":"","category":"section"},{"location":"theory/sac2.html","page":"Stochastic Analytic Continuation 2","title":"Stochastic Analytic Continuation 2","text":"See [StochAC] Block","category":"page"},{"location":"examples/green1.html","page":"Matsubara Green's Function","title":"Matsubara Green's Function","text":"info: Info\nIn order to demonstrate usefulness of the ACFlow toolkit, four examples are illustrated in this section. These examples cover typical application scenarios of the ACFlow toolkit, including analytic continuations ofMatsubara self-energy function\nMatsubara Green's function\nImaginary time Green's function\nCurrent-current correlation functionwithin the script mode or standard mode. All of the necessary source codes and data files, which can be used to reproduce the results as shown in this section, are placed in the /home/your_home/acflow/tutor/T* folders.","category":"page"},{"location":"examples/green1.html#Matsubara-Green's-Function","page":"Matsubara Green's Function","title":"Matsubara Green's Function","text":"","category":"section"},{"location":"examples/green1.html","page":"Matsubara Green's Function","title":"Matsubara Green's Function","text":"The purpose of the second example is to treat the Matsubara Green's function by using the StochOM solver.","category":"page"},{"location":"examples/green1.html","page":"Matsubara Green's Function","title":"Matsubara Green's Function","text":"At first, please consider the following spectral density with two gaussian peaks:","category":"page"},{"location":"examples/green1.html","page":"Matsubara Green's Function","title":"Matsubara Green's Function","text":"A(omega) =\nA_1 expleftfrac-(omega - epsilon_1)^22 Gamma^2_1right +\nA_2 expleftfrac-(omega - epsilon_2)^22 Gamma^2_2right","category":"page"},{"location":"examples/green1.html","page":"Matsubara Green's Function","title":"Matsubara Green's Function","text":"with A_1 = 10, A_2 = 03, epsilon_1 = 05, epsilon_2 = -25, Gamma_1 = 02, and Gamma_2 = 08. Then the Matsubara Green's function G(iomega_n) is evaluated by using mathbfG = mathbfKA with beta = 100. Random noises, built by formula 00001 r_1 exp(i 2pi r_2 ) where r_1 and r_2 are random numbers in (0.0,1.0), are added to G(iomega_n). The error bar of G(iomega_n) is fixed to 1e-4. The generated data for G(iomega_n) are written in giw.data.","category":"page"},{"location":"examples/green1.html","page":"Matsubara Green's Function","title":"Matsubara Green's Function","text":"Next, we are going to use the standard mode, such that a configure file (ac.toml) must be prepared. It is listed as follows. Since the StochOM solver is chosen, the [BASE] and [StochOM] blocks must be present at the same time.","category":"page"},{"location":"examples/green1.html","page":"Matsubara Green's Function","title":"Matsubara Green's Function","text":"[BASE]\nfinput = \"giw.data\"\nsolver = \"StochOM\"\nktype  = \"fermi\"\nmtype  = \"flat\"\ngrid   = \"ffreq\"\nmesh   = \"linear\"\nngrid  = 10\nnmesh  = 501\nwmax   = 5.0\nwmin   = -5.0\nbeta   = 10.0\noffdiag = false\n\n[StochOM]\nntry  = 100000\nnstep = 1000\nnbox  = 100\nsbox  = 0.005\nwbox  = 0.02\nnorm  = -1.0","category":"page"},{"location":"examples/green1.html","page":"Matsubara Green's Function","title":"Matsubara Green's Function","text":"Then we use the acrun.jl or Pacrun.jl script to perform analytic continuation simulation. The calculated results are shown in Fig.1. As is seen in Fig.1(a), both the sharp peak around 0.5 eV and the broad peak around -2.5 eV are correctly reproduced by the StochOM solver. In Fig.1(b), the reconstructed Matsubara Green's function agrees quite well with the raw input data.","category":"page"},{"location":"examples/green1.html","page":"Matsubara Green's Function","title":"Matsubara Green's Function","text":"(Image: T_E2.png)","category":"page"},{"location":"examples/green1.html","page":"Matsubara Green's Function","title":"Matsubara Green's Function","text":"Figure 1 | Analytic continuation of Matsubara Green's function by using the stochastic optimization method. (a) Simulated and exact spectral functions. (b) Reconstructed and synthetic Matsubara Green's functions. Only the imaginary parts are presented in this figure.","category":"page"},{"location":"theory/nac.html#nac","page":"Nevanlinna Analytical Continuation","title":"Nevanlinna Analytical Continuation","text":"","category":"section"},{"location":"theory/nac.html","page":"Nevanlinna Analytical Continuation","title":"Nevanlinna Analytical Continuation","text":"warning: Warning\nThe NevanAC solver is experimental. Please use it at your own risk.","category":"page"},{"location":"theory/nac.html#Relevant-parameters","page":"Nevanlinna Analytical Continuation","title":"Relevant parameters","text":"","category":"section"},{"location":"theory/nac.html","page":"Nevanlinna Analytical Continuation","title":"Nevanlinna Analytical Continuation","text":"See [NevanAC] Block","category":"page"},{"location":"man/param.html#param","page":"Parameters","title":"Parameters","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"A comprehensive dictionary about parameters.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"The official configuration file for the ACFlow toolkit is case.toml. This page contains all the valid parameters that can appear in case.toml. As for the format of case.toml, please look at case.toml.","category":"page"},{"location":"man/param.html#Contents","page":"Parameters","title":"Contents","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Pages = [\"param.md\"]\nDepth = 3","category":"page"},{"location":"man/param.html#base_block","page":"Parameters","title":"[BASE] Block","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"note: Note\nThis block is mandatory. The parameters in this block is useful for all the solvers.","category":"page"},{"location":"man/param.html#finput","page":"Parameters","title":"finput","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Filename for the input data. The input data should be stored in a column-wised and formated (CSV-like) text file.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"String.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"finput = \"gtau.data\"","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#solver","page":"Parameters","title":"solver","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter specifies the solvers that used to solve the analytic continuation problem. Now the ACFlow toolkit supports six different solvers. They are as follows:MaxEnt\nNevanAC\nStochAC\nStochSK\nStochOM\nStochPXHere, MaxEnt means the maximum entropy method. The MaxEnt solver can be used to treat the correlators in Matsubara frequency or imaginary time axis. If solver = \"MaxEnt\", then the [MaxEnt] block must be available in the configuration file.NevanAC means the Nevanlinna analytical continuation. The NevanAC solver can be used to treat the fermionic correlators in Matsubara frequency. Note that this solver is extremely sensitive to the noise level of the input data.StochAC means the stochastic analytic continuation method (K. S. D. Beach's algorithm). The StochAC solver can be used to treat the correlators in Matsubara frequency or imaginary time axis. If solver = \"StochAC\", then the [StochAC] block must be available in the configuration file.StochSK means the stochastic analytic continuation method (A. W. Sandvik's algorithm). The StochSK solver can be used to treat the correlators in Matsubara frequency or imaginary time axis. If solver = \"StochSK\", then the [StochSK] block must be available in the configuration file.StochOM means the stochastic optimization method. The StochOM solver can be used to treat the correlators in Matsubara frequency or imaginary time axis. If solver = \"StochOM\", then the [StochOM] block must be available in the configuration file.StochPX means the stochastic pole expansion method. The StochPX solver can be used to treat the correlators in Matsubara frequency axis only. If solver = \"StochPX\", then the [StochPX] block must be available in the configuration file.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"warning: Warning\nFor the StochOM solver, if the correlators are defined in imaginary time axis, they must be bosonic. In other words, the StochOM solver does not support analytic continuation of fermionic imaginary time correlation function.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"String.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"solver = \"MaxEnt\"","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#ktype","page":"Parameters","title":"ktype","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"It denotes the type of kernel functions. Now the ACFlow toolkit supports three types of kernel functions. They are:fermi\nboson\nbsymmHere, fermi means fermionic kernel function, which readsK(tauomega) = frace^-tauomega1 + e^-betaomegaandK(omega_nomega) = frac1iomega_n - omegaboson means bosonic kernel function, which readsK(tauomega) = fracomega e^-tauomega1 - e^-betaomegaandK(omega_nomega) = fracomegaiomega_n - omegabsymm means symmetric bosonic kernel function, which readsK(tauomega) = fracomega e^-tauomega + e^-(beta - tau)omega 1 - e^-betaomegaandK(omega_n omega) = frac-2omega^2omega_n^2 + omega^2As for detailed formula for these kernel functions, please refer to the comments in src/kernel.jl.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"String.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"ktype = \"fermi\"","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. It must be compatible with the grid parameter.","category":"page"},{"location":"man/param.html#mtype","page":"Parameters","title":"mtype","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"It denotes the type of default model functions. Now the ACFlow toolkit supports the following choices:flat\ngauss\n1gauss\n2gauss\nlorentz\n1lorentz\n2lorentz\nrisedecay\nfileHere, flat means the flat model (i.e., constant), gauss means the Gaussian model, 1gauss means the Shifted Gaussian model, 2gauss means the Two Gaussians model, lorentz means the Lorentzian model, 1lorentz means the Shifted Lorentzian model, 2lorentz means the Two Lorentzians model, and risedecay means the Rise-And-Decay model.Besides flat and file, all the other model functions need additional parameters to customize them (Of course, the ACFlow toolkit will supplement default parameters). The parameters can be specified by the pmodel parameter.Especially, if mtype = \"file\", then the default model function is encoded in model.inp. ACFlow will read this file and initialize the default model function automatically. Be careful, the mesh for this model function must be consistent with the one used in the analytic continuation calculations.As for detailed formula for these models, please refer to the comments in src/model.jl.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"String.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"mtype = \"flat\"","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. Only the MaxEnt solver need these model functions. The StochAC solver only supports the flat model. The StochSK, StochOM, and StochPX solvers are free of model functions.","category":"page"},{"location":"man/param.html#grid","page":"Parameters","title":"grid","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter specifies the grid's type for input data in imaginary axis. Now the ACFlow toolkit supports the following choices:ftime\nfpart\nbtime\nbpart\nffreq\nffrag\nbfreq\nbfragHere, ftime means fermionic and imaginary time, btime means bosonic and imaginary time, ffreq means fermionic and Matsubara frequency, and bfreq means bosonic and Matsubara frequency. fpart means fermionic and imaginary time as well, but the grid of imaginary time might be incomplete. bpart is similar to fpart, but it is for the bosonic case. ffrag means fermionic and Matsubara frequency as well, but the grid of Matsubara frequency might be incomplete. bfrag is similar to ffrag, but it is for the bosonic case.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"String.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"grid = \"ftime\"","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. It must be compatible with the ktype parameter. If grid is \"bfrag\", the first Matsubara frequency point, i.e. iomega_0 = 0, should be kept. See also ngrid.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"warning: Warning\nIf the NevanAC solver is employed, the grid parameter should be \"ffreq\" or \"ffrag\".","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"warning: Warning\nIf the StochOM solver is employed, the grid parameter should not be \"ftime\" or \"fpart\".","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"warning: Warning\nIf the StochPX solver is employed, the grid parameter should be \"ffreq\", \"ffrag\", \"bfreq\", or \"bfrag\".","category":"page"},{"location":"man/param.html#mesh","page":"Parameters","title":"mesh","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter specifies the mesh's type for output data (usually the spectral functions) in real axis. Now the ACFlow toolkit supports the following choices:linear\ntangent\nlorentz\nhalflorentzHere, linear means the Linear mesh, tangent means the Tangent mesh, lorentz means the Lorentzian mesh, and halflorentz means the Half-Lorentzian mesh.Notes that only the linear mesh is uniform, the other three meshes are non-uniform. And the halflorentz mesh is defined on the positive-half axis only.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"String.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"mesh = \"linear\"","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. See also nmesh.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"warning: Warning\nAs for the StochOM solver , it seems that the linear mesh works better.","category":"page"},{"location":"man/param.html#ngrid","page":"Parameters","title":"ngrid","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of grid points. The parameter, together with the beta and grid parameters, controls the generation of grid for input data.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"ngrid = 10","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. It must be compatible with the input data. See also grid.","category":"page"},{"location":"man/param.html#nmesh","page":"Parameters","title":"nmesh","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of mesh points. The parameter, together with the wmax, wmin, and mesh parameters, controls the generation of mesh for output data.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"nmesh = 501","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. See also mesh.","category":"page"},{"location":"man/param.html#wmax","page":"Parameters","title":"wmax","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Right boundary (maximum value) of mesh. Note that wmax should be always greater than wmin.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"wmax = 10.0","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#wmin","page":"Parameters","title":"wmin","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Left boundary (minimum value) of mesh. Note that wmax should be always greater than wmin.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"wmin = -10.0","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"warning: Warning\nIf the ktype = \"bsymm\", the wmin parameter should be 0.0. In other words, the spectral density is defined on the half positive axis.","category":"page"},{"location":"man/param.html#beta","page":"Parameters","title":"beta","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Inverse temperature beta. It is equal to 1T.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"beta = 10.0","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. This parameter must be compatible with the input data and grid. Specifically, for the imaginary time axis, the last grid point should be beta. As for the Matsubara frequency axis, the difference between two successive grid points should be pibeta.","category":"page"},{"location":"man/param.html#offdiag","page":"Parameters","title":"offdiag","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Is the input correlator the offdiagonal part in matrix-valued function? As for the offdiagonal correlator, the corresponding spectral function might be not positive-definite. Some tricks have been implemented to cure this issue.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Bool.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"offdiag = false","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. This parameter is useful for the MaxEnt and StochPX solvers only.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"warning: Warning\nNow only the MaxEnt and StochPX solvers supports this parameter. On the other hand, the MaxEntAux algorithm works always for the solvers that don't support this parameter.","category":"page"},{"location":"man/param.html#fwrite","page":"Parameters","title":"fwrite","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Are the analytic continuation results written into external files? If it is false, then only the terminal output is retained and all the other outputs are disable. By default (if this parameter is missing or true), the files should be generated.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Bool.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"fwrite = false","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is optional.","category":"page"},{"location":"man/param.html#pmodel","page":"Parameters","title":"pmodel","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Additional parameters for customizing the model functions. Note that the gauss, lorentz, and risedecay models need one parameter Gamma. The 1gauss and 1lorentz models need two parameters, Gamma and s. The 2gauss and 2lorentz models need three parameters, Gamma, s_1, and s_2.The pmodel parameter is used to define these parameters. If there is only one element in pmodel, then Gamma = pmodel[1]. If there are two elements in pmodel, then Gamma = pmodel[1] and s = pmodel[2]. If there are three elements in pmodel, then Gamma = pmodel[1], s_1 = pmodel[2], and s_2 = pmodel[3].","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Array.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"pmodel = [1.0]","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is optional.  The default values for Gamma, s, s_1, and s_2 are 2.0, 2.0, -2.0, and 2.0, respectively.","category":"page"},{"location":"man/param.html#pmesh","page":"Parameters","title":"pmesh","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Additional parameters for customizing the mesh. The tangent mesh needs the f_1 parameter. The lorentz and halflorentz meshes need the cut parameter. The pmesh parameter can be used to setup the two parameters. If pmesh contains one element or more than one elements, then f_1 equiv cut equiv pmesh[1].","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Array.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"pmesh = [2.1]","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is optional. The default values for f_1 and cut are 2.1 and 0.01, respectively. See also mesh.","category":"page"},{"location":"man/param.html#exclude","page":"Parameters","title":"exclude","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Restriction of the energy range of the calculated spectral functions. This features is implemented by the StochAC, StochSK, StochOM, and StochPX solvers. In these solvers, the delta or box functions, which are used to mimic the spectral functions, are restricted to live out of the given energy ranges. For example, exclude = [[8.0,16.0]] means that the energy range [8.0,16.0] is strictly forbidden.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Array.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"exclude = [[-8.0,-4.0],[4.0,8.0]]","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is optional. If you are using the MaxEnt solver, this parameter will be ignored. If solver = StochPX and offdiag = true, this parameter is mandatory. In this case, it is used to restrict the regions that the poles with positive weights can survive (or equivalently, the regions that the poles with negative weights can survice are also determined). For example, if exclude = [[-3.0,3.0]], wmin = -5.0, and wmax = 5.0, then the regions for poles with negative weights are [-3.0,3.0], while the regions for poles with positive weights are [-5.0,-3.0] U [3.0,5.0].","category":"page"},{"location":"man/param.html#maxent_block","page":"Parameters","title":"[MaxEnt] Block","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"note: Note\nThe parameters in this block is valid for the MaxEnt solver only.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"warning: Warning\nIf solver = \"MaxEnt\", the [MaxEnt] block must be available.","category":"page"},{"location":"man/param.html#method","page":"Parameters","title":"method","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"How to determine the optimized alpha parameter? The MaxEnt solver supports four different algorithms. They arehistoric\nclassic\nbryan\nchi2kinkUsually, the chi2kink algorithm is preferred.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"String.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"method = \"bryan\"","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. As for the underlying principles of these algorithms, please see Maximum Entropy Method.","category":"page"},{"location":"man/param.html#stype","page":"Parameters","title":"stype","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type of the entropic factor. The MaxEnt solver supports two schemes. They aresj\nbrHere, sj means the Shannon-Jaynes entropy, while br means the Bayesian Reconstruction entropy. Usually, the Shannon-Jaynes entropy is preferred, since with it the positivity of the generated spectrum is always guaranteed. The Bayesian Reconstruction entropy tends to yield sharp features.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"String.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"stype = \"sj\"","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. As for the underlying principles of these entropic factors, please see Maximum Entropy Method.","category":"page"},{"location":"man/param.html#nalph","page":"Parameters","title":"nalph","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Total number of the chosen alpha parameters.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"nalph = 12","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. Only the chi2kink algorithm needs this parameter to control the number of alpha parameters.","category":"page"},{"location":"man/param.html#alpha","page":"Parameters","title":"alpha","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Starting value for the alpha parameter. The MaxEnt solver always starts with a huge alpha parameter, and then decreases it gradually.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"alpha = 1e9","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. It should be a very large number, such as 10^9 sim 10^13.","category":"page"},{"location":"man/param.html#ratio","page":"Parameters","title":"ratio","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Scaling factor for the alpha parameter. The next alpha is equal to the current alpha divided by ratio.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"ratio = 10.0","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. It muse be larger than 1.0.","category":"page"},{"location":"man/param.html#blur","page":"Parameters","title":"blur","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Sometimes, the kernel functions and spectral functions can be preblurred to obtain smoother results. Shall we preblur them? If blur is larger than zero, then it means the blur parameter. If blur is smaller than zero, then it means that the preblur feature is disable.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"blur = -1.0","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#nevanac_block","page":"Parameters","title":"[NevanAC] Block","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"note: Note\nThe parameters in this block is valid for the NevanAC solver only.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"warning: Warning\nIf solver = \"NevanAC\", the [NevanAC] block must be available.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"warning: Warning\nThis solver is numerically unstable, so use it at your own risk.","category":"page"},{"location":"man/param.html#pick","page":"Parameters","title":"pick","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Check the Pick criterion or not. If pick is true, ACFlow will try to figure out the optimal number of the input data (i.e., how many data points are retained for further postprocessing) by using the Pick criterion.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Bool.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"pick = true","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#hardy","page":"Parameters","title":"hardy","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Perform Hardy basis optimization or not. The spectrum obtained by the Nevanlinna analytical continuation is usually wiggly. So, the Hardy basis optimization can help us smooth the spectrum.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Bool.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"hardy = true","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. See also hmax.","category":"page"},{"location":"man/param.html#hmax","page":"Parameters","title":"hmax","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Upper cut off of Hardy order. In principle, the larger the Hardy order is, the smoother the obtained spectrum is. Usually hmax = 20 is enough to get smooth spectrum.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"hmax = 50","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. See also hardy.","category":"page"},{"location":"man/param.html#alpha-2","page":"Parameters","title":"alpha","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Regulation parameter for smooth norm. If the alpha parameter is too large, the detailed features in the spectra could be smeared out.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"alpha = 1e-4","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#eta","page":"Parameters","title":"eta","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Tiny distance from the real axis. It is used to construct the Hardy matrix, instead of the Green's function.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"eta = 1e-2","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#stochac_block","page":"Parameters","title":"[StochAC] Block","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"note: Note\nThe parameters in this block is valid for the StochAC solver only.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"warning: Warning\nIf solver = \"StochAC\", the [StochAC] block must be available.","category":"page"},{"location":"man/param.html#nfine","page":"Parameters","title":"nfine","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of points of a very fine linear mesh. This mesh is for the delta functions.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"nfine = 10000","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#ngamm","page":"Parameters","title":"ngamm","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of delta functions. Their superposition is used to mimic the spectral functions.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"ngamm = 512","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#nwarm","page":"Parameters","title":"nwarm","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of Monte Carlo thermalization steps.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"nwarm = 4000","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#nstep","page":"Parameters","title":"nstep","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of Monte Carlo sweeping steps.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"nstep = 4000000","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#ndump","page":"Parameters","title":"ndump","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Intervals for monitoring Monte Carlo sweeps. For every ndump steps, the StochAC solver will try to output some useful information to help diagnosis.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"ndump = 40000","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#nalph-2","page":"Parameters","title":"nalph","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Total number of the chosen alpha parameters.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"nalph = 20","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#alpha-3","page":"Parameters","title":"alpha","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Starting value for the alpha parameter. The StochAC solver always starts with a small alpha parameter, and then increases it gradually.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"alpha = 1.0","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#ratio-2","page":"Parameters","title":"ratio","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Scaling factor for the alpha parameter. It should be larger than 1.0.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"ratio = 1.2","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#stochsk_block","page":"Parameters","title":"[StochSK] Block","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"note: Note\nThe parameters in this block is valid for the StochSK solver only.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"warning: Warning\nIf solver = \"StochSK\", the [StochSK] block must be available.","category":"page"},{"location":"man/param.html#method-2","page":"Parameters","title":"method","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"How to determine the optimized Theta parameter? The StochSK solver supports two different algorithms. They arechi2min\nchi2kinkUsually, the chi2min algorithm is preferred. This algorithm is suggested by Shao and Sandvik et al. See Stochastic Analytic Continuation 1 for more details.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"String.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"method = \"chi2min\"","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#nfine-2","page":"Parameters","title":"nfine","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of points of a very fine linear mesh. This mesh is for the delta functions.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"nfine = 100000","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#ngamm-2","page":"Parameters","title":"ngamm","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of delta functions. Their superposition is used to mimic the spectral functions.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"ngamm = 1000","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#nwarm-2","page":"Parameters","title":"nwarm","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of Monte Carlo thermalization steps.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"nwarm = 1000","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#nstep-2","page":"Parameters","title":"nstep","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of Monte Carlo sweeping steps.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"nstep = 20000","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#ndump-2","page":"Parameters","title":"ndump","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Intervals for monitoring Monte Carlo sweeps. For every ndump steps, the StochSK solver will try to output some useful information to help diagnosis.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"ndump = 200","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#retry","page":"Parameters","title":"retry","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"How often to recalculate the goodness-of-fit function (it is actually chi^2) to avoid numerical deterioration.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"retry = 10","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#theta","page":"Parameters","title":"theta","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Starting value for the Theta parameter. The StochSK solver always starts with a huge Theta parameter, and then decreases it gradually.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"theta = 1e+6","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#ratio-3","page":"Parameters","title":"ratio","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Scaling factor for the Theta parameter. It should be less than 1.0.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"ratio = 0.9","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#stochom_block","page":"Parameters","title":"[StochOM] Block","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"note: Note\nThe parameters in this block is valid for the StochOM solver only.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"warning: Warning\nIf solver = \"StochOM\", the [StochOM] block must be available.","category":"page"},{"location":"man/param.html#ntry","page":"Parameters","title":"ntry","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of attempts to figure out the solution.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"ntry = 2000","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#nstep-3","page":"Parameters","title":"nstep","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of Monte Carlo steps per try.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"nstep = 1000","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#nbox","page":"Parameters","title":"nbox","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of boxes. Their superposition is used to construct the spectral functions.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"nbox = 100","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#sbox","page":"Parameters","title":"sbox","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Minimum area of the randomly generated boxes.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"sbox = 0.005","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#wbox","page":"Parameters","title":"wbox","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Minimum width of the randomly generated boxes.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"wbox = 0.02","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#norm","page":"Parameters","title":"norm","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Is the norm calculated? If norm is larger than 0.0, it denotes the normalization factor. If norm is smaller than 0.0, it means that the normalization condition is ignored.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"norm = -1.0","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#stochpx_block","page":"Parameters","title":"[StochPX] Block","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"note: Note\nThe parameters in this block is valid for the StochPX solver only.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"warning: Warning\nIf solver = \"StochPX\", the [StochPX] block must be available.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"warning: Warning\nThe StochPX solver is still in development. Please use it at your own risk.","category":"page"},{"location":"man/param.html#method-3","page":"Parameters","title":"method","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"How to evaluate the final spectral density? The StochPX solver supports two different algorithms. They aremean\nbestIf method = \"mean\", then the solver will try to calculate an averaged spectrum from some selected good solutions. If method = \"best\", then the solver will pick up the best solution (which should exhibit the smallest goodness-of-fit functional chi^2).","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"String.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"method = \"mean\"","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. Note that the \"mean\" method is suitable for the condensed matter cases (broad and smooth peaks), while the \"best\" method is useful for the molecule cases (sharp peaks).","category":"page"},{"location":"man/param.html#nfine-3","page":"Parameters","title":"nfine","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of points of a very fine linear mesh. This mesh is for the poles.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"nfine = 100000","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#npole","page":"Parameters","title":"npole","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of poles on the real axis, which is used to mimic the Matsubara Green's function.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"npole = 200","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. For condensed matter cases, npole should be quite large. While for molecule cases, npole should be small.","category":"page"},{"location":"man/param.html#ntry-2","page":"Parameters","title":"ntry","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of attempts to figure out the solution.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"ntry = 1000","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#nstep-4","page":"Parameters","title":"nstep","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of Monte Carlo sweeping steps per attempt / try.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"nstep = 1000000","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. This parameter is related to the npole parameter. If npole is large, nstep could be small. If npole is small, nstep should be large.","category":"page"},{"location":"man/param.html#theta-2","page":"Parameters","title":"theta","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Artificial inverse temperature Theta. When it is increased, the transition probabilities of Monte Carlo updates will decrease.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"theta = 1e+6","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. The users can check the stat.data file to judge whether the theta parameter is reasonable.","category":"page"},{"location":"man/param.html#eta-2","page":"Parameters","title":"eta","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Tiny distance from the real axis eta, which is used to reconstruct the retarded Green's function and the spectral density. When it is increased, the spectral density will be become more and more smooth.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"eta = 1e-4","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"library/outline.html#Outline","page":"Outline","title":"Outline","text":"","category":"section"},{"location":"library/outline.html#Contents","page":"Outline","title":"Contents","text":"","category":"section"},{"location":"library/outline.html","page":"Outline","title":"Outline","text":"Pages = [\"acflow.md\",\n         \"global.md\",\n         \"type.md\",\n         \"base.md\",\n         \"solver.md\",\n         \"grid.md\",\n         \"mesh.md\",\n         \"model.md\",\n         \"kernel.md\",\n         \"config.md\",\n         \"inout.md\",\n         \"math.md\",\n         \"util.md\"\n        ]\nDepth = 2","category":"page"},{"location":"library/outline.html#Index","page":"Outline","title":"Index","text":"","category":"section"},{"location":"library/outline.html#Modules","page":"Outline","title":"Modules","text":"","category":"section"},{"location":"library/outline.html","page":"Outline","title":"Outline","text":"Modules = [ACFlow]\nOrder = [:module]","category":"page"},{"location":"library/outline.html#Constants","page":"Outline","title":"Constants","text":"","category":"section"},{"location":"library/outline.html","page":"Outline","title":"Outline","text":"Modules = [ACFlow]\nOrder = [:constant]","category":"page"},{"location":"library/outline.html#Types","page":"Outline","title":"Types","text":"","category":"section"},{"location":"library/outline.html","page":"Outline","title":"Outline","text":"Modules = [ACFlow]\nOrder = [:type]","category":"page"},{"location":"library/outline.html#Macros","page":"Outline","title":"Macros","text":"","category":"section"},{"location":"library/outline.html","page":"Outline","title":"Outline","text":"Modules = [ACFlow]\nOrder = [:macro]","category":"page"},{"location":"library/outline.html#Functions","page":"Outline","title":"Functions","text":"","category":"section"},{"location":"library/outline.html","page":"Outline","title":"Outline","text":"Modules = [ACFlow]\nOrder = [:function]","category":"page"},{"location":"examples/green2.html","page":"Imaginary Time Green's Function","title":"Imaginary Time Green's Function","text":"info: Info\nIn order to demonstrate usefulness of the ACFlow toolkit, four examples are illustrated in this section. These examples cover typical application scenarios of the ACFlow toolkit, including analytic continuations ofMatsubara self-energy function\nMatsubara Green's function\nImaginary time Green's function\nCurrent-current correlation functionwithin the script mode or standard mode. All of the necessary source codes and data files, which can be used to reproduce the results as shown in this section, are placed in the /home/your_home/acflow/tutor/T* folders.","category":"page"},{"location":"examples/green2.html#Imaginary-Time-Green's-Function","page":"Imaginary Time Green's Function","title":"Imaginary Time Green's Function","text":"","category":"section"},{"location":"examples/green2.html","page":"Imaginary Time Green's Function","title":"Imaginary Time Green's Function","text":"In this example, analytic continuation of imaginary time Green's function will be tested. Note that this example is borrowed from arXiv:0403055 directly.","category":"page"},{"location":"examples/green2.html","page":"Imaginary Time Green's Function","title":"Imaginary Time Green's Function","text":"The exact spectral function reads:","category":"page"},{"location":"examples/green2.html","page":"Imaginary Time Green's Function","title":"Imaginary Time Green's Function","text":"A(omega) =\nbegincases\nfrac1W fracomegasqrtomega^2 - Delta^2quad  textifDelta  omega  W2 \n0  textotherwise\nendcases","category":"page"},{"location":"examples/green2.html","page":"Imaginary Time Green's Function","title":"Imaginary Time Green's Function","text":"Here, W denotes bandwidth, and Delta is used to control size of the energy gap. Let W = 6 and 2Delta = 1. This spectrum should exhibit flat shoulders, steep peaks, and sharp gap edges. Actually, it is the spectrum of a BCS superconductor.","category":"page"},{"location":"examples/green2.html","page":"Imaginary Time Green's Function","title":"Imaginary Time Green's Function","text":"First, the imaginary time Green's function G(tau) is generated using mathbfG = mathbfKA. Then a normally-distributed random noise is add to G(tau). Maximum amplitude of the noise is 1e-4. The error bar of G(tau) is fixed to 1e-3. The data are written in gtau.data.","category":"page"},{"location":"examples/green2.html","page":"Imaginary Time Green's Function","title":"Imaginary Time Green's Function","text":"Next, we try to prepare the configure file (ac.toml). In this case, we would like to benchmark the StochAC solver, so the solver parameter is set to ''StochAC'' and the grid parameter is set to ''ftime''. Furthermore, the exclude parameter is enabled to impose some a priori constraints to the spectrum. The full ac.toml is listed as follows:","category":"page"},{"location":"examples/green2.html","page":"Imaginary Time Green's Function","title":"Imaginary Time Green's Function","text":"[BASE]\nfinput = \"giw.data\"\nsolver = \"MaxEnt\"\nktype  = \"fermi\"\nmtype  = \"flat\"\ngrid   = \"ffreq\"\nmesh   = \"linear\"\nngrid  = 10\nnmesh  = 501\nwmax   = 5.0\nwmin   = -5.0\nbeta   = 10.0\noffdiag = false\nexclude = [[-5.0,-3.0], [-0.5,0.5], [3.0,5.0]]\n\n[StochAC]\nnfine = 10000\nngamm = 512\nnwarm = 4000\nnstep = 10000000\nndump = 40000\nnalph = 40\nalpha = 1.00\nratio = 1.20","category":"page"},{"location":"examples/green2.html","page":"Imaginary Time Green's Function","title":"Imaginary Time Green's Function","text":"We perform analytic continuation simulation by running the acrun.jl or Pacrun.jl script. In order to obtain smooth spectral density, it is useful to increase number of delta functions (See ngamm parameter) and number of Monte Carlo sampling steps (See nstep parameter).","category":"page"},{"location":"examples/green2.html","page":"Imaginary Time Green's Function","title":"Imaginary Time Green's Function","text":"Figure 1 shows the calculated results. In Fig.1(a), the exact spectral function is compared with the simulated spectrum. Note that besides the StochAC solver, the other three solvers are also tested. Their results are also plotted in this figure for a direct comparison. It is remarkable that the StochAC and StochSK solvers do a superior job of modelling the spectrum. The major characteristics of the spectrum, including flat regions, steep peaks, and sharp gap edges, are well captured by the two solvers. Especially, we have finished more tests without any constraints on the spectral density. The gap in the spectrum can be reproduced as well. On the other hand, the spectra obtained by the MaxEnt and StochOM solvers are much too smooth, and show extra shoulder peaks around pm 2.0. Figure 1(b) shows alpha-resolved spectral functions A_alpha(omega) for selected alpha parameters. Fluctuation in the flat regions of the calculated spectral density grows when alpha increases. Figure 1(c) shows internal energy U as a function of alpha. From this figure, the critical alpha is estimated, which is indicated by the vertical bar. Finally, the reproduced Green's function tildeG(tau) agrees quite well with the raw input data, which is shown in Fig.1(d).","category":"page"},{"location":"examples/green2.html","page":"Imaginary Time Green's Function","title":"Imaginary Time Green's Function","text":"(Image: T_E3.png)","category":"page"},{"location":"examples/green2.html","page":"Imaginary Time Green's Function","title":"Imaginary Time Green's Function","text":"Figure 1 | Analytic continuation of imaginary time Green's function by using the stochastic analytic continuation (Beach's algorithm). (a) Simulated and exact spectral functions. (b) alpha-dependent spectral functions. (c) Internal energy U as a function of alpha. The vertical bar indicates the optimal alpha parameter. (d) Simulated and exact imaginary time Green's functions.","category":"page"},{"location":"intro/background.html#Background","page":"Background","title":"Background","text":"","category":"section"},{"location":"intro/background.html#Analytic-Continuation-Problem","page":"Background","title":"Analytic Continuation Problem","text":"","category":"section"},{"location":"intro/background.html","page":"Background","title":"Background","text":"It is well-known that quantum Monte Carlo (QMC) method is a powerful and exact numerical approach, and has been widely used in many research fields, such as nuclear physics, condense matter physics, and many-body physics. Here, we just focus on the finite temperature QMC algorithms, which are used to solve interacting lattice models or quantum impurity models. Generally speaking, the simulated results of QMC methods are some sorts of single-particle or two-particle correlation functions, which are usually defined on imaginary time axis (tau equiv -it) or Matsubara frequency axis (iomega_n). Therefore, they can't be compared directly with the correspondingly experimental results, including but not limited to electronic density of states A(omega), optical conductivity sigma(omega), dynamical structure factor S(mathbfqomega), and so on. It is necessary to convert the QMC simulated results from imaginary time axis or Matsubara frequency axis to real axis (i.e. tau to omega or iomega_n to omega), which is the origin of the analytic continuation problem.","category":"page"},{"location":"intro/background.html#Fredholm-Integral-Equation","page":"Background","title":"Fredholm Integral Equation","text":"","category":"section"},{"location":"intro/background.html","page":"Background","title":"Background","text":"Let's concentrate on the following Fredholm integral equation of the first kind:","category":"page"},{"location":"intro/background.html","page":"Background","title":"Background","text":"g(y) = int K(yx) f(x)dx","category":"page"},{"location":"intro/background.html","page":"Background","title":"Background","text":"Here, K(yx) is the known kernel function, f(x) is the model function, and g(y) denotes raw data. Given f(x), it is quite easy to get g(y) via numerical integration. However, given g(y), solving the Fredholm integral equation reversely to get f(x) is not as easy as expected. There is no universal solution. In some cases, even the existence of solution can not be guaranteed.","category":"page"},{"location":"intro/background.html#Available-Analytic-Continuation-Methods","page":"Background","title":"Available Analytic Continuation Methods","text":"","category":"section"},{"location":"intro/background.html","page":"Background","title":"Background","text":"The so-called analytic continuation problem can be reformulated in terms of the Fredholm integral equation. Thus, its objective is to seek a reasonable f(x) to satisfy the above equation. The QMC simulated data g(y) are noisy and the kernel function K(yx) is ill conditioned, which make analytic continuation of QMC simulated data a huge challenge. In order to solve this problem, in the past decades peoples have developed numerous methods, including the least square fitting method, singular value decomposition, Padtexte approximation, Tikhonov-Philips regularization method, maximum entropy method, stochastic analytic continuation, stochastic optimization method, sparse modelling method, and machine learning method, etc. However, each method has its pros and cons. None of these methods can override the others. The analytic continuation problem is still far away from being completely solved.","category":"page"},{"location":"intro/background.html#Our-Motivations","page":"Background","title":"Our Motivations","text":"","category":"section"},{"location":"intro/background.html","page":"Background","title":"Background","text":"In recent years, quite a few analytic continuation codes have been released, including","category":"page"},{"location":"intro/background.html","page":"Background","title":"Background","text":"maxent (by Mark Jarrell)\nOmegaMaxent\nana_cont\nALPSCore/maxent\nTRIQS/som\nALF","category":"page"},{"location":"intro/background.html","page":"Background","title":"Background","text":"just to name a few. We note that the maximum entropy method has dominated this field for quite a long time. Thus most of these codes only support the maximum entropy method. It is rather difficult to crosscheck the simulated results obtained by various analytic continuation methods. In addition, the features of the available codes are quite limited and hard to be extended. In order to fill in this gap, we would like to present a new open source toolkit, called ACFlow, for analytic continuation. This toolkit implements three primary analytic continuation methods, namely the","category":"page"},{"location":"intro/background.html","page":"Background","title":"Background","text":"Maximum entropy method\nStochastic analytic continuation\nStochastic optimization method","category":"page"},{"location":"intro/background.html","page":"Background","title":"Background","text":"within an united framework. It provides an easy-to-used library and application interface. Some diagnostic and analytic tools are also available. With ACFlow, the users can easily setup and execute analytic continuation calculations, and validate the calculated results. We believe that this toolkit will play a vital role in solving analytic continuation problems.","category":"page"},{"location":"intro/background.html","page":"Background","title":"Background","text":"info: Info\nQuite recently, two new analytic continuation methods, namely the stochastic pole expansion and the Nevanlinna analytical continuation, have been implemented in the ACFlow toolkit. So, now it supports five analytic continuation methods :-).","category":"page"},{"location":"library/base.html#Core","page":"Core","title":"Core","text":"","category":"section"},{"location":"library/base.html","page":"Core","title":"Core","text":"Provide basic user's interfaces for the ACFlow toolkit.","category":"page"},{"location":"library/base.html#Contents","page":"Core","title":"Contents","text":"","category":"section"},{"location":"library/base.html","page":"Core","title":"Core","text":"Pages = [\"base.md\"]\nDepth = 2","category":"page"},{"location":"library/base.html#Index","page":"Core","title":"Index","text":"","category":"section"},{"location":"library/base.html","page":"Core","title":"Core","text":"Pages = [\"base.md\"]","category":"page"},{"location":"library/base.html#Solvers","page":"Core","title":"Solvers","text":"","category":"section"},{"location":"library/base.html","page":"Core","title":"Core","text":"solve(grid::Vector{F64}, Gval::Vector{T}, Gerr::Vector{T}) where {T}\nsolve(grid::Vector{F64}, Gval::Vector{T}, err::T) where {T}\nsolve(grid::Vector{F64}, Gval::Vector{T}) where {T}\nsolve(rd::RawData)","category":"page"},{"location":"library/base.html#ACFlow.solve-Union{Tuple{T}, Tuple{Vector{Float64}, Vector{T}, Vector{T}}} where T","page":"Core","title":"ACFlow.solve","text":"solve(grid::Vector{F64}, Gval::Vector{T}, Gerr::Vector{T})\n\nSolve the analytic continuation problem. The arguments grid, Gval, and Gerr are the grid, value, and error bar, respectively.\n\n\n\n\n\n","category":"method"},{"location":"library/base.html#ACFlow.solve-Union{Tuple{T}, Tuple{Vector{Float64}, Vector{T}, T}} where T","page":"Core","title":"ACFlow.solve","text":"solve(grid::Vector{F64}, Gval::Vector{T}, err::T)\n\nSolve the analytic continuation problem. The arguments grid, Gval, and err are the grid, value, and error bar, respectively.\n\n\n\n\n\n","category":"method"},{"location":"library/base.html#ACFlow.solve-Union{Tuple{T}, Tuple{Vector{Float64}, Vector{T}}} where T","page":"Core","title":"ACFlow.solve","text":"solve(grid::Vector{F64}, Gval::Vector{T})\n\nSolve the analytic continuation problem. The arguments grid and Gval are the grid and value, respectively. Furthermore, the error bar is set to a fixed value 1.0e-4.\n\n\n\n\n\n","category":"method"},{"location":"library/base.html#ACFlow.solve-Tuple{RawData}","page":"Core","title":"ACFlow.solve","text":"solve(rd::RawData)\n\nSolve the analytic continuation problem. The input data are encapsulated in a RawData struct. This function call is the actual interface to the desired analytic continuation solvers.\n\nSee also: RawData.\n\n\n\n\n\n","category":"method"},{"location":"library/base.html#Parameters","page":"Core","title":"Parameters","text":"","category":"section"},{"location":"library/base.html","page":"Core","title":"Core","text":"setup_param\nread_param","category":"page"},{"location":"library/base.html#ACFlow.setup_param","page":"Core","title":"ACFlow.setup_param","text":"setup_param(C::Dict{String,Any}, S::Dict{String,Any}, reset::Bool = true)\n\nSetup the configuration dictionaries via function call. Here C contains parameters for general setup, while S contains parameters for selected analytic continuation solver. If reset is true, then the configuration dictionaries will be reset to their default values at first. Later, C S will be used to customized the dictionaries further.\n\nSee also: read_param.\n\n\n\n\n\n","category":"function"},{"location":"library/base.html#ACFlow.read_param","page":"Core","title":"ACFlow.read_param","text":"read_param()\n\nSetup the configuration dictionaries via an external file. The valid format of a configuration file is toml.\n\nSee also: read_param.\n\n\n\n\n\n","category":"function"},{"location":"library/base.html#Data","page":"Core","title":"Data","text":"","category":"section"},{"location":"library/base.html","page":"Core","title":"Core","text":"read_data\nmake_data","category":"page"},{"location":"library/base.html#ACFlow.read_data","page":"Core","title":"ACFlow.read_data","text":"read_data(only_real_part::Bool = true)\n\nRead data in imaginary axis and return a RawData struct.\n\nSee also: RawData.\n\n\n\n\n\n","category":"function"},{"location":"library/base.html#ACFlow.make_data","page":"Core","title":"ACFlow.make_data","text":"make_data(rd::RawData; T::DataType = F64)\n\nConvert RawData struct to GreenData struct. Note that RawData is provided by the users directly, while GreenData is more suitable for various analytic continuation solvers and algorithms. Note that the GreenData struct is accessed and manipulated by this code internally, while the RawData struct is exposed to the users.\n\nSee also: RawData, GreenData.\n\n\n\n\n\n","category":"function"},{"location":"library/base.html#Grids","page":"Core","title":"Grids","text":"","category":"section"},{"location":"library/base.html","page":"Core","title":"Core","text":"make_grid","category":"page"},{"location":"library/base.html#ACFlow.make_grid","page":"Core","title":"ACFlow.make_grid","text":"make_grid(rd::RawData; T::DataType = F64)\n\nExtract grid for input data from a RawData struct. It will return a sub-type of the AbstractGrid struct.\n\nSee also: RawData, AbstractGrid.\n\n\n\n\n\n","category":"function"},{"location":"library/base.html#Meshes","page":"Core","title":"Meshes","text":"","category":"section"},{"location":"library/base.html","page":"Core","title":"Core","text":"make_mesh","category":"page"},{"location":"library/base.html#ACFlow.make_mesh","page":"Core","title":"ACFlow.make_mesh","text":"make_mesh(; T::DataType = F64)\n\nTry to generate an uniform (linear) or non-uniform (non-linear) mesh for the spectral function in real axis. Notice that it supports arbitrary precision mesh. By default, the precision is F64. One can specify the precision by the argument T.\n\nSee also: LinearMesh, TangentMesh, LorentzMesh.\n\n\n\n\n\n","category":"function"},{"location":"library/base.html#Models","page":"Core","title":"Models","text":"","category":"section"},{"location":"library/base.html","page":"Core","title":"Core","text":"make_model","category":"page"},{"location":"library/base.html#ACFlow.make_model","page":"Core","title":"ACFlow.make_model","text":"make_model(am::AbstractMesh)\n\nTry to generate a default model function at given mesh am through various schemes.\n\nSee also: AbstractMesh.\n\n\n\n\n\n","category":"function"},{"location":"library/base.html#Kernels","page":"Core","title":"Kernels","text":"","category":"section"},{"location":"library/base.html","page":"Core","title":"Core","text":"make_kernel","category":"page"},{"location":"library/base.html#ACFlow.make_kernel","page":"Core","title":"ACFlow.make_kernel","text":"make_kernel(am::AbstractMesh, ag::AbstractGrid)\n\nTry to generate various kernel functions.\n\nSee also: AbstractMesh, AbstractGrid.\n\n\n\n\n\n","category":"function"},{"location":"library/base.html#Postprocessing","page":"Core","title":"Postprocessing","text":"","category":"section"},{"location":"library/base.html","page":"Core","title":"Core","text":"reprod\nkramers","category":"page"},{"location":"library/base.html#ACFlow.reprod","page":"Core","title":"ACFlow.reprod","text":"reprod(am::AbstractMesh, kernel::Matrix{F64}, A::Vector{F64})\n\nTry to reproduce the input data using the calculated spectrum function A. kernel is the kernel function, and am is the mesh in which the spectrum is defined.\n\nSee also: AbstractMesh.\n\n\n\n\n\n","category":"function"},{"location":"library/base.html#ACFlow.kramers","page":"Core","title":"ACFlow.kramers","text":"kramers(am::AbstractMesh, A::Vector{F64})\n\nTry to calculate the real part of the green's function from its imaginary part via the Kramers-Kronig relations.\n\n\n\n\n\n","category":"function"},{"location":"man/impl.html#Implementations","page":"Implementations","title":"Implementations","text":"","category":"section"},{"location":"man/impl.html#Powered-by-Julia","page":"Implementations","title":"Powered by Julia","text":"","category":"section"},{"location":"man/impl.html","page":"Implementations","title":"Implementations","text":"The ACFlow toolkit is developed with pure Julia language. Thanks to powerful type system and multiple dispatch paradigm of the Julia language, the five different analytic continuation solvers are integrated into an united software architecture. Redundant codes are greatly reduced. It is quite easy to implement new analytic continuation solver or add new features to the existing solvers if necessary. Distributed computing is a built-in feature of Julia. So, it is straightforward to realize parallel calculations in the ACFlow toolkit. Now except for the MaxEnt and NevanAC solvers, all the other solvers are parallelized.","category":"page"},{"location":"man/impl.html#Code-Repository","page":"Implementations","title":"Code Repository","text":"","category":"section"},{"location":"man/impl.html","page":"Implementations","title":"Implementations","text":"The official code repository of the ACFlow toolkit is:","category":"page"},{"location":"man/impl.html","page":"Implementations","title":"Implementations","text":"https://github.com/huangli712/ACFlow","category":"page"},{"location":"man/impl.html#Core-Codes","page":"Implementations","title":"Core Codes","text":"","category":"section"},{"location":"man/impl.html","page":"Implementations","title":"Implementations","text":"The source codes of the ACFlow toolkit are placed in the acflow/src folder. Their functions are summarized in Table 1.","category":"page"},{"location":"man/impl.html","page":"Implementations","title":"Implementations","text":"Filename Description\nACFlow.jl Entry of the ACFlow module.\nmaxent.jl Maximum entropy method.\nnac.jl Nevanlinna analytical continuation.\nsac.jl Stochastic analytic continuation (K. S. D. Beach's algorithm).\nsan.jl Stochastic analytic continuation (A. W. Sandvik's algorithm).\nsom.jl Stochastic optimization method.\nspx.jl Stochastic pole expansion.\nglobal.jl Numerical and physical constants.\ntypes.jl Basic data structures and computational parameters.\nbase.jl Driver for analytic continuation simulation.\ninout.jl Read input data and write calculated results.\nconfig.jl Parse configuration file and extract computational parameters.\nmath.jl Root finding, numerical integration, interpolation, Einstein summation, and curve fitting.\nutil.jl Some utility functions.\nmesh.jl Meshes for spectral density.\ngrid.jl Grids for input data.\nmodel.jl Default model functions.\nkernel.jl Kernel functions.","category":"page"},{"location":"man/impl.html","page":"Implementations","title":"Implementations","text":"Table 1 | List of source codes of the ACFlow toolkit.","category":"page"},{"location":"man/impl.html","page":"Implementations","title":"Implementations","text":"note: Note\nThere are two more scripts (acrun.jl and Pacrun.jl) in the acflow/util folder. They are used to launch the analytic continuation tasks.","category":"page"},{"location":"man/impl.html#Documentation","page":"Implementations","title":"Documentation","text":"","category":"section"},{"location":"man/impl.html","page":"Implementations","title":"Implementations","text":"The documentation of the ACFlow toolkit is written by using the Markdown language and the Documenter.jl package. The source codes are placed in the acflow/docs folder. The users can build documentation by themselves. Please see Installation for how to do that. Or they can read the latest documentation in the following website:","category":"page"},{"location":"man/impl.html","page":"Implementations","title":"Implementations","text":"https://huangli712.github.io/projects/acflow/index.html","category":"page"},{"location":"man/impl.html#Tests-and-Examples","page":"Implementations","title":"Tests and Examples","text":"","category":"section"},{"location":"man/impl.html","page":"Implementations","title":"Implementations","text":"Forty tests and four tutorials are also shipped with the ACFlow toolkit. The source codes for internal tests are placed in the acflow/test folder, while those for tutorials are saved in the acflow/tutor folder. See acflow/test/test.md and acflow/tutor/tutor.md for more details.","category":"page"},{"location":"man/feature.html#Main-Features","page":"Main Features","title":"Main Features","text":"","category":"section"},{"location":"man/feature.html","page":"Main Features","title":"Main Features","text":"Now the ACFlow toolkit supports five analytic continuation methods as introduced before. It includes six different analytic continuation solvers, namely","category":"page"},{"location":"man/feature.html","page":"Main Features","title":"Main Features","text":"MaxEnt\nNevanAC\nStochAC\nStochSK\nStochOM\nStochPX","category":"page"},{"location":"man/feature.html","page":"Main Features","title":"Main Features","text":"Just as their names suggested, the MaxEnt solver implements the maximum entropy method. The NevanAC solver implements the Nevanlinna analytical continuation. The StochAC and StochSK solvers implement the K. S. D. Beach's algorithm and A. W. Sandvik's algorithm of the stochastic analytic continuation, respectively. The StochOM solver implements the stochastic optimization method. The StochPX solver implements the stochastic pole expansion method. The ACFlow toolkit also provides a convenient library, which can be used to prepare and carry out analytic continuation calculations flexibly. The major features of the present ACFlow toolkit (v1.8.0 and above) are summarized in Table 1.","category":"page"},{"location":"man/feature.html","page":"Main Features","title":"Main Features","text":"Features MaxEnt NevanAC StochAC StochSK StochOM StochPX\nMatrix-valued Green's function Y N N N N Y\nFragment input grid Y Y Y Y Y Y\nImaginary time grid Y N Y Y Y N\nMatsubara frequency grid Y Y Y Y Y Y\nLinear mesh Y Y Y Y Y Y\nNonlinear mesh Y Y Y Y Y Y\nFermionic kernel Y Y Y Y Y Y\nBosonic kernel Y N Y Y Y Y\nSelf-defined model function Y N N N N N\nConstrained analytic continuation N N Y Y Y Y\nSelf-adaptive parameterization N N Y N N Y\nRegeneration of input data Y Y Y Y Y Y\nKramers-Kronig transformation Y Y Y Y Y Y\nParallel computing N N Y Y Y Y\nParallel tempering N N Y N N N\nInteractive mode Y Y Y Y Y Y\nScript mode Y Y Y Y Y Y\nStandard mode Y Y Y Y Y Y","category":"page"},{"location":"man/feature.html","page":"Main Features","title":"Main Features","text":"Table 1 | Major features of the ACFlow toolkit. MaxEnt, NevanAC, StochAC, StochSK, StochOM, and StochPX are the six analytic continuation solvers as implemented in this toolkit.","category":"page"},{"location":"man/feature.html","page":"Main Features","title":"Main Features","text":"In Table 1, Y means yes while N means no. Interactive mode, Script mode, and Standard model are three running modes supported by the ACFlow toolkit. We will introduce them later. The MaxEnt solver supports the historic, classic, bryan, and chi2kink algorithms to determine the alpha parameter. The StochAC solver is only compatible with a flat model function, while the NevanAC, StochSK, StochOM, and StochPX solvers don't rely on any default model functions. The StochOM solver does not support analytic continuation of fermionic imaginary time Green's function for the moment.","category":"page"},{"location":"man/feature.html","page":"Main Features","title":"Main Features","text":"info: Info\nNote that analytic continuation problem is a hotspot in computational physics and many-body physics all the time. Many efforts have been devoted to solve it in recent years. Noticeable achievements include maximum quantum entropy method, Nevanlinna analytical continuation, blocked-mode sampling and grid point sampling in stochastic analytic continuation, constrained stochastic analytic continuation, machine learning assisted analytic continuation, and so on. We would like to incorporate these new progresses into the ACFlow toolkit in the near future. BTW, contributions from the other users are always welcomed.","category":"page"},{"location":"library/grid.html#Grids","page":"Grids","title":"Grids","text":"","category":"section"},{"location":"library/grid.html","page":"Grids","title":"Grids","text":"Grids on imaginary axis.","category":"page"},{"location":"library/grid.html","page":"Grids","title":"Grids","text":"In the ACFlow toolkit, the input correlators are defined on grid, while the calculated spectral functions are defined on mesh. The ACFlow toolkit supports both imaginary time and Matsubara frequency grids. Note that for Matsubara frequency grid, the bosonic and fermionic grids are different.","category":"page"},{"location":"library/grid.html#Contents","page":"Grids","title":"Contents","text":"","category":"section"},{"location":"library/grid.html","page":"Grids","title":"Grids","text":"Pages = [\"grid.md\"]\nDepth = 2","category":"page"},{"location":"library/grid.html#Index","page":"Grids","title":"Index","text":"","category":"section"},{"location":"library/grid.html","page":"Grids","title":"Grids","text":"Pages = [\"grid.md\"]","category":"page"},{"location":"library/grid.html#Types","page":"Grids","title":"Types","text":"","category":"section"},{"location":"library/grid.html","page":"Grids","title":"Grids","text":"AbstractGrid\nFermionicImaginaryTimeGrid\nFermionicFragmentTimeGrid\nFermionicMatsubaraGrid\nFermionicFragmentMatsubaraGrid\nBosonicImaginaryTimeGrid\nBosonicFragmentTimeGrid\nBosonicMatsubaraGrid\nBosonicFragmentMatsubaraGrid","category":"page"},{"location":"library/grid.html#ACFlow.AbstractGrid","page":"Grids","title":"ACFlow.AbstractGrid","text":"AbstractGrid\n\nAn abstract type representing the imaginary axis. It is used to build the internal type system.\n\n\n\n\n\n","category":"type"},{"location":"library/grid.html#ACFlow.FermionicImaginaryTimeGrid","page":"Grids","title":"ACFlow.FermionicImaginaryTimeGrid","text":"FermionicImaginaryTimeGrid\n\nMutable struct. It represents the fermionic imaginary time grid.\n\nMembers\n\nntime -> Number of time slices.\nβ     -> Inverse temperature.\nτ     -> Vector of grid points.\n\nSee also: FermionicFragmentTimeGrid.\n\n\n\n\n\n","category":"type"},{"location":"library/grid.html#ACFlow.FermionicFragmentTimeGrid","page":"Grids","title":"ACFlow.FermionicFragmentTimeGrid","text":"FermionicFragmentTimeGrid\n\nMutable struct. It represents part of the fermionic imaginary time grid. In other words, the grid might be fragmentary。\n\nMembers\n\nntime -> Number of time slices.\nβ     -> Inverse temperature.\nτ     -> Vector of grid points.\n\nSee also: FermionicImaginaryTimeGrid.\n\n\n\n\n\n","category":"type"},{"location":"library/grid.html#ACFlow.FermionicMatsubaraGrid","page":"Grids","title":"ACFlow.FermionicMatsubaraGrid","text":"FermionicMatsubaraGrid\n\nMutable struct. It represents the fermionic Matsubara frequency grid.\n\nMembers\n\nnfreq -> Number of Matsubara frequency points.\nβ     -> Inverse temperature.\nω     -> Vector of grid points.\n\nSee also: FermionicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"type"},{"location":"library/grid.html#ACFlow.FermionicFragmentMatsubaraGrid","page":"Grids","title":"ACFlow.FermionicFragmentMatsubaraGrid","text":"FermionicFragmentMatsubaraGrid\n\nMutable struct. It represents part of the fermionic Matsubara frequency grid. In other words, the grid might be fragmentary。\n\nMembers\n\nnfreq -> Number of Matsubara frequency points.\nβ     -> Inverse temperature.\nω     -> Vector of grid points.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\n","category":"type"},{"location":"library/grid.html#ACFlow.BosonicImaginaryTimeGrid","page":"Grids","title":"ACFlow.BosonicImaginaryTimeGrid","text":"BosonicImaginaryTimeGrid\n\nMutable struct. It represents the bosonic imaginary time grid.\n\nMembers\n\nntime -> Number of time slices.\nβ     -> Inverse temperature.\nτ     -> Vector of grid points.\n\nSee also: BosonicFragmentTimeGrid.\n\n\n\n\n\n","category":"type"},{"location":"library/grid.html#ACFlow.BosonicFragmentTimeGrid","page":"Grids","title":"ACFlow.BosonicFragmentTimeGrid","text":"BosonicFragmentTimeGrid\n\nMutable struct. It represents part of the bosonic imaginary time grid. In other words, the grid might be fragmentary。\n\nMembers\n\nntime -> Number of time slices.\nβ     -> Inverse temperature.\nτ     -> Vector of grid points.\n\nSee also: BosonicImaginaryTimeGrid.\n\n\n\n\n\n","category":"type"},{"location":"library/grid.html#ACFlow.BosonicMatsubaraGrid","page":"Grids","title":"ACFlow.BosonicMatsubaraGrid","text":"BosonicMatsubaraGrid\n\nMutable struct. It represents the bosonic Matsubara frequency grid.\n\nMembers\n\nnfreq -> Number of Matsubara frequency points.\nβ     -> Inverse temperature.\nω     -> Vector of grid points.\n\nSee also: BosonicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"type"},{"location":"library/grid.html#ACFlow.BosonicFragmentMatsubaraGrid","page":"Grids","title":"ACFlow.BosonicFragmentMatsubaraGrid","text":"BosonicFragmentMatsubaraGrid\n\nMutable struct. It represents part of the bosonic Matsubara frequency grid. In other words, the grid might be fragmentary。 However, the first frequency point should be present (ωₙ ≡ 0.0).\n\nMembers\n\nnfreq -> Number of Matsubara frequency points.\nβ     -> Inverse temperature.\nω     -> Vector of grid points.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\n","category":"type"},{"location":"library/grid.html#Constructors","page":"Grids","title":"Constructors","text":"","category":"section"},{"location":"library/grid.html","page":"Grids","title":"Grids","text":"FermionicImaginaryTimeGrid(ntime::I64, β::F64)\nFermionicFragmentTimeGrid(β::F64, τ::Vector{F64})\nFermionicMatsubaraGrid(nfreq::I64, β::F64)\nFermionicFragmentMatsubaraGrid(β::F64, ω::Vector{F64})\nBosonicImaginaryTimeGrid(ntime::I64, β::F64)\nBosonicFragmentTimeGrid(β::F64, τ::Vector{F64})\nBosonicMatsubaraGrid(nfreq::I64, β::F64)\nBosonicFragmentMatsubaraGrid(β::F64, ω::Vector{F64})","category":"page"},{"location":"library/grid.html#ACFlow.FermionicImaginaryTimeGrid-Tuple{Int64, Float64}","page":"Grids","title":"ACFlow.FermionicImaginaryTimeGrid","text":"FermionicImaginaryTimeGrid(ntime::I64, β::T) where {T}\n\nA constructor for the FermionicImaginaryTimeGrid struct, which is defined in src/types.jl.\n\nSee also: FermionicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#ACFlow.FermionicFragmentTimeGrid-Tuple{Float64, Vector{Float64}}","page":"Grids","title":"ACFlow.FermionicFragmentTimeGrid","text":"FermionicFragmentTimeGrid(β::T, τ::Vector{T}) where {T}\n\nA constructor for the FermionicFragmentTimeGrid struct, which is defined in src/types.jl.\n\nSee also: FermionicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#ACFlow.FermionicMatsubaraGrid-Tuple{Int64, Float64}","page":"Grids","title":"ACFlow.FermionicMatsubaraGrid","text":"FermionicMatsubaraGrid(nfreq::I64, β::T) where {T}\n\nA constructor for the FermionicMatsubaraGrid struct, which is defined in src/types.jl. The Matsubara grid is evaluated as ωₙ = (2n - 1) π / β.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#ACFlow.FermionicFragmentMatsubaraGrid-Tuple{Float64, Vector{Float64}}","page":"Grids","title":"ACFlow.FermionicFragmentMatsubaraGrid","text":"FermionicFragmentMatsubaraGrid(β::T, ω::Vector{T}) where {T}\n\nA constructor for the FermionicFragmentMatsubaraGrid struct, which is defined in src/types.jl. The Matsubara grid is from input.\n\nSee also: FermionicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#ACFlow.BosonicImaginaryTimeGrid-Tuple{Int64, Float64}","page":"Grids","title":"ACFlow.BosonicImaginaryTimeGrid","text":"BosonicImaginaryTimeGrid(ntime::I64, β::T)\n\nA constructor for the BosonicImaginaryTimeGrid struct, which is defined in src/types.jl.\n\nSee also: BosonicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#ACFlow.BosonicFragmentTimeGrid-Tuple{Float64, Vector{Float64}}","page":"Grids","title":"ACFlow.BosonicFragmentTimeGrid","text":"BosonicFragmentTimeGrid(β::T, τ::Vector{T}) where {T}\n\nA constructor for the BosonicFragmentTimeGrid struct, which is defined in src/types.jl.\n\nSee also: BosonicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#ACFlow.BosonicMatsubaraGrid-Tuple{Int64, Float64}","page":"Grids","title":"ACFlow.BosonicMatsubaraGrid","text":"BosonicMatsubaraGrid(nfreq::I64, β::T) where {T}\n\nA constructor for the BosonicMatsubaraGrid struct, which is defined in src/types.jl. The Matsubara grid is evaluated as ωₙ = (2n - 2) π / β.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#ACFlow.BosonicFragmentMatsubaraGrid-Tuple{Float64, Vector{Float64}}","page":"Grids","title":"ACFlow.BosonicFragmentMatsubaraGrid","text":"BosonicFragmentMatsubaraGrid(β::T, ω::Vector{T}) where {T}\n\nA constructor for the BosonicFragmentMatsubaraGrid struct, which is defined in src/types.jl. The Matsubara grid is from input.\n\nSee also: BosonicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.*-Functions","page":"Grids","title":"Base.* Functions","text":"","category":"section"},{"location":"library/grid.html","page":"Grids","title":"Grids","text":"Base.length(fg::FermionicImaginaryTimeGrid)\nBase.length(fg::FermionicFragmentTimeGrid)\nBase.length(fg::FermionicMatsubaraGrid)\nBase.length(fg::FermionicFragmentMatsubaraGrid)\nBase.length(bg::BosonicImaginaryTimeGrid)\nBase.length(bg::BosonicFragmentTimeGrid)\nBase.length(bg::BosonicMatsubaraGrid)\nBase.length(bg::BosonicFragmentMatsubaraGrid)\nBase.iterate(fg::FermionicImaginaryTimeGrid)\nBase.iterate(fg::FermionicFragmentTimeGrid)\nBase.iterate(fg::FermionicMatsubaraGrid)\nBase.iterate(fg::FermionicFragmentMatsubaraGrid)\nBase.iterate(bg::BosonicImaginaryTimeGrid)\nBase.iterate(bg::BosonicFragmentTimeGrid)\nBase.iterate(bg::BosonicMatsubaraGrid)\nBase.iterate(bg::BosonicFragmentMatsubaraGrid)\nBase.iterate(fg::FermionicImaginaryTimeGrid, i::I64)\nBase.iterate(fg::FermionicFragmentTimeGrid, i::I64)\nBase.iterate(fg::FermionicMatsubaraGrid, i::I64)\nBase.iterate(fg::FermionicFragmentMatsubaraGrid, i::I64)\nBase.iterate(bg::BosonicImaginaryTimeGrid, i::I64)\nBase.iterate(bg::BosonicFragmentTimeGrid, i::I64)\nBase.iterate(bg::BosonicMatsubaraGrid, i::I64)\nBase.iterate(bg::BosonicFragmentMatsubaraGrid, i::I64)\nBase.eachindex(fg::FermionicImaginaryTimeGrid)\nBase.eachindex(fg::FermionicFragmentTimeGrid)\nBase.eachindex(fg::FermionicMatsubaraGrid)\nBase.eachindex(fg::FermionicFragmentMatsubaraGrid)\nBase.eachindex(bg::BosonicImaginaryTimeGrid)\nBase.eachindex(bg::BosonicFragmentTimeGrid)\nBase.eachindex(bg::BosonicMatsubaraGrid)\nBase.eachindex(bg::BosonicFragmentMatsubaraGrid)\nBase.firstindex(fg::FermionicImaginaryTimeGrid)\nBase.firstindex(fg::FermionicFragmentTimeGrid)\nBase.firstindex(fg::FermionicMatsubaraGrid)\nBase.firstindex(fg::FermionicFragmentMatsubaraGrid)\nBase.firstindex(bg::BosonicImaginaryTimeGrid)\nBase.firstindex(bg::BosonicFragmentTimeGrid)\nBase.firstindex(bg::BosonicMatsubaraGrid)\nBase.firstindex(bg::BosonicFragmentMatsubaraGrid)\nBase.lastindex(fg::FermionicImaginaryTimeGrid)\nBase.lastindex(fg::FermionicFragmentTimeGrid)\nBase.lastindex(fg::FermionicMatsubaraGrid)\nBase.lastindex(fg::FermionicFragmentMatsubaraGrid)\nBase.lastindex(bg::BosonicImaginaryTimeGrid)\nBase.lastindex(bg::BosonicFragmentTimeGrid)\nBase.lastindex(bg::BosonicMatsubaraGrid)\nBase.lastindex(bg::BosonicFragmentMatsubaraGrid)\nBase.getindex(fg::FermionicImaginaryTimeGrid, ind::I64)\nBase.getindex(fg::FermionicFragmentTimeGrid, ind::I64)\nBase.getindex(fg::FermionicMatsubaraGrid, ind::I64)\nBase.getindex(fg::FermionicFragmentMatsubaraGrid, ind::I64)\nBase.getindex(bg::BosonicImaginaryTimeGrid, ind::I64)\nBase.getindex(bg::BosonicFragmentTimeGrid, ind::I64)\nBase.getindex(bg::BosonicMatsubaraGrid, ind::I64)\nBase.getindex(bg::BosonicFragmentMatsubaraGrid, ind::I64)\nBase.getindex(fg::FermionicImaginaryTimeGrid, I::UnitRange{I64})\nBase.getindex(fg::FermionicFragmentTimeGrid, I::UnitRange{I64})\nBase.getindex(fg::FermionicMatsubaraGrid, I::UnitRange{I64})\nBase.getindex(fg::FermionicFragmentMatsubaraGrid, I::UnitRange{I64})\nBase.getindex(bg::BosonicImaginaryTimeGrid, I::UnitRange{I64})\nBase.getindex(bg::BosonicFragmentTimeGrid, I::UnitRange{I64})\nBase.getindex(bg::BosonicMatsubaraGrid, I::UnitRange{I64})\nBase.getindex(bg::BosonicFragmentMatsubaraGrid, I::UnitRange{I64})","category":"page"},{"location":"library/grid.html#Base.length-Tuple{FermionicImaginaryTimeGrid}","page":"Grids","title":"Base.length","text":"Base.length(fg::FermionicImaginaryTimeGrid)\n\nReturn number of grid points in a FermionicImaginaryTimeGrid struct.\n\nSee also: FermionicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.length-Tuple{FermionicFragmentTimeGrid}","page":"Grids","title":"Base.length","text":"Base.length(fg::FermionicFragmentTimeGrid)\n\nReturn number of grid points in a FermionicFragmentTimeGrid struct.\n\nSee also: FermionicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.length-Tuple{FermionicMatsubaraGrid}","page":"Grids","title":"Base.length","text":"Base.length(fg::FermionicMatsubaraGrid)\n\nReturn number of grid points in a FermionicMatsubaraGrid struct.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.length-Tuple{FermionicFragmentMatsubaraGrid}","page":"Grids","title":"Base.length","text":"Base.length(fg::FermionicFragmentMatsubaraGrid)\n\nReturn number of grid points in a FermionicFragmentMatsubaraGrid struct.\n\nSee also: FermionicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.length-Tuple{BosonicImaginaryTimeGrid}","page":"Grids","title":"Base.length","text":"Base.length(bg::BosonicImaginaryTimeGrid)\n\nReturn number of grid points in a BosonicImaginaryTimeGrid struct.\n\nSee also: BosonicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.length-Tuple{BosonicFragmentTimeGrid}","page":"Grids","title":"Base.length","text":"Base.length(bg::BosonicFragmentTimeGrid)\n\nReturn number of grid points in a BosonicFragmentTimeGrid struct.\n\nSee also: BosonicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.length-Tuple{BosonicMatsubaraGrid}","page":"Grids","title":"Base.length","text":"Base.length(bg::BosonicMatsubaraGrid)\n\nReturn number of grid points in a BosonicMatsubaraGrid struct.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.length-Tuple{BosonicFragmentMatsubaraGrid}","page":"Grids","title":"Base.length","text":"Base.length(bg::BosonicFragmentMatsubaraGrid)\n\nReturn number of grid points in a BosonicFragmentMatsubaraGrid struct.\n\nSee also: BosonicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{FermionicImaginaryTimeGrid}","page":"Grids","title":"Base.iterate","text":"Base.iterate(fg::FermionicImaginaryTimeGrid)\n\nAdvance the iterator of a FermionicImaginaryTimeGrid struct to obtain the next grid point.\n\nSee also: FermionicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{FermionicFragmentTimeGrid}","page":"Grids","title":"Base.iterate","text":"Base.iterate(fg::FermionicFragmentTimeGrid)\n\nAdvance the iterator of a FermionicFragmentTimeGrid struct to obtain the next grid point.\n\nSee also: FermionicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{FermionicMatsubaraGrid}","page":"Grids","title":"Base.iterate","text":"Base.iterate(fg::FermionicMatsubaraGrid)\n\nAdvance the iterator of a FermionicMatsubaraGrid struct to obtain the next grid point.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{FermionicFragmentMatsubaraGrid}","page":"Grids","title":"Base.iterate","text":"Base.iterate(fg::FermionicFragmentMatsubaraGrid)\n\nAdvance the iterator of a FermionicFragmentMatsubaraGrid struct to obtain the next grid point.\n\nSee also: FermionicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{BosonicImaginaryTimeGrid}","page":"Grids","title":"Base.iterate","text":"Base.iterate(bg::BosonicImaginaryTimeGrid)\n\nAdvance the iterator of a BosonicImaginaryTimeGrid struct to obtain the next grid point.\n\nSee also: BosonicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{BosonicFragmentTimeGrid}","page":"Grids","title":"Base.iterate","text":"Base.iterate(bg::BosonicFragmentTimeGrid)\n\nAdvance the iterator of a BosonicFragmentTimeGrid struct to obtain the next grid point.\n\nSee also: BosonicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{BosonicMatsubaraGrid}","page":"Grids","title":"Base.iterate","text":"Base.iterate(bg::BosonicMatsubaraGrid)\n\nAdvance the iterator of a BosonicMatsubaraGrid struct to obtain the next grid point.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{BosonicFragmentMatsubaraGrid}","page":"Grids","title":"Base.iterate","text":"Base.iterate(bg::BosonicFragmentMatsubaraGrid)\n\nAdvance the iterator of a BosonicFragmentMatsubaraGrid struct to obtain the next grid point.\n\nSee also: BosonicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{FermionicImaginaryTimeGrid, Int64}","page":"Grids","title":"Base.iterate","text":"Base.iterate(fg::FermionicImaginaryTimeGrid, i::I64)\n\nThis is the key method that allows a FermionicImaginaryTimeGrid struct to be iterated, yielding a sequences of grid points.\n\nSee also: FermionicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{FermionicFragmentTimeGrid, Int64}","page":"Grids","title":"Base.iterate","text":"Base.iterate(fg::FermionicFragmentTimeGrid, i::I64)\n\nThis is the key method that allows a FermionicFragmentTimeGrid struct to be iterated, yielding a sequences of grid points.\n\nSee also: FermionicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{FermionicMatsubaraGrid, Int64}","page":"Grids","title":"Base.iterate","text":"Base.iterate(fg::FermionicMatsubaraGrid, i::I64)\n\nCreate an iterable object for visiting each index of a FermionicMatsubaraGrid struct.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{FermionicFragmentMatsubaraGrid, Int64}","page":"Grids","title":"Base.iterate","text":"Base.iterate(fg::FermionicFragmentMatsubaraGrid, i::I64)\n\nCreate an iterable object for visiting each index of a FermionicFragmentMatsubaraGrid struct.\n\nSee also: FermionicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{BosonicImaginaryTimeGrid, Int64}","page":"Grids","title":"Base.iterate","text":"Base.iterate(bg::BosonicImaginaryTimeGrid, i::I64)\n\nCreate an iterable object for visiting each index of a BosonicImaginaryTimeGrid struct.\n\nSee also: BosonicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{BosonicFragmentTimeGrid, Int64}","page":"Grids","title":"Base.iterate","text":"Base.iterate(bg::BosonicFragmentTimeGrid, i::I64)\n\nCreate an iterable object for visiting each index of a BosonicFragmentTimeGrid struct.\n\nSee also: BosonicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{BosonicMatsubaraGrid, Int64}","page":"Grids","title":"Base.iterate","text":"Base.iterate(bg::BosonicMatsubaraGrid, i::I64)\n\nCreate an iterable object for visiting each index of a BosonicMatsubaraGrid struct.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{BosonicFragmentMatsubaraGrid, Int64}","page":"Grids","title":"Base.iterate","text":"Base.iterate(bg::BosonicFragmentMatsubaraGrid, i::I64)\n\nCreate an iterable object for visiting each index of a BosonicFragmentMatsubaraGrid struct.\n\nSee also: BosonicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.eachindex-Tuple{FermionicImaginaryTimeGrid}","page":"Grids","title":"Base.eachindex","text":"Base.eachindex(fg::FermionicImaginaryTimeGrid)\n\nCreate an iterable object for visiting each index of a FermionicImaginaryTimeGrid struct.\n\nSee also: FermionicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.eachindex-Tuple{FermionicFragmentTimeGrid}","page":"Grids","title":"Base.eachindex","text":"Base.eachindex(fg::FermionicFragmentTimeGrid)\n\nCreate an iterable object for visiting each index of a FermionicFragmentTimeGrid struct.\n\nSee also: FermionicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.eachindex-Tuple{FermionicMatsubaraGrid}","page":"Grids","title":"Base.eachindex","text":"Base.eachindex(fg::FermionicMatsubaraGrid)\n\nCreate an iterable object for visiting each index of a FermionicMatsubaraGrid struct.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.eachindex-Tuple{FermionicFragmentMatsubaraGrid}","page":"Grids","title":"Base.eachindex","text":"Base.eachindex(fg::FermionicFragmentMatsubaraGrid)\n\nCreate an iterable object for visiting each index of a FermionicFragmentMatsubaraGrid struct.\n\nSee also: FermionicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.eachindex-Tuple{BosonicImaginaryTimeGrid}","page":"Grids","title":"Base.eachindex","text":"Base.eachindex(bg::BosonicImaginaryTimeGrid)\n\nCreate an iterable object for visiting each index of a BosonicImaginaryTimeGrid struct.\n\nSee also: BosonicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.eachindex-Tuple{BosonicFragmentTimeGrid}","page":"Grids","title":"Base.eachindex","text":"Base.eachindex(bg::BosonicFragmentTimeGrid)\n\nCreate an iterable object for visiting each index of a BosonicFragmentTimeGrid struct.\n\nSee also: BosonicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.eachindex-Tuple{BosonicMatsubaraGrid}","page":"Grids","title":"Base.eachindex","text":"Base.eachindex(bg::BosonicMatsubaraGrid)\n\nCreate an iterable object for visiting each index of a BosonicMatsubaraGrid struct.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.eachindex-Tuple{BosonicFragmentMatsubaraGrid}","page":"Grids","title":"Base.eachindex","text":"Base.eachindex(bg::BosonicFragmentMatsubaraGrid)\n\nCreate an iterable object for visiting each index of a BosonicFragmentMatsubaraGrid struct.\n\nSee also: BosonicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.firstindex-Tuple{FermionicImaginaryTimeGrid}","page":"Grids","title":"Base.firstindex","text":"Base.firstindex(fg::FermionicImaginaryTimeGrid)\n\nReturn the first index of a FermionicImaginaryTimeGrid struct.\n\nSee also: FermionicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.firstindex-Tuple{FermionicFragmentTimeGrid}","page":"Grids","title":"Base.firstindex","text":"Base.firstindex(fg::FermionicFragmentTimeGrid)\n\nReturn the first index of a FermionicFragmentTimeGrid struct.\n\nSee also: FermionicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.firstindex-Tuple{FermionicMatsubaraGrid}","page":"Grids","title":"Base.firstindex","text":"Base.firstindex(fg::FermionicMatsubaraGrid)\n\nReturn the first index of a FermionicMatsubaraGrid struct.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.firstindex-Tuple{FermionicFragmentMatsubaraGrid}","page":"Grids","title":"Base.firstindex","text":"Base.firstindex(fg::FermionicFragmentMatsubaraGrid)\n\nReturn the first index of a FermionicFragmentMatsubaraGrid struct.\n\nSee also: FermionicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.firstindex-Tuple{BosonicImaginaryTimeGrid}","page":"Grids","title":"Base.firstindex","text":"Base.firstindex(bg::BosonicImaginaryTimeGrid)\n\nReturn the first index of a BosonicImaginaryTimeGrid struct.\n\nSee also: BosonicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.firstindex-Tuple{BosonicFragmentTimeGrid}","page":"Grids","title":"Base.firstindex","text":"Base.firstindex(bg::BosonicFragmentTimeGrid)\n\nReturn the first index of a BosonicFragmentTimeGrid struct.\n\nSee also: BosonicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.firstindex-Tuple{BosonicMatsubaraGrid}","page":"Grids","title":"Base.firstindex","text":"Base.firstindex(bg::BosonicMatsubaraGrid)\n\nReturn the first index of a BosonicMatsubaraGrid struct.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.firstindex-Tuple{BosonicFragmentMatsubaraGrid}","page":"Grids","title":"Base.firstindex","text":"Base.firstindex(bg::BosonicFragmentMatsubaraGrid)\n\nReturn the first index of a BosonicFragmentMatsubaraGrid struct.\n\nSee also: BosonicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.lastindex-Tuple{FermionicImaginaryTimeGrid}","page":"Grids","title":"Base.lastindex","text":"Base.lastindex(fg::FermionicImaginaryTimeGrid)\n\nReturn the last index of a FermionicImaginaryTimeGrid struct.\n\nSee also: FermionicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.lastindex-Tuple{FermionicFragmentTimeGrid}","page":"Grids","title":"Base.lastindex","text":"Base.lastindex(fg::FermionicFragmentTimeGrid)\n\nReturn the last index of a FermionicFragmentTimeGrid struct.\n\nSee also: FermionicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.lastindex-Tuple{FermionicMatsubaraGrid}","page":"Grids","title":"Base.lastindex","text":"Base.lastindex(fg::FermionicMatsubaraGrid)\n\nReturn the last index of a FermionicMatsubaraGrid struct.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.lastindex-Tuple{FermionicFragmentMatsubaraGrid}","page":"Grids","title":"Base.lastindex","text":"Base.lastindex(fg::FermionicFragmentMatsubaraGrid)\n\nReturn the last index of a FermionicFragmentMatsubaraGrid struct.\n\nSee also: FermionicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.lastindex-Tuple{BosonicImaginaryTimeGrid}","page":"Grids","title":"Base.lastindex","text":"Base.lastindex(bg::BosonicImaginaryTimeGrid)\n\nReturn the last index of a BosonicImaginaryTimeGrid struct.\n\nSee also: BosonicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.lastindex-Tuple{BosonicFragmentTimeGrid}","page":"Grids","title":"Base.lastindex","text":"Base.lastindex(bg::BosonicFragmentTimeGrid)\n\nReturn the last index of a BosonicFragmentTimeGrid struct.\n\nSee also: BosonicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.lastindex-Tuple{BosonicMatsubaraGrid}","page":"Grids","title":"Base.lastindex","text":"Base.lastindex(bg::BosonicMatsubaraGrid)\n\nReturn the last index of a BosonicMatsubaraGrid struct.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.lastindex-Tuple{BosonicFragmentMatsubaraGrid}","page":"Grids","title":"Base.lastindex","text":"Base.lastindex(bg::BosonicFragmentMatsubaraGrid)\n\nReturn the last index of a BosonicFragmentMatsubaraGrid struct.\n\nSee also: BosonicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{FermionicImaginaryTimeGrid, Int64}","page":"Grids","title":"Base.getindex","text":"Base.getindex(fg::FermionicImaginaryTimeGrid, ind::I64)\n\nRetrieve the value(s) stored at the given key or index within a FermionicImaginaryTimeGrid struct.\n\nSee also: FermionicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{FermionicFragmentTimeGrid, Int64}","page":"Grids","title":"Base.getindex","text":"Base.getindex(fg::FermionicFragmentTimeGrid, ind::I64)\n\nRetrieve the value(s) stored at the given key or index within a FermionicFragmentTimeGrid struct.\n\nSee also: FermionicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{FermionicMatsubaraGrid, Int64}","page":"Grids","title":"Base.getindex","text":"Base.getindex(fg::FermionicMatsubaraGrid, ind::I64)\n\nRetrieve the value(s) stored at the given key or index within a FermionicMatsubaraGrid struct.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{FermionicFragmentMatsubaraGrid, Int64}","page":"Grids","title":"Base.getindex","text":"Base.getindex(fg::FermionicFragmentMatsubaraGrid, ind::I64)\n\nRetrieve the value(s) stored at the given key or index within a FermionicFragmentMatsubaraGrid struct.\n\nSee also: FermionicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{BosonicImaginaryTimeGrid, Int64}","page":"Grids","title":"Base.getindex","text":"Base.getindex(bg::BosonicImaginaryTimeGrid, ind::I64)\n\nRetrieve the value(s) stored at the given key or index within a BosonicImaginaryTimeGrid struct.\n\nSee also: BosonicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{BosonicFragmentTimeGrid, Int64}","page":"Grids","title":"Base.getindex","text":"Base.getindex(bg::BosonicFragmentTimeGrid, ind::I64)\n\nRetrieve the value(s) stored at the given key or index within a BosonicFragmentTimeGrid struct.\n\nSee also: BosonicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{BosonicMatsubaraGrid, Int64}","page":"Grids","title":"Base.getindex","text":"Base.getindex(bg::BosonicMatsubaraGrid, ind::I64)\n\nRetrieve the value(s) stored at the given key or index within a BosonicMatsubaraGrid struct.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{BosonicFragmentMatsubaraGrid, Int64}","page":"Grids","title":"Base.getindex","text":"Base.getindex(bg::BosonicFragmentMatsubaraGrid, ind::I64)\n\nRetrieve the value(s) stored at the given key or index within a BosonicFragmentMatsubaraGrid struct.\n\nSee also: BosonicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{FermionicImaginaryTimeGrid, UnitRange{Int64}}","page":"Grids","title":"Base.getindex","text":"Base.getindex(fg::FermionicImaginaryTimeGrid, I::UnitRange{I64})\n\nReturn a subset of a FermionicImaginaryTimeGrid struct as specified by I.\n\nSee also: FermionicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{FermionicFragmentTimeGrid, UnitRange{Int64}}","page":"Grids","title":"Base.getindex","text":"Base.getindex(fg::FermionicFragmentTimeGrid, I::UnitRange{I64})\n\nReturn a subset of a FermionicFragmentTimeGrid struct as specified by I.\n\nSee also: FermionicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{FermionicMatsubaraGrid, UnitRange{Int64}}","page":"Grids","title":"Base.getindex","text":"Base.getindex(fg::FermionicMatsubaraGrid, I::UnitRange{I64})\n\nReturn a subset of a FermionicMatsubaraGrid struct as specified by I.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{FermionicFragmentMatsubaraGrid, UnitRange{Int64}}","page":"Grids","title":"Base.getindex","text":"Base.getindex(fg::FermionicFragmentMatsubaraGrid, I::UnitRange{I64})\n\nReturn a subset of a FermionicFragmentMatsubaraGrid struct as specified by I.\n\nSee also: FermionicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{BosonicImaginaryTimeGrid, UnitRange{Int64}}","page":"Grids","title":"Base.getindex","text":"Base.getindex(bg::BosonicImaginaryTimeGrid, I::UnitRange{I64})\n\nReturn a subset of a BosonicImaginaryTimeGrid struct as specified by I.\n\nSee also: BosonicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{BosonicFragmentTimeGrid, UnitRange{Int64}}","page":"Grids","title":"Base.getindex","text":"Base.getindex(bg::BosonicFragmentTimeGrid, I::UnitRange{I64})\n\nReturn a subset of a BosonicFragmentTimeGrid struct as specified by I.\n\nSee also: BosonicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{BosonicMatsubaraGrid, UnitRange{Int64}}","page":"Grids","title":"Base.getindex","text":"Base.getindex(bg::BosonicMatsubaraGrid, I::UnitRange{I64})\n\nReturn a subset of a BosonicMatsubaraGrid struct as specified by I.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{BosonicFragmentMatsubaraGrid, UnitRange{Int64}}","page":"Grids","title":"Base.getindex","text":"Base.getindex(bg::BosonicFragmentMatsubaraGrid, I::UnitRange{I64})\n\nReturn a subset of a BosonicFragmentMatsubaraGrid struct as specified by I.\n\nSee also: BosonicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Utilities","page":"Grids","title":"Utilities","text":"","category":"section"},{"location":"library/grid.html","page":"Grids","title":"Grids","text":"rebuild!\nresize!\nreverse!","category":"page"},{"location":"library/grid.html#ACFlow.rebuild!","page":"Grids","title":"ACFlow.rebuild!","text":"rebuild!(fg::FermionicImaginaryTimeGrid, ntime::I64, β::T) where {T}\n\nRebuild the FermionicImaginaryTimeGrid struct via new ntime and β parameters.\n\nSee also: FermionicImaginaryTimeGrid.\n\n\n\n\n\nrebuild!(fg::FermionicFragmentTimeGrid, ntime::I64, β::T) where {T}\n\nRebuild the FermionicFragmentTimeGrid struct via new ntime and β parameters. Now its imaginary time points are continuous and complete.\n\nSee also: FermionicFragmentTimeGrid.\n\n\n\n\n\nrebuild!(fg::FermionicMatsubaraGrid, nfreq::I64, β::T) where {T}\n\nRebuild the FermionicMatsubaraGrid struct via new nfreq and β parameters.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\nrebuild!(fg::FermionicFragmentMatsubaraGrid, nfreq::I64, β::T) where {T}\n\nRebuild the FermionicFragmentMatsubaraGrid struct via new nfreq and β parameters. Now its Matsubara frequency points are continuous and complete.\n\nSee also: FermionicFragmentMatsubaraGrid.\n\n\n\n\n\nrebuild!(bg::BosonicImaginaryTimeGrid, ntime::I64, β::T) where {T}\n\nRebuild the BosonicImaginaryTimeGrid struct via new ntime and β parameters.\n\nSee also: BosonicImaginaryTimeGrid.\n\n\n\n\n\nrebuild!(bg::BosonicFragmentTimeGrid, ntime::I64, β::T) where {T}\n\nRebuild the BosonicFragmentTimeGrid struct via new ntime and β parameters. Now its imaginary time points are continuous and complete.\n\nSee also: BosonicFragmentTimeGrid.\n\n\n\n\n\nrebuild!(bg::BosonicMatsubaraGrid, nfreq::I64, β::T) where {T}\n\nRebuild the BosonicMatsubaraGrid struct via new nfreq and β parameters.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\nrebuild!(bg::BosonicFragmentMatsubaraGrid, nfreq::I64, β::T) where {T}\n\nRebuild the BosonicFragmentMatsubaraGrid struct via new nfreq and β parameters. Now its Matsubara frequency points are continuous and complete.\n\nSee also: BosonicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"function"},{"location":"library/grid.html#Base.resize!","page":"Grids","title":"Base.resize!","text":"Base.resize!(fg::FermionicMatsubaraGrid, nfreq::I64)\n\nReduce the size of the fermionic Matsubara grid. Note that nfreq should be smaller than or equal to fg.nfreq. This function is called by the NevanAC solver only.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\nBase.resize!(fg::FermionicFragmentMatsubaraGrid, nfreq::I64)\n\nReduce the size of the fermionic fragment Matsubara grid. Note that nfreq should be smaller than or equal to fg.nfreq. This function is called by the NevanAC solver only.\n\nSee also: FermionicFragmentMatsubaraGrid.\n\n\n\n\n\nBase.resize!(bg::BosonicMatsubaraGrid, nfreq::I64)\n\nReduce the size of the bosonic Matsubara grid. Note that nfreq should be smaller than or equal to bg.nfreq. This function is called by the NevanAC solver only.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\nBase.resize!(bg::BosonicFragmentMatsubaraGrid, nfreq::I64)\n\nReduce the size of the bosonic fragment Matsubara grid. Note that nfreq should be smaller than or equal to bg.nfreq. This function is called by the NevanAC solver only.\n\nSee also: BosonicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"function"},{"location":"library/grid.html#Base.reverse!","page":"Grids","title":"Base.reverse!","text":"Base.reverse!(fg::FermionicMatsubaraGrid)\n\nReverse the fermionic Matsubara grid. This function is called by the NevanAC solver only.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\nBase.reverse!(fg::FermionicFragmentMatsubaraGrid)\n\nReverse the fermionic fragment Matsubara grid. This function is called by the NevanAC solver only.\n\nSee also: FermionicFragmentMatsubaraGrid.\n\n\n\n\n\nBase.reverse!(bg::BosonicMatsubaraGrid)\n\nReverse the bosonic Matsubara grid. This function is called by the NevanAC solver only.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\nBase.reverse!(bg::BosonicFragmentMatsubaraGrid)\n\nReverse the bosonic fragment Matsubara grid. This function is called by the NevanAC solver only.\n\nSee also: BosonicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"function"},{"location":"theory/maxent.html#mem","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"","category":"section"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"Perhaps the maximum entropy method is the most frequently used approach for analytic continuation problems because of its high computational efficiency. Next, we will discuss the basic principles and several variants of it.","category":"page"},{"location":"theory/maxent.html#Bayesian-Inference","page":"Maximum Entropy Method","title":"Bayesian Inference","text":"","category":"section"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"Bayes's theorem is the cornerstone of the maximum entropy method. Given two events a and b, Bayes's theorem says:","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"beginequation\nPabPb = PbaPa\nendequation","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"where Pa is the probability of event a, Pab is the conditional probability of event a with given event b. In the scenario of analytic continuation problem, barG(tau) and A(omega) are treated as two events, where barG(tau) denotes the measured value of G(tau). So the best solution for A(omega) is of course the one that maximizes PAbarG, which is called the posterior probability. According to the Bayes's theorem, we get","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"beginequation\nPAbarG = fracPbarGAPAPbarG\nendequation","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"where PbarGA is the likelihood function, PA is the prior probability, and PbarG is the evidence. Since the evidence is a normalization constant depending on the prior probability and the likelihood function only, it is ignored in the following discussions. Thus,","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"beginequation\nPAbarG propto PbarGAPA\nendequation","category":"page"},{"location":"theory/maxent.html#Posterior-Probability","page":"Maximum Entropy Method","title":"Posterior Probability","text":"","category":"section"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"In the maximum entropy method, the likelihood function PbarGA is assumed to be in direct proportion to e^-chi^22. chi^2 is named as goodness-of-fit function, which measures distance between barG(tau) and reconstructed imaginary time Green's function tildeG(tau):","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"beginequation\nchi^2 = sum^L_i = 1 leftfracbarG_i(tau) - tildeG_i(tau)sigma_iright^2\nendequation","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"beginequation\ntildeG_i = sum_j K_ij A_j\nendequation","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"Here, L is number of imaginary time points, sigma denotes the error bar (standard deviation) of barG(tau). K_ij and A_j are discrete kernel and spectral functions, respectively. On the other hand, the prior probability PA is supposed to be in direct proportion to e^alpha S, where alpha is a regulation parameter and S means entropy. Sometimes S is also known as the Kullback-Leibler distance (or the Shannon-Jaynes entropy). Its formula is as follows:","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"beginequation\nS= int domega left(A(omega) - m(omega) - A(omega)logleftfracA(omega)m(omega)rightright)\nendequation","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"where m(omega) is the default model function. The ACFlow toolkit also supports another kind of entropy, i.e., the Bayesian Reconstruction entropy. It reads:","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"beginequation\nS = int domega left(1 - fracA(omega)m(omega) + log leftfracA(omega)m(omega)rightright)\nendequation","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"According to the Bayes's theorem, the posterior probability PAbarG propto e^Q and","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"beginequation\nQ = alpha S - fracchi^22\nendequation","category":"page"},{"location":"theory/maxent.html#Various-Algorithms","page":"Maximum Entropy Method","title":"Various Algorithms","text":"","category":"section"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"Now the original analytic continuation problem becomes how to figure out the optimal A(omega) that maximizes Q. In other words, we have to solve the following equation:","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"beginequation\nfracpartial Qpartial A bigg_A = hatA = 0\nendequation","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"where hatA(omega) is the optimal A(omega). Eq.(9) can be easily solved by using standard Newton method. However, the obtained hatA(omega) is alpha-dependent. That is to say, for a given alpha, there is always a hatA(omega) that satisfies Eq.(9). So, new problem arises because we have to find out a way to generate the final spectral function from these alpha-resolved hatA(omega). Now there exist four algorithms, namely historic, classic, bryan, and chi2kink. Next we will introduce them one by one.","category":"page"},{"location":"theory/maxent.html#Historic-Algorithm","page":"Maximum Entropy Method","title":"Historic Algorithm","text":"","category":"section"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"The historic algorithm is quite simple. The alpha parameter will be adjusted iteratively to meet the following criterion:","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"beginequation\nchi^2 = N\nendequation","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"where N is the number of mesh points for spectral density A(omega).","category":"page"},{"location":"theory/maxent.html#Classic-Algorithm","page":"Maximum Entropy Method","title":"Classic Algorithm","text":"","category":"section"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"The basic equation for the classic algorithm reads","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"beginequation\n-2 alpha S(A_alpha) = textTr\nleft\nfracLambda(A_alpha)alpha I + Lambda(A_alpha)\nright\nendequation","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"where I is an identity matrix. The elements of Lambda matrix are calculated as follows:","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"beginequation\nLambda_ij = sqrtA_i left(sum_kl K_ki C^-1_kl K_ljright) sqrtA_j\nendequation","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"where C is the covariance matrix. Eq.(10) will be iteratively solved until the optimal alpha and hatA(omega) are figured out.","category":"page"},{"location":"theory/maxent.html#Bryan-Algorithm","page":"Maximum Entropy Method","title":"Bryan Algorithm","text":"","category":"section"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"In both historic and classic algorithms, the spectral function hatA(omega) is always related to an optimal alpha parameter. However, the spirit of the bryan algorithm is completely different. It tries to yield a series of alpha parameters and calculate the corresponding A_alpha(omega). Then the final spectral function A(omega) is obtained by evaluating the following integration:","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"beginequation\noverlineA(omega) = int dalphaA_alpha(omega) Palpha  barG\nendequation","category":"page"},{"location":"theory/maxent.html#Chi2kink-Algorithm","page":"Maximum Entropy Method","title":"Chi2kink Algorithm","text":"","category":"section"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"This algorithm was proposed by Bergeron and Tremblay recently. The first step is to generate a series of alpha parameters and evaluate the corresponding spectral functions A_alpha(omega) and goodness-of-fit functions chi^2A_alpha. Then we plot log_10(chi^2) as a function of log_10(alpha). Usually this plot is split into three different regions: (1) Default model region. In the limit of alpha to infty, chi^2 goes to a constant high value. It means that the likelihood function e^-chi^22 has negligible weight, such that the prior probability e^alpha S becomes dominant and minimizes QA. At that time, the calculated A(omega) resembles the default model function m(omega). (2) Noise-fitting region. In the limit of alpha to 0, chi^2 is relatively flat and approaches its global minimum. In this region, the minimization algorithm tends to fit the noise in G(tau). (3) Information-fitting region. alpha S is comparable with chi^22, so that chi^2 is strongly dependent on alpha. Bergeron et al. suggested that the optimal alpha parameter situates in the crossover between noise-fitting region and information-fitting region. So the second derivative of chi^2 with respect to alpha is calculated, and the maximum value in the resulting curve indicates the optimal value of alpha. Quite recently, Kaufmann and Held proposed a more numerically stable and flexible approach to compute the optimal alpha. They use the following function to fit log_10chi^2(alpha)-log_10(alpha):","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"beginequation\nphi(xabcd) = a + fracb1 + e^-d(x-c)\nendequation","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"where a, b, c, and d are fitting parameters. Then the optimal alpha is approximated by 10^c-fd, where f is an empirical constant (The favorite value of f lies in 225).","category":"page"},{"location":"theory/maxent.html#Relevant-parameters","page":"Maximum Entropy Method","title":"Relevant parameters","text":"","category":"section"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"See [MaxEnt] Block","category":"page"},{"location":"library/util.html#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"library/util.html","page":"Utilities","title":"Utilities","text":"Provide some utility macros and functions for the ACFlow toolkit.","category":"page"},{"location":"library/util.html#Contents","page":"Utilities","title":"Contents","text":"","category":"section"},{"location":"library/util.html","page":"Utilities","title":"Utilities","text":"Pages = [\"util.md\"]\nDepth = 2","category":"page"},{"location":"library/util.html#Index","page":"Utilities","title":"Index","text":"","category":"section"},{"location":"library/util.html","page":"Utilities","title":"Utilities","text":"Pages = [\"util.md\"]","category":"page"},{"location":"library/util.html#Color-Constants","page":"Utilities","title":"Color Constants","text":"","category":"section"},{"location":"library/util.html","page":"Utilities","title":"Utilities","text":"COLORS\nMODES","category":"page"},{"location":"library/util.html#ACFlow.COLORS","page":"Utilities","title":"ACFlow.COLORS","text":"COLORS\n\nA global dict, which is used to specify the system colors.\n\n\n\n\n\n","category":"constant"},{"location":"library/util.html#ACFlow.MODES","page":"Utilities","title":"ACFlow.MODES","text":"MODES\n\nA global dict, which is used to specify the mode for output characters.\n\n\n\n\n\n","category":"constant"},{"location":"library/util.html#Macros","page":"Utilities","title":"Macros","text":"","category":"section"},{"location":"library/util.html","page":"Utilities","title":"Utilities","text":"@cswitch\n@time_call\n@pcs","category":"page"},{"location":"library/util.html#ACFlow.@cswitch","page":"Utilities","title":"ACFlow.@cswitch","text":"@cswitch(constexpr, body)\n\nProvides a C-like switch statement with the falling through behavior. This implementation was borrowed from the following github repository:\n\nhttps://github.com/Gnimuc/CSyntax.jl\n\nExamples\n\nengine = get_d(\"engine\")\n@cswitch engine begin\n    @case \"vasp\"\n        just_do_it()\n        break\n\n    @default\n        sorry()\n        break\nend\n\n\n\n\n\n","category":"macro"},{"location":"library/util.html#ACFlow.@time_call","page":"Utilities","title":"ACFlow.@time_call","text":"@time_call(ex)\n\nEvaluate a function call (ex), and then print the elapsed time (number of seconds) it took to execute.\n\nThis macro is a variation of the standard @elapsed macro.\n\n\n\n\n\n","category":"macro"},{"location":"library/util.html#ACFlow.@pcs","page":"Utilities","title":"ACFlow.@pcs","text":"@pcs(x...)\n\nTry to print colorful strings. Here x is a combination of strings and colors. Its format likes string1 color1 string2 color2 (repeat). For the supported colors, please check the global dict COLORS.\n\nExamples\n\njulia> @pcs \"Hello world!\" blue\njulia> @pcs \"Hello \" red \"world!\" green\n\nSee also: COLORS, welcome.\n\n\n\n\n\n","category":"macro"},{"location":"library/util.html#Query-Runtime-Environment","page":"Utilities","title":"Query Runtime Environment","text":"","category":"section"},{"location":"library/util.html","page":"Utilities","title":"Utilities","text":"require\nsetup_args\nquery_args","category":"page"},{"location":"library/util.html#ACFlow.require","page":"Utilities","title":"ACFlow.require","text":"require()\n\nCheck the version of julia runtime environment. It should be higher than v1.6.x. One of the most important philosophies of the ACFlow toolkit is minimizing the dependence on the third-party libraries as far as possible. Note that the ACFlow toolkit relys on the TOML package to parse the *.toml file. Only in v1.6.0 and higher versions, julia includes the TOML package in its standard library.\n\n\n\n\n\n","category":"function"},{"location":"library/util.html#ACFlow.setup_args","page":"Utilities","title":"ACFlow.setup_args","text":"setup_args(x::Vararg{String})\n\nSetup ARGS manually. This function is used only in REPL environment. We can use this function to update ARGS, so that the query_args() and the other related functions can work correctly.\n\nExamples\n\njulia> setup_args(\"ac.toml\")\n1-element Array{String,1}:\n \"ac.toml\"\n\nSee also: query_args.\n\n\n\n\n\n","category":"function"},{"location":"library/util.html#ACFlow.query_args","page":"Utilities","title":"ACFlow.query_args","text":"query_args()\n\nCheck whether the configuration file (case.toml) is provided.\n\nSee also: setup_args.\n\n\n\n\n\n","category":"function"},{"location":"library/util.html#Colorful-Outputs","page":"Utilities","title":"Colorful Outputs","text":"","category":"section"},{"location":"library/util.html","page":"Utilities","title":"Utilities","text":"welcome\noverview\ngoodbye\nsorry\nprompt","category":"page"},{"location":"library/util.html#ACFlow.welcome","page":"Utilities","title":"ACFlow.welcome","text":"welcome()\n\nPrint out the welcome messages to the screen.\n\n\n\n\n\n","category":"function"},{"location":"library/util.html#ACFlow.overview","page":"Utilities","title":"ACFlow.overview","text":"overview()\n\nPrint out the overview of ACFlow to the screen.\n\n\n\n\n\n","category":"function"},{"location":"library/util.html#ACFlow.goodbye","page":"Utilities","title":"ACFlow.goodbye","text":"goodbye()\n\nPrint the goodbye messages to the screen.\n\n\n\n\n\n","category":"function"},{"location":"library/util.html#ACFlow.sorry","page":"Utilities","title":"ACFlow.sorry","text":"sorry()\n\nPrint an error message to the screen.\n\n\n\n\n\n","category":"function"},{"location":"library/util.html#ACFlow.prompt","page":"Utilities","title":"ACFlow.prompt","text":"prompt(msg::String)\n\nPrint a stylized ACFlow message to the screen.\n\n\n\n\n\n","category":"function"},{"location":"library/util.html#Input/output-Operations","page":"Utilities","title":"Input/output Operations","text":"","category":"section"},{"location":"library/util.html","page":"Utilities","title":"Utilities","text":"line_to_array","category":"page"},{"location":"library/util.html#ACFlow.line_to_array","page":"Utilities","title":"ACFlow.line_to_array","text":"line_to_array(io::IOStream)\n\nConvert a line (reading from an IOStream) to a string array.\n\n\n\n\n\nline_to_array(str::AbstractString)\n\nConvert a string (AbstractString) to a string array.\n\n\n\n\n\n","category":"function"},{"location":"library/util.html#Color-Tools","page":"Utilities","title":"Color Tools","text":"","category":"section"},{"location":"library/util.html","page":"Utilities","title":"Utilities","text":"colorize","category":"page"},{"location":"library/util.html#ACFlow.colorize","page":"Utilities","title":"ACFlow.colorize","text":"colorize(c::String, s::String; bg::String = \"default\", m::String=\"default\")\n\nReturn some escape sequences, which will be displayed as colorized texts in the terminal.\n\n\n\n\n\ncolorize(c::String, s::String; bg::String = \"default\", m::String=\"default\")\n\nReturn some escape sequences, which will be displayed as colorized texts in the terminal.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#Math","page":"Math","title":"Math","text":"","category":"section"},{"location":"library/math.html","page":"Math","title":"Math","text":"Define some essential mathematical functions.","category":"page"},{"location":"library/math.html#Contents","page":"Math","title":"Contents","text":"","category":"section"},{"location":"library/math.html","page":"Math","title":"Math","text":"Pages = [\"math.md\"]\nDepth = 3","category":"page"},{"location":"library/math.html#Index","page":"Math","title":"Index","text":"","category":"section"},{"location":"library/math.html","page":"Math","title":"Math","text":"Pages = [\"math.md\"]","category":"page"},{"location":"library/math.html#Root-Finding","page":"Math","title":"Root Finding","text":"","category":"section"},{"location":"library/math.html","page":"Math","title":"Math","text":"secant\nnewton","category":"page"},{"location":"library/math.html#ACFlow.secant","page":"Math","title":"ACFlow.secant","text":"secant(func, x0, args...)\n\nIt implements the well-known secant algorithm to locate root of a given polynomial function. Here, func means the function, x0 is the initial guess, and args... denotes the required arguments for function call to func. In addition, the maximum iterations and tolerance are controled by maxiter and tol, respectively. Be careful, func must be a single variable function.\n\nSee also: newton.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#ACFlow.newton","page":"Math","title":"ACFlow.newton","text":"newton(fun::Function, guess, kwargs...;\n       maxiter::I64 = 20000, mixing::F64 = 0.5)\n\nIt implements the well-known newton algorithm to locate root of a given polynomial function. Here, fun means the function, guess is the initial solution, and kwargs... denotes the required arguments for fun. Please be careful, func is a multiple variable function. It not only returns the value, but also the jacobian matrix of the function.\n\nSee also: secant.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#Numerical-Integrations","page":"Math","title":"Numerical Integrations","text":"","category":"section"},{"location":"library/math.html","page":"Math","title":"Math","text":"trapz\nsimpson","category":"page"},{"location":"library/math.html#ACFlow.trapz","page":"Math","title":"ACFlow.trapz","text":"trapz(x::AbstractMesh,\n      y::AbstractVector{T}) where {T<:N64}\n\nPerform numerical integration by using the composite trapezoidal rule.\n\nSee also: simpson.\n\n\n\n\n\ntrapz(x::AbstractVector{S},\n      y::AbstractVector{T},\n      linear::Bool = false) where {S<:Number, T<:Number}\n\nPerform numerical integration by using the composite trapezoidal rule. Note that it supports arbitrary precision via BigFloat.\n\nSee also: simpson.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#ACFlow.simpson","page":"Math","title":"ACFlow.simpson","text":"simpson(x::AbstractVector{S},\n        y::AbstractVector{T}) where {S<:Number, T<:Number}\n\nPerform numerical integration by using the simpson rule. Note that the length of x and y must be odd numbers. And x must be a linear and uniform mesh.\n\nSee also: trapz.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#Numerical-Derivatives","page":"Math","title":"Numerical Derivatives","text":"","category":"section"},{"location":"library/math.html","page":"Math","title":"Math","text":"second_derivative\ngradient_via_fd","category":"page"},{"location":"library/math.html#ACFlow.second_derivative","page":"Math","title":"ACFlow.second_derivative","text":"second_derivative(x::AbstractVector, y::AbstractVector)\n\nCompute second derivative y''(x). If the length of x and y is N, the length of the returned vector is N-2.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#ACFlow.gradient_via_fd","page":"Math","title":"ACFlow.gradient_via_fd","text":"gradient_via_fd(f, x)\n\nCompute ∂f/∂x via finite difference method. It is less accurate and much slower than the automatic differentiation approach. Actually, we won't use this function to calculate gradient. The Zygote.gradient() function is always a better choice.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#Interpolations","page":"Math","title":"Interpolations","text":"","category":"section"},{"location":"library/math.html#Structs","page":"Math","title":"Structs","text":"","category":"section"},{"location":"library/math.html","page":"Math","title":"Math","text":"AbstractInterpolation\nLinearInterpolation\nQuadraticInterpolation\nCubicSplineInterpolation","category":"page"},{"location":"library/math.html#ACFlow.AbstractInterpolation","page":"Math","title":"ACFlow.AbstractInterpolation","text":"AbstractInterpolation\n\nIt represents an abstract interpolation engine, which is used to build the internal type system.\n\n\n\n\n\n","category":"type"},{"location":"library/math.html#ACFlow.LinearInterpolation","page":"Math","title":"ACFlow.LinearInterpolation","text":"LinearInterpolation\n\nIt represents the linear interpolation algorithm.\n\n\n\n\n\n","category":"type"},{"location":"library/math.html#ACFlow.QuadraticInterpolation","page":"Math","title":"ACFlow.QuadraticInterpolation","text":"QuadraticInterpolation\n\nIt represents the quadratic interpolation algorithm.\n\n\n\n\n\n","category":"type"},{"location":"library/math.html#ACFlow.CubicSplineInterpolation","page":"Math","title":"ACFlow.CubicSplineInterpolation","text":"CubicSplineInterpolation\n\nIt represents the cubic spline interpolation algorithm.\n\n\n\n\n\n","category":"type"},{"location":"library/math.html#Constructors","page":"Math","title":"Constructors","text":"","category":"section"},{"location":"library/math.html","page":"Math","title":"Math","text":"LinearInterpolation(u::AbstractVector, t::AbstractVector)\nQuadraticInterpolation(u::AbstractVector, t::AbstractVector)\nCubicSplineInterpolation(u::AbstractVector, t::AbstractVector)","category":"page"},{"location":"library/math.html#ACFlow.LinearInterpolation-Tuple{AbstractVector, AbstractVector}","page":"Math","title":"ACFlow.LinearInterpolation","text":"LinearInterpolation(u::AbstractVector, t::AbstractVector)\n\nCreate a LinearInterpolation struct. Note that u and t denote f(x) and x, respectively.\n\n\n\n\n\n","category":"method"},{"location":"library/math.html#ACFlow.QuadraticInterpolation-Tuple{AbstractVector, AbstractVector}","page":"Math","title":"ACFlow.QuadraticInterpolation","text":"QuadraticInterpolation(u::AbstractVector, t::AbstractVector)\n\nCreate a QuadraticInterpolation struct. Note that u and t denote f(x) and x, respectively.\n\n\n\n\n\n","category":"method"},{"location":"library/math.html#ACFlow.CubicSplineInterpolation-Tuple{AbstractVector, AbstractVector}","page":"Math","title":"ACFlow.CubicSplineInterpolation","text":"CubicSplineInterpolation(u::AbstractVector, t::AbstractVector)\n\nCreate a CubicSplineInterpolation struct. Note that u and t denote f(x) and x, respectively.\n\n\n\n\n\n","category":"method"},{"location":"library/math.html#Functions","page":"Math","title":"Functions","text":"","category":"section"},{"location":"library/math.html","page":"Math","title":"Math","text":"munge_data\n_interp","category":"page"},{"location":"library/math.html#ACFlow.munge_data","page":"Math","title":"ACFlow.munge_data","text":"munge_data(u::AbstractVector{<:Real}, t::AbstractVector{<:Real})\n\nPreprocess the input data. Note that u and t denote f(x) and x, respectively.\n\n\n\n\n\nmunge_data(u::AbstractVector, t::AbstractVector)\n\nPreprocess the input data. Note that u and t denote f(x) and x, respectively.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#ACFlow._interp","page":"Math","title":"ACFlow._interp","text":"_interp(A::LinearInterpolation{<:AbstractVector}, t::Number)\n\nTo implement the linear interpolation algorithm.\n\nSee also: LinearInterpolation.\n\n\n\n\n\n_interp(A::QuadraticInterpolation{<:AbstractVector}, t::Number)\n\nTo implement the quadratic interpolation algorithm.\n\nSee also: QuadraticInterpolation.\n\n\n\n\n\n_interp(A::CubicSplineInterpolation{<:AbstractVector{<:Number}}, t::Number)\n\nTo implement the cubic spline interpolation algorithm.\n\nSee also: CubicSplineInterpolation.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#Einstein-Summation-Convention","page":"Math","title":"Einstein Summation Convention","text":"","category":"section"},{"location":"library/math.html","page":"Math","title":"Math","text":"@einsum","category":"page"},{"location":"library/math.html#ACFlow.@einsum","page":"Math","title":"ACFlow.@einsum","text":"@einsum(ex)\n\nPerform Einstein summation like operations on Julia Arrays.\n\nExamples\n\nBasic matrix multiplication can be implemented as:\n\n@einsum A[i, j] := B[i, k] * C[k, j]\n\nIf the destination array is preallocated, then use =:\n\nA = ones(5, 6, 7) # Preallocated space\nX = randn(5, 2)\nY = randn(6, 2)\nZ = randn(7, 2)\n\n# Store the result in A, overwriting as necessary:\n@einsum A[i, j, k] = X[i, r] * Y[j, r] * Z[k, r]\n\nIf destination is not preallocated, then use := to automatically create a new array for the result:\n\nX = randn(5, 2)\nY = randn(6, 2)\nZ = randn(7, 2)\n\n# Create new array B with appropriate dimensions:\n@einsum B[i, j, k] := X[i, r] * Y[j, r] * Z[k, r]\n\n\n\n\n\n","category":"macro"},{"location":"library/math.html#Curve-Fitting","page":"Math","title":"Curve Fitting","text":"","category":"section"},{"location":"library/math.html#Structs-2","page":"Math","title":"Structs","text":"","category":"section"},{"location":"library/math.html","page":"Math","title":"Math","text":"OnceDifferentiable\nLMOptimizationResults\nLsqFitResult","category":"page"},{"location":"library/math.html#ACFlow.OnceDifferentiable","page":"Math","title":"ACFlow.OnceDifferentiable","text":"OnceDifferentiable\n\nMutable struct. It is used for objectives and solvers where the gradient is available/exists.\n\nMembers\n\nℱ! -> Objective. It is actually a function call and return objective.\n𝒥! -> It is a function call as well and returns jacobian of objective.\n𝐹  -> Cache for ℱ! output.\n𝐽  -> Cache for 𝒥! output.\n\n\n\n\n\n","category":"type"},{"location":"library/math.html#ACFlow.LMOptimizationResults","page":"Math","title":"ACFlow.LMOptimizationResults","text":"LMOptimizationResults{T,N}\n\nIt is used to save the optimization results of the levenberg_marquardt algorithm.\n\nMembers\n\nx₀         -> Initial guess for the solution.\nminimizer  -> Final results for the solution.\nminimum    -> Residual.\niterations -> Number of iterations.\nxconv      -> If the convergence criterion 1 is satisfied.\ngconv      -> If the convergence criterion 2 is satisfied.\n\n\n\n\n\n","category":"type"},{"location":"library/math.html#ACFlow.LsqFitResult","page":"Math","title":"ACFlow.LsqFitResult","text":"LsqFitResult\n\nIt encapsulates the results for curve fitting.\n\nMembers\n\nparam     -> Fitted results, i.e, the fitting parameters.\nresid     -> Residuals.\njacobian  -> Jacobian matrix.\nconverged -> If the curve-fitting algorithm is converged.\n\n\n\n\n\n","category":"type"},{"location":"library/math.html#Constructors-2","page":"Math","title":"Constructors","text":"","category":"section"},{"location":"library/math.html","page":"Math","title":"Math","text":"OnceDifferentiable(𝑓, p0::AbstractArray, 𝐹::AbstractArray)","category":"page"},{"location":"library/math.html#ACFlow.OnceDifferentiable-Tuple{Any, AbstractArray, AbstractArray}","page":"Math","title":"ACFlow.OnceDifferentiable","text":"OnceDifferentiable(𝑓, p0::AbstractArray, 𝐹::AbstractArray)\n\nConstructor for OnceDifferentiable struct. 𝑓 is the function, p0 is the inital guess, 𝐹 = 𝑓(p0) is the cache for 𝑓's output.\n\n\n\n\n\n","category":"method"},{"location":"library/math.html#Functions-2","page":"Math","title":"Functions","text":"","category":"section"},{"location":"library/math.html","page":"Math","title":"Math","text":"value\nvalue!\njacobian\njacobian!\nlevenberg_marquardt\ncurve_fit","category":"page"},{"location":"library/math.html#ACFlow.value","page":"Math","title":"ACFlow.value","text":"value(obj::OnceDifferentiable)\n\nReturn obj.𝐹. obj will not be affected.\n\n\n\n\n\nvalue(obj::OnceDifferentiable, 𝐹, x)\n\nReturn 𝑓(x). obj will not be affected, but 𝐹 is updated.\n\n\n\n\n\nvalue(obj::BFGSDifferentiable)\n\nReturn obj.𝐹. obj will not be affected.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#ACFlow.value!","page":"Math","title":"ACFlow.value!","text":"value!(obj::OnceDifferentiable, x)\n\nReturn 𝑓(x). obj.𝐹 will be updated and returned.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#ACFlow.jacobian","page":"Math","title":"ACFlow.jacobian","text":"jacobian(obj::OnceDifferentiable)\n\nReturn obj.𝐽. obj will not be affected.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#ACFlow.jacobian!","page":"Math","title":"ACFlow.jacobian!","text":"jacobian!(obj::OnceDifferentiable, x)\n\nReturn jacobian. obj.𝐽 will be updated and returned.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#ACFlow.levenberg_marquardt","page":"Math","title":"ACFlow.levenberg_marquardt","text":"levenberg_marquardt(df::OnceDifferentiable, x₀::AbstractVector{T})\n\nReturns the argmin over x of sum(f(x).^2) using the Levenberg-Marquardt algorithm. The function f is encoded in df. x₀ is an initial guess for the solution.\n\nSee also: OnceDifferentiable.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#ACFlow.curve_fit","page":"Math","title":"ACFlow.curve_fit","text":"curve_fit(model, x, y, p0)\n\nFit data to a non-linear model. p0 is an initial model parameter guess. The return object is a composite type (LsqFitResult).\n\nSee also: LsqFitResult.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#Numerical-Optimization","page":"Math","title":"Numerical Optimization","text":"","category":"section"},{"location":"library/math.html#Structs-3","page":"Math","title":"Structs","text":"","category":"section"},{"location":"library/math.html","page":"Math","title":"Math","text":"BFGSDifferentiable\nBFGSState\nBFGSOptimizationResults","category":"page"},{"location":"library/math.html#ACFlow.BFGSDifferentiable","page":"Math","title":"ACFlow.BFGSDifferentiable","text":"BFGSDifferentiable\n\nMutable struct. It is used for objectives and solvers where the gradient is available/exists.\n\nMembers\n\nℱ! -> Objective. It is actually a function call and return objective.\n𝒟! -> It is a function call as well and returns derivative of objective.\n𝐹  -> Cache for ℱ! output.\n𝐷  -> Cache for 𝒟! output.\n\n\n\n\n\n","category":"type"},{"location":"library/math.html#ACFlow.BFGSState","page":"Math","title":"ACFlow.BFGSState","text":"BFGSState\n\nMutable struct. It is used to trace the history of states visited.\n\nMembers\n\nx     -> Current position.\nls    -> Current search direction.\nδx    -> Changes in position.\nδg    -> Changes in gradient.\nxₚ    -> Previous position.\ngₚ    -> Previous gradient.\nfₚ    -> Previous f (f in xₚ).\nH⁻¹   -> Current inverse Hessian matrix.\nalpha -> A internal parameter to control the BFGS algorithm.\n\n\n\n\n\n","category":"type"},{"location":"library/math.html#ACFlow.BFGSOptimizationResults","page":"Math","title":"ACFlow.BFGSOptimizationResults","text":"BFGSOptimizationResults\n\nIt is used to save the optimization results of the BFGS algorithm.\n\nMembers\n\nx₀         -> Initial guess for the solution.\nminimizer  -> Final results for the solution.\nminimum    -> Objective at the final solution.\niterations -> Number of iterations.\nδx         -> Absolute change in x.\nΔx         -> Relative change in x.\nδf         -> Absolute change in f.\nΔf         -> Relative change in f.\nresid      -> Maximum gradient of f at the final solution.\ngconv      -> If the convergence criterion is satisfied\n\n\n\n\n\n","category":"type"},{"location":"library/math.html#Constructors-3","page":"Math","title":"Constructors","text":"","category":"section"},{"location":"library/math.html","page":"Math","title":"Math","text":"BFGSDifferentiable(f, df, x::AbstractArray)","category":"page"},{"location":"library/math.html#ACFlow.BFGSDifferentiable-Tuple{Any, Any, AbstractArray}","page":"Math","title":"ACFlow.BFGSDifferentiable","text":"BFGSDifferentiable(f, df, x::AbstractArray)\n\nConstructor for BFGSDifferentiable struct. f is the function, df is the derivative of objective, x is the initial guess.\n\n\n\n\n\n","category":"method"},{"location":"library/math.html#Functions-3","page":"Math","title":"Functions","text":"","category":"section"},{"location":"library/math.html","page":"Math","title":"Math","text":"value(obj::BFGSDifferentiable)\ngradient\nvalue_gradient!\nmaxdiff\neval_δf\neval_Δf\neval_δx\neval_Δx\neval_resid\noptimize\ninit_state\nupdate_state!\nupdate_g!\nupdate_h!\ntrace\nlinesearch!\nconverged","category":"page"},{"location":"library/math.html#ACFlow.value-Tuple{BFGSDifferentiable}","page":"Math","title":"ACFlow.value","text":"value(obj::BFGSDifferentiable)\n\nReturn obj.𝐹. obj will not be affected.\n\n\n\n\n\n","category":"method"},{"location":"library/math.html#ACFlow.gradient","page":"Math","title":"ACFlow.gradient","text":"gradient(obj::BFGSDifferentiable)\n\nReturn obj.𝐷. obj will not be affected.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#ACFlow.value_gradient!","page":"Math","title":"ACFlow.value_gradient!","text":"value_gradient!(obj::BFGSDifferentiable, x)\n\nEvaluate objective and derivative at x. obj.𝐹 and obj.𝐷 should be updated. Note that here obj.𝒟! is actually nac.jl/smooth_norm().\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#ACFlow.maxdiff","page":"Math","title":"ACFlow.maxdiff","text":"maxdiff(x::AbstractArray, y::AbstractArray)\n\nReturn the maximum difference between two arrays: x and y. Note that the sizes of x and y should be the same.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#ACFlow.eval_δf","page":"Math","title":"ACFlow.eval_δf","text":"eval_δf(d::BFGSDifferentiable, s::BFGSState)\n\nEvaluate the absolute changes in f.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#ACFlow.eval_Δf","page":"Math","title":"ACFlow.eval_Δf","text":"eval_Δf(d::BFGSDifferentiable, s::BFGSState)\n\nEvaluate the relative changes in f.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#ACFlow.eval_δx","page":"Math","title":"ACFlow.eval_δx","text":"eval_δx(s::BFGSState)\n\nEvaluate the absolute changes in x.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#ACFlow.eval_Δx","page":"Math","title":"ACFlow.eval_Δx","text":"eval_Δx(s::BFGSState)\n\nEvaluate the relative changes in x.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#ACFlow.eval_resid","page":"Math","title":"ACFlow.eval_resid","text":"eval_resid(d::BFGSDifferentiable)\n\nEvaluate residual (maximum gradient of f at the current position).\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#ACFlow.optimize","page":"Math","title":"ACFlow.optimize","text":"optimize(f, g, x₀::AbstractArray; max_iter::I64 = 1000)\n\nReturn the argmin over x of f(x) using the BFGS algorithm. Here, f is the function call, and g will return the gradient of f, x₀ is an initial guess for the solution.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#ACFlow.init_state","page":"Math","title":"ACFlow.init_state","text":"init_state(d::BFGSDifferentiable, x₀::AbstractArray)\n\nCreate a BFGSState object. Note that d should be updated in this function (d.𝐹 and d.𝐷). x₀ is an initial guess for the solution.\n\nSee also: BFGSDifferentiable, BFGSState.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#ACFlow.update_state!","page":"Math","title":"ACFlow.update_state!","text":"update_state!(d::BFGSDifferentiable, s::BFGSState)\n\nEvaluate line search direction and change of x. New position and old gradient are saved in s.\n\nSee also: BFGSDifferentiable, BFGSState.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#ACFlow.update_g!","page":"Math","title":"ACFlow.update_g!","text":"update_g!(d::BFGSDifferentiable, s::BFGSState)\n\nUpdate the function value and gradient (d.𝐹 and d.𝐷 are changed).\n\nSee also: BFGSDifferentiable, BFGSState.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#ACFlow.update_h!","page":"Math","title":"ACFlow.update_h!","text":"update_h!(d::BFGSDifferentiable, s::BFGSState)\n\nTry to evaluate the new Hessian matrix.\n\nSee also: BFGSDifferentiable, BFGSState.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#ACFlow.trace","page":"Math","title":"ACFlow.trace","text":"trace(d::BFGSDifferentiable, iter::I64, curr_time::F64)\n\nPrint some useful information about the optimization procedure.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#ACFlow.linesearch!","page":"Math","title":"ACFlow.linesearch!","text":"linesearch!(d::BFGSDifferentiable, s::BFGSState)\n\nEvaluate line search direction. Actually, s.alpha, s.fₚ, and s.xₚ will be updated in this function.\n\nSee also: BFGSDifferentiable, BFGSState.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#ACFlow.converged","page":"Math","title":"ACFlow.converged","text":"converged(r::BFGSOptimizationResults)\n\nCheck whether the optimization is converged.\n\nSee also: BFGSOptimizationResults.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#Line-Search","page":"Math","title":"Line Search","text":"","category":"section"},{"location":"library/math.html#Structs-4","page":"Math","title":"Structs","text":"","category":"section"},{"location":"library/math.html","page":"Math","title":"Math","text":"LineSearchException","category":"page"},{"location":"library/math.html#ACFlow.LineSearchException","page":"Math","title":"ACFlow.LineSearchException","text":"LineSearchException\n\nMutable struct. It contains information about the error occured in the line search.\n\nMembers\n\nmessage -> Error message.\nalpha   -> A key parameter used to control line search.\n\n\n\n\n\n","category":"type"},{"location":"library/math.html#Functions-4","page":"Math","title":"Functions","text":"","category":"section"},{"location":"library/math.html","page":"Math","title":"Math","text":"LS","category":"page"},{"location":"library/math.html#ACFlow.LS","page":"Math","title":"ACFlow.LS","text":"LS(state::BFGSState, alpha::T, scaled::Bool)\n\nLine search: initial and static version.\n\n\n\n\n\nLS(df::BFGSDifferentiable,\n    x::Vector{C64}, s::Vector{C64},\n    c::F64, phi_0::F64, dphi_0::F64)\n\nLine search: Hager-Zhang algorithm.\n\n\n\n\n\n","category":"function"},{"location":"theory/basic.html#Basic-Principles","page":"Basic Principles","title":"Basic Principles","text":"","category":"section"},{"location":"theory/basic.html#Finite-Temperature-Green's-Functions","page":"Basic Principles","title":"Finite Temperature Green's Functions","text":"","category":"section"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"Under the Wick's rotation t to itau, the time evolution operator in the Heisenberg picture e^itH will be replaced by e^-tau H. Such a transformation will increase efficiency of QMC random walking and suppress numerical oscillation (when t is large, the periodic oscillation of e^itH is quite obvious). This is an important reason why most of the finite temperature QMC algorithms are formulated in imaginary time axis. The outputs of finite temperature QMC simulations are usually single-particle or two-particle correlation functions. For example, the imaginary time Green's function G(tau) is defined as follows:","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nG(tau) = langle mathcalT_tau d(tau) d^dagger(0) rangle\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"where tau denotes imaginary time, mathcalT_tau denotes time-ordered operator, and d and d^dagger are annihilation and creation operators, respectively. The Matsubara Green's function G(iomega_n) can be measured by QMC simulations or constructed from G(tau) via direct Fourier transformation:","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nG(iomega_n) = int^beta_0 dtaue^-iomega_n tau G(tau)\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nG(tau) = frac1beta sum_n e^iomega_n tau G(iomega_n)\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"Here, beta means the inverse temperature (beta equiv 1T) and omega_n is the Matsubara frequency. Note that omega_n is equal to (2n + 1) pi  beta for fermions and 2npi beta for bosons (n is an integer).","category":"page"},{"location":"theory/basic.html#spectrum","page":"Basic Principles","title":"Spectral representation","text":"","category":"section"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"Supposed that the spectral density of the single-particle Green's function is A(omega), then we have:","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nG(tau) = int^+infty_-infty domega\n          frace^-tauomega1 pm e^-betaomega\n          A(omega)\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"with the positive (negative) sign for fermionic (bosonic) operators. Similarly,","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nG(iomega_n) = int^+infty_-infty domega\n               frac1iomega_n - omega A(omega)\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"The two equations denote the spectral representation of Green's function. We notice that the SPX method, as well as the other analytic continuation methods that are classified as ASM, are closely related to the spectral representation. Next we would like to make further discussions about this representation for the fermionic and bosonic correlators.  ","category":"page"},{"location":"theory/basic.html#Fermionic-correlators","page":"Basic Principles","title":"Fermionic correlators","text":"","category":"section"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"The spectral density A(omega) is defined on (-inftyinfty). It is positive definite, i.e., A(omega) ge 0. Eq.(4) and Eq.(5) can be reformulated as:","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nG(tau) = int^+infty_-infty domegaK(tauomega) A(omega)\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"and","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nG(iomega_n) = int^+infty_-infty domegaK(omega_nomega) A(omega)\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"respectively. The kernel functions K(tauomega) and K(omega_nomega) are defined as follows:","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nK(tauomega) = frace^-tauomega1 + e^-betaomega\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"and","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nK(omega_nomega) = frac1iomega_n - omega\nendequation","category":"page"},{"location":"theory/basic.html#Bosonic-correlators","page":"Basic Principles","title":"Bosonic correlators","text":"","category":"section"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"The spectral density A(omega) obeys the following constraint: textsign(omega) A(omega) ge 0. Thus, it is more convenient to define a new function tildeA(omega) where tildeA(omega) = A(omega)omega. Clearly, tildeA(omega) is always positive definite. As a result Eq.(4) and Eq.(5) can be rewritten as:","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nG(tau) = int^+infty_-infty domega\n    K(tauomega)tildeA(omega)\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"and","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nG(iomega_n) = int^+infty_-infty domega\n    K(omega_nomega) tildeA(omega)\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"respectively. Now the bosonic kernel K(tauomega) becomes:","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nK(tauomega) = fracomega e^-tauomega1 - e^-betaomega\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"Especially, K(tau0) = 1beta. As for K(omega_nomega), its expression is:","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nK(omega_nomega) = fracomegaiomega_n - omega\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"Especially, K(00) = -1. Besides the bosonic Green's function, typical correlator of this kind includes the transverse spin susceptibility chi_+-(tau) = langle S_+(tau) S_-(0) rangle, where S_+ = S_x + iS_y and S_- = S_x - i S_y.","category":"page"},{"location":"theory/basic.html#Bosonic-correlators-of-Hermitian-operators","page":"Basic Principles","title":"Bosonic correlators of Hermitian operators","text":"","category":"section"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"There is a special case of the previous observable kind with d = d^dagger. Here, A(omega) becomes an odd function, and equivalently, tildeA(omega) is an even function [i.e., tildeA(omega) = tildeA(-omega)]. Therefore the limits of integrations in Eq.(4) and Eq.(5) are reduced from (-inftyinfty) to (0infty). So the two equations can be transformed into:","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nG(tau) = int^+infty_0 domega\n    K(tauomega)tildeA(omega)\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"and","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nG(iomega_n) = int^+infty_0 domega\n    K(omega_nomega) tildeA(omega)\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"respectively. The corresponding K(tauomega) reads:","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nK(tauomega) = fracomega lefte^-tauomega + e^-(beta - tau)omegaright\n                      1 - e^-betaomega\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"Especially, K(tau0) = 2  beta. And K(omega_nomega) becomes:","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nK(omega_n omega) = frac-2omega^2omega_n^2 + omega^2\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"Especially, K(00) = -2. Perhaps the longitudinal spin susceptibility chi_zz(tau) = langle S_z(tau) S_z(0) rangle and the charge susceptibility chi_ch(tau) = langle N(tau) N(0) rangle are the most widely used observables of this kind.","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"As mentioned above, the kernel function is quite strange. The values of K(tauomega) could change by tens of orders of magnitude. Especially, at large positive and negative frequencies, K(tauomega) is exponentially small. It implies that at large omega the features of A(omega) depend upon the fine structures of G(tau). However, the G(tau) data provided by QMC simulations are always fluctuant and noisy. Tiny deviations in G(tau) from its expected values can lead to enormous changes in A(omega). Thus, analytic continuation is often characterized as an ill-posed problem.","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"In principle, for incomplete and noise G(tau) or G(iomega_n), the number of spectral functions A(omega) that satisfy Eq.(4) and Eq.(5) is infinite. So the question becomes which A(omega) should be chosen. Now there are two different strategies to solve this problem. The first one is to choose the most likely A(omega). The second one is to evaluate the average of all the candidate spectral functions.","category":"page"},{"location":"theory/basic.html#Pole-representation","page":"Basic Principles","title":"Pole representation","text":"","category":"section"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"It is well known that the finite temperature many-body Green's functions can be expressed within the Lehmann representation:","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nG_ab(z) = frac1Z sum_mn\nfraclangle n  d_a  m rangle langle m  d_b^dagger  n ranglez + E_n - E_m\nleft(e^-beta E_n pm e^-beta E_mright)\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"where a and b are the band indices, d (d^dagger) denote the annihilation (creation) operators, n rangle and m rangle are eigenstates of the Hamiltonian hatH, and E_n and E_m are the corresponding eigenvalues, Z is the partition function (Z = sum_n e^-beta E_n). The positive sign corresponds to fermions, while the negative sign corresponds to bosons. The domain of this function is on the complex plane, but the real axis is excluded (z in 0 bigcup mathbbCbackslashmathbbR). If z = iomega_n in imathbbR, G_ab(iomega_n) is the Matsubara Green's function. If z = omega + i0^+, G_ab(omega + i0^+) = G_ab^R(omega) is called the retarded Green's function.","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"At first we focus on the diagonal cases (a = b). For the sake of simplicity, the band indices are ignored in the following discussions. Let A_mn = langle n  d  m rangle langle m  d^dagger  n rangle left(e^-beta E_n + e^-beta E_mright)  Z and P_mn = E_m - E_n, then G(z) = sum_mn A_mn  (z - P_mn). Clearly, only those nonzero elements of A_mn contribute to the Green's function. If the indices m and n are further compressed into gamma (i.e, gamma = mn), then Eq.(18) is simplified to:","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nG(z) = sum^N_p_gamma = 1 fracA_gammaz - P_gamma\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"Here, A_gamma and P_gamma mean the amplitude and location of the gamma-th pole, respectively. N_p means the number of poles, which is equal to the total number of nonzero A_mn. Such an analytic expression of Green's function is called the pole expansion. It is valid for both fermionic and bosonic correlators.","category":"page"},{"location":"theory/basic.html#Fermionic-correlators-2","page":"Basic Principles","title":"Fermionic correlators","text":"","category":"section"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"For fermionic systems, the pole representation for Matsubara Green's function can be recast as:","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nG(iomega_n) = sum^N_p_gamma = 1 Xi(omega_n P_gamma) A_gamma\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"Here, Xi is the kernel matrix. It is evaluated by:","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nXi(omega_n omega) = frac1iomega_n - omega\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"Note that A_gamma and P_gamma should satisfy the following constraints:","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nforall gamma 0 le A_gamma le 1 sum_gamma A_gamma = 1 P_gamma in mathbbR\nendequation","category":"page"},{"location":"theory/basic.html#Bosonic-correlators-2","page":"Basic Principles","title":"Bosonic correlators","text":"","category":"section"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"For bosonic systems, the pole representation for Matsubara Green's function can be defined as follows:","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nG(iomega_n) = sum^N_p_gamma=1 Xi(omega_n P_gamma) tildeA_gamma\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"Here, Xi is evaluated by:","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nXi(omega_n omega) = fracG_0 omegaiomega_n - omega\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"where G_0 = -G(iomega_n = 0), which should be a positive real number. Be careful, Xi(0omega) = -G_0. tildeA_gamma is the renormalized amplitude of the gamma-th pole:","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\ntildeA_gamma = fracA_gammaG_0 P_gamma\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"Note that tildeA_gamma and P_gamma should satisfy the following constraints:","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nforall gamma 0 le tildeA_gamma le 1 sum_gamma tildeA_gamma = 1 P_gamma in mathbbR\nendequation","category":"page"},{"location":"theory/basic.html#Bosonic-correlators-of-Hermitian-operators-2","page":"Basic Principles","title":"Bosonic correlators of Hermitian operators","text":"","category":"section"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"Its pole representation can be defined as follows (forall gamma, A_gamma  0 and P_gamma  0):","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginalign\nG(iomega_n) = sum^N_p_gamma = 1\nleft(\n    fracA_gammaiomega_n - P_gamma -\n    fracA_gammaiomega_n + P_gamma\nright) \n= sum^N_p_gamma = 1\nXi(omega_n P_gamma) tildeA_gamma\nendalign","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"Thus, the kernel matrix Xi reads:","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nXi(omega_n omega) = frac-G_0 omega^2omega^2_n + omega^2\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"Especially, Xi(00) = -G_0. The renormalized weight tildeA_gamma reads:","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\ntildeA_gamma = frac2A_gammaG_0 P_gamma\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"The constraints for tildeA_gamma and P_gamma are also defined in Eq.(26).","category":"page"},{"location":"theory/basic.html#Matrix-valued-Green's-functions","page":"Basic Principles","title":"Matrix-valued Green's functions","text":"","category":"section"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"As for the off-diagonal cases (a neq b), it is lightly to prove that sum_gamma A_gamma = 0. It implies that there exist poles with negative weights. Hence we can split the poles into two groups according to the signs of their amplitudes. The Matsubara Green's function can be expressed as follows:","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginalign\nG(iomega_n) = sum^N^+_p_gamma = 1 \n               fracA^+_gammaiomega_n - P^+_gamma -\n               sum^N^-_p_gamma = 1\n               fracA^-_gammaiomega_n - P^-_gamma \n             = sum^N^+_p_gamma = 1\n               Xi(omega_n P^+_gamma) A^+_gamma -\n               sum^N^-_p_gamma = 1\n               Xi(omega_n P^-_gamma) A^-_gamma\n\nendalign","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"Here, Xi(omega_n omega) is already defined in Eq.(21). The A^pm_gamma and P^pm_gamma are restricted by Eq.(22). In addition,","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nN_p = N^+_p + N^-_p\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"and","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nsum^N^+_p_gamma = 1 A^+_gamma - \nsum^N^-_p_gamma = 1 A^-_gamma = 0\nendequation","category":"page"},{"location":"theory/basic.html#Relevant-parameters","page":"Basic Principles","title":"Relevant parameters","text":"","category":"section"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"See [BASE] Block","category":"page"},{"location":"intro/ack.html#Acknowledgements","page":"Acknowledgements","title":"Acknowledgements","text":"","category":"section"},{"location":"intro/ack.html","page":"Acknowledgements","title":"Acknowledgements","text":"This project has been supported by the following foundations:","category":"page"},{"location":"intro/ack.html","page":"Acknowledgements","title":"Acknowledgements","text":"CAEP Foundation (under Grant No.CX20210033)\nNational Science Foundation of China (under Grants No.11874329).\nNational Science Foundation of China (under Grants No.11934020).","category":"page"},{"location":"man/install.html#install","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"It is an easy task to install the ACFlow toolkit. First, since it is written in pure Julia language, it is necessary to install the Julia runtime environment in advance. The newest version of Julia is always preferred (version > 1.60). Because the core codes only rely on Julia's built-in standard library, no the third-party packages are needed. Second, just download source codes of the ACFlow toolkit from its github repository. It should be a compressed file, such as acflow.zip or acflow.tar.gz. Please uncompress it in your favorite directory by using the following commands:","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"$ unzip acflow.zip","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"or","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"$ tar xvfz acflow.tar.gz","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"Third, please input the following commands in Julia's REPL (Read-Eval-Print Loop) environment:","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"julia> using Pkg\njulia> Pkg.add(url = \"/home/your_home/acflow/\")","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"Here, Pkg is Julia's built-in package manager, and /home/your_home/acflow is assumed to be the root directory of the ACFlow toolkit. In practice, the users can use the Pkg package to install the ACFlow toolkit from its github repository directly:","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"julia> using Pkg\njulia> Pkg.add(url = \"https://github.com/huangli712/ACFlow\")","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"So the second step is optional. Furthermore, if the installed ACFlow toolkit is outdated, the users can use the following commands to upgrade ACFlow:","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"julia> using Pkg\njulia> Pkg.update(\"ACFlow\")","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"Finally, in order to generate the documentation, please type the following commands in the terminal:","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"$ pwd\n/home/your_home/acflow\n$ cd docs\n$ julia make.jl","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"After a few seconds, the documentation is built and saved in the acflow/docs/build directory if everything is OK. The home page of the documentation is acflow/docs/build/index.html. The users can open it with any web browsers.","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"info: Info\nSometimes in offline environment, the package manager is disable. At this time, we should setup the environment variable ACFLOW_HOME as follows:$ export ACFLOW_HOME=/home/your_home/acflow/srcAnd then plug the following code in front of your Julia's scripts:push!(LOAD_PATH, ENV[\"ACFLOW_HOME\"])Or else Julia won't find the ACFlow package.","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"note: Note\nAfter v1.8.0, the ACFlow toolkit relies on the Zygote.jl package to calculate gradient. The Zygota.jl package adopts the automatic differentiation approach, which is more efficient than the finite difference method. If the users have trouble in installing the Zygote.jl package, we provide an internal function to bypass it.Firstly, please disable Zygote in ACFlow.jl.# using ZygoteSecondly, fix 𝐽!(J::Vector{C64}, x::Vector{C64}) in nac.jlfunction 𝐽!(J::Vector{C64}, x::Vector{C64})\n    #J .= Zygote.gradient(𝑓, x)[1]\n\n    # Finite difference algorithm\n    J .= gradient_via_fd(𝑓, x)\n    #\nendNote that gradient_via_fd() is based on the finite difference method, which is much slower and less accurate than the automatic differentiation approach. It is implemented in the math.jl.","category":"page"},{"location":"theory/spx.html#spx","page":"Stochastic Pole Expansion","title":"Stochastic Pole Expansion","text":"","category":"section"},{"location":"theory/spx.html","page":"Stochastic Pole Expansion","title":"Stochastic Pole Expansion","text":"warning: Warning\nThe StochPX solver is experimental. Please use it at your own risk.","category":"page"},{"location":"theory/spx.html#Stochastic-optimization","page":"Stochastic Pole Expansion","title":"Stochastic optimization","text":"","category":"section"},{"location":"theory/spx.html","page":"Stochastic Pole Expansion","title":"Stochastic Pole Expansion","text":"Supposed that the input Matsubara Green's function is mathcalG(iomega_n), where n = 1, 2, cdots, N_omega, the objective of analytic continuation is to fit the (possibly noisy and incomplete) Matsubara data into the pole representation under some constraints. In mathematical language, we should solve the following multivariate optimization problem:","category":"page"},{"location":"theory/spx.html","page":"Stochastic Pole Expansion","title":"Stochastic Pole Expansion","text":"beginequation\nmathopargminlimits_ leftA_gamma P_gammaright^N_p_gamma = 1  chi^2leftleftA_gamma P_gammaright^N_p_gamma = 1right\nendequation","category":"page"},{"location":"theory/spx.html","page":"Stochastic Pole Expansion","title":"Stochastic Pole Expansion","text":"Here, chi^2leftleftA_gamma P_gammaright^N_p_gamma = 1right is the so-called goodness-of-fit function or loss function. Its definition is as follows:","category":"page"},{"location":"theory/spx.html","page":"Stochastic Pole Expansion","title":"Stochastic Pole Expansion","text":"beginequation\nchi^2\nleftleftA_gamma P_gammaright^N_p_gamma = 1right \n= frac1N_omegasum^N_omega_n = 1\nleftleft\nmathcalG(iomega_n) - sum^N_p_gamma = 1 fracA_gammaiomega_n - P_gamma \nrightright^2_F\nendequation","category":"page"},{"location":"theory/spx.html","page":"Stochastic Pole Expansion","title":"Stochastic Pole Expansion","text":"where cdot_F denotes the Frobenius norm. The minimization of Eq.(2) is highly non-convex. Traditional gradient-based optimization methods, such as non-negative least squares method, conjugate gradient method, Newton and quasi-Newton methods, are frequently trapped in local minima. Their optimized results strongly depend on the initial guess. The semi-definite relaxation (SDR) fitting method, adaptive Antoulas-Anderson (AAA) algorithm, and conformal mapping plus Prony's method, which have been employed to search the locations of poles in previous works, are also tested. But these methods usually fail when N_p is huge [N_p sim O(10^3)] or the Matsubara data are noisy.","category":"page"},{"location":"theory/spx.html","page":"Stochastic Pole Expansion","title":"Stochastic Pole Expansion","text":"In order to overcome the above obstacles, we employ the simulated annealing method to locate the global minimum of chi^2. The core idea is as follows: First of all, a set of A_gamma P_gamma parameters are generated randomly. These parameters form a configuration space mathcalC = A_gamma P_gamma. Second, this configuration space is sampled by using the Metropolis Monte Carlo algorithm. In the present SPX method, four Monte Carlo updates are supported (see Figure 1). They include: (i) Select one pole randomly and shift its location. (ii) Select two poles randomly and shift their locations. (iii) Select two poles randomly and change their amplitudes. The sum-rules for fermionic and bosonic correlatores, should be respected in this update. (iv) Select two poles randomly and exchange their amplitudes. Assumed that the current Monte Carlo configuration is mathcalC = A_gamma P_gamma, the new one is mathcalC = A_gamma P_gamma, and Delta chi^2 = chi^2(mathcalC) - chi^2(mathcalC), then the transition probability reads:","category":"page"},{"location":"theory/spx.html","page":"Stochastic Pole Expansion","title":"Stochastic Pole Expansion","text":"beginequation\np(mathcalC to mathcalC) =\nleft\n    beginarraylr\n        expleft(-fracDelta chi^22Thetaright)  textifDelta chi^2  0 \n        10  textifDelta chi^2 le 0\n    endarray\nright\nendequation","category":"page"},{"location":"theory/spx.html","page":"Stochastic Pole Expansion","title":"Stochastic Pole Expansion","text":"where Theta is an artificial system temperature and chi^2 is interpreted as energy of the system. Third, the above two steps should be restarted periodically to avoid trapped by local minima. Fourth, once all the Monte Carlo sampling tasks are finished, we should pick up the best  solution which exhibits the smallest chi^2, or select some good solutions with small chi^2 and evaluate their arithmetic average. Finally, with the optimized N_p, and A_gamma, and P_gamma parameters, the retarded Green's function G^R(omega) can be easily evaluated by replacing iomega_n with omega + ieta in the pole representation, where eta is a positive infinitesimal number. And the spectral density A(omega) is calculated by:","category":"page"},{"location":"theory/spx.html","page":"Stochastic Pole Expansion","title":"Stochastic Pole Expansion","text":"beginequation\nA(omega) = - frac1pi textIm G^R(omega)\nendequation","category":"page"},{"location":"theory/spx.html","page":"Stochastic Pole Expansion","title":"Stochastic Pole Expansion","text":"(Image: spx.png)","category":"page"},{"location":"theory/spx.html","page":"Stochastic Pole Expansion","title":"Stochastic Pole Expansion","text":"Figure 1 | Schematic picture for the pole representation of the Matsubara Green's function. The poles are visualized by vertical colorful bars. Move 1, Move 2, and Move 4 denote three possible Monte Carlo updates: (i) shift a randomly selected pole, (ii) shift two randomly selected poles, and (iii)~swap two randomly selected poles. See main text for more details.","category":"page"},{"location":"theory/spx.html#Constrained-sampling-algorithm","page":"Stochastic Pole Expansion","title":"Constrained sampling algorithm","text":"","category":"section"},{"location":"theory/spx.html","page":"Stochastic Pole Expansion","title":"Stochastic Pole Expansion","text":"In the SPX method, the amplitudes and locations of the poles should be optimized by the Monte Carlo algorithm under some constraints (i.e., the sum-rules). We note that these constraints are from the canonical relations for the fermionic and bosonic operators. They should be satisfied, or else the causality of the spectrum is not guaranteed. But beyond that, more constraints are allowable. Further restrictions on the amplitudes and locations of the poles can greatly reduce the configuration space that need to be sampled and enhance the possibility to reach the global minimum of the optimization problem. The possible strategies include: (1) Restrict A_gamma only; (2) Restrict P_gamma only; and (3) Restrict A_gamma and P_gamma at the same time. These extra constraints can be deduced from a priori knowledge about the Matsubara Green's function G(iomega_n) and the spectral density A(omega). For example, for a molecule system, the amplitudes of the poles are likely close. On the other hand, if we know nothing about the input data, we can always try some constraints. The universal trend is that the more reasonable the constraints, the smaller the chi^2 function. This is the so-called constrained sampling algorithm. By combined it with the SPX method (dubbed C-SPX), the ability of resolving fine features in the spectra will be greatly enhanced. To the best of our knowledge, the constrained sampling algorithm was firstly proposed by A. W. Sandvik. And then it is broadly used in the analytic continuations of spin susceptibilities of quantum many-body systems. Quite recently, Shao and Sandvik summarized various approaches to apply the constraints and benchmark their performances in a comprehensive review concerning the SAC method. Due to the similarities of the SPX and SAC methods, it is believed that all the constraint schemes as suggested in previous works should be useful for the SPX method.","category":"page"},{"location":"theory/spx.html#Self-adaptive-sampling-algorithm","page":"Stochastic Pole Expansion","title":"Self-adaptive sampling algorithm","text":"","category":"section"},{"location":"theory/spx.html","page":"Stochastic Pole Expansion","title":"Stochastic Pole Expansion","text":"In analogy to the SAC method, the poles in the SPX method are distributed randomly in a real frequency grid. This grid must be extremely dense, and is usually linear. But in principle a nonuniform grid is possible. For example, Shao and Sandvik have suggested a nonlinear grid with monotonically increasing spacing for the delta functions which are used to parameterize a spectrum that exhibits a sharp band edge. Since a spectral density can be viewed as a probability distribution and we notice that the distribution of the poles looks quite similar to the spectrum. So, it is natural to adjust the frequency grid dynamically to make sure that the grid density has approximate distribution with the spectral density as obtained in previous run. We adopt the following algorithm to update the frequency grid: (1) Create a new function phi(epsilon):","category":"page"},{"location":"theory/spx.html","page":"Stochastic Pole Expansion","title":"Stochastic Pole Expansion","text":"beginequation\nphi(epsilon) = int^epsilon_omega_textmin A(omega) domegaepsilon in omega_textminomega_textmax\nendequation","category":"page"},{"location":"theory/spx.html","page":"Stochastic Pole Expansion","title":"Stochastic Pole Expansion","text":"(2) The new frequency grid f_i is evaluated by:","category":"page"},{"location":"theory/spx.html","page":"Stochastic Pole Expansion","title":"Stochastic Pole Expansion","text":"beginequation\nf_i = phi^-1(lambda_i)i = 1 cdots N_f \nendequation","category":"page"},{"location":"theory/spx.html","page":"Stochastic Pole Expansion","title":"Stochastic Pole Expansion","text":"where lambda_i is a linear mesh in phi(omega_textmin)phi(omega_textmax). Next we should perform the analytic continuation simulation again and extract a new spectrum. We find that the chi^2 drops quickly in the first a few iterations, and then approaches to a constant value slowly. At the same time, the spectrum is refined gradually. In the iterations, the frequency grid for the poles is adaptively modified according to the given spectrum, thus we call it the self-adaptive sampling algorithm. It is actually a new variation of the constrained sampling algorithm. More important, it is quite effective. Based on our experiences, 3 sim 5 iterations are enough to obtain a convergent solution. In practice, we often use the spectrum generated by the MaxEnt method to initialize the frequency grid, and then employ the SPX method (dubbed SA-SPX) to refine this spectrum further.","category":"page"},{"location":"theory/spx.html#Relevant-parameters","page":"Stochastic Pole Expansion","title":"Relevant parameters","text":"","category":"section"},{"location":"theory/spx.html","page":"Stochastic Pole Expansion","title":"Stochastic Pole Expansion","text":"See [StochPX] Block","category":"page"},{"location":"library/kernel.html#Kernels","page":"Kernels","title":"Kernels","text":"","category":"section"},{"location":"library/kernel.html","page":"Kernels","title":"Kernels","text":"Build kernel functions.","category":"page"},{"location":"library/kernel.html","page":"Kernels","title":"Kernels","text":"The ACFlow toolkit supports twelve types of kernel functions. They are:","category":"page"},{"location":"library/kernel.html","page":"Kernels","title":"Kernels","text":"Fermionic imaginary time kernel (ktype = \"fermi\", grid = \"ftime\")\nFermionic fragment imaginary time kernel (ktype = \"fermi\", grid = \"fpart\")\nFermionic Matsubara kernel (ktype = \"fermi\", grid = \"ffreq\")\nFermionic fragment Matsubara kernel (ktype = \"fermi\", grid = \"ffrag\")\nBosonic imaginary time kernel (ktype = \"boson\", grid = \"btime\")\nBosonic fragment imaginary time kernel (ktype = \"boson\", grid = \"bpart\")\nBosonc Matsubara kernel (ktype = \"boson\", grid = \"bfreq\")\nBosonc fragment Matsubara kernel (ktype = \"boson\", grid = \"bfrag\")\nSymmetric bosonic imaginary time kernel (ktype = \"bsymm\", grid = \"btime\")\nSymmetric bosonic fragment imaginary time kernel (ktype = \"bsymm\", grid = \"bpart\")\nSymmetric bosonic Matsubara kernel (ktype = \"bsymm\", grid = \"bfreq\")\nSymmetric bosonic fragment Matsubara kernel (ktype = \"bsymm\", grid = \"bfrag\")","category":"page"},{"location":"library/kernel.html","page":"Kernels","title":"Kernels","text":"Note that the MaxEnt, StochAC, and StochSK solvers rely on the make_kernel() function to provide the kernel function. However, the kernel function or matrix used in the StochOM and StochPX solvers are implemented in their own calc_lambda() functions.","category":"page"},{"location":"library/kernel.html#Contents","page":"Kernels","title":"Contents","text":"","category":"section"},{"location":"library/kernel.html","page":"Kernels","title":"Kernels","text":"Pages = [\"kernel.md\"]\nDepth = 2","category":"page"},{"location":"library/kernel.html#Index","page":"Kernels","title":"Index","text":"","category":"section"},{"location":"library/kernel.html","page":"Kernels","title":"Kernels","text":"Pages = [\"kernel.md\"]","category":"page"},{"location":"library/kernel.html#Making-Kernels","page":"Kernels","title":"Making Kernels","text":"","category":"section"},{"location":"library/kernel.html","page":"Kernels","title":"Kernels","text":"build_kernel\nbuild_kernel_symm","category":"page"},{"location":"library/kernel.html#ACFlow.build_kernel","page":"Kernels","title":"ACFlow.build_kernel","text":"build_kernel(am::AbstractMesh, fg::FermionicImaginaryTimeGrid)\n\nTry to build fermionic kernel function in imaginary time axis.\n\nSee also: AbstractMesh, FermionicImaginaryTimeGrid.\n\n\n\n\n\nbuild_kernel(am::AbstractMesh, fg::FermionicFragmentTimeGrid)\n\nTry to build fermionic kernel function in imaginary time axis. Note that fg contains incomplete imaginary time data.\n\nSee also: AbstractMesh, FermionicFragmentTimeGrid.\n\n\n\n\n\nbuild_kernel(am::AbstractMesh, fg::FermionicMatsubaraGrid)\n\nTry to build fermionic kernel function in Matsubara frequency axis. This function support preblur algorithm.\n\nSee also: AbstractMesh, FermionicMatsubaraGrid.\n\n\n\n\n\nbuild_kernel(am::AbstractMesh, fg::FermionicFragmentMatsubaraGrid)\n\nTry to build fermionic kernel function in Matsubara frequency axis. This function support preblur algorithm.\n\nSee also: AbstractMesh, FermionicFragmentMatsubaraGrid.\n\n\n\n\n\nbuild_kernel(am::AbstractMesh, bg::BosonicImaginaryTimeGrid)\n\nTry to build bosonic kernel function in imaginary time axis.\n\nSee also: AbstractMesh, BosonicImaginaryTimeGrid.\n\n\n\n\n\nbuild_kernel(am::AbstractMesh, bg::BosonicFragmentTimeGrid)\n\nTry to build bosonic kernel function in imaginary time axis. Note that bg contains incomplete imaginary time data.\n\nSee also: AbstractMesh, BosonicFragmentTimeGrid.\n\n\n\n\n\nbuild_kernel(am::AbstractMesh, bg::BosonicMatsubaraGrid)\n\nTry to build bosonic kernel function in Matsubara frequency axis.\n\nSee also: AbstractMesh, BosonicMatsubaraGrid.\n\n\n\n\n\nbuild_kernel(am::AbstractMesh, bg::BosonicFragmentMatsubaraGrid)\n\nTry to build bosonic kernel function in Matsubara frequency axis.\n\nSee also: AbstractMesh, BosonicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"function"},{"location":"library/kernel.html#ACFlow.build_kernel_symm","page":"Kernels","title":"ACFlow.build_kernel_symm","text":"build_kernel_symm(am::AbstractMesh, bg::BosonicImaginaryTimeGrid)\n\nTry to build bosonic kernel function in imaginary time axis (just for correlator of Hermitian operator only).\n\nSee also: AbstractMesh, BosonicImaginaryTimeGrid.\n\n\n\n\n\nbuild_kernel_symm(am::AbstractMesh, bg::BosonicFragmentTimeGrid)\n\nTry to build bosonic kernel function in imaginary time axis (just for correlator of Hermitian operator only). Note that bg contains incomplete imaginary time data.\n\nSee also: AbstractMesh, BosonicFragmentTimeGrid.\n\n\n\n\n\nbuild_kernel_symm(am::AbstractMesh, bg::BosonicMatsubaraGrid)\n\nTry to build bosonic kernel function in Matsubara frequency axis (just for correlator of Hermitian operator only). This function support preblur algorithm.\n\nSee also: AbstractMesh, BosonicMatsubaraGrid.\n\n\n\n\n\nbuild_kernel_symm(am::AbstractMesh, bg::BosonicFragmentMatsubaraGrid)\n\nTry to build bosonic kernel function in Matsubara frequency axis (just for correlator of Hermitian operator only). This function support preblur algorithm.\n\nSee also: AbstractMesh, BosonicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"function"},{"location":"library/kernel.html#Utilities","page":"Kernels","title":"Utilities","text":"","category":"section"},{"location":"library/kernel.html","page":"Kernels","title":"Kernels","text":"make_blur\nmake_singular_space\nmake_gauss_peaks","category":"page"},{"location":"library/kernel.html#ACFlow.make_blur","page":"Kernels","title":"ACFlow.make_blur","text":"make_blur(am::AbstractMesh, A::Vector{F64}, blur::F64)\n\nTry to blur the given spectrum A, which is defined in am. And blur is the blur parameter.\n\n\n\n\n\n","category":"function"},{"location":"library/kernel.html#ACFlow.make_singular_space","page":"Kernels","title":"ACFlow.make_singular_space","text":"make_singular_space(kernel::Matrix{F64})\n\nPerform singular value decomposition for the input matrix.\n\n\n\n\n\n","category":"function"},{"location":"library/kernel.html#ACFlow.make_gauss_peaks","page":"Kernels","title":"ACFlow.make_gauss_peaks","text":"make_gauss_peaks(blur::F64)\n\nTry to generate a series of gaussian peaks along a linear mesh, whose energy range is [-5 * blur, +5 * blur].\n\n\n\n\n\n","category":"function"},{"location":"library/model.html#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"library/model.html","page":"Models","title":"Models","text":"For default model functions.","category":"page"},{"location":"library/model.html","page":"Models","title":"Models","text":"The ACFlow toolkit supports various model functions, such as flat, Gaussian, Lorentzian, and a few unusual models. They are useful for the MaxEnt and StochAC solvers. In order to build these model functions, we need some additional parameters, including Gamma, s, s_1, and s_2. They should be setup by using the parameter pmodel.","category":"page"},{"location":"library/model.html#Contents","page":"Models","title":"Contents","text":"","category":"section"},{"location":"library/model.html","page":"Models","title":"Models","text":"Pages = [\"model.md\"]\nDepth = 2","category":"page"},{"location":"library/model.html#Index","page":"Models","title":"Index","text":"","category":"section"},{"location":"library/model.html","page":"Models","title":"Models","text":"Pages = [\"model.md\"]","category":"page"},{"location":"library/model.html#Flat-Model","page":"Models","title":"Flat Model","text":"","category":"section"},{"location":"library/model.html","page":"Models","title":"Models","text":"build_flat_model","category":"page"},{"location":"library/model.html#ACFlow.build_flat_model","page":"Models","title":"ACFlow.build_flat_model","text":"build_flat_model(am::AbstractMesh)\n\nTry to build a flat model in am. Then this model function is normalized. Only this model function is suitable for the StochAC solver.\n\nSee also: AbstractMesh.\n\n\n\n\n\n","category":"function"},{"location":"library/model.html#Gaussian-Models","page":"Models","title":"Gaussian Models","text":"","category":"section"},{"location":"library/model.html","page":"Models","title":"Models","text":"note: Note\nThis class includes the standard Gaussian model, shifted Gaussian model, and two-Gaussians model.","category":"page"},{"location":"library/model.html","page":"Models","title":"Models","text":"build_gaussian_model\nbuild_1gaussian_model\nbuild_2gaussians_model","category":"page"},{"location":"library/model.html#ACFlow.build_gaussian_model","page":"Models","title":"ACFlow.build_gaussian_model","text":"build_gaussian_model(am::AbstractMesh, Γ::F64)\n\nTry to build a Gaussian model, which is then normalized. The argument Γ is used to control the width of the Gaussian peak.\n\nSee also: AbstractMesh.\n\n\n\n\n\n","category":"function"},{"location":"library/model.html#ACFlow.build_1gaussian_model","page":"Models","title":"ACFlow.build_1gaussian_model","text":"build_1gaussian_model(am::AbstractMesh, Γ::F64, s::F64)\n\nTry to build a shifted Gaussian model, which is then normalized. The argument Γ is used to control the width of the Gaussian peak, and s means the shift of the central peak. If s > 0, the peak is shifted to positive half-axis, and vice versa.\n\nSee also: AbstractMesh.\n\n\n\n\n\n","category":"function"},{"location":"library/model.html#ACFlow.build_2gaussians_model","page":"Models","title":"ACFlow.build_2gaussians_model","text":"build_2gaussians_model(am::AbstractMesh, Γ::F64, s₁::F64, s₂::F64)\n\nTry to build a Two Gaussians model, which is then normalized. The argument Γ is used to control the width of the Gaussian peak, and s₁ and s₂ denote the centers of the two peaks.\n\nSee also: AbstractMesh.\n\n\n\n\n\n","category":"function"},{"location":"library/model.html#Lorentzian-Models","page":"Models","title":"Lorentzian Models","text":"","category":"section"},{"location":"library/model.html","page":"Models","title":"Models","text":"note: Note\nThis class includes the standard Lorentzian model, shifted Lorentzian model, and two-Lorentzians model.","category":"page"},{"location":"library/model.html","page":"Models","title":"Models","text":"build_lorentzian_model\nbuild_1lorentzian_model\nbuild_2lorentzians_model","category":"page"},{"location":"library/model.html#ACFlow.build_lorentzian_model","page":"Models","title":"ACFlow.build_lorentzian_model","text":"build_lorentzian_model(am::AbstractMesh, Γ::F64)\n\nTry to build a Lorentzian model, which is then normalized. The argument Γ is used to control the width of the Lorentzian peak.\n\nSee also: AbstractMesh.\n\n\n\n\n\n","category":"function"},{"location":"library/model.html#ACFlow.build_1lorentzian_model","page":"Models","title":"ACFlow.build_1lorentzian_model","text":"build_1lorentzian_model(am::AbstractMesh, Γ::F64, s::F64)\n\nTry to build a shifted Lorentzian model, which is then normalized. The argument Γ is used to control the width of the Lorentzian peak, and s means the shift of the central peak. If s > 0, the peak is shifted to positive half-axis, and vice versa.\n\nSee also: AbstractMesh.\n\n\n\n\n\n","category":"function"},{"location":"library/model.html#ACFlow.build_2lorentzians_model","page":"Models","title":"ACFlow.build_2lorentzians_model","text":"build_2lorentzians_model(am::AbstractMesh, Γ::F64, s₁::F64, s₂::F64)\n\nTry to build a Two-Lorentzians model, which is then normalized. The argument Γ is used to control the width of the Lorentzian peak, and s₁ and s₂ denote the centers of the two peaks.\n\nSee also: AbstractMesh.\n\n\n\n\n\n","category":"function"},{"location":"library/model.html#Unusual-Models","page":"Models","title":"Unusual Models","text":"","category":"section"},{"location":"library/model.html","page":"Models","title":"Models","text":"note: Note\nThis class includes the Rise-And-Decay model, file model, and function model.","category":"page"},{"location":"library/model.html","page":"Models","title":"Models","text":"build_risedecay_model\nbuild_file_model\nbuild_func_model","category":"page"},{"location":"library/model.html#ACFlow.build_risedecay_model","page":"Models","title":"ACFlow.build_risedecay_model","text":"build_risedecay_model(am::AbstractMesh, Γ::F64)\n\nTry to build a Rise-And-Decay model, which is then normalized. This model function is defined on positive half-axis, so it is more suitable for the bosonic response function.\n\nSee also: AbstractMesh.\n\n\n\n\n\n","category":"function"},{"location":"library/model.html#ACFlow.build_file_model","page":"Models","title":"ACFlow.build_file_model","text":"build_file_model(am::AbstractMesh, fn::String)\n\nTry to read a model function from external file (specified by fn). Note that the mesh used to generate the model function must be compatible with am. In addition, the model function will be normalized automatically.\n\nSee also: AbstractMesh.\n\n\n\n\n\n","category":"function"},{"location":"library/model.html#ACFlow.build_func_model","page":"Models","title":"ACFlow.build_func_model","text":"build_func_model(fun::Function, am::AbstractMesh, kwargs...)\n\nTry to build a model function by customized function fun. kwargs denotes the arguments required by fun. Actually, this feature does not really work.\n\nSee also: AbstractMesh.\n\n\n\n\n\n","category":"function"},{"location":"library/global.html#Constants","page":"Constants","title":"Constants","text":"","category":"section"},{"location":"library/global.html","page":"Constants","title":"Constants","text":"Define some type aliases and string constants for the ACFlow toolkit.","category":"page"},{"location":"library/global.html#Contents","page":"Constants","title":"Contents","text":"","category":"section"},{"location":"library/global.html","page":"Constants","title":"Constants","text":"Pages = [\"global.md\"]\nDepth = 2","category":"page"},{"location":"library/global.html#Index","page":"Constants","title":"Index","text":"","category":"section"},{"location":"library/global.html","page":"Constants","title":"Constants","text":"Pages = [\"global.md\"]","category":"page"},{"location":"library/global.html#Numerical-Types","page":"Constants","title":"Numerical Types","text":"","category":"section"},{"location":"library/global.html","page":"Constants","title":"Constants","text":"I32\nI64\nAPI\nF32\nF64\nAPF\nC32\nC64\nAPC\nR32\nR64\nAPR\nN32\nN64\nAPN","category":"page"},{"location":"library/global.html#ACFlow.I32","page":"Constants","title":"ACFlow.I32","text":"I32\n\nAlias of Integer type (32 bit).\n\nSee also: R32, N32.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACFlow.I64","page":"Constants","title":"ACFlow.I64","text":"I64\n\nAlias of Integer type (64 bit).\n\nSee also: R64, N64.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACFlow.API","page":"Constants","title":"ACFlow.API","text":"API\n\nAlias of Integer type (Arbitrary Precision Integer).\n\nSee also: APF, APC.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACFlow.F32","page":"Constants","title":"ACFlow.F32","text":"F32\n\nAlias of Float type (32 bit).\n\nSee also: R32, N32.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACFlow.F64","page":"Constants","title":"ACFlow.F64","text":"F64\n\nAlias of Float type (64 bit).\n\nSee also: R64, N64.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACFlow.APF","page":"Constants","title":"ACFlow.APF","text":"APF\n\nAlias of Float type (Arbitrary Precision Float).\n\nSee also: API, APC.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACFlow.C32","page":"Constants","title":"ACFlow.C32","text":"C32\n\nAlias of Complex type (32 bit).\n\nSee also: R32, N32.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACFlow.C64","page":"Constants","title":"ACFlow.C64","text":"C64\n\nAlias of Complex type (64 bit).\n\nSee also: R64, N64.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACFlow.APC","page":"Constants","title":"ACFlow.APC","text":"APC\n\nAlias of Complex type (Arbitrary Precision Complex).\n\nSee also: API, APF.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACFlow.R32","page":"Constants","title":"ACFlow.R32","text":"R32\n\nAlias of Integer and Float types (32 bit). Here R means Real.\n\nSee also: N32, N64, APN.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACFlow.R64","page":"Constants","title":"ACFlow.R64","text":"R64\n\nAlias of Integer and Float types (64 bit). Here R means Real.\n\nSee also: N32, N64, APN.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACFlow.APR","page":"Constants","title":"ACFlow.APR","text":"APR\n\nAlias of Integer and Float types (Arbitrary Precision). Here R means Real.\n\nSee also: N32, N64, APN.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACFlow.N32","page":"Constants","title":"ACFlow.N32","text":"N32\n\nAlias of Integer, Float, and Complex types (32 bit). Here N means Number.\n\nSee also: R32, R64, APR.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACFlow.N64","page":"Constants","title":"ACFlow.N64","text":"N64\n\nAlias of Integer, Float, and Complex types (64 bit). Here N means Number.\n\nSee also: R32, R64, APR.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACFlow.APN","page":"Constants","title":"ACFlow.APN","text":"APN\n\nAlias of Integer, Float, and Complex types (Arbitrary Precision). Here N means Number.\n\nSee also: R32, R64, APR.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#String-Constants","page":"Constants","title":"String Constants","text":"","category":"section"},{"location":"library/global.html","page":"Constants","title":"Constants","text":"__LIBNAME__\n__VERSION__\n__RELEASE__\n__AUTHORS__","category":"page"},{"location":"library/global.html#ACFlow.__LIBNAME__","page":"Constants","title":"ACFlow.__LIBNAME__","text":"__LIBNAME__\n\nName of this julia toolkit.\n\nSee also: __VERSION__.\n\n\n\n\n\n","category":"constant"},{"location":"library/global.html#ACFlow.__VERSION__","page":"Constants","title":"ACFlow.__VERSION__","text":"__VERSION__\n\nVersion of this julia toolkit.\n\nSee also: __RELEASE__.\n\n\n\n\n\n","category":"constant"},{"location":"library/global.html#ACFlow.__RELEASE__","page":"Constants","title":"ACFlow.__RELEASE__","text":"__RELEASE__\n\nRelease date of this julia toolkit.\n\nSee also: __AUTHORS__.\n\n\n\n\n\n","category":"constant"},{"location":"library/global.html#ACFlow.__AUTHORS__","page":"Constants","title":"ACFlow.__AUTHORS__","text":"__AUTHORS__\n\nCore authors of this julia toolkit.\n\nSee also: __LIBNAME__.\n\n\n\n\n\n","category":"constant"},{"location":"library/global.html#Utilities","page":"Constants","title":"Utilities","text":"","category":"section"},{"location":"library/global.html","page":"Constants","title":"Constants","text":"authors","category":"page"},{"location":"library/global.html#ACFlow.authors","page":"Constants","title":"ACFlow.authors","text":"authors()\n\nPrint authors / contributors of the ACFlow toolkit.\n\nSee also: __AUTHORS__.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"Define various solvers for the ACFlow toolkit.","category":"page"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"Now the ACFlow toolkit supports six analytic continuation solvers. They are:","category":"page"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"MaxEnt (Maximum Entropy Method, see maxent.jl)\nNevanAC (Nevanlinna Analytical Continuation, see nac.jl)\nStochAC (Stochastic Analytic Continuation, see sac.jl)\nStochSK (Stochastic Analytic Continuation, see san.jl)\nStochOM (Stochastic Optimization Method, see som.jl)\nStochPX (Stochastic Pole Expansion, see spx.jl)","category":"page"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"Note that the StochAC solver is based on the Beach's variant, while the StochSK solver is based on the Sandvik's variant.","category":"page"},{"location":"library/solver.html#Contents","page":"Solvers","title":"Contents","text":"","category":"section"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"Pages = [\"solver.md\"]\nDepth = 3","category":"page"},{"location":"library/solver.html#Index","page":"Solvers","title":"Index","text":"","category":"section"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"Pages = [\"solver.md\"]","category":"page"},{"location":"library/solver.html#Abstract-Structs","page":"Solvers","title":"Abstract Structs","text":"","category":"section"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"AbstractSolver\nAbstractMC","category":"page"},{"location":"library/solver.html#ACFlow.AbstractSolver","page":"Solvers","title":"ACFlow.AbstractSolver","text":"AbstractSolver\n\nAn abstract type representing the solver for analytic continuation problem. It is used to build the internal type system. All the other solvers are its sub-types.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#ACFlow.AbstractMC","page":"Solvers","title":"ACFlow.AbstractMC","text":"AbstractMC\n\nAn abstract type representing the Monte Carlo engine. It is used to build the internal type system.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#MaxEnt-Solver","page":"Solvers","title":"MaxEnt Solver","text":"","category":"section"},{"location":"library/solver.html#Structs","page":"Solvers","title":"Structs","text":"","category":"section"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"MaxEntSolver\nMaxEntContext","category":"page"},{"location":"library/solver.html#ACFlow.MaxEntSolver","page":"Solvers","title":"ACFlow.MaxEntSolver","text":"MaxEntSolver\n\nIt represents the analytic continuation solver that implements the maximum entropy method.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#ACFlow.MaxEntContext","page":"Solvers","title":"ACFlow.MaxEntContext","text":"MaxEntContext\n\nMutable struct. It is used within the MaxEnt solver only.\n\nMembers\n\nGᵥ     -> Input data for correlator.\nσ²     -> Actually 1.0 / σ².\ngrid   -> Grid for input data.\nmesh   -> Mesh for output spectrum.\nmodel  -> Default model function.\nkernel -> Default kernel function.\nVₛ     -> Matrix from singular value decomposition.\nW₂     -> Precomputed array.\nW₃     -> Precomputed array.\nBₘ     -> Precomputed array.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#Functions","page":"Solvers","title":"Functions","text":"","category":"section"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"solve(S::MaxEntSolver, rd::RawData)\ninit(S::MaxEntSolver, rd::RawData)\nACFlow.run(mec::MaxEntContext)\nACFlow.last(mec::MaxEntContext, svec::Vector, sol::Dict)\nhistoric\nclassic\nbryan\nchi2kink\noptimizer\nprecompute\nf_and_J\nf_and_J_od\nsvd_to_real\nsvd_to_real_od\ncalc_entropy\ncalc_entropy_od\ncalc_bayes\ncalc_bayes_od\ncalc_chi2(mec::MaxEntContext, A::Vector{F64})","category":"page"},{"location":"library/solver.html#ACFlow.solve-Tuple{MaxEntSolver, RawData}","page":"Solvers","title":"ACFlow.solve","text":"solve(S::MaxEntSolver, rd::RawData)\n\nSolve the analytic continuation problem by the maximum entropy method.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init-Tuple{MaxEntSolver, RawData}","page":"Solvers","title":"ACFlow.init","text":"init(S::MaxEntSolver, rd::RawData)\n\nInitialize the MaxEnt solver and return a MaxEntContext struct.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.run-Tuple{MaxEntContext}","page":"Solvers","title":"ACFlow.run","text":"run(mec::MaxEntContext)\n\nPerform maximum entropy simulation with different algorithms. Now it supports the historic, classic, bryan, and chi2kink algorithms.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.last-Tuple{MaxEntContext, Vector, Dict}","page":"Solvers","title":"ACFlow.last","text":"last(mec::MaxEntContext, svec::Vector, sol::Dict)\n\nPostprocess the results generated during the maximum entropy simulations. Here sol is the final solution for the analytic continuation problem, while svec contains all the intermediate results (it is a vector of dictionary actually).\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.historic","page":"Solvers","title":"ACFlow.historic","text":"historic(mec::MaxEntContext)\n\nApply the historic algorithm to solve the analytic continuation problem. It choose α in a way that χ² ≈ N.\n\nFor the historic algorithm, alpha is usually 10⁶, and ratio is 10.0. It is compatible with the Bayesian Reconstruction entropy.\n\nSee also: MaxEntContext.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.classic","page":"Solvers","title":"ACFlow.classic","text":"classic(mec::MaxEntContext)\n\nApply the classic algorithm to solve the analytic continuation problem.\n\nClassic algorithm uses Bayes statistics to approximately determine the most probable value of α. We always start at a large value of α, where the optimization yields basically the default model, therefore u_vec is only a few steps away from 0 (= default model). And then we gradually decrease α, step by step moving away from the default model towards data fitting. Using u_vec as start for the next (smaller) α brings a great speedup into this procedure.\n\nFor the classic algorithm, alpha is usually 10⁶, and ratio is 10.0. It is incompatible with the Bayesian Reconstruction entropy.\n\nSee also: MaxEntContext.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.bryan","page":"Solvers","title":"ACFlow.bryan","text":"bryan(mec::MaxEntContext)\n\nApply the bryan algorithm to solve the analytic continuation problem.\n\nBryan's maxent calculates an average of spectral functions, weighted by their Bayesian probability.\n\nFor the bryan algorithm, alpha is usually 500, and ratio is 1.1. It is incompatible with the Bayesian Reconstruction entropy.\n\nSee also: MaxEntContext.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.chi2kink","page":"Solvers","title":"ACFlow.chi2kink","text":"chi2kink(mec::MaxEntContext)\n\nApply the chi2kink algorithm to solve the analytic continuation problem.\n\nWe start with an optimization at a large value of α, where we should get only the default model. And then, α is decreased step-by-step, until the minimal value of α is reached. Then, we fit a function\n\nϕ(x; a, b, c, d) = a + b / [1 + exp(-d*(x-c))],\n\nfrom which the optimal α is determined by\n\nx_opt = c - fit_position / d,\n\nand\n\nalpha_opt = 10^x_opt.\n\nFor the chi2kink algorithm, alpha is usually 10⁹, ratio is 10.0, the number of alpha parameters is 12. It is compatible with the Bayesian Reconstruction entropy.\n\nSee also: MaxEntContext.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.optimizer","page":"Solvers","title":"ACFlow.optimizer","text":"optimizer(mec::MaxEntContext, α::F64, us::Vector{F64}, use_bayes::Bool)\n\nOptimization of maxent functional for a given value of α. Since a priori the best value of α is unknown, this function has to be called several times in order to find a good value.\n\nα means a weight factor of the entropy. us is a vector in singular space. It is used as a starting value for the optimization. For the very first optimization, done at large α, we use zeros, which corresponds to the default model. Then we use the result of the previous optimization as a starting value. use_bayes determines whether to use the Bayesian inference parameters for α.\n\nThis function will return a dictionary object that holds the results of the optimization, e.g. spectral function, χ² deviation.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.precompute","page":"Solvers","title":"ACFlow.precompute","text":"precompute(Gᵥ::Vector{F64}, σ²::Vector{F64},\n           am::AbstractMesh,\n           D::Vector{F64},\n           K::Matrix{F64})\n\nPrecompute some key coefficients. Here Gᵥ and σ² are input data, am is the mesh for spectrum, D is the default model, and K is the kernel function.\n\n\n\n\n\nprecompute(grid::AbstractGrid,\n           mesh::AbstractMesh,\n           Gᵥ::Vector{APC})\n\nPrecompute some key quantities, such as Φ, 𝒜, ℋ, and 𝑎𝑏. Note that Φ and 𝒜 won't be changed any more. But ℋ and 𝑎𝑏 should be updated by the Hardy basis optimization to get a smooth spectrum. Here Gᵥ is input data, grid is the grid for input data, and mesh is the mesh for output spectrum.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.f_and_J","page":"Solvers","title":"ACFlow.f_and_J","text":"f_and_J(u::Vector{F64}, mec::MaxEntContext, α::F64)\n\nThis function evaluates the function whose root we want to find. Here u is a singular space vector that parametrizes the spectral function, and α is a (positive) weight factor of the entropy.\n\nIt returns f, value of the function whose zero we want to find, and J, jacobian at the current position.\n\nSee also: f_and_J_od.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.f_and_J_od","page":"Solvers","title":"ACFlow.f_and_J_od","text":"f_and_J_od(u::Vector{F64}, mec::MaxEntContext, α::F64)\n\nThis function evaluates the function whose root we want to find. Here u is a singular space vector that parametrizes the spectral function, and α is a (positive) weight factor of the entropy.\n\nIt returns f, value of the function whose zero we want to find, and J, jacobian at the current position.\n\nThis function is similar to f_and_J, but for offdiagonal elements.\n\nSee also: f_and_J.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.svd_to_real","page":"Solvers","title":"ACFlow.svd_to_real","text":"svd_to_real(mec::MaxEntContext, u::Vector{F64})\n\nGo from singular value space to real space. It will transform the singular space vector u into real-frequency space (to get the spectral function) by A(ω) = D(ω) eⱽᵘ, where D(ω) is the default model V is the matrix from the singular value decomposition. The argument u means a singular space vector that parametrizes the spectral function.\n\nSee also: svd_to_real_od.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.svd_to_real_od","page":"Solvers","title":"ACFlow.svd_to_real_od","text":"svd_to_real_od(mec::MaxEntContext, u::Vector{F64})\n\nGo from singular value space to real space. It will transform the singular space vector u into real-frequency space in the case of an offdiagonal element. It will return the spectral function.\n\nSee also: svd_to_real.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_entropy","page":"Solvers","title":"ACFlow.calc_entropy","text":"calc_entropy(mec::MaxEntContext, A::Vector{F64}, u::Vector{F64})\n\nIt computes entropy for positive definite spectral function. Here the arguments A means spectral function and u means a singular space vector that parametrizes the spectral function.\n\nSee also: calc_entropy_od.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_entropy_od","page":"Solvers","title":"ACFlow.calc_entropy_od","text":"calc_entropy_od(mec::MaxEntContext, A::Vector{F64})\n\nIt compute positive-negative entropy for spectral function with norm 0. Here the argument A means spectral function.\n\nSee also: calc_entropy.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_bayes","page":"Solvers","title":"ACFlow.calc_bayes","text":"calc_bayes(mec::MaxEntContext,\n           A::Vector{F64},\n           S::F64, χ²::F64, α::F64)\n\nIt calculates Bayesian convergence criterion (ng, tr, and conv) for classic maxent (maximum of probablility distribution) and then Bayesian a-posteriori probability (log_prob) for α after optimization of A.\n\nHere, A is the spectral function, S the entropy, χ² the deviation, and α weight factor of the entropy.\n\nSee also: calc_bayes_od.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_bayes_od","page":"Solvers","title":"ACFlow.calc_bayes_od","text":"calc_bayes_od(mec::MaxEntContext,\n              A::Vector{F64},\n              S::F64, χ²::F64, α::F64)\n\nIt calculates Bayesian convergence criterion (ng, tr, and conv) for classic maxent (maximum of probablility distribution) and then Bayesian a-posteriori probability (log_prob) for α after optimization of A.\n\nHere, A is the spectral function, S the entropy, χ² the deviation, and α weight factor of the entropy.\n\nIt is just a offdiagonal version of calc_bayes().\n\nSee also: calc_bayes.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_chi2-Tuple{MaxEntContext, Vector{Float64}}","page":"Solvers","title":"ACFlow.calc_chi2","text":"calc_chi2(mec::MaxEntContext, A::Vector{F64})\n\nIt computes the χ²-deviation of the spectral function A.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#NevanAC-Solver","page":"Solvers","title":"NevanAC Solver","text":"","category":"section"},{"location":"library/solver.html#Structs-2","page":"Solvers","title":"Structs","text":"","category":"section"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"NevanACSolver\nNevanACContext","category":"page"},{"location":"library/solver.html#ACFlow.NevanACSolver","page":"Solvers","title":"ACFlow.NevanACSolver","text":"NevanACSolver\n\nIt represents the analytic continuation solver that implements the Nevanlinna analytical continuation (It doesn't support the analytic confinuations for matrix-valued Green's functions).\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#ACFlow.NevanACContext","page":"Solvers","title":"ACFlow.NevanACContext","text":"NevanACContext\n\nMutable struct. It is used within the NevanAC solver only.\n\nMembers\n\nGᵥ   -> Input data for correlator.\ngrid -> Grid for input data.\nmesh -> Mesh for output spectrum.\nΦ    -> Φ vector in Schur algorithm.\n𝒜    -> Coefficients matrix abcd in Schur algorithm.\nℋ    -> Hardy matrix for Hardy basis optimization.\n𝑎𝑏   -> Coefficients matrix for expanding θ with Hardy basis.\nhmin -> Minimal value of the order of Hardy basis functions.\nhopt -> Optimal value of the order of Hardy basis functions.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#Functions-2","page":"Solvers","title":"Functions","text":"","category":"section"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"solve(S::NevanACSolver, rd::RawData)\ninit(S::NevanACSolver, rd::RawData)\nACFlow.run(nac::NevanACContext)\nACFlow.last(nac::NevanACContext)\nprecompute(grid::AbstractGrid, mesh::AbstractMesh, Gᵥ::Vector{APC})\ncalc_mobius\ncalc_inv_mobius\ncalc_pick\ncalc_phis\ncalc_abcd\ncalc_hbasis\ncalc_hmatrix\ncalc_theta(𝒜::Array{APC,3}, ℋ::Array{APC,2}, 𝑎𝑏::Vector{C64})\ncalc_green\ncalc_noptim\ncalc_hmin!\ncalc_hopt!\nhardy_optimize!\nsmooth_norm\ncheck_pick\ncheck_causality","category":"page"},{"location":"library/solver.html#ACFlow.solve-Tuple{NevanACSolver, RawData}","page":"Solvers","title":"ACFlow.solve","text":"solve(S::NevanACSolver, rd::RawData)\n\nSolve the analytic continuation problem by the Nevanlinna analytical continuation method.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init-Tuple{NevanACSolver, RawData}","page":"Solvers","title":"ACFlow.init","text":"init(S::NevanACSolver, rd::RawData)\n\nInitialize the NevanAC solver and return a NevanACContext struct.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.run-Tuple{NevanACContext}","page":"Solvers","title":"ACFlow.run","text":"run(nac::NevanACContext)\n\nPerform Hardy basis optimization to smooth the spectrum. the members ℋ, 𝑎𝑏, hmin, and hopt of the NevanACContext object (nac) should be updated in this function.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.last-Tuple{NevanACContext}","page":"Solvers","title":"ACFlow.last","text":"last(nac::NevanACContext)\n\nPostprocess the results generated during the Nevanlinna analytical continuation simulations.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.precompute-Tuple{AbstractGrid, AbstractMesh, Vector{Complex{BigFloat}}}","page":"Solvers","title":"ACFlow.precompute","text":"precompute(grid::AbstractGrid,\n           mesh::AbstractMesh,\n           Gᵥ::Vector{APC})\n\nPrecompute some key quantities, such as Φ, 𝒜, ℋ, and 𝑎𝑏. Note that Φ and 𝒜 won't be changed any more. But ℋ and 𝑎𝑏 should be updated by the Hardy basis optimization to get a smooth spectrum. Here Gᵥ is input data, grid is the grid for input data, and mesh is the mesh for output spectrum.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.calc_mobius","page":"Solvers","title":"ACFlow.calc_mobius","text":"calc_mobius(z::Vector{APC})\n\nA direct Mobius transformation.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_inv_mobius","page":"Solvers","title":"ACFlow.calc_inv_mobius","text":"calc_inv_mobius(z::Vector{APC})\n\nAn inverse Mobius transformation.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_pick","page":"Solvers","title":"ACFlow.calc_pick","text":"calc_pick(k::I64, ℎ::Vector{APC}, λ::Vector{APC})\n\nTry to calculate the Pick matrix, anc check whether it is a positive semidefinite matrix. See Eq. (5) in Fei's NAC paper.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_phis","page":"Solvers","title":"ACFlow.calc_phis","text":"calc_phis(grid::AbstractGrid, Gᵥ::Vector{APC})\n\nTry to calculate the Φ vector, which is used to calculate the 𝒜 matrix. Note that Φ should not be changed anymore once it has been established.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_abcd","page":"Solvers","title":"ACFlow.calc_abcd","text":"calc_abcd(grid::AbstractGrid, mesh::AbstractMesh, Φ::Vector{APC})\n\nTry to calculate the coefficients matrix abcd (here it is called 𝒜), which is then used to calculate θ. See Eq. (8) in Fei's NAC paper.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_hbasis","page":"Solvers","title":"ACFlow.calc_hbasis","text":"calc_hbasis(z::APC, k::I64)\n\nTry to calculate the Hardy basis f^k(z).\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_hmatrix","page":"Solvers","title":"ACFlow.calc_hmatrix","text":"calc_hmatrix(mesh::AbstractMesh, H::I64)\n\nTry to calculate f^k(z) f^k(z)^* for 0 ≤ 𝑘 ≤ 𝐻-1, which is called the hardy matrix (ℋ) and is used to evaluate heta_M+1.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_theta-Tuple{Array{Complex{BigFloat}, 3}, Matrix{Complex{BigFloat}}, Vector{ComplexF64}}","page":"Solvers","title":"ACFlow.calc_theta","text":"calc_theta(𝒜::Array{APC,3}, ℋ::Array{APC,2}, 𝑎𝑏::Vector{C64})\n\nTry to calculate the contractive function θ(z). 𝒜 is the coefficients matrix abcd, ℋ is the Hardy matrix, and 𝑎𝑏 are complex coefficients for expanding θₘ₊₁. See Eq. (7) in Fei's NAC paper.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.calc_green","page":"Solvers","title":"ACFlow.calc_green","text":"calc_green(𝒜::Array{APC,3}, ℋ::Array{APC,2}, 𝑎𝑏::Vector{C64})\n\nFirstly we try to calculate θ. Then θ is back transformed to a Nevanlinna interpolant via the inverse Mobius transform. Here, 𝒜 (abcd matrix), ℋ (Hardy matrix), and 𝑎𝑏 are used to evaluate θ.\n\n\n\n\n\ncalc_green(Λ::Array{F64,2}, nk::I64)\n\nTry to reconstruct the correlator via the field configuration.\n\nSee also: calc_error.\n\n\n\n\n\ncalc_green(P::Vector{I64},\n           A::Vector{F64},\n           𝕊::Vector{F64},\n           Λ::Array{F64,2})\n\nReconstruct green's function at imaginary axis by the pole expansion.\n\n\n\n\n\ncalc_green(P::Vector{I64},\n           A::Vector{F64},\n           𝕊::Vector{F64},\n           mesh::AbstractMesh,\n           fmesh::AbstractMesh)\n\nReconstruct green's function at real axis by the pole expansion. It is for the fermionic systems only.\n\n\n\n\n\ncalc_green(P::Vector{I64},\n           A::Vector{F64},\n           𝕊::Vector{F64},\n           mesh::AbstractMesh,\n           fmesh::AbstractMesh, χ₀::F64, bsymm::Bool)\n\nReconstruct green's function at real axis by the pole expansion. Here, χ₀ is actually -G(iωₙ = 0). And the argument bsymm is used to distinguish two different bosonic kernels. If bsymm is false, it means that the kernel is boson. If bsymm is true, the kernel is bsymm. It is for the bosonic systems only.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_noptim","page":"Solvers","title":"ACFlow.calc_noptim","text":"calc_noptim(ωₙ::Vector{APC}, Gₙ::Vector{APC})\n\nEvaluate the optimal value for the size of input data (how may frequency points are actually used in the analytic continuation simulations) via the Pick criterion.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_hmin!","page":"Solvers","title":"ACFlow.calc_hmin!","text":"calc_hmin!(nac::NevanACContext)\n\nTry to perform Hardy basis optimization. Such that the Hardy matrix ℋ and the corresponding coefficients 𝑎𝑏 are updated. They are used to calculate θ, which is then back transformed to generate smooth G (i.e., the spectrum) at real axis.\n\nThis function will determine the minimal value of H (hmin). Of course, ℋ and 𝑎𝑏 in NevanACContext object are also changed.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_hopt!","page":"Solvers","title":"ACFlow.calc_hopt!","text":"calc_hopt!(nac::NevanACContext)\n\nTry to perform Hardy basis optimization. Such that the Hardy matrix ℋ and the corresponding coefficients 𝑎𝑏 are updated. They are used to calculate θ, which is then back transformed to generate smooth G (i.e., the spectrum) at real axis.\n\nThis function will determine the optimal value of H (hopt). Of course, ℋ and 𝑎𝑏 in NevanACContext object are also changed.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.hardy_optimize!","page":"Solvers","title":"ACFlow.hardy_optimize!","text":"hardy_optimize!(nac::NevanACContext,\n                ℋ::Array{APC,2},\n                𝑎𝑏::Vector{C64},\n                H::I64)\n\nFor given Hardy matrix ℋ, try to update the expanding coefficients 𝑎𝑏 by minimizing the smooth norm.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.smooth_norm","page":"Solvers","title":"ACFlow.smooth_norm","text":"smooth_norm(nac::NevanACContext, ℋ::Array{APC,2}, 𝑎𝑏::Vector{C64})\n\nEstablish the smooth norm, which is used to improve the smoothness of the output spectrum.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.check_pick","page":"Solvers","title":"ACFlow.check_pick","text":"check_pick(wn::Vector{APC}, gw::Vector{APC}, Nopt::I64)\n\nCheck whether the input data are valid (the Pick criterion is satisfied). Here, wn is the Matsubara frequency, gw is the Matsubara function, and Nopt is the optimized number of Matsubara data points.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.check_causality","page":"Solvers","title":"ACFlow.check_causality","text":"check_causality(ℋ::Array{APC,2}, 𝑎𝑏::Vector{C64})\n\nCheck causality of the Hardy coefficients 𝑎𝑏.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#StochAC-Solver","page":"Solvers","title":"StochAC Solver","text":"","category":"section"},{"location":"library/solver.html#Structs-3","page":"Solvers","title":"Structs","text":"","category":"section"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"StochACSolver\nStochACMC\nStochACElement\nStochACContext","category":"page"},{"location":"library/solver.html#ACFlow.StochACSolver","page":"Solvers","title":"ACFlow.StochACSolver","text":"StochACSolver\n\nIt represents the analytic continuation solver that implements the stochastic analytic continuation method (K. S. D. Beach's version).\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#ACFlow.StochACMC","page":"Solvers","title":"ACFlow.StochACMC","text":"StochACMC\n\nMutable struct. It is used within the StochAC solver. It includes random number generator and some counters.\n\nMembers\n\nrng  -> Random number generator.\nMacc -> Counter for move operation (accepted).\nMtry -> Counter for move operation (tried).\nSacc -> Counter for swap operation (accepted).\nStry -> Counter for swap operation (tried).\n\nSee also: StochACSolver.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#ACFlow.StochACElement","page":"Solvers","title":"ACFlow.StochACElement","text":"StochACElement\n\nMutable struct. It is used to record the field configurations, which will be sampled by  Monte Carlo sweeping procedure.\n\nMembers\n\nΓₚ -> It means the positions of the δ functions.\nΓₐ -> It means the weights / amplitudes of the δ functions.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#ACFlow.StochACContext","page":"Solvers","title":"ACFlow.StochACContext","text":"StochACContext\n\nMutable struct. It is used within the StochAC solver only.\n\nMembers\n\nGᵥ     -> Input data for correlator.\nσ¹     -> Actually 1.0 / σ¹.\nallow  -> Allowable indices.\ngrid   -> Grid for input data.\nmesh   -> Mesh for output spectrum.\nmodel  -> Default model function.\nkernel -> Default kernel function.\nAout   -> Calculated spectral function, it is actually ⟨n(x)⟩.\nΔ      -> Precomputed δ functions.\nhτ     -> α-resolved h(τ).\nHα     -> α-resolved Hc.\nUα     -> α-resolved internal energy, it is actually ⟨Hα⟩.\nαₗ     -> Vector of the α parameters.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#Functions-3","page":"Solvers","title":"Functions","text":"","category":"section"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"solve(S::StochACSolver, rd::RawData)\ninit(S::StochACSolver, rd::RawData)\nACFlow.run(MC::StochACMC, SE::StochACElement, SC::StochACContext)\nprun(S::StochACSolver, p1::Dict{String,Vector{Any}}, p2::Dict{String,Vector{Any}}, MC::StochACMC, SE::StochACElement, SC::StochACContext)\naverage(step::F64, SC::StochACContext)\nACFlow.last(SC::StochACContext, Aout::Array{F64,2}, Uα::Vector{F64})\nwarmup(MC::StochACMC, SE::StochACElement, SC::StochACContext)\nsample(MC::StochACMC, SE::StochACElement, SC::StochACContext)\nmeasure(SE::StochACElement, SC::StochACContext)\ninit_mc(S::StochACSolver)\ninit_element(S::StochACSolver, rng::AbstractRNG, allow::Vector{I64})\ninit_iodata(S::StochACSolver, rd::RawData)\ncalc_fmesh(S::StochACSolver)\ncalc_phi\ncalc_delta\ncalc_hamil\ncalc_htau\ncalc_alpha\nconstraints(S::StochACSolver, fmesh::AbstractMesh)\ntry_move_a(i::I64, MC::StochACMC, SE::StochACElement, SC::StochACContext)\ntry_move_p(i::I64, MC::StochACMC, SE::StochACElement, SC::StochACContext)\ntry_move_x(MC::StochACMC, SE::StochACElement, SC::StochACContext)","category":"page"},{"location":"library/solver.html#ACFlow.solve-Tuple{StochACSolver, RawData}","page":"Solvers","title":"ACFlow.solve","text":"solve(S::StochACSolver, rd::RawData)\n\nSolve the analytic continuation problem by the stochastic analytic continuation algorithm (K. S. D. Beach's version).\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init-Tuple{StochACSolver, RawData}","page":"Solvers","title":"ACFlow.init","text":"init(S::StochACSolver, rd::RawData)\n\nInitialize the StochAC solver and return the StochACMC, StochACElement, and StochACContext structs.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.run-Tuple{StochACMC, StochACElement, StochACContext}","page":"Solvers","title":"ACFlow.run","text":"run(MC::StochACMC, SE::StochACElement, SC::StochACContext)\n\nPerform stochastic analytic continuation simulation, sequential version.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.prun-Tuple{StochACSolver, Dict{String, Vector{Any}}, Dict{String, Vector{Any}}, StochACMC, StochACElement, StochACContext}","page":"Solvers","title":"ACFlow.prun","text":"prun(S::StochACSolver,\n     p1::Dict{String,Vector{Any}},\n     p2::Dict{String,Vector{Any}},\n     MC::StochACMC, SE::StochACElement, SC::StochACContext)\n\nPerform stochastic analytic continuation simulation, parallel version. The arguments p1 and p2 are copies of PBASE and PStochAC, respectively.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.average-Tuple{Float64, StochACContext}","page":"Solvers","title":"ACFlow.average","text":"average(step::F64, SC::StochACContext)\n\nPostprocess the results generated during the stochastic analytic continuation simulations. It will calculate the spectral functions, and internal energies.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.last-Tuple{StochACContext, Matrix{Float64}, Vector{Float64}}","page":"Solvers","title":"ACFlow.last","text":"last(SC::StochACContext, Aout::Array{F64,2}, Uα::Vector{F64})\n\nIt will process and write the calculated results by the StochAC solver, including effective hamiltonian, final spectral function, reproduced correlator.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.warmup-Tuple{StochACMC, StochACElement, StochACContext}","page":"Solvers","title":"ACFlow.warmup","text":"warmup(MC::StochACMC, SE::StochACElement, SC::StochACContext)\n\nWarmup the Monte Carlo engine to acheieve thermalized equilibrium.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.sample-Tuple{StochACMC, StochACElement, StochACContext}","page":"Solvers","title":"ACFlow.sample","text":"sample(MC::StochACMC, SE::StochACElement, SC::StochACContext)\n\nPerform Monte Carlo sweeps and sample the field configurations.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.measure-Tuple{StochACElement, StochACContext}","page":"Solvers","title":"ACFlow.measure","text":"measure(SE::StochACElement, SC::StochACContext)\n\nMeasure the spectral functions and internal energies.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init_mc-Tuple{StochACSolver}","page":"Solvers","title":"ACFlow.init_mc","text":"init_mc(S::StochACSolver)\n\nTry to create a StochACMC struct.\n\nSee also: StochACMC.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init_element-Tuple{StochACSolver, AbstractRNG, Vector{Int64}}","page":"Solvers","title":"ACFlow.init_element","text":"init_element(S::StochACSolver, rng::AbstractRNG, allow::Vector{I64})\n\nRandomize the configurations for future Monte Carlo sampling. It will return a StochACElement object.\n\nSee also: StochACElement.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init_iodata-Tuple{StochACSolver, RawData}","page":"Solvers","title":"ACFlow.init_iodata","text":"init_iodata(S::StochACSolver, rd::RawData)\n\nPreprocess the input data (rd), then allocate memory for the α-resolved spectral functions.\n\nSee also: RawData.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.calc_fmesh-Tuple{StochACSolver}","page":"Solvers","title":"ACFlow.calc_fmesh","text":"calc_fmesh(S::StochACSolver)\n\nTry to calculate very fine (dense) mesh in [wmin, wmax], which is used internally to build the kernel function. Note that this mesh could be non-uniform. If the file fmesh.inp exists, the code will try to load it to initialize the mesh. Or else the code will try to create a linear mesh automatically.\n\nSee also: LinearMesh, DynamicMesh.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.calc_phi","page":"Solvers","title":"ACFlow.calc_phi","text":"calc_phi(am::AbstractMesh, model::Vector{F64})\n\nTry to calculate ϕ(ω) function. am is the mesh for calculated spectrum, and model means the default model function.\n\nSee also: AbstractMesh, calc_delta.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_delta","page":"Solvers","title":"ACFlow.calc_delta","text":"calc_delta(fmesh::AbstractMesh, ϕ::Vector{F64})\n\nPrecompute the δ functions. fmesh is a very dense mesh in [wmin, wmax] and ϕ is the ϕ function.\n\nSee also: calc_phi.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_hamil","page":"Solvers","title":"ACFlow.calc_hamil","text":"calc_hamil(Γₚ, Γₐ, kernel, Gᵥ, σ¹)\n\nInitialize h(τ) and H(α) using Eq.(35) and Eq.(36), respectively. Γₚ and Γₐ represent n(x), kernel means the kernel function, Gᵥ is the correlator. Note that kernel and Gᵥ have been rotated into singular space. Please see comments in init() for more details.\n\nSee also: calc_htau.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_htau","page":"Solvers","title":"ACFlow.calc_htau","text":"calc_htau(Γₚ, Γₐ, kernel, Gᵥ)\n\nTry to calculate α-dependent h(τ) via Eq.(36). Γₚ and Γₐ represent n(x), kernel means the kernel function, Gᵥ is the correlator. Note that kernel and Gᵥ have been rotated into singular space. Please see comments in init() for more details.\n\nSee also: calc_hamil.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_alpha","page":"Solvers","title":"ACFlow.calc_alpha","text":"calc_alpha()\n\nGenerate a list for the α parameters\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.constraints-Tuple{StochACSolver, AbstractMesh}","page":"Solvers","title":"ACFlow.constraints","text":"constraints(S::StochACSolver, fmesh::AbstractMesh)\n\nTry to implement the constrained stochastic analytic continuation method. This function will return a collection. It contains all the allowable indices. Be careful, the constrained stochastic analytic continuation method is compatible with the self-adaptive mesh.\n\nSee also: StochACSolver.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.try_move_a-Tuple{Int64, StochACMC, StochACElement, StochACContext}","page":"Solvers","title":"ACFlow.try_move_a","text":"try_move_a(i::I64, MC::StochACMC, SE::StochACElement, SC::StochACContext)\n\nSelect two δ functions randomly and then change their weights. Here i means the index for α parameters.\n\nSee also: try_move_p.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.try_move_p-Tuple{Int64, StochACMC, StochACElement, StochACContext}","page":"Solvers","title":"ACFlow.try_move_p","text":"try_move_p(i::I64, MC::StochACMC, SE::StochACElement, SC::StochACContext)\n\nSelect two δ functions randomly and then change their positions. Here i means the index for α parameters.\n\nSee also: try_move_a.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.try_move_x-Tuple{StochACMC, StochACElement, StochACContext}","page":"Solvers","title":"ACFlow.try_move_x","text":"try_move_x(MC::StochACMC, SE::StochACElement, SC::StochACContext)\n\nTry to exchange field configurations between two adjacent layers.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#StochSK-Solver","page":"Solvers","title":"StochSK Solver","text":"","category":"section"},{"location":"library/solver.html#Structs-4","page":"Solvers","title":"Structs","text":"","category":"section"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"StochSKSolver\nStochSKMC\nStochSKElement\nStochSKContext","category":"page"},{"location":"library/solver.html#ACFlow.StochSKSolver","page":"Solvers","title":"ACFlow.StochSKSolver","text":"StochSKSolver\n\nIt represents the analytic continuation solver that implements the stochastic analytic continuation method (A. W. Sandvik's version).\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#ACFlow.StochSKMC","page":"Solvers","title":"ACFlow.StochSKMC","text":"StochSKMC\n\nMutable struct. It is used within the StochSK solver. It includes random number generator and some counters.\n\nMembers\n\nrng  -> Random number generator.\nSacc -> Counter for single-updated operation (accepted).\nStry -> Counter for single-updated operation (tried).\nPacc -> Counter for pair-updated operation (accepted).\nPtry -> Counter for pair-updated operation (tried).\nQacc -> Counter for quadruple-updated operation (accepted).\nQtry -> Counter for quadruple-updated operation (tried).\n\nSee also: StochSKSolver.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#ACFlow.StochSKElement","page":"Solvers","title":"ACFlow.StochSKElement","text":"StochSKElement\n\nMutable struct. It is used to record the field configurations, which will be sampled by Monte Carlo sweeping procedure.\n\nIn the present implementation of StochSK solver, the amplitudes of the δ functions are fixed. But in principles, they could be sampled in the Monte Carlo procedure.\n\nMembers\n\nP -> It means the positions of the δ functions.\nA -> It means the weights / amplitudes of the δ functions.\nW -> It denotes the window that is used to shift the δ functions.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#ACFlow.StochSKContext","page":"Solvers","title":"ACFlow.StochSKContext","text":"StochSKContext\n\nMutable struct. It is used within the StochSK solver only.\n\nMembers\n\nGᵥ     -> Input data for correlator.\nGᵧ     -> Generated correlator.\nσ¹     -> Actually 1.0 / σ¹.\nallow  -> Allowable indices.\ngrid   -> Grid for input data.\nmesh   -> Mesh for output spectrum.\nkernel -> Default kernel function.\nAout   -> Calculated spectral function.\nχ²     -> Current goodness function.\nχ²min  -> Mininum goodness function.\nχ²vec  -> Vector of goodness function.\nΘ      -> Current Θ parameter.\nΘvec   -> Vector of Θ parameter.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#Functions-4","page":"Solvers","title":"Functions","text":"","category":"section"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"solve(S::StochSKSolver, rd::RawData)\ninit(S::StochSKSolver, rd::RawData)\nACFlow.run(MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)\nprun(S::StochSKSolver, p1::Dict{String,Vector{Any}}, p2::Dict{String,Vector{Any}}, MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)\naverage(step::F64, SC::StochSKContext)\nACFlow.last(SC::StochSKContext, Asum::Vector{F64}, χ²vec::Vector{F64}, Θvec::Vector{F64})\nwarmup(MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)\nsample(MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)\nmeasure(SE::StochSKElement, SC::StochSKContext)\nACFlow.shuffle(MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)\ninit_mc(S::StochSKSolver)\ninit_element(S::StochSKSolver, rng::AbstractRNG, allow::Vector{I64})\ninit_iodata(S::StochSKSolver, rd::RawData)\ncalc_fmesh(S::StochSKSolver)\ncalc_correlator\ncalc_goodness\ncalc_theta\nconstraints(S::StochSKSolver, fmesh::AbstractMesh)\ntry_move_s(MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)\ntry_move_p(MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)\ntry_move_q(MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)","category":"page"},{"location":"library/solver.html#ACFlow.solve-Tuple{StochSKSolver, RawData}","page":"Solvers","title":"ACFlow.solve","text":"solve(S::StochSKSolver, rd::RawData)\n\nSolve the analytic continuation problem by the stochastic analytic continuation algorithm (A. W. Sandvik's version).\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init-Tuple{StochSKSolver, RawData}","page":"Solvers","title":"ACFlow.init","text":"init(S::StochSKSolver, rd::RawData)\n\nInitialize the StochSK solver and return the StochSKMC, StochSKElement, and StochSKContext structs.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.run-Tuple{StochSKMC, StochSKElement, StochSKContext}","page":"Solvers","title":"ACFlow.run","text":"run(MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)\n\nPerform stochastic analytic continuation simulation, sequential version.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.prun-Tuple{StochSKSolver, Dict{String, Vector{Any}}, Dict{String, Vector{Any}}, StochSKMC, StochSKElement, StochSKContext}","page":"Solvers","title":"ACFlow.prun","text":"prun(S::StochSKSolver,\n     p1::Dict{String,Vector{Any}},\n     p2::Dict{String,Vector{Any}},\n     MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)\n\nPerform stochastic analytic continuation simulation, parallel version. The arguments p1 and p2 are copies of PBASE and PStochSK, respectively.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.average-Tuple{Float64, StochSKContext}","page":"Solvers","title":"ACFlow.average","text":"average(step::F64, SC::StochSKContext)\n\nPostprocess the results generated during the stochastic analytic continuation simulations. It will generate the spectral functions.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.last-Tuple{StochSKContext, Vector{Float64}, Vector{Float64}, Vector{Float64}}","page":"Solvers","title":"ACFlow.last","text":"last(SC::StochSKContext,\n     Asum::Vector{F64},\n     χ²vec::Vector{F64}, Θvec::Vector{F64})\n\nIt will process and write the calculated results by the StochSK solver, including final spectral function and reproduced correlator.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.warmup-Tuple{StochSKMC, StochSKElement, StochSKContext}","page":"Solvers","title":"ACFlow.warmup","text":"warmup(MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)\n\nWarmup the Monte Carlo engine to acheieve thermalized equilibrium. Then it will try to figure out the optimized Θ and the corresponding Monte Carlo field configuration.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.sample-Tuple{StochSKMC, StochSKElement, StochSKContext}","page":"Solvers","title":"ACFlow.sample","text":"sample(MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)\n\nPerform Monte Carlo sweeps and sample the field configurations.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.measure-Tuple{StochSKElement, StochSKContext}","page":"Solvers","title":"ACFlow.measure","text":"measure(SE::StochSKElement, SC::StochSKContext)\n\nMeasure the final spectral functions.\n\nSee also: nearest.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.shuffle-Tuple{StochSKMC, StochSKElement, StochSKContext}","page":"Solvers","title":"ACFlow.shuffle","text":"shuffle(MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)\n\nTry to shuffle the Monte Carlo field configuration via the Metropolis algorithm. Then the window for shifting the δ functions is adjusted.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init_mc-Tuple{StochSKSolver}","page":"Solvers","title":"ACFlow.init_mc","text":"init_mc(S::StochSKSolver)\n\nTry to create a StochSKMC struct.\n\nSee also: StochSKMC.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init_element-Tuple{StochSKSolver, AbstractRNG, Vector{Int64}}","page":"Solvers","title":"ACFlow.init_element","text":"init_element(S::StochSKSolver, rng::AbstractRNG, allow::Vector{I64})\n\nRandomize the configurations for future Monte Carlo sampling. It will return a StochSKElement object.\n\nSee also: StochSKElement.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init_iodata-Tuple{StochSKSolver, RawData}","page":"Solvers","title":"ACFlow.init_iodata","text":"init_iodata(S::StochSKSolver, rd::RawData)\n\nPreprocess the input data (rd), then allocate memory for the calculated spectral functions.\n\nSee also: RawData.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.calc_fmesh-Tuple{StochSKSolver}","page":"Solvers","title":"ACFlow.calc_fmesh","text":"calc_fmesh(S::StochSKSolver)\n\nTry to calculate very fine (dense) linear mesh in [wmin, wmax], which is used internally to build the kernel function. Note that the stochastic analytic continuation method (A. W. Sandvik's version) does not support the self-adaptive mesh.\n\nSee also: LinearMesh, DynamicMesh.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.calc_correlator","page":"Solvers","title":"ACFlow.calc_correlator","text":"calc_correlator(SE::StochSKElement, kernel::Array{F64,2})\n\nTry to calculate correlator with the kernel function and the Monte Carlo field configuration. This correlator will then be used to evaluate the goodness function.\n\nSee also: calc_goodness.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_goodness","page":"Solvers","title":"ACFlow.calc_goodness","text":"calc_goodness(Gₙ::Vector{F64}, Gᵥ::Vector{F64})\n\nTry to calculate the goodness function (i.e, χ²), which measures the distance between input and regenerated correlators.\n\nSee also: calc_correlator.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_theta","page":"Solvers","title":"ACFlow.calc_theta","text":"calc_theta(𝒜::Array{APC,3}, ℋ::Array{APC,2}, 𝑎𝑏::Vector{C64})\n\nTry to calculate the contractive function θ(z). 𝒜 is the coefficients matrix abcd, ℋ is the Hardy matrix, and 𝑎𝑏 are complex coefficients for expanding θₘ₊₁. See Eq. (7) in Fei's NAC paper.\n\n\n\n\n\ncalc_theta(len::I64, SC::StochSKContext)\n\nTry to locate the optimal Θ and χ². This function implements the chi2min and chi2kink algorithms. Note that the chi2min algorithm is preferred.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.constraints-Tuple{StochSKSolver, AbstractMesh}","page":"Solvers","title":"ACFlow.constraints","text":"constraints(S::StochSKSolver, fmesh::AbstractMesh)\n\nTry to implement the constrained stochastic analytic continuation method. This function will return a collection. It contains all the allowable indices. Be careful, fmesh should be a fine linear mesh.\n\nSee also: StochSKSolver.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.try_move_s-Tuple{StochSKMC, StochSKElement, StochSKContext}","page":"Solvers","title":"ACFlow.try_move_s","text":"try_move_s(MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)\n\nTry to update the Monte Carlo field configurations via the Metropolis algorithm. In each update, only single δ function is shifted.\n\nSee also: try_move_p.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.try_move_p-Tuple{StochSKMC, StochSKElement, StochSKContext}","page":"Solvers","title":"ACFlow.try_move_p","text":"try_move_p(MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)\n\nTry to update the Monte Carlo field configurations via the Metropolis algorithm. In each update, only a pair of δ functions are shifted.\n\nSee also: try_move_s.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.try_move_q-Tuple{StochSKMC, StochSKElement, StochSKContext}","page":"Solvers","title":"ACFlow.try_move_q","text":"try_move_q(MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)\n\nTry to update the Monte Carlo field configurations via the Metropolis algorithm. In each update, four different δ functions are shifted.\n\nSee also: try_move_s.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#StochOM-Solver","page":"Solvers","title":"StochOM Solver","text":"","category":"section"},{"location":"library/solver.html#Structs-5","page":"Solvers","title":"Structs","text":"","category":"section"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"StochOMSolver\nStochOMMC\nBox\nStochOMElement\nStochOMContext","category":"page"},{"location":"library/solver.html#ACFlow.StochOMSolver","page":"Solvers","title":"ACFlow.StochOMSolver","text":"StochOMSolver\n\nIt represents the analytic continuation solver that implements the stochastic optimization method.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#ACFlow.StochOMMC","page":"Solvers","title":"ACFlow.StochOMMC","text":"StochOMMC\n\nMutable struct. It is used within the StochOM solver. It includes random number generator and some counters.\n\nMembers\n\nrng  -> Random number generator.\nMacc -> Counter for move operation (accepted).\nMtry -> Counter for move operation (tried).\n\nSee also: StochOMSolver.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#ACFlow.Box","page":"Solvers","title":"ACFlow.Box","text":"Box\n\nRectangle. The field configuration consists of many boxes. They exhibit various areas (width × height). We use the Metropolis important sampling algorithm to sample them and evaluate their contributions to the spectrum.\n\nMembers\n\nh -> Height of the box.\nw -> Width of the box.\nc -> Position of the box.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#ACFlow.StochOMElement","page":"Solvers","title":"ACFlow.StochOMElement","text":"StochOMElement\n\nMutable struct. It is used to record the field configurations, which will be sampled by Monte Carlo sweeping procedure.\n\nMembers\n\nC -> Field configuration.\nΛ -> Contributions of the field configuration to the correlator.\nG -> Reproduced correlator.\nΔ -> Difference between reproduced and raw correlators.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#ACFlow.StochOMContext","page":"Solvers","title":"ACFlow.StochOMContext","text":"StochOMContext\n\nMutable struct. It is used within the StochOM solver only.\n\nMembers\n\nGᵥ    -> Input data for correlator.\nσ¹    -> Actually 1.0 / σ¹.\ngrid  -> Grid for input data.\nmesh  -> Mesh for output spectrum.\nCᵥ    -> It is used to record the field configurations for all attempts.\nΔᵥ    -> It is used to record the errors for all attempts.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#Functions-5","page":"Solvers","title":"Functions","text":"","category":"section"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"solve(S::StochOMSolver, rd::RawData)\ninit(S::StochOMSolver, rd::RawData)\nACFlow.run(MC::StochOMMC, SC::StochOMContext)\nprun(S::StochOMSolver, p1::Dict{String,Vector{Any}}, p2::Dict{String,Vector{Any}}, MC::StochOMMC, SC::StochOMContext)\naverage(SC::StochOMContext)\nACFlow.last(SC::StochOMContext, Aout::Vector{F64})\nupdate(MC::StochOMMC, SE::StochOMElement, SC::StochOMContext)\ninit_mc(S::StochOMSolver)\ninit_element(MC::StochOMMC, SC::StochOMContext)\ninit_iodata(S::StochOMSolver, rd::RawData)\ninit_context(S::StochOMSolver)\ncalc_lambda\ncalc_error\ncalc_green(Λ::Array{F64,2}, nk::I64)\ncalc_norm\nconstraints(e₁::F64, e₂::F64)\ntry_insert\ntry_remove\ntry_shift\ntry_width\ntry_height\ntry_split\ntry_merge\nPdx","category":"page"},{"location":"library/solver.html#ACFlow.solve-Tuple{StochOMSolver, RawData}","page":"Solvers","title":"ACFlow.solve","text":"solve(S::StochOMSolver, rd::RawData)\n\nSolve the analytic continuation problem by the stochastic optimization method.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init-Tuple{StochOMSolver, RawData}","page":"Solvers","title":"ACFlow.init","text":"init(S::StochOMSolver, rd::RawData)\n\nInitialize the StochOM solver and return the StochOMMC and StochOMContext structs.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.run-Tuple{StochOMMC, StochOMContext}","page":"Solvers","title":"ACFlow.run","text":"run(MC::StochOMMC, SC::StochOMContext)\n\nPerform stochastic optimization simulation, sequential version.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.prun-Tuple{StochOMSolver, Dict{String, Vector{Any}}, Dict{String, Vector{Any}}, StochOMMC, StochOMContext}","page":"Solvers","title":"ACFlow.prun","text":"prun(S::StochOMSolver,\n     p1::Dict{String,Vector{Any}},\n     p2::Dict{String,Vector{Any}},\n     MC::StochOMMC, SC::StochOMContext)\n\nPerform stochastic optimization simulation, parallel version. The arguments p1 and p2 are copies of PBASE and PStochOM, respectively.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.average-Tuple{StochOMContext}","page":"Solvers","title":"ACFlow.average","text":"average(SC::StochOMContext)\n\nPostprocess the collected results after the stochastic optimization simulations. It will generate the spectral functions.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.last-Tuple{StochOMContext, Vector{Float64}}","page":"Solvers","title":"ACFlow.last","text":"last(SC::StochOMContext, Aout::Vector{F64})\n\nIt will process and write the calculated results by the StochOM solver, including final spectral function and reproduced correlator.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.update-Tuple{StochOMMC, StochOMElement, StochOMContext}","page":"Solvers","title":"ACFlow.update","text":"update(MC::StochOMMC, SE::StochOMElement, SC::StochOMContext)\n\nUsing the Metropolis algorithm to update the field configuration, i.e, a collection of hundreds of boxes.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init_mc-Tuple{StochOMSolver}","page":"Solvers","title":"ACFlow.init_mc","text":"init_mc(S::StochOMSolver)\n\nTry to create a StochOMMC struct.\n\nSee also: StochOMMC.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init_element-Tuple{StochOMMC, StochOMContext}","page":"Solvers","title":"ACFlow.init_element","text":"init_element(MC::StochOMMC, SC::StochOMContext)\n\nTry to initialize a StochOMElement struct.\n\nSee also: StochOMElement.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init_iodata-Tuple{StochOMSolver, RawData}","page":"Solvers","title":"ACFlow.init_iodata","text":"init_iodata(S::StochOMSolver, rd::RawData)\n\nPreprocess the input data (rd).\n\nSee also: RawData, GreenData.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init_context-Tuple{StochOMSolver}","page":"Solvers","title":"ACFlow.init_context","text":"init_context(S::StochOMSolver)\n\nTry to initialize the key members of a StochOMContext struct.\n\nSee also: StochOMContext.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.calc_lambda","page":"Solvers","title":"ACFlow.calc_lambda","text":"calc_lambda(r::Box, grid::FermionicMatsubaraGrid)\n\nTry to calculate the contribution of a given box r to the Λ function. This function works for FermionicMatsubaraGrid only.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\ncalc_lambda(r::Box, grid::FermionicImaginaryTimeGrid)\n\nTry to calculate the contribution of a given box r to the Λ function. This function works for FermionicImaginaryTimeGrid only.\n\nSee also: FermionicImaginaryTimeGrid.\n\n\n\n\n\ncalc_lambda(r::Box, grid::BosonicMatsubaraGrid)\n\nTry to calculate the contribution of a given box r to the Λ function. This function works for BosonicMatsubaraGrid only.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\ncalc_lambda(r::Box, grid::BosonicImaginaryTimeGrid)\n\nTry to calculate the contribution of a given box r to the Λ function. This function works for BosonicImaginaryTimeGrid only.\n\nSee also: BosonicImaginaryTimeGrid.\n\n\n\n\n\ncalc_lambda(grid::AbstractGrid, fmesh::AbstractMesh)\n\nPrecompute the kernel matrix Λ (Λ ≡ 1 / (iωₙ - ϵ)). It is for the fermionic systems.\n\n\n\n\n\ncalc_lambda(grid::AbstractGrid,\n            fmesh::AbstractMesh,\n            χ₀::F64,\n            bsymm::Bool)\n\nPrecompute the kernel matrix Λ. Here, χ₀ is actually -G(iωₙ = 0). And the argument bsymm is used to distinguish two different bosonic kernels. If bsymm is false, it means that the kernel is boson. If bsymm is true, the kernel is bsymm. This function is for the bosonic systems.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_error","page":"Solvers","title":"ACFlow.calc_error","text":"calc_error(G::Vector{F64}, Gᵥ::Vector{F64}, σ¹::Vector{F64})\n\nTry to calculate χ². Here Gᵥ and σ¹ denote the raw correlator and related standard deviation. G means the reproduced correlator.\n\nSee also: calc_green.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_green-Tuple{Matrix{Float64}, Int64}","page":"Solvers","title":"ACFlow.calc_green","text":"calc_green(Λ::Array{F64,2}, nk::I64)\n\nTry to reconstruct the correlator via the field configuration.\n\nSee also: calc_error.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.calc_norm","page":"Solvers","title":"ACFlow.calc_norm","text":"calc_norm(C::Vector{Box})\n\nCalculate the total area of all boxes.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.constraints-Tuple{Float64, Float64}","page":"Solvers","title":"ACFlow.constraints","text":"constraints(e₁::F64, e₂::F64)\n\nThis function is used to judege whether a given box overlapes with the forbidden zone. Here e₁ and e₂ denote the left and right boundaries of the box.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.try_insert","page":"Solvers","title":"ACFlow.try_insert","text":"try_insert(MC::StochOMMC,\n           SE::StochOMElement,\n           SC::StochOMContext,\n           dacc::F64)\n\nInsert a new box into the field configuration.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.try_remove","page":"Solvers","title":"ACFlow.try_remove","text":"try_remove(MC::StochOMMC,\n           SE::StochOMElement,\n           SC::StochOMContext,\n           dacc::F64)\n\nRemove an old box from the field configuration.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.try_shift","page":"Solvers","title":"ACFlow.try_shift","text":"try_shift(MC::StochOMMC,\n          SE::StochOMElement,\n          SC::StochOMContext,\n          dacc::F64)\n\nChange the position of given box in the field configuration.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.try_width","page":"Solvers","title":"ACFlow.try_width","text":"try_width(MC::StochOMMC,\n          SE::StochOMElement,\n          SC::StochOMContext,\n          dacc::F64)\n\nChange the width and height of given box in the field configuration. Note that the box's area is kept.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.try_height","page":"Solvers","title":"ACFlow.try_height","text":"try_height(MC::StochOMMC,\n           SE::StochOMElement,\n           SC::StochOMContext,\n           dacc::F64)\n\nChange the heights of two given boxes in the field configuration.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.try_split","page":"Solvers","title":"ACFlow.try_split","text":"try_split(MC::StochOMMC,\n          SE::StochOMElement,\n          SC::StochOMContext,\n          dacc::F64)\n\nSplit a given box into two boxes in the field configuration.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.try_merge","page":"Solvers","title":"ACFlow.try_merge","text":"try_merge(MC::StochOMMC,\n          SE::StochOMElement,\n          SC::StochOMContext,\n          dacc::F64)\n\nMerge two given boxes into one box in the field configuration.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.Pdx","page":"Solvers","title":"ACFlow.Pdx","text":"Pdx(xmin::F64, xmax::F64, rng::AbstractRNG)\n\nTry to calculate the probability density function.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#StochPX-Solver","page":"Solvers","title":"StochPX Solver","text":"","category":"section"},{"location":"library/solver.html#Structs-6","page":"Solvers","title":"Structs","text":"","category":"section"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"StochPXSolver\nStochPXMC\nStochPXElement\nStochPXContext","category":"page"},{"location":"library/solver.html#ACFlow.StochPXSolver","page":"Solvers","title":"ACFlow.StochPXSolver","text":"StochPXSolver\n\nIt represents the analytic continuation solver that implements the stochastic pole expansion.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#ACFlow.StochPXMC","page":"Solvers","title":"ACFlow.StochPXMC","text":"StochPXMC\n\nMutable struct. It is used within the StochPX solver. It includes random number generator and some counters.\n\nMembers\n\nrng  -> Random number generator.\nSacc -> Counter for position-updated (type 1) operation (accepted).\nStry -> Counter for position-updated (type 1) operation (tried).\nPacc -> Counter for position-updated (type 2) operation (accepted).\nPtry -> Counter for position-updated (type 2) operation (tried).\nAacc -> Counter for amplitude-updated operation (accepted).\nAtry -> Counter for amplitude-updated operation (tried).\nXacc -> Counter for exchange operation (accepted).\nXtry -> Counter for exchange operation (tried).\n\nSee also: StochPXSolver.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#ACFlow.StochPXElement","page":"Solvers","title":"ACFlow.StochPXElement","text":"StochPXElement\n\nMutable struct. It is used to record the field configurations, which will be sampled by Monte Carlo sweeping procedure.\n\nFor the off-diagonal elements of the matrix-valued green's function, the signs of the poles (𝕊) could be negative (-1.0). However, for the other cases, 𝕊 is always positive (+1.0).\n\nMembers\n\nP -> It means the positions of the poles.\nA -> It means the weights / amplitudes of the poles.\n𝕊 -> It means the signs of the poles.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#ACFlow.StochPXContext","page":"Solvers","title":"ACFlow.StochPXContext","text":"StochPXContext\n\nMutable struct. It is used within the StochPX solver only.\n\nMembers\n\nGᵥ     -> Input data for correlator.\nGᵧ     -> Generated correlator.\nσ¹     -> Actually 1.0 / σ¹.\nallow  -> Allowable indices.\ngrid   -> Grid for input data.\nmesh   -> Mesh for output spectrum.\nfmesh  -> Very dense mesh for the poles.\nΛ      -> Precomputed kernel matrix.\nΘ      -> Artificial inverse temperature.\nχ²min  -> Minimum of χ²min.\nχ²     -> Vector of goodness function.\nPᵥ     -> Vector of poles' positions.\nAᵥ     -> Vector of poles' amplitudes.\n𝕊ᵥ     -> Vector of poles' signs.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#Functions-6","page":"Solvers","title":"Functions","text":"","category":"section"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"solve(S::StochPXSolver, rd::RawData)\ninit(S::StochPXSolver, rd::RawData)\nACFlow.run(MC::StochPXMC, SE::StochPXElement, SC::StochPXContext)\nprun(S::StochPXSolver, p1::Dict{String,Vector{Any}}, p2::Dict{String,Vector{Any}}, MC::StochPXMC, SE::StochPXElement, SC::StochPXContext)\naverage(SC::StochPXContext)\nACFlow.last(SC::StochPXContext, Aout::Vector{F64}, Gout::Vector{C64}, Gᵣ::Vector{F64})\nsample(t::I64, MC::StochPXMC, SE::StochPXElement, SC::StochPXContext)\nmeasure(t::I64, SE::StochPXElement, SC::StochPXContext)\ninit_mc(S::StochPXSolver)\ninit_element(S::StochPXSolver, rng::AbstractRNG, allow::Vector{I64})\ninit_iodata(S::StochPXSolver, rd::RawData)\ninit_context(S::StochPXSolver)\nreset_mc(MC::StochPXMC)\nreset_element(rng::AbstractRNG, allow::Vector{I64}, SE::StochPXElement)\nreset_context(t::I64, SE::StochPXElement, SC::StochPXContext)\ncalc_fmesh(S::StochPXSolver)\ncalc_lambda(grid::AbstractGrid, fmesh::AbstractMesh)\ncalc_lambda(grid::AbstractGrid, fmesh::AbstractMesh, χ₀::F64, bsymm::Bool)\ncalc_green(P::Vector{I64}, A::Vector{F64}, 𝕊::Vector{F64}, Λ::Array{F64,2})\ncalc_green(P::Vector{I64}, A::Vector{F64}, 𝕊::Vector{F64}, mesh::AbstractMesh, fmesh::AbstractMesh)\ncalc_green(P::Vector{I64}, A::Vector{F64}, 𝕊::Vector{F64}, mesh::AbstractMesh, fmesh::AbstractMesh, χ₀::F64, bsymm::Bool)\ncalc_chi2(Gₙ::Vector{F64}, Gᵥ::Vector{F64})\nconstraints(S::StochPXSolver, fmesh::AbstractMesh)\ntry_move_s(t::I64, MC::StochPXMC, SE::StochPXElement, SC::StochPXContext)\ntry_move_p(t::I64, MC::StochPXMC, SE::StochPXElement, SC::StochPXContext)\ntry_move_a(t::I64, MC::StochPXMC, SE::StochPXElement, SC::StochPXContext)\ntry_move_x(t::I64, MC::StochPXMC, SE::StochPXElement, SC::StochPXContext)","category":"page"},{"location":"library/solver.html#ACFlow.solve-Tuple{StochPXSolver, RawData}","page":"Solvers","title":"ACFlow.solve","text":"solve(S::StochPXSolver, rd::RawData)\n\nSolve the analytic continuation problem by the stochastic pole expansion. Note that this solver is still experimental.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init-Tuple{StochPXSolver, RawData}","page":"Solvers","title":"ACFlow.init","text":"init(S::StochPXSolver, rd::RawData)\n\nInitialize the StochPX solver and return the StochPXMC, StochPXElement, and StochPXContext structs.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.run-Tuple{StochPXMC, StochPXElement, StochPXContext}","page":"Solvers","title":"ACFlow.run","text":"run(MC::StochPXMC, SE::StochPXElement, SC::StochPXContext)\n\nPerform stochastic pole expansion simulation, sequential version.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.prun-Tuple{StochPXSolver, Dict{String, Vector{Any}}, Dict{String, Vector{Any}}, StochPXMC, StochPXElement, StochPXContext}","page":"Solvers","title":"ACFlow.prun","text":"prun(S::StochPXSolver,\n     p1::Dict{String,Vector{Any}},\n     p2::Dict{String,Vector{Any}},\n     MC::StochPXMC, SE::StochPXElement, SC::StochPXContext)\n\nPerform stochastic pole expansion simulation, parallel version. The arguments p1 and p2 are copies of PBASE and PStochPX, respectively.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.average-Tuple{StochPXContext}","page":"Solvers","title":"ACFlow.average","text":"average(SC::StochPXContext)\n\nPostprocess the results generated during the stochastic pole expansion simulations. It will generate the spectral functions, real frequency green's function, and imaginary frequency green's function.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.last-Tuple{StochPXContext, Vector{Float64}, Vector{ComplexF64}, Vector{Float64}}","page":"Solvers","title":"ACFlow.last","text":"last(SC::StochPXContext,\n     Aout::Vector{F64},\n     Gout::Vector{C64},\n     Gᵣ::Vector{F64})\n\nIt will write the calculated results by the StochPX solver, including final spectral function and reproduced correlator.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.sample-Tuple{Int64, StochPXMC, StochPXElement, StochPXContext}","page":"Solvers","title":"ACFlow.sample","text":"sample(t::I64, MC::StochPXMC, SE::StochPXElement, SC::StochPXContext)\n\nTry to search the configuration space to locate the minimum by using the simulated annealing algorithm. Here, t means the t-th attempt.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.measure-Tuple{Int64, StochPXElement, StochPXContext}","page":"Solvers","title":"ACFlow.measure","text":"measure(t::I64, SE::StochPXElement, SC::StochPXContext)\n\nStore Monte Carlo field configurations (positions, amplitudes, and signs of many poles) for the t-th attempt.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init_mc-Tuple{StochPXSolver}","page":"Solvers","title":"ACFlow.init_mc","text":"init_mc(S::StochPXSolver)\n\nTry to create a StochPXMC struct.\n\nSee also: StochPXMC.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init_element-Tuple{StochPXSolver, AbstractRNG, Vector{Int64}}","page":"Solvers","title":"ACFlow.init_element","text":"init_element(S::StochPXSolver, rng::AbstractRNG, allow::Vector{I64})\n\nRandomize the configurations for future Monte Carlo sampling. It will return a StochPXElement object.\n\nSee also: StochPXElement.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init_iodata-Tuple{StochPXSolver, RawData}","page":"Solvers","title":"ACFlow.init_iodata","text":"init_iodata(S::StochPXSolver, rd::RawData)\n\nPreprocess the input data (rd).\n\nSee also: RawData.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init_context-Tuple{StochPXSolver}","page":"Solvers","title":"ACFlow.init_context","text":"init_context(S::StochPXSolver)\n\nTry to initialize the key members of a StochPXContext struct.\n\nSee also: StochPXContext.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.reset_mc-Tuple{StochPXMC}","page":"Solvers","title":"ACFlow.reset_mc","text":"reset_mc(MC::StochPXMC)\n\nReset the counters in StochPXMC struct.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.reset_element-Tuple{AbstractRNG, Vector{Int64}, StochPXElement}","page":"Solvers","title":"ACFlow.reset_element","text":"reset_element(rng::AbstractRNG, allow::Vector{I64}, SE::StochPXElement)\n\nReset the Monte Carlo field configurations (i.e. positions and amplitudes of the poles). Note that the signs of the poles should not be changed.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.reset_context-Tuple{Int64, StochPXElement, StochPXContext}","page":"Solvers","title":"ACFlow.reset_context","text":"reset_context(t::I64, SE::StochPXElement, SC::StochPXContext)\n\nRecalculate imaginary frequency green's function and goodness-of-fit function by new Monte Carlo field configurations for the t-th attempts.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.calc_fmesh-Tuple{StochPXSolver}","page":"Solvers","title":"ACFlow.calc_fmesh","text":"calc_fmesh(S::StochPXSolver)\n\nTry to calculate very fine (dense) mesh in [wmin, wmax], which is used internally to represent the possible positions of poles. Note that this mesh could be non-uniform. If the file fmesh.inp exists, the code will try to load it to initialize the mesh. Or else the code will generate a linear mesh automatically.\n\nSee also: LinearMesh, DynamicMesh.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.calc_lambda-Tuple{AbstractGrid, AbstractMesh}","page":"Solvers","title":"ACFlow.calc_lambda","text":"calc_lambda(grid::AbstractGrid, fmesh::AbstractMesh)\n\nPrecompute the kernel matrix Λ (Λ ≡ 1 / (iωₙ - ϵ)). It is for the fermionic systems.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.calc_lambda-Tuple{AbstractGrid, AbstractMesh, Float64, Bool}","page":"Solvers","title":"ACFlow.calc_lambda","text":"calc_lambda(grid::AbstractGrid,\n            fmesh::AbstractMesh,\n            χ₀::F64,\n            bsymm::Bool)\n\nPrecompute the kernel matrix Λ. Here, χ₀ is actually -G(iωₙ = 0). And the argument bsymm is used to distinguish two different bosonic kernels. If bsymm is false, it means that the kernel is boson. If bsymm is true, the kernel is bsymm. This function is for the bosonic systems.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.calc_green-Tuple{Vector{Int64}, Vector{Float64}, Vector{Float64}, Matrix{Float64}}","page":"Solvers","title":"ACFlow.calc_green","text":"calc_green(P::Vector{I64},\n           A::Vector{F64},\n           𝕊::Vector{F64},\n           Λ::Array{F64,2})\n\nReconstruct green's function at imaginary axis by the pole expansion.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.calc_green-Tuple{Vector{Int64}, Vector{Float64}, Vector{Float64}, AbstractMesh, AbstractMesh}","page":"Solvers","title":"ACFlow.calc_green","text":"calc_green(P::Vector{I64},\n           A::Vector{F64},\n           𝕊::Vector{F64},\n           mesh::AbstractMesh,\n           fmesh::AbstractMesh)\n\nReconstruct green's function at real axis by the pole expansion. It is for the fermionic systems only.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.calc_green-Tuple{Vector{Int64}, Vector{Float64}, Vector{Float64}, AbstractMesh, AbstractMesh, Float64, Bool}","page":"Solvers","title":"ACFlow.calc_green","text":"calc_green(P::Vector{I64},\n           A::Vector{F64},\n           𝕊::Vector{F64},\n           mesh::AbstractMesh,\n           fmesh::AbstractMesh, χ₀::F64, bsymm::Bool)\n\nReconstruct green's function at real axis by the pole expansion. Here, χ₀ is actually -G(iωₙ = 0). And the argument bsymm is used to distinguish two different bosonic kernels. If bsymm is false, it means that the kernel is boson. If bsymm is true, the kernel is bsymm. It is for the bosonic systems only.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.calc_chi2-Tuple{Vector{Float64}, Vector{Float64}}","page":"Solvers","title":"ACFlow.calc_chi2","text":"calc_chi2(Gₙ::Vector{F64}, Gᵥ::Vector{F64})\n\nTry to calculate the goodness function (i.e, χ²), which measures the distance between input and regenerated correlators.\n\nSee also: calc_green.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.constraints-Tuple{StochPXSolver, AbstractMesh}","page":"Solvers","title":"ACFlow.constraints","text":"constraints(S::StochPXSolver, fmesh::AbstractMesh)\n\nTry to implement the constrained stochastic pole expansion. This function will return a collection. It contains all the allowable indices. Be careful, the constrained stochastic pole expansion method is compatible with the self-adaptive mesh.\n\nSee also: StochPXSolver.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.try_move_s-Tuple{Int64, StochPXMC, StochPXElement, StochPXContext}","page":"Solvers","title":"ACFlow.try_move_s","text":"try_move_s(t::I64, MC::StochPXMC, SE::StochPXElement, SC::StochPXContext)\n\nChange the position of one randomly selected pole.\n\nSee also: try_move_p.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.try_move_p-Tuple{Int64, StochPXMC, StochPXElement, StochPXContext}","page":"Solvers","title":"ACFlow.try_move_p","text":"try_move_p(t::I64, MC::StochPXMC, SE::StochPXElement, SC::StochPXContext)\n\nChange the positions of two randomly selected poles.\n\nSee also: try_move_s.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.try_move_a-Tuple{Int64, StochPXMC, StochPXElement, StochPXContext}","page":"Solvers","title":"ACFlow.try_move_a","text":"try_move_a(t::I64, MC::StochPXMC, SE::StochPXElement, SC::StochPXContext)\n\nChange the amplitudes of two randomly selected poles.\n\nSee also: try_move_x.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.try_move_x-Tuple{Int64, StochPXMC, StochPXElement, StochPXContext}","page":"Solvers","title":"ACFlow.try_move_x","text":"try_move_x(t::I64, MC::StochPXMC, SE::StochPXElement, SC::StochPXContext)\n\nExchange the amplitudes of two randomly selected poles.\n\nSee also: try_move_a.\n\n\n\n\n\n","category":"method"},{"location":"man/input.html#Input-Files","page":"Input Files","title":"Input Files","text":"","category":"section"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"The input files for the ACFlow toolkit can be divided into two groups: data files and configuration files.","category":"page"},{"location":"man/input.html#Data-Files","page":"Input Files","title":"Data Files","text":"","category":"section"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"The input data should be stored in some text-based files, which adopt the space-separated data format. For imaginary time Green's function, the data file should contain three columns. They represent tau, barG(tau), and standard deviation of barG(tau). For fermionic Matsubara Green's function, the data file should contain five columns. They represent omega_n, ReG(iomega_n), ImG(iomega_n), standard deviation of ReG(iomega_n), and standard deviation of ImG(iomega_n). For bosonic correlation function chi(iomega_n), the data file should contain three columns. They represent omega_n, Rechi(iomega_n), and standard deviation of Rechi(iomega_n).","category":"page"},{"location":"man/input.html#Configuration-Files","page":"Input Files","title":"Configuration Files","text":"","category":"section"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"The configuration file adopts the TOML format. It is used to customize the computational parameters. It consists of one or more blocks. Possible blocks (or sections) of the configuration file include [BASE], [MaxEnt], [NevanAC], [StochAC], [StochSK], [StochOM], and [StochPX]. The [BASE] block is mandatory, while the other blocks are optional. A schematic configuration file (ac.toml) is listed as follows:","category":"page"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"[BASE]\nfinput = \"giw.data\"\nsolver = \"StochOM\"\n...\n\n[MaxEnt]\nmethod = \"chi2kink\"\n...\n\n[NevanAC]\npick   = true\n...\n\n[StochAC]\nnfine  = 10000\n...\n\n[StochSK]\nmethod = \"chi2min\"\n...\n\n[StochOM]\nntry   = 100000\n...\n\n[StochPX]\nmethod = \"mean\"\n...","category":"page"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"In the [BASE] block, the analytic continuation problem is defined. The solver used to solve the problem must be assigned. The types of mesh, grid, default model function, and kernel function are also determined. The [MaxEnt], [NevanAC], [StochAC], [StochSK], [StochOM], and [StochPX] blocks are used to customize the corresponding analytic continuation solvers further. In Table 1-Table 7, all the possible input parameters for these blocks are collected and summarized. As for detailed explanations of these parameters, please see Parameters.","category":"page"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"Parameter Type Default Description\nfinput string ''green.data'' Filename for input data.\nsolver string ''MaxEnt'' Solver for the analytic continuation problem.\nktype string ''fermi'' Type of kernel function.\nmtype string ''flat'' Type of default model function.\ngrid string ''ffreq'' Grid for input data (imaginary axis).\nmesh string ''linear'' Mesh for output data (real axis).\nngrid integer 10 Number of grid points.\nnmesh integer 501 Number of mesh points.\nwmax float 5.0 Right boundary (maximum value) of mesh.\nwmin float -5.0 Left boundary (minimum value) of mesh.\nbeta float 10.0 Inverse temperature.\noffdiag bool false Treat the off-diagonal part of matrix-valued function?\nfwrite bool N/A Are the analytic continuation results written into files?\npmodel array N/A Additional parameters for customizing the default model.\npmesh array N/A Additional parameters for customizing the mesh.\nexclude array N/A Restriction of energy range of the spectrum.","category":"page"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"Table 1 | Possible parameters for the [BASE] block.","category":"page"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"Parameter Type Default Description\nmethod string ''chi2kink'' How to determine the optimized alpha parameter?\nstype string ''sj'' Type of the entropic factor.\nnalph integer 12 Total number of the used alpha parameters.\nalpha float 1e9 Starting value for the alpha parameter.\nratio float 10.0 Scaling factor for the alpha parameter.\nblur float -1.0 Shall we preblur the kernel and spectrum?","category":"page"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"Table 2 | Possible input parameters for the [MaxEnt] block, which are used to configure the solver based on the maximum entropy method.","category":"page"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"Parameter Type Default Description\npick bool false Check the Pick criterion or not.\nhardy bool false Perform Hardy basis optimization or not.\nhmax integer 50 Upper cut off of Hardy order.\nalpha float 1e-4 Regulation parameter for smooth norm.\neta float 1e-2 Tiny distance from the real axis.","category":"page"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"Table 3 | Possible input parameters for the [NevanAC] block, which are used to configure the solver based on the Nevanlinna analytical continuation.","category":"page"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"Parameter Type Default Description\nnfine integer 10000 Number of points of a very fine linear mesh.\nngamm integer 512 Number of delta functions.\nnwarm integer 4000 Number of Monte Carlo thermalization steps.\nnstep integer 4000000 Number of Monte Carlo sweeping steps.\nndump integer 40000 Intervals for monitoring Monte Carlo sweeps.\nnalph integer 20 Total number of the used alpha parameters.\nalpha float 1.0 Starting value for the alpha parameter.\nratio float 1.2 Scaling factor for the alpha parameter.","category":"page"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"Table 4 | Possible input parameters for the [StochAC] block, which are used to configure the solver based on the stochastic analytic continuation (Beach's algorithm).","category":"page"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"Parameter Type Default Description\nmethod string ''chi2min'' How to determine the optimized Theta parameter?\nnfine integer 100000 Number of points of a very fine linear mesh.\nngamm integer 1000 Number of delta functions.\nnwarm integer 1000 Number of Monte Carlo thermalization steps.\nnstep integer 20000 Number of Monte Carlo sweeping steps.\nndump integer 200 Intervals for monitoring Monte Carlo sweeps.\nretry integer 10 How often to recalculate the goodness-of-fit function.\ntheta float 1e6 Starting value for the Theta parameter.\nratio float 0.9 Scaling factor for the Theta parameter.","category":"page"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"Table 5 | Possible input parameters for the [StochSK] block, which are used to configure the solver based on the stochastic analytic continuation (Sandvik's algorithm).","category":"page"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"Parameter Type Default Description\nntry integer 2000 Number of attempts to figure out the solution.\nnstep integer 1000 Number of Monte Carlo sweeping steps per try.\nnbox integer 100 Number of rectangles to used construct the spectrum.\nsbox float 0.005 Minimum area of the randomly generated rectangles.\nwbox float 0.02 Minimum width of the randomly generated rectangles.\nnorm float -1.0 Is the norm calculated?","category":"page"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"Table 6 | Possible input parameters for the [StochOM] block, which are used to configure the solver based on the stochastic optimization method.","category":"page"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"Parameter Type Default Description\nmethod string ''mean'' How to evaluate the final spectral density?\nnfine integer 100000 Number of points of a very fine linear mesh.\nnpole integer 200 Number of poles.\nntry integer 1000 Number of attempts to figure out the solution.\nnstep integer 1000000 Number of Monte Carlo sweeping steps per attempt / try.\ntheta float 1e+6 Artificial inverse temperature Theta.\neta float 1e-4 Tiny distance from the real axis eta.","category":"page"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"Table 7 | Possible input parameters for the [StochPX] block, which are used to configure the solver based on the stochastic pole expansion.","category":"page"},{"location":"examples/current.html","page":"Current-Current Correlation Function","title":"Current-Current Correlation Function","text":"info: Info\nIn order to demonstrate usefulness of the ACFlow toolkit, four examples are illustrated in this section. These examples cover typical application scenarios of the ACFlow toolkit, including analytic continuations ofMatsubara self-energy function\nMatsubara Green's function\nImaginary time Green's function\nCurrent-current correlation functionwithin the script mode or standard mode. All of the necessary source codes and data files, which can be used to reproduce the results as shown in this section, are placed in the /home/your_home/acflow/tutor/T* folders.","category":"page"},{"location":"examples/current.html#Current-Current-Correlation-Function","page":"Current-Current Correlation Function","title":"Current-Current Correlation Function","text":"","category":"section"},{"location":"examples/current.html","page":"Current-Current Correlation Function","title":"Current-Current Correlation Function","text":"The former three examples only concern fermionic correlators. How about bosonic correlators? In this example, we will demonstrate how to perform analytic continuation simulation for a typical bosonic correlator, the current-current correlation function Pi(tau), to obtain the optical conductivity sigma(omega). Note that this example is taken from Phys. Rev. B 82, 165125 (2010) directly.","category":"page"},{"location":"examples/current.html","page":"Current-Current Correlation Function","title":"Current-Current Correlation Function","text":"The exact optical conductivity sigma(omega) reads:","category":"page"},{"location":"examples/current.html","page":"Current-Current Correlation Function","title":"Current-Current Correlation Function","text":"sigma(omega) =\nleft\nfracW_11 + (omegaGamma_1)^2 +\nfracW_21 + (omega - epsilon)Gamma_2^2 +\nfracW_21 + (omega + epsilon)Gamma_2^2\nright\nfrac11 + (omegaGamma_3)^6","category":"page"},{"location":"examples/current.html","page":"Current-Current Correlation Function","title":"Current-Current Correlation Function","text":"where W_1 = 03, W_2 = 02, Gamma_1 = 03, Gamma_2 = 12, Gamma_3 = 40, and epsilon = 30. The current-current correlation function Pi(tau) can be evaluated from sigma(omega) by using the following equation:","category":"page"},{"location":"examples/current.html","page":"Current-Current Correlation Function","title":"Current-Current Correlation Function","text":"Pi(tau) = int^infty_-infty K(tauomega) sigma(omega)domega","category":"page"},{"location":"examples/current.html","page":"Current-Current Correlation Function","title":"Current-Current Correlation Function","text":"where the kernel function K(tauomega) is different from the general form. It reads:","category":"page"},{"location":"examples/current.html","page":"Current-Current Correlation Function","title":"Current-Current Correlation Function","text":"K(tauomega) = frac1pi fracomega e^-tauomega1- e^-betaomega","category":"page"},{"location":"examples/current.html","page":"Current-Current Correlation Function","title":"Current-Current Correlation Function","text":"In this case, beta is fixed to be 20.0.","category":"page"},{"location":"examples/current.html","page":"Current-Current Correlation Function","title":"Current-Current Correlation Function","text":"At first, we use the above equations to prepare Pi(tau). The error bar of Pi(tau) is fixed to 1e-4. The calculated Pi(tau) is written in chit.data.","category":"page"},{"location":"examples/current.html","page":"Current-Current Correlation Function","title":"Current-Current Correlation Function","text":"Next, we conduct analytic continuation simulation as usual. The used configuration file is attached as follows. Here, the StochSK solver is adopted, so the solver parameter is ''StochSK'' and the grid parameter is ''btime''. And the Shao-Sandvik algorithm is applied to seek optimal Theta, so the method parameter is ''chi2min''. The users can further increase the values of nfine, ngamm, and nstep parameters to improve computational accuracy.","category":"page"},{"location":"examples/current.html","page":"Current-Current Correlation Function","title":"Current-Current Correlation Function","text":"[BASE]\nfinput = \"chit.data\"\nsolver = \"StochSK\"\nktype  = \"bsymm\"\nmtype  = \"flat\"\ngrid   = \"btime\"\nmesh   = \"linear\"\nngrid  = 501\nnmesh  = 801\nwmax   = 8.0\nwmin   = 0.0\nbeta   = 20.0\noffdiag = false\n\n[StochSK]\nmethod = \"chi2min\"\nnfine = 40000\nngamm = 1000\nnwarm = 1000\nnstep = 20000\nndump = 200\nretry = 10\ntheta = 1e+6\nratio = 0.90","category":"page"},{"location":"examples/current.html","page":"Current-Current Correlation Function","title":"Current-Current Correlation Function","text":"The calculated results are illustrated in Fig.1. From Fig.1(a), it is clear that the main features of optical conductivity are successfully captured by the StochSK solver. Both the sharp Drude peak at omega = 0 and a broad satellite peak around omega = 30 are well reproduced. As is seen in Fig.1(b), the reconstructed tildePi(tau) coincides with the original Pi(tau).","category":"page"},{"location":"examples/current.html","page":"Current-Current Correlation Function","title":"Current-Current Correlation Function","text":"(Image: T_E4.png)","category":"page"},{"location":"examples/current.html","page":"Current-Current Correlation Function","title":"Current-Current Correlation Function","text":"Figure 1 | Analytic continuation of current-current correlation function by using the stochastic analytic continuation (Sandvik's algorithm). (a) Simulated and exact optical conductivities sigma(omega). (b) Simulated and exact current-current correlation functions Pi(tau).","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"info: Info\nIn order to demonstrate usefulness of the ACFlow toolkit, four examples are illustrated in this section. These examples cover typical application scenarios of the ACFlow toolkit, including analytic continuations ofMatsubara self-energy function\nMatsubara Green's function\nImaginary time Green's function\nCurrent-current correlation functionwithin the script mode or standard mode. All of the necessary source codes and data files, which can be used to reproduce the results as shown in this section, are placed in the /home/your_home/acflow/tutor/T* folders.","category":"page"},{"location":"examples/sigma.html#Matsubara-Self-Energy-Function","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"","category":"section"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"Now let us consider the following single-band Hubbard model on a Bethe lattice at first:","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"H = -t sum_langle ij rangle sigma c^dagger_isigmac_jsigma\n - mu sum_i n_i + U sum_i n_iuparrow n_idownarrow","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"where t is the hopping parameter, mu is the chemical potential, U is the Coulomb interaction, n is the occupation number, sigma denotes the spin, i and j are site indices. This model is solved by using the dynamical mean-field theory (dubbed DMFT) with the hybridization expansion continuous-time quantum Monte Carlo solver (dubbed CT-HYB) as implemented in the iQIST package. The parameters used in the DMFT + CT-HYB calculation are t = 05, U = 20, mu = 10, and beta = 100. Once the DMFT self-consistent calculation is finished, the Matsubara self-energy function Sigma(iomega_n) is obtained. We are going to convert it to real frequency self-energy function Sigma(omega). The data of Matsubara self-energy function Sigma(iomega_n) have been preprocessed and stored in siw.data. This file contains five columns, which are used to record the Matsubara frequency omega_n, ReSigma(iomega_n), ImSigma(iomega_n), error bar of ReSigma(iomega_n), error bar of ImSigma(iomega_n), respectively. Only the first twenty Matsubara frequency points are kept, because the high-frequency data are somewhat noisy.","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"The purpose of this example is to demonstrate usage of the MaxEnt solver and the script mode of the ACFlow toolkit. Next we will explain the key steps in detail. As for the complete Julia script, please refer to sigma.jl and gendata.jl in the /home/your_home/acflow/tutor/T01/ folder.","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"First, we have to load the essential Julia packages. Both the DelimitedFiles and Printf packages belong to Julia's standard library. They are used to read input data and write calculated results, respectively.","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"#!/usr/bin/env julia\n\nusing DelimitedFiles\nusing Printf\nusing ACFlow\n\nwelcome() # Print welcome message only","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"Next, the data of Matsubara self-energy function are read from siw.data. The Hartree term Sigma_H should be subtracted from its real part:","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"Sigma(iomega_n) to Sigma(iomega_n) - Sigma_H","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"Note that Sigma_H is approximately equal to the asymptotic value of real part of Sigma(iomega_n) when n goes to infinite.","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"# Deal with self-energy function\n#\n# Read self-energy function\ndlm = readdlm(\"siw.data\")\n#\n# Get grid\ngrid = dlm[:,1]\n#\n# Get self-energy function\nSinp = dlm[:,2] + im * dlm[:,3] # Value\nSerr = dlm[:,4] + im * dlm[:,5] # Error bar\n#\n# Subtract hartree term\nSh = 1.0\n@. Sinp = Sinp - Sh","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"Next, the computational parameters are encapsulated into two dictionaries. The dict B is for the [BASE] block, while the dict S is for the MaxEnt solver. Then the setup_param() function is called, so that these parameters take effect. Here, the MatEnt solver is employed to tackle the analytic continuation problem. But the other stochastic sampling solvers are also applicable. The default model function is gaussian. The mesh for spectral density is non-uniform (A tangent mesh). The number of used alpha parameters is 15, and the optimal alpha parameter is determined by the chi^2kink algorithm.","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"# Setup parameters\n#\n# For [BASE] block\n# See types.jl/_PBASE for default setup\nB = Dict{String,Any}(\n    \"solver\" => \"MaxEnt\",  # Choose MaxEnt solver\n    \"mtype\"  => \"gauss\",   # Default model function\n    \"mesh\"   => \"tangent\", # Mesh for spectral density\n    \"ngrid\"  => 20,        # Number of input points\n    \"nmesh\"  => 801,       # Number of output points\n    \"wmax\"   => 8.0,       # Right boundary of mesh\n    \"wmin\"   => -8.0,      # Left boundary of mesh\n    \"beta\"   => 10.0,      # Inverse temperature\n)\n#\n# For [MaxEnt] block\n# See types.jl/_PMaxEnt for default setup\nS = Dict{String,Any}(\n    \"nalph\"  => 15,        # Number of alpha\n    \"alpha\"  => 1e12,      # Starting value of alpha\n    \"blur\"   => -1.0,      # Enable preblur or not\n)\n#\n# Let the parameters take effect\nsetup_param(B, S)","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"It is quite easy to start the analytic continuation calculation. Just call the solve() function and pass the grid, input data, and error bar data to it. The return values of this function call are real frequency mesh, spectral density, and reconstructed Matsubara self-energy function.","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"# Call the solver\nmesh, Aout, Sout = solve(grid, Sinp, Serr)","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"Finally, the real frequency self-energy function must be supplemented with the Hartree term. Then the final results are written into sigma.data.","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"# Calculate final self-energy function on real axis\n#\n# Add hartree term\n@. Sout = Sout + Sh\n#\n# Write self-energy function to sigma.data\nopen(\"sigma.data\", \"w\") do fout\n    for i in eachindex(mesh)\n        z = Sout[i]\n        @printf(fout, \"%20.16f %20.16f %20.16f\\n\",\n                mesh[i], real(z), imag(z))\n    end\nend","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"The calculated results are displayed in Fig.1. Fig.1(a) and (b) show the real and imaginary parts of the real frequency self-energy function, respectively. Near the Fermi level, ReSigma(omega) exhibits quasi-linear behavior, with which the quasiparticle weight Z and effective mass of electron m^* can be easily evaluated. As for the imaginary part, ImSigma(0) is finite, which indicates that the electron-electron scattering is not trivial. Fig.1(c) shows the alpha-dependent chi^2. The vertical bar in this figure indicates the optimal alpha is around 10^2154. In Fig.(d), the reproduced and raw self-energy functions are compared. It is apparent that they are consistent with each other.","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"(Image: T_E1.png)","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"Figure 1 | Analytic continuation of Matsubara self-energy function by using the maximum entropy method. (a) Real part of real frequency self-energy function. (b) Imaginary part of real frequency self-energy function. (c) chi^2 as a function of alpha. The vertical bar indicates the optimal alpha parameter chosen by the chi2kink algorithm. (d) Reproduced and original data for imaginary part of the Matsubara self-energy functions.","category":"page"},{"location":"library/mesh.html#Meshes","page":"Meshes","title":"Meshes","text":"","category":"section"},{"location":"library/mesh.html","page":"Meshes","title":"Meshes","text":"Meshes on real axis.","category":"page"},{"location":"library/mesh.html","page":"Meshes","title":"Meshes","text":"The spectral functions are always defined on real axis. The ACFlow toolkit supports various uniform and non-uniform meshes. In order to build these meshes, we need some additional control parameters, including f_1 and cut. They should be setup by using the parameter pmesh.","category":"page"},{"location":"library/mesh.html#Contents","page":"Meshes","title":"Contents","text":"","category":"section"},{"location":"library/mesh.html","page":"Meshes","title":"Meshes","text":"Pages = [\"mesh.md\"]\nDepth = 2","category":"page"},{"location":"library/mesh.html#Index","page":"Meshes","title":"Index","text":"","category":"section"},{"location":"library/mesh.html","page":"Meshes","title":"Meshes","text":"Pages = [\"mesh.md\"]","category":"page"},{"location":"library/mesh.html#Types","page":"Meshes","title":"Types","text":"","category":"section"},{"location":"library/mesh.html","page":"Meshes","title":"Meshes","text":"AbstractMesh\nLinearMesh\nTangentMesh\nLorentzMesh\nHalfLorentzMesh\nDynamicMesh","category":"page"},{"location":"library/mesh.html#ACFlow.AbstractMesh","page":"Meshes","title":"ACFlow.AbstractMesh","text":"AbstractMesh\n\nAn abstract type representing the real axis. It is used to build the internal type system.\n\n\n\n\n\n","category":"type"},{"location":"library/mesh.html#ACFlow.LinearMesh","page":"Meshes","title":"ACFlow.LinearMesh","text":"LinearMesh\n\nMutable struct. A linear and uniform mesh.\n\nMembers\n\nnmesh  -> Number of mesh points.\nwmax   -> Right boundary (maximum value).\nwmin   -> Left boundary (minimum value).\nmesh   -> Mesh itself.\nweight -> Precomputed integration weights (composite trapezoidal rule).\n\nSee also: TangentMesh.\n\n\n\n\n\n","category":"type"},{"location":"library/mesh.html#ACFlow.TangentMesh","page":"Meshes","title":"ACFlow.TangentMesh","text":"TangentMesh\n\nMutable struct. A non-linear and non-uniform mesh. Note that it should be defined on both negative and positive half-axis.\n\nMembers\n\nnmesh  -> Number of mesh points.\nwmax   -> Right boundary (maximum value).\nwmin   -> Left boundary (minimum value).\nmesh   -> Mesh itself.\nweight -> Precomputed integration weights (composite trapezoidal rule).\n\nSee also: LinearMesh.\n\n\n\n\n\n","category":"type"},{"location":"library/mesh.html#ACFlow.LorentzMesh","page":"Meshes","title":"ACFlow.LorentzMesh","text":"LorentzMesh\n\nMutable struct. A non-linear and non-uniform mesh. Note that it should be defined on both negative and positive half-axis.\n\nMembers\n\nnmesh  -> Number of mesh points.\nwmax   -> Right boundary (maximum value).\nwmin   -> Left boundary (minimum value).\nmesh   -> Mesh itself.\nweight -> Precomputed integration weights (composite trapezoidal rule).\n\nSee also: HalfLorentzMesh.\n\n\n\n\n\n","category":"type"},{"location":"library/mesh.html#ACFlow.HalfLorentzMesh","page":"Meshes","title":"ACFlow.HalfLorentzMesh","text":"HalfLorentzMesh\n\nMutable struct. A non-linear and non-uniform mesh. Note that it should be defined on positive half-axis only.\n\nMembers\n\nnmesh  -> Number of mesh points.\nwmax   -> Right boundary (maximum value).\nwmin   -> Left boundary (minimum value). It must be 0.0.\nmesh   -> Mesh itself.\nweight -> Precomputed integration weights (composite trapezoidal rule).\n\nSee also: LorentzMesh.\n\n\n\n\n\n","category":"type"},{"location":"library/mesh.html#ACFlow.DynamicMesh","page":"Meshes","title":"ACFlow.DynamicMesh","text":"DynamicMesh\n\nMutable struct. A mesh used internally in stochastic methods. It supports both uniform and non-uniform meshes. The mesh is usually generated by util/gmesh.jl, saved in fmesh.inp, and loaded dynamically during the initialization step. This mesh should not be used as a regular mesh for describing the spectral functions.\n\nMembers\n\nnmesh  -> Number of mesh points.\nwmax   -> Right boundary (maximum value).\nwmin   -> Left boundary (minimum value).\nmesh   -> Mesh itself.\nweight -> Precomputed integration weights (composite trapezoidal rule).\n\nSee also: LinearMesh.\n\n\n\n\n\n","category":"type"},{"location":"library/mesh.html#Constructors","page":"Meshes","title":"Constructors","text":"","category":"section"},{"location":"library/mesh.html","page":"Meshes","title":"Meshes","text":"LinearMesh(nmesh::I64, wmin::F64, wmax::F64)\nTangentMesh(nmesh::I64, wmin::F64, wmax::F64, 𝑝::F64 = 2.1)\nLorentzMesh(nmesh::I64, wmin::F64, wmax::F64, 𝑝::F64 = 0.01)\nHalfLorentzMesh(nmesh::I64, wmax::F64, 𝑝::F64 = 0.01)\nDynamicMesh(mesh::Vector{F64})","category":"page"},{"location":"library/mesh.html#ACFlow.LinearMesh-Tuple{Int64, Float64, Float64}","page":"Meshes","title":"ACFlow.LinearMesh","text":"LinearMesh(nmesh::I64, wmin::T, wmax::T) where {T}\n\nA constructor for the LinearMesh struct, which is announced in src/types.jl.\n\nSee also: LinearMesh.\n\n\n\n\n\n","category":"method"},{"location":"library/mesh.html#ACFlow.TangentMesh-2","page":"Meshes","title":"ACFlow.TangentMesh","text":"TangentMesh(nmesh::I64, wmin::T, wmax::T, 𝑝::T = 2.1) where {T}\n\nA constructor for the TangentMesh struct, which is announced in src/types.jl.\n\nSee also: TangentMesh.\n\n\n\n\n\n","category":"type"},{"location":"library/mesh.html#ACFlow.LorentzMesh-2","page":"Meshes","title":"ACFlow.LorentzMesh","text":"LorentzMesh(nmesh::I64, wmin::T, wmax::T, 𝑝::T = 0.01) where {T}\n\nA constructor for the LorentzMesh struct, which is announced in src/types.jl. The algorithm for generating a lorentzian mesh is taken from:\n\nhttps://github.com/CQMP/Maxent.\n\nSee also: LorentzMesh.\n\n\n\n\n\n","category":"type"},{"location":"library/mesh.html#ACFlow.HalfLorentzMesh-2","page":"Meshes","title":"ACFlow.HalfLorentzMesh","text":"HalfLorentzMesh(nmesh::I64, wmax::T, 𝑝::T = 0.01) where {T}\n\nA constructor for the HalfLorentzMesh struct, which is announced in src/types.jl. The algorithm for generating a half-lorentzian mesh is taken from:\n\nhttps://github.com/CQMP/Maxent.\n\nSee also: HalfLorentzMesh.\n\n\n\n\n\n","category":"type"},{"location":"library/mesh.html#ACFlow.DynamicMesh-Tuple{Vector{Float64}}","page":"Meshes","title":"ACFlow.DynamicMesh","text":"DynamicMesh(mesh::Vector{T}) where {T}\n\nA constructor for the DynamicMesh struct, which is announced in src/types.jl. The δ peaks in the stochastic analytic continuation or the poles in the stochastic pole expansion method could be placed in this mesh. This mesh should not be used to define the spectrum.\n\nSee also: DynamicMesh.\n\n\n\n\n\n","category":"method"},{"location":"library/mesh.html#Base.*-Functions","page":"Meshes","title":"Base.* Functions","text":"","category":"section"},{"location":"library/mesh.html","page":"Meshes","title":"Meshes","text":"Base.length(am::AbstractMesh)\nBase.iterate(am::AbstractMesh)\nBase.iterate(am::AbstractMesh, i::I64)\nBase.eachindex(am::AbstractMesh)\nBase.firstindex(am::AbstractMesh)\nBase.lastindex(am::AbstractMesh)\nBase.getindex(am::AbstractMesh, ind::I64)\nBase.getindex(am::AbstractMesh, I::UnitRange{I64})","category":"page"},{"location":"library/mesh.html#Base.length-Tuple{AbstractMesh}","page":"Meshes","title":"Base.length","text":"Base.length(am::AbstractMesh)\n\nReturn number of mesh points in a Mesh-like struct.\n\n\n\n\n\n","category":"method"},{"location":"library/mesh.html#Base.iterate-Tuple{AbstractMesh}","page":"Meshes","title":"Base.iterate","text":"Base.iterate(am::AbstractMesh)\n\nAdvance the iterator of a Mesh-like struct to obtain the next mesh point.\n\n\n\n\n\n","category":"method"},{"location":"library/mesh.html#Base.iterate-Tuple{AbstractMesh, Int64}","page":"Meshes","title":"Base.iterate","text":"Base.iterate(am::AbstractMesh, i::I64)\n\nThis is the key method that allows a Mesh-like struct to be iterated, yielding a sequences of mesh points.\n\n\n\n\n\n","category":"method"},{"location":"library/mesh.html#Base.eachindex-Tuple{AbstractMesh}","page":"Meshes","title":"Base.eachindex","text":"Base.eachindex(am::AbstractMesh)\n\nCreate an iterable object for visiting each index of a Mesh-like struct.\n\n\n\n\n\n","category":"method"},{"location":"library/mesh.html#Base.firstindex-Tuple{AbstractMesh}","page":"Meshes","title":"Base.firstindex","text":"Base.firstindex(am::AbstractMesh)\n\nReturn the first index of a Mesh-like struct.\n\n\n\n\n\n","category":"method"},{"location":"library/mesh.html#Base.lastindex-Tuple{AbstractMesh}","page":"Meshes","title":"Base.lastindex","text":"Base.lastindex(am::AbstractMesh)\n\nReturn the last index of a Mesh-like struct.\n\n\n\n\n\n","category":"method"},{"location":"library/mesh.html#Base.getindex-Tuple{AbstractMesh, Int64}","page":"Meshes","title":"Base.getindex","text":"Base.getindex(am::AbstractMesh, ind::I64)\n\nRetrieve the value(s) stored at the given key or index within a Mesh-like struct.\n\n\n\n\n\n","category":"method"},{"location":"library/mesh.html#Base.getindex-Tuple{AbstractMesh, UnitRange{Int64}}","page":"Meshes","title":"Base.getindex","text":"Base.getindex(am::AbstractMesh, I::UnitRange{I64})\n\nReturn a subset of a Mesh-like struct as specified by I.\n\n\n\n\n\n","category":"method"},{"location":"library/mesh.html#Utilities","page":"Meshes","title":"Utilities","text":"","category":"section"},{"location":"library/mesh.html","page":"Meshes","title":"Meshes","text":"nearest","category":"page"},{"location":"library/mesh.html#ACFlow.nearest","page":"Meshes","title":"ACFlow.nearest","text":"nearest(am::AbstractMesh, r::F64)\n\nGiven a position (0.0 ≤ r ≤ 1.0), and return the index of the nearest point in the mesh am.\n\nExamples\n\nam = LinearMesh(1001, -10.0, 10.0)\npos = nearest(am, 0.2) # pos = 201\nprintln(am[pos]) # -6.0\n\nSee also: AbstractMesh.\n\n\n\n\n\n","category":"function"},{"location":"man/output.html#Output-Files","page":"Output Files","title":"Output Files","text":"","category":"section"},{"location":"man/output.html","page":"Output Files","title":"Output Files","text":"Once the analytic continuation simulation is finished, the final spectral function A(omega) is outputted to Aout.data. Note that A(omega) is equivalent to the imaginary part of real frequency Green's function ImG(omega). Then the ACFlow toolkit will automatically calculate the corresponding real part ReG(omega) via the Kramers-Kronig transformation. The full Green's function at real axis G(omega) is stored in Gout.data. The spectral function is also used to reconstruct the imaginary time or Matsubara Green's functions [tildeG(tau) or tildeG(iomega_n)], which is stored in repr.data. Besides the three output files, the ACFlow toolkit will generate quite a few output files, which can be used to analyze and diagnose the calculated results. All of the possible output files of the ACFlow toolkit are collected and explained in Table 1.","category":"page"},{"location":"man/output.html","page":"Output Files","title":"Output Files","text":"Filename Description\nAout.data Final spectral function A(omega).\nAout.data.alpha_i alpha-resolved spectral function A_alpha(omega) for the StochAC solver.\nrepr.data Reproduced Green's function tildeG at imaginary time or frequency axis.\nGout.data Full Green's function at real axis G(omega).\nchi2.data log_10(chi^2) vs log_10(alpha).\ngoodness.dat log_10(chi^2) vs log_10(Theta) for the StochSK solver.\nmodel.data Default model m(omega).\nhamil.data U(alpha) vs alpha for the StochAC solver.\npassed.data Indices of selected solutions for the StochOM and the StochPX solvers.\npole.data Amplitudes and positions of the poles for the StochPX solver.\nprob.data PalphabarG vs alpha for the MaxEnt solver (bryan algorithm).\nstat.data Monte Carlo statistical information for stochastic sampling methods.","category":"page"},{"location":"man/output.html","page":"Output Files","title":"Output Files","text":"Table 1 | Possible output files of the ACFlow toolkit.","category":"page"},{"location":"man/output.html","page":"Output Files","title":"Output Files","text":"warning: Warning\nFor bosonic systems, the MaxEnt, StochAC, StochSK, and StochOM solvers will generate and output tildeA(omega), instead of traditional A(omega). That is to say, in Aout.data, the data are actually tildeA(omega). If the users want to retrieve A(omega), they have to do the transformation by themselves:tildeA(omega) = fracA(omega)omegaor resort to Gout.data. On the other hand, the StochPX solver will always generate and output A(omega), irrespective of bosonic and fermionic systems.","category":"page"},{"location":"library/type.html#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"library/type.html","page":"Types","title":"Types","text":"Define some fundamental types and structs for the ACFlow toolkit.","category":"page"},{"location":"library/type.html#Contents","page":"Types","title":"Contents","text":"","category":"section"},{"location":"library/type.html","page":"Types","title":"Types","text":"Pages = [\"type.md\"]\nDepth = 2","category":"page"},{"location":"library/type.html#Index","page":"Types","title":"Index","text":"","category":"section"},{"location":"library/type.html","page":"Types","title":"Types","text":"Pages = [\"type.md\"]","category":"page"},{"location":"library/type.html#Data-Types","page":"Types","title":"Data Types","text":"","category":"section"},{"location":"library/type.html","page":"Types","title":"Types","text":"DType\nADT\nAbstractData\nRawData\nGreenData","category":"page"},{"location":"library/type.html#ACFlow.DType","page":"Types","title":"ACFlow.DType","text":"Customized types. It is used to define the following dicts.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#ACFlow.ADT","page":"Types","title":"ACFlow.ADT","text":"Customized types. It is used to define the following dicts.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#ACFlow.AbstractData","page":"Types","title":"ACFlow.AbstractData","text":"AbstractData\n\nAn abstract type representing the input data in imaginary axis. It is used to build the internal type system.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#ACFlow.RawData","page":"Types","title":"ACFlow.RawData","text":"RawData\n\nMutable struct. It represent the raw input data. The datatype T of raw data may be Float64 or ComplexF64.\n\nMembers\n\n_grid -> Raw grid for the input data, such as τ or iωₙ.\nvalue -> Raw input data, such as G(τ), G(iωₙ), or Σ(iωₙ).\nerror -> Error bar (standard deviation) of raw input data, σ.\n\nSee also: GreenData.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#ACFlow.GreenData","page":"Types","title":"ACFlow.GreenData","text":"GreenData\n\nMutable struct. It represents the preprocessed input data. Note that it should support arbitrary precision via T\n\nMembers\n\nvalue -> Preprocessed input data.\nerror -> Preprocessed error bar.\ncovar -> Diagonal parts of the covariance matrix, σ².\n\nSee also: RawData.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#Dictionaries","page":"Types","title":"Dictionaries","text":"","category":"section"},{"location":"library/type.html","page":"Types","title":"Types","text":"PBASE\nPMaxEnt\nPNevanAC\nPStochAC\nPStochSK\nPStochOM\nPStochPX","category":"page"},{"location":"library/type.html#ACFlow.PBASE","page":"Types","title":"ACFlow.PBASE","text":"PBASE\n\nDictionary for configuration parameters: general setup.\n\n\n\n\n\n","category":"constant"},{"location":"library/type.html#ACFlow.PMaxEnt","page":"Types","title":"ACFlow.PMaxEnt","text":"PMaxEnt\n\nDictionary for configuration parameters: the maximum entropy method.\n\n\n\n\n\n","category":"constant"},{"location":"library/type.html#ACFlow.PNevanAC","page":"Types","title":"ACFlow.PNevanAC","text":"PNevanAC\n\nDictionary for configuration parameters: the Nevanlinna analytical continuation method.\n\n\n\n\n\n","category":"constant"},{"location":"library/type.html#ACFlow.PStochAC","page":"Types","title":"ACFlow.PStochAC","text":"PStochAC\n\nDictionary for configuration parameters: the stochastic analytic continuation method (K. S. D. Beach's version).\n\n\n\n\n\n","category":"constant"},{"location":"library/type.html#ACFlow.PStochSK","page":"Types","title":"ACFlow.PStochSK","text":"PStochSK\n\nDictionary for configuration parameters: the stochastic analytic continuation method (A. W. Sandvik's version).\n\n\n\n\n\n","category":"constant"},{"location":"library/type.html#ACFlow.PStochOM","page":"Types","title":"ACFlow.PStochOM","text":"PStochOM\n\nDictionary for configuration parameters: the stochastic optimization method.\n\n\n\n\n\n","category":"constant"},{"location":"library/type.html#ACFlow.PStochPX","page":"Types","title":"ACFlow.PStochPX","text":"PStochPX\n\nDictionary for configuration parameters: the stochastic pole expansion.\n\n\n\n\n\n","category":"constant"},{"location":"index.html#ACFlow","page":"Home","title":"ACFlow","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"A full-fledged analytic continuation toolkit in Julia.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"note: Note\nThank you for using ACFlow. This documentation will help you to be familiar with and explore the ACFlow toolkit.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"warning: Warning\nThe ACFlow toolkit is in heavy development. Please use it at your own risk.","category":"page"},{"location":"index.html#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"intro/background.md\",\n    \"intro/ack.md\",\n    \"intro/cite.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"man/feature.md\",\n    \"man/impl.md\",\n    \"man/install.md\",\n    \"man/run.md\",\n    \"man/input.md\",\n    \"man/output.md\",\n    \"man/param.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"examples/sigma.md\",\n    \"examples/green1.md\",\n    \"examples/green2.md\",\n    \"examples/current.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#Theory","page":"Home","title":"Theory","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"theory/basic.md\",\n    \"theory/maxent.md\",\n    \"theory/nac.md\",\n    \"theory/sac1.md\",\n    \"theory/sac2.md\",\n    \"theory/som.md\",\n    \"theory/spx.md\",\n    \"theory/reference.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#Library","page":"Home","title":"Library","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"library/outline.md\",\n    \"library/acflow.md\",\n    \"library/global.md\",\n    \"library/types.md\",\n    \"library/base.md\",\n    \"library/solver.md\",\n    \"library/grid.md\",\n    \"library/mesh.md\",\n    \"library/model.md\",\n    \"library/kernel.md\",\n    \"library/config.md\",\n    \"library/inout.md\",\n    \"library/math.md\",\n    \"library/util.md\",\n]\nDepth = 1","category":"page"}]
}

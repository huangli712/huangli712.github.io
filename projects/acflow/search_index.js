var documenterSearchIndex = {"docs":
[{"location":"theory/reference.html#References","page":"References","title":"References","text":"","category":"section"},{"location":"theory/reference.html","page":"References","title":"References","text":"Maximum entropy method","category":"page"},{"location":"theory/reference.html","page":"References","title":"References","text":"","category":"page"},{"location":"theory/reference.html","page":"References","title":"References","text":"[1] J. E. Gubernatis, M. Jarrell, R. N. Silver, D. S. Sivia, Quantum monte carlo simulations and maximum entropy: Dynamics from imaginary-time data, Phys. Rev. B 44, 6011 (1991).","category":"page"},{"location":"theory/reference.html","page":"References","title":"References","text":"[2] M. Jarrell, J. Gubernatis, Bayesian inference and the analytic continuation of imaginary-time quantum monte carlo data, Phys. Rep. 269, 133 (1996).","category":"page"},{"location":"theory/reference.html","page":"References","title":"References","text":"Stochastic analytical continuation","category":"page"},{"location":"theory/reference.html","page":"References","title":"References","text":"","category":"page"},{"location":"theory/reference.html","page":"References","title":"References","text":"[1] A. W. Sandvik, Stochastic method for analytic continuation of quantum monte carlo data, Phys. Rev. B 57, 10287 (1998)","category":"page"},{"location":"theory/reference.html","page":"References","title":"References","text":"[2] K. S. D. Beach, Identifying the maximum entropy method as a special limit of stochastic analytic continuation, arXiv:0403055 (2004).","category":"page"},{"location":"theory/reference.html","page":"References","title":"References","text":"[3] A. W. Sandvik, Constrained sampling method for analytic continuation, Phys. Rev. E 94, 063308 (2016).","category":"page"},{"location":"theory/reference.html","page":"References","title":"References","text":"[4] H. Shao, Y. Q. Qin, S. Capponi, S. Chesi, Z. Y. Meng, A. W. Sandvik, Nearly deconfined spinon excitations in the square-lattice spin-1/2 heisenberg antiferromagnet, Phys. Rev. X 7, 041072 (2017).","category":"page"},{"location":"theory/reference.html","page":"References","title":"References","text":"[5] H. Shao, A. W. Sandvik, Progress on stochastic analytic continuation of quantum monte carlo data, Phys. Rep. 1003, 1 (2023).","category":"page"},{"location":"theory/reference.html","page":"References","title":"References","text":"Stochastic optimization method","category":"page"},{"location":"theory/reference.html","page":"References","title":"References","text":"","category":"page"},{"location":"theory/reference.html","page":"References","title":"References","text":"[1] A. S. Mishchenko, N. V. Prokof’ev, A. Sakamoto, B. V. Svistunov, Diagrammatic quantum monte carlo study of the frohlich polaron, Phys. Rev. B 62, 6317 (2000).","category":"page"},{"location":"theory/reference.html","page":"References","title":"References","text":"[2] I. Krivenko, M. Harland, Triqs/som: Implementation of the stochastic optimization method for analytic continuation, Comput. Phys. Commun. 239, 166 (2019).","category":"page"},{"location":"library/config.html#Configuration","page":"Configuration","title":"Configuration","text":"","category":"section"},{"location":"library/config.html","page":"Configuration","title":"Configuration","text":"Read, parse, and extract the configuration parameters.","category":"page"},{"location":"library/config.html#Contents","page":"Configuration","title":"Contents","text":"","category":"section"},{"location":"library/config.html","page":"Configuration","title":"Configuration","text":"Pages = [\"config.md\"]\nDepth = 2","category":"page"},{"location":"library/config.html#Index","page":"Configuration","title":"Index","text":"","category":"section"},{"location":"library/config.html","page":"Configuration","title":"Configuration","text":"Pages = [\"config.md\"]","category":"page"},{"location":"library/config.html#Parser","page":"Configuration","title":"Parser","text":"","category":"section"},{"location":"library/config.html","page":"Configuration","title":"Configuration","text":"inp_toml\nfil_dict\nrev_dict","category":"page"},{"location":"library/config.html#ACFlow.inp_toml","page":"Configuration","title":"ACFlow.inp_toml","text":"inp_toml(f::String, key::String, necessary::Bool)\n\nParse the configuration file (in toml format). It reads only parts of the configuration file, which depends on the value of key.\n\n\n\n\n\ninp_toml(f::String, necessary::Bool)\n\nParse the configuration file (in toml format). It reads the whole file.\n\n\n\n\n\n","category":"function"},{"location":"library/config.html#ACFlow.fil_dict","page":"Configuration","title":"ACFlow.fil_dict","text":"fil_dict(cfg::Dict{String,Any})\n\nTransfer configurations from dict cfg to internal dicts (including PBASE, PMaxEnt, PStochAC, PStochSK, and PStochOM etc).\n\n\n\n\n\n","category":"function"},{"location":"library/config.html#ACFlow.rev_dict","page":"Configuration","title":"ACFlow.rev_dict","text":"rev_dict(BASE::Dict{String,Any})\n\nSetup the configuration dictionary: PBASE.\n\nSee also: PBASE.\n\n\n\n\n\nrev_dict(BASE::Dict{String,Vector{Any}})\n\nSetup the configuration dictionary: PBASE.\n\nSee also: PBASE.\n\n\n\n\n\nrev_dict(S::MaxEntSolver, MaxEnt::Dict{String,Any})\n\nSetup the configuration dictionary: PMaxEnt.\n\nSee also: PMaxEnt.\n\n\n\n\n\nrev_dict(S::MaxEntSolver, MaxEnt::Dict{String,Vector{Any}})\n\nSetup the configuration dictionary: PMaxEnt.\n\nSee also: PMaxEnt.\n\n\n\n\n\nrev_dict(S::StochACSolver, StochAC::Dict{String,Any})\n\nSetup the configuration dictionary: PStochAC.\n\nSee also: PStochAC.\n\n\n\n\n\nrev_dict(S::StochACSolver, StochAC::Dict{String,Vector{Any}})\n\nSetup the configuration dictionary: PStochAC.\n\nSee also: PStochAC.\n\n\n\n\n\nrev_dict(S::StochSKSolver, StochSK::Dict{String,Any})\n\nSetup the configuration dictionary: PStochSK.\n\nSee also: PStochSK.\n\n\n\n\n\nrev_dict(S::StochSKSolver, StochSK::Dict{String,Vector{Any}})\n\nSetup the configuration dictionary: PStochSK.\n\nSee also: PStochSK.\n\n\n\n\n\nrev_dict(S::StochOMSolver, StochOM::Dict{String,Any})\n\nSetup the configuration dictionary: PStochOM.\n\nSee also: PStochOM.\n\n\n\n\n\nrev_dict(S::StochOMSolver, StochOM::Dict{String,Vector{Any}})\n\nSetup the configuration dictionary: PStochOM.\n\nSee also: PStochOM.\n\n\n\n\n\nrev_dict(S::StochPXSolver, StochPX::Dict{String,Any})\n\nSetup the configuration dictionary: PStochPX.\n\nSee also: PStochPX.\n\n\n\n\n\nrev_dict(S::StochPXSolver, StochPX::Dict{String,Vector{Any}})\n\nSetup the configuration dictionary: PStochPX.\n\nSee also: PStochPX.\n\n\n\n\n\n","category":"function"},{"location":"library/config.html#Validation","page":"Configuration","title":"Validation","text":"","category":"section"},{"location":"library/config.html","page":"Configuration","title":"Configuration","text":"chk_dict\n_v","category":"page"},{"location":"library/config.html#ACFlow.chk_dict","page":"Configuration","title":"ACFlow.chk_dict","text":"chk_dict()\n\nValidate the correctness and consistency of configurations.\n\nSee also: fil_dict, _v.\n\n\n\n\n\n","category":"function"},{"location":"library/config.html#ACFlow._v","page":"Configuration","title":"ACFlow._v","text":"_v(key::String, val::Array{Any,1})\n\nVerify the value array. Called by chk_dict() function only.\n\nSee also: chk_dict.\n\n\n\n\n\n","category":"function"},{"location":"library/config.html#Extraction","page":"Configuration","title":"Extraction","text":"","category":"section"},{"location":"library/config.html","page":"Configuration","title":"Configuration","text":"get_b\nget_m\nget_a\nget_k\nget_s\nget_x","category":"page"},{"location":"library/config.html#ACFlow.get_b","page":"Configuration","title":"ACFlow.get_b","text":"get_b(key::String)\n\nExtract configurations from dict: PBASE.\n\nSee also: PBASE.\n\n\n\n\n\n","category":"function"},{"location":"library/config.html#ACFlow.get_m","page":"Configuration","title":"ACFlow.get_m","text":"get_m(key::String)\n\nExtract configurations from dict: PMaxEnt.\n\nSee also: PMaxEnt.\n\n\n\n\n\n","category":"function"},{"location":"library/config.html#ACFlow.get_a","page":"Configuration","title":"ACFlow.get_a","text":"get_a(key::String)\n\nExtract configurations from dict: PStochAC.\n\nSee also: PStochAC.\n\n\n\n\n\n","category":"function"},{"location":"library/config.html#ACFlow.get_k","page":"Configuration","title":"ACFlow.get_k","text":"get_k(key::String)\n\nExtract configurations from dict: PStochSK.\n\nSee also: PStochSK.\n\n\n\n\n\n","category":"function"},{"location":"library/config.html#ACFlow.get_s","page":"Configuration","title":"ACFlow.get_s","text":"get_s(key::String)\n\nExtract configurations from dict: PStochOM.\n\nSee also: PStochOM.\n\n\n\n\n\n","category":"function"},{"location":"library/config.html#ACFlow.get_x","page":"Configuration","title":"ACFlow.get_x","text":"get_x(key::String)\n\nExtract configurations from dict: PStochPX.\n\nSee also: PStochPX.\n\n\n\n\n\n","category":"function"},{"location":"theory/sac1.html#san","page":"Stochastic Analytical Continuation 1","title":"Stochastic Analytical Continuation 1","text":"","category":"section"},{"location":"theory/sac1.html","page":"Stochastic Analytical Continuation 1","title":"Stochastic Analytical Continuation 1","text":"info: Info\nIn principle, for given Green's function G, there exists infinitely many spectral densities A(omega) that can be used to reproduce G via mathbfG = mathbfKA. The maximum entropy method tries to pick up the most likely spectral function which maximizes PAbarG (It actually maximizes Q). Here, we would like to introduce an alternative approach, namely the stochastic analytical continuation. It is argued that the weights for all the possible spectral densities are the same if they can give rise to the same chi^2. At first, a sequence of spectral densities will be generated by stochastic method. Then an unbiased thermal average of all possible spectra, Boltzmann weighted according to goodness-of-fit function chi^2, produces an average spectrum. Thus sometimes the method was named as average spectrum method or stochastic sampling method in the references. There are several variants for the stochastic analytical continuation. Next we will introduce two representative algorithms as proposed by A. W. Sandvik and K. S. D. Beach, respectively.","category":"page"},{"location":"theory/sac1.html#Sandvik's-Algorithm","page":"Stochastic Analytical Continuation 1","title":"Sandvik's Algorithm","text":"","category":"section"},{"location":"theory/sac1.html","page":"Stochastic Analytical Continuation 1","title":"Stochastic Analytical Continuation 1","text":"It was early on realized that a different way to achieve a smooth spectrum is to average over many solutions with reasonable chi^2 values. Several years later, A. W. Sandvik introduced the stochastic analytical continuation in a slightly different form. He suggested that the spectral function A(omega) can be parameterized using N delta functions (Please see Fig.1 for schematic diagram):","category":"page"},{"location":"theory/sac1.html","page":"Stochastic Analytical Continuation 1","title":"Stochastic Analytical Continuation 1","text":"beginequation\nA(omega) = sum^N_i = 1 gamma_i delta(omega - omega_i)\nendequation","category":"page"},{"location":"theory/sac1.html","page":"Stochastic Analytical Continuation 1","title":"Stochastic Analytical Continuation 1","text":"where gamma_i and omega_i denote the amplitude and position of the i-th delta function, respectively. Next, the Metropolis important sampling algorithm is employed to sample the configuration space mathcalC = omega_i gamma_i. In practice, there are two elementary Monte Carlo updates. One is to change the amplitudes of a pair of delta functions under the constraint sum_i gamma_i = 1. Another one is to shift position of a randomly chosen delta function. Of course, block or global updates can be implemented to improve ergodicity and sampling efficiency.","category":"page"},{"location":"theory/sac1.html","page":"Stochastic Analytical Continuation 1","title":"Stochastic Analytical Continuation 1","text":"(Image: san.png)","category":"page"},{"location":"theory/sac1.html","page":"Stochastic Analytical Continuation 1","title":"Stochastic Analytical Continuation 1","text":"Figure 1 | Typical Monte Carlo field configurations for stochastic analytical continuation (A. W. Sandvik's version). Here, the delta functions reside at unrestricted frequencies omega_i, but their amplitudes gamma_i are equal and fixed. Note that different parameterizations are also possible.","category":"page"},{"location":"theory/sac1.html","page":"Stochastic Analytical Continuation 1","title":"Stochastic Analytical Continuation 1","text":"The transition probability of Monte Carlo updates reads:","category":"page"},{"location":"theory/sac1.html","page":"Stochastic Analytical Continuation 1","title":"Stochastic Analytical Continuation 1","text":"beginequation\np(mathcalC to mathcalC) = expleft(-fracDeltachi^22Thetaright)\nendequation","category":"page"},{"location":"theory/sac1.html","page":"Stochastic Analytical Continuation 1","title":"Stochastic Analytical Continuation 1","text":"where chi^2 is the goodness-of-fit function, Theta is a regulation parameter which is similar to the alpha parameter appeared in the maximum entropy method. Well, the remaining problem is how to fix Theta. Sandvik suggested to measure the following entropic term for some Theta:","category":"page"},{"location":"theory/sac1.html","page":"Stochastic Analytical Continuation 1","title":"Stochastic Analytical Continuation 1","text":"beginequation\nS(Theta) = - sum^N_i = 1 gamma_i log(gamma_i) K(0omega_i)\nendequation","category":"page"},{"location":"theory/sac1.html","page":"Stochastic Analytical Continuation 1","title":"Stochastic Analytical Continuation 1","text":"where K is the kernel function as defined above. Then make a plot of S with respect to log(Theta^-1). Overall, when Theta is large, S exhibits large fluctuations. When Theta is small, S will approach its global minimum steadily. A sharp drop in S before the approach to a constant value has been observed, and there is a local maximum at some Theta = hatTheta preceding the drop. Thus, Sandvik postulated that hatTheta was the optimum value at which to accumulate and average the spectral function. Syljuasen et al. suggested that let Theta = 1. Fuchs et al. tried to fix Theta by using Bayesian inference. Such that their approach was named as stochastic analytical inference. Very recently, Shao and Sandvik et al. proposed a smart method to determine the optimal value of Theta. Theta is adjusted so that","category":"page"},{"location":"theory/sac1.html","page":"Stochastic Analytical Continuation 1","title":"Stochastic Analytical Continuation 1","text":"beginequation\nlangle chi^2(Theta) rangle approx chi^2_textmin + c sqrt2chi^2_textmin\nendequation","category":"page"},{"location":"theory/sac1.html","page":"Stochastic Analytical Continuation 1","title":"Stochastic Analytical Continuation 1","text":"where c is a constant of order 1, chi^2_textmin is the minimum value of chi^2 at given Theta. Note that chi^2_textmin can be obtained in a simulated annealing process to very low Theta.","category":"page"},{"location":"library/inout.html#Input-and-output","page":"Input and output","title":"Input and output","text":"","category":"section"},{"location":"library/inout.html","page":"Input and output","title":"Input and output","text":"Define input and output functions for the ACFlow toolkit.","category":"page"},{"location":"library/inout.html#Contents","page":"Input and output","title":"Contents","text":"","category":"section"},{"location":"library/inout.html","page":"Input and output","title":"Input and output","text":"Pages = [\"inout.md\"]\nDepth = 2","category":"page"},{"location":"library/inout.html#Index","page":"Input and output","title":"Index","text":"","category":"section"},{"location":"library/inout.html","page":"Input and output","title":"Input and output","text":"Pages = [\"inout.md\"]","category":"page"},{"location":"library/inout.html#Read-Data","page":"Input and output","title":"Read Data","text":"","category":"section"},{"location":"library/inout.html","page":"Input and output","title":"Input and output","text":"read_real_data\nread_cmplx_data","category":"page"},{"location":"library/inout.html#ACFlow.read_real_data","page":"Input and output","title":"ACFlow.read_real_data","text":"read_real_data(finput::AbstractString, ngrid::I64)\n\nRead input data. This function is used for imaginary-time data. The input file should contain three columns. The first column is the imaginary-time grid, the second column is the value, the third column is the standard deviation σ. Here, ngrid specifies the number of grid points.\n\nSee also: read_cmplx_data.\n\n\n\n\n\n","category":"function"},{"location":"library/inout.html#ACFlow.read_cmplx_data","page":"Input and output","title":"ACFlow.read_cmplx_data","text":"read_cmplx_data(finput::AbstractString, ngrid::I64)\n\nRead input data. This function is used for Matsubara frequency data. The input should contain four columns or five columns. The first column is the Matsubara freqency grid, the second and third columns are the values (real part and imaginary part), the four and fifth columns are the standard deviations σ for the real and imaginary parts, respectively. If there are only four columns, it means that the real and imaginary parts share the same standard deviations.\n\nSee also: read_real_data.\n\n\n\n\n\nread_cmplx_data(finput::AbstractString, ngrid::I64, only_real_part::Bool)\n\nRead input data. This function is used for Matsubara frequency data. The input file only contains three columns. The first column is the Matsubara frequency grid, the second column is the real part or imaginary part of the data (which is specified by the argument only_real_part), and the third column is the standard deviation σ. This function is for bosonic correlation function.\n\nSee also: read_real_data.\n\n\n\n\n\n","category":"function"},{"location":"library/inout.html#Write-Data","page":"Input and output","title":"Write Data","text":"","category":"section"},{"location":"library/inout.html","page":"Input and output","title":"Input and output","text":"write_spectrum\nwrite_backward\nwrite_complete\nwrite_misfit\nwrite_goodness\nwrite_model\nwrite_hamiltonian\nwrite_passed\nwrite_pole\nwrite_probability\nwrite_statistics","category":"page"},{"location":"library/inout.html#ACFlow.write_spectrum","page":"Input and output","title":"ACFlow.write_spectrum","text":"write_spectrum(am::AbstractMesh, Aout::Vector{F64})\n\nWrite spectrum A(ω) to Aout.data. The grid is defined in am, and the spectrum is contained in Aout.\n\n\n\n\n\nwrite_spectrum(am::AbstractMesh, αₗ::Vector{F64}, Aout::Array{F64,2})\n\nWrite α-resolved spectrum A(ω) to Aout.data.alpha. The grid is defined in am, the α-resolved spectrum is contained in Aout, αₗ is the list for the α parameters. This function is called by the StochAC solver.\n\n\n\n\n\n","category":"function"},{"location":"library/inout.html#ACFlow.write_backward","page":"Input and output","title":"ACFlow.write_backward","text":"write_backward(ag::AbstractGrid, G::Vector{F64})\n\nWe can use the calculated spectrum in real axis to reproduce the input data in imaginary axis. This function will write the reproduced data to repr.data, which can be compared with the original data. Here, G is the reproduced data.\n\nSee also: reprod.\n\n\n\n\n\n","category":"function"},{"location":"library/inout.html#ACFlow.write_complete","page":"Input and output","title":"ACFlow.write_complete","text":"write_complete(am::AbstractMesh, G::Vector{C64})\n\nWrite the full data at real axis to Gout.data. am denotes the real axis, G is the calculated green's function data. Note that its real part is obtained via the so-called Kramers-Kronig transformation.\n\nSee also: kramers.\n\n\n\n\n\n","category":"function"},{"location":"library/inout.html#ACFlow.write_misfit","page":"Input and output","title":"ACFlow.write_misfit","text":"write_misfit(α_vec::Vector{F64}, χ²_vec::Vector{F64})\n\nWrite log10(α)-log10(χ²) data to chi2.data, which could be used to judge whether the obtained optimal α parameter is reasonable.\n\nSee also: write_goodness.\n\n\n\n\n\n","category":"function"},{"location":"library/inout.html#ACFlow.write_goodness","page":"Input and output","title":"ACFlow.write_goodness","text":"write_goodness(Θ_vec::Vector{F64}, χ²_vec::Vector{F64})\n\nWrite log10(Θ)-log10(χ²) data to goodness.data, which could be used to judge whether the obtained optimal Θ parameter is reasonable. This function is only useful for the StochSK solver.\n\nSee also: write_misfit.\n\n\n\n\n\n","category":"function"},{"location":"library/inout.html#ACFlow.write_model","page":"Input and output","title":"ACFlow.write_model","text":"write_model(am::AbstractMesh, D::Vector{F64})\n\nWrite the default model function to model.data.\n\n\n\n\n\n","category":"function"},{"location":"library/inout.html#ACFlow.write_hamiltonian","page":"Input and output","title":"ACFlow.write_hamiltonian","text":"write_hamiltonian(α_vec::Vector{F64}, Uα::Vector{F64})\n\nWrite α-U(α) data to hamil.data, which could be used to judge whether the obtained optimal α parameter is reasonable. This function is only useful for the StochAC solver.\n\n\n\n\n\n","category":"function"},{"location":"library/inout.html#ACFlow.write_passed","page":"Input and output","title":"ACFlow.write_passed","text":"write_passed(passed::Vector{I64}, med::F64, αgood::F64)\n\nWrite indices of selected solutions which should be used to calculate the averaged spectrum. Here, passed means the indices, med is the median value of χ², and αgood is the factor that is used to filter the solutions. This function is only useful for the StochOM and the StochPX solvers.\n\n\n\n\n\n","category":"function"},{"location":"library/inout.html#ACFlow.write_pole","page":"Input and output","title":"ACFlow.write_pole","text":"write_pole(Pᵥ::Vector{Vector{I64}},\n           Aᵥ::Vector{Vector{F64}},\n           𝕊ᵥ::Vector{Vector{F64}},\n           χ²::Vector{F64},\n           fmesh::AbstractMesh)\n\nWrite poles' positions and amplitudes to pole.data. This function is only useful for the StochPX solver.\n\n\n\n\n\n","category":"function"},{"location":"library/inout.html#ACFlow.write_probability","page":"Input and output","title":"ACFlow.write_probability","text":"write_probability(α_vec::Vector{F64}, p_vec::Vector{F64})\n\nWrite p(α) data to prob.data. This function is only useful for the MaxEnt solver (bryan algorithm).\n\n\n\n\n\n","category":"function"},{"location":"library/inout.html#ACFlow.write_statistics","page":"Input and output","title":"ACFlow.write_statistics","text":"write_statistics(MC::StochACMC)\n\nWrite Monte Carlo statistical information for the StochAC solver. Note that the StochAC solver is based on a stochastic approach.\n\nSee also: PStochAC, StochACMC.\n\n\n\n\n\nwrite_statistics(MC::StochSKMC)\n\nWrite Monte Carlo statistical information for the StochSK solver. Note that the StochSK solver is based on a stochastic approach.\n\nSee also: PStochSK, StochSKMC.\n\n\n\n\n\nwrite_statistics(MC::StochOMMC)\n\nWrite Monte Carlo statistical information for the StochOM solver. Note that the StochOM solver is based on a stochastic approach.\n\nSee also: PStochOM, StochOMMC.\n\n\n\n\n\nwrite_statistics(MC::StochPXMC)\n\nWrite Monte Carlo statistical information for the StochPX solver. Note that the StochPX solver is based on a stochastic approach.\n\nSee also: PStochPX, StochPXMC.\n\n\n\n\n\n","category":"function"},{"location":"man/run.html#Running-Modes","page":"Running Modes","title":"Running Modes","text":"","category":"section"},{"location":"man/run.html","page":"Running Modes","title":"Running Modes","text":"The ACFlow toolkit is designed to be flexible and easy-to-use. It provides three running modes to facilitate analytical continuation calculations, namely the interactive, script, and standard modes.","category":"page"},{"location":"man/run.html","page":"Running Modes","title":"Running Modes","text":"warning: Warning\nThe environment variable ACFLOW_HOME must be set at advance.","category":"page"},{"location":"man/run.html#Interactive-Mode","page":"Running Modes","title":"Interactive Mode","text":"","category":"section"},{"location":"man/run.html","page":"Running Modes","title":"Running Modes","text":"With the ACFlow toolkit, the users can configure and carry out analytical continuation simulations interactively in Julia's REPL (Read-Eval-Print Loop) environment. For example,","category":"page"},{"location":"man/run.html","page":"Running Modes","title":"Running Modes","text":"julia> push!(LOAD_PATH, ENV[\"ACFLOW_HOME\"])\njulia> using ACFlow\njulia> setup_args(\"ac.toml\")\njulia> read_param()\njulia> mesh, Aout, Gout = solve(read_data())","category":"page"},{"location":"man/run.html","page":"Running Modes","title":"Running Modes","text":"Here, ac.toml is a configuration file, which contains essential computational parameters. The return values of the solve() function (i.e., mesh, Aout, and Gout) are mesh at real axis omega, spectral density A(omega), and reproduced Green's function tildeG, respectively. They can be further analyzed or visualized by the users.","category":"page"},{"location":"man/run.html#Script-Mode","page":"Running Modes","title":"Script Mode","text":"","category":"section"},{"location":"man/run.html","page":"Running Modes","title":"Running Modes","text":"The core functionalities of the ACFlow toolkit are exposed to the users via a simple application programming interface. So, the users can write Julia scripts easily by themselves to perform analytical continuation simulations. A minimal Julia script (acrun.jl) is listed as follows:","category":"page"},{"location":"man/run.html","page":"Running Modes","title":"Running Modes","text":"#!/usr/bin/env julia\n\npush!(LOAD_PATH, ENV[\"ACFLOW_HOME\"])\n\nusing ACFlow\n\nsetup_args(\"ac.toml\")\nread_param()\nmesh, Aout, Gout = solve(read_data())","category":"page"},{"location":"man/run.html","page":"Running Modes","title":"Running Modes","text":"Of course, this script can be extended to finish complex tasks. Later, a realistic example will be provided to show how to complete an analytical continuation of Matsubara self-energy function via the script mode.","category":"page"},{"location":"man/run.html#Standard-Mode","page":"Running Modes","title":"Standard Mode","text":"","category":"section"},{"location":"man/run.html","page":"Running Modes","title":"Running Modes","text":"In the standard mode, the users have to prepare the input data manually. In addition, a configuration file must be provided. Supposed that the configuration file is ac.toml, then the analytical continuation calculation is launched as follows:","category":"page"},{"location":"man/run.html","page":"Running Modes","title":"Running Modes","text":"$ /home/your_home/acflow/util/acrun.jl ac.toml","category":"page"},{"location":"man/run.html","page":"Running Modes","title":"Running Modes","text":"or","category":"page"},{"location":"man/run.html","page":"Running Modes","title":"Running Modes","text":"$ /home/your_home/acflow/util/Pacrun.jl ac.toml","category":"page"},{"location":"man/run.html","page":"Running Modes","title":"Running Modes","text":"warning: Warning\nBy default, the Pacrun.jl will launch 8 processes. If the users want to use more or less processes, they should modify line 13 in Pacrun.jl:addprocs(8)Specifically, change number 8.","category":"page"},{"location":"man/run.html","page":"Running Modes","title":"Running Modes","text":"Noted that the acrun.jl script runs sequentially, while the Pacrun.jl script supports parallel and distributed computing. As we can conclude from the filename extension of configuration file (ac.toml), it adopts the TOML specification. The users may edit it with any text-based editors. Next we will introduce syntax and format of the input data files and configuration files.","category":"page"},{"location":"library/acflow.html#ACFlow.jl","page":"ACFlow","title":"ACFlow.jl","text":"","category":"section"},{"location":"library/acflow.html","page":"ACFlow","title":"ACFlow","text":"Declare the module and public members.","category":"page"},{"location":"library/acflow.html#Modules","page":"ACFlow","title":"Modules","text":"","category":"section"},{"location":"library/acflow.html","page":"ACFlow","title":"ACFlow","text":"ACFlow","category":"page"},{"location":"library/acflow.html#ACFlow","page":"ACFlow","title":"ACFlow","text":"ACFlow\n\nACFlow is a modern software toolkit for solving the many-body analytical continuation problem. It is usually used to convert the single-particle or two-particle correlators from imaginary axis to real axis. Now this toolkit is under heavy development. PLEASE USE IT AT YOUR OWN RISK.\n\nNowadays the ACFlow toolkit supports the following algorithms:\n\nMaximum Entropy Method (MaxEnt solver)\nStochastic Analytical Continuation (StochAC and StochSK solvers)\nStochastic Optimization Method (StochOM solver)\nStochastic Pole eXpansion (StochPX solver, experimental)\n\nMore algorithms will be implemented in the future.\n\nNote that ACFlow toolkit has been designed to be integrated into the Zen package. Actually, it is also compatible with the iQIST toolkit. In the other words, the end user can use it to analytically continue the imaginary time (or Matsubara frequency) data generated by the various quantum impurity solvers in the iQIST toolkit. Of course, it is quite easy to implement some kinds of interfaces for the other quantum impurity solvers.\n\nFor more details about how to obtain, install and use the ACFlow toolkit, please visit the following website:\n\nhttps://huangli712.github.io/projects/acflow/index.html\n\nAny suggestions, comments, and feedbacks are welcome. Enjoy it!\n\n\n\n\n\n","category":"module"},{"location":"library/acflow.html#Initialization","page":"ACFlow","title":"Initialization","text":"","category":"section"},{"location":"library/acflow.html","page":"ACFlow","title":"ACFlow","text":"_precompile\nACFlow.__init__","category":"page"},{"location":"library/acflow.html#ACFlow._precompile","page":"ACFlow","title":"ACFlow._precompile","text":"_precompile()\n\nHere, we would like to precompile the whole ACFlow toolkit to reduce the runtime latency and speed up the successive calculations.\n\n\n\n\n\n","category":"function"},{"location":"library/acflow.html#ACFlow.__init__","page":"ACFlow","title":"ACFlow.__init__","text":"__init__()\n\nThis function would be executed immediately after the module is loaded at runtime for the first time. It works at the REPL mode only.\n\n\n\n\n\n","category":"function"},{"location":"intro/cite.html#Citation","page":"Citation","title":"Citation","text":"","category":"section"},{"location":"intro/cite.html","page":"Citation","title":"Citation","text":"Please cite the following papers:","category":"page"},{"location":"intro/cite.html","page":"Citation","title":"Citation","text":"","category":"page"},{"location":"intro/cite.html","page":"Citation","title":"Citation","text":"[1] Li Huang, ACFlow: An open source toolkit for analytical continuation of quantum Monte Carlo data, arXiv:2211.16692 (2022).","category":"page"},{"location":"theory/som.html#Stochastic-Optimization-Method","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"","category":"section"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"A. O. Mishchenko et al. proposed the stochastic optimization method. Though it looks like the stochastic analytical continuation, their differences are quite apparent. The stochastic optimization method does not need any likelihood function or Boltzmann distribution to weight the candidate spectral functions. It generates a lot of spectral functions through Monte Carlo samplings. For each candidate spectral function, the deviation D between the reconstructed Green's function tildeG and original Green's function barG is measured. Those spectral functions with small deviations D are selected and averaged. Such that the desired spectral function is obtained.","category":"page"},{"location":"theory/som.html#Deviation-Function","page":"Stochastic Optimization Method","title":"Deviation Function","text":"","category":"section"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"In the stochastic optimization method, the deviation between reconstructed data tildeG and input data barG is described by:","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"beginequation\nDA = sum^M_m=1 Delta(m)\nendequation","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"where M is the number of input data, and Delta(m) is the deviation function,","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"beginequation\nDelta(m) = fracbarG(m) - tildeG(m)S(m)\nendequation","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"Here, S(m) = G(m)^d (where 0 le d le 1). Recently, Krivenko et al. suggested that it would be better to use the goodness-of-fit functional chi^2A to replace DA.","category":"page"},{"location":"theory/som.html#Spectral-Density","page":"Stochastic Optimization Method","title":"Spectral Density","text":"","category":"section"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"The stochastic optimization method will try to accumulate the candidate spectral functions that manifest small DA. Supposed the Monte Carlo simulations are repeated for L times. For the i-th Monte Carlo simulation, the spectral density A_i(omega) and deviation DA_i are recorded. The minimum value of deviation is minDA_i. Thus, the final spectral density reads:","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"beginequation\nA(omega) = frac1L_textgood sum^L_i = 1\ntheta(alpha_textgood minDA_i - DA_i) A_i(omega)\nendequation","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"Here, theta(x) is the Heaviside step function, and alpha_textgood is a adjustable parameter. L_textgood denotes the number of good spectral functions:","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"beginequation\nL_textgood = sum^L_i = 1\ntheta(alpha_textgood minDA_i - DA_i)\nendequation","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"That is to say, only those spectral functions who satisfy the following condition will be selected:","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"beginequation\nDA_i le alpha_textgood minDA_i\nendequation","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"Clearly, the larger alpha_textgood is, the more spectral functions are included. It is usually set to 2.","category":"page"},{"location":"theory/som.html#Rectangle-Representation","page":"Stochastic Optimization Method","title":"Rectangle Representation","text":"","category":"section"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"Similar to the stochastic analytical continuation, the stochastic optimization method usually employs a few rectangle functions to parameterize the spectral function:","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"beginequation\nA(omega) = sum_i R_c_i w_i h_i (omega)\nendequation","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"where i is the index of rectangle function. The definition of rectangle function R_c_i w_i h_i (omega) reads:","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"beginequation\nR_c_i w_i h_i (omega) =\nh_i\nthetaomega - (c_i - w_i2)\ntheta(c_i + w_i2) - omega\nendequation","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"where c_i, w_i, h_i denote the center, width, and height of the i-th rectangle, respectively. Pay attention to that the area of all rectangles must be normalized to 1:","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"beginequation\nsum_i h_i w_i = 1\nendequation","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"(Image: som.png)","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"Figure 1 | Typical Monte Carlo field configurations for stochastic optimization method. The spectral function is parameterized by multiple rectangle functions. Here, c_i, w_i, and h_i denote the center, width, and height of the i-th rectangle, respectively.","category":"page"},{"location":"theory/som.html#Monte-Carlo-Sampling","page":"Stochastic Optimization Method","title":"Monte Carlo Sampling","text":"","category":"section"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"The parameters of all rectangle functions create a configuration space:","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"beginequation\nmathcalC = c_i w_i h_i\nendequation","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"Then the Metropolis algorithm is utilized to sample this configuration space. Mishchenko et al. introduces seven Monte Carlo updates, including: (a) Insert a new rectangle, change width and height of another rectangle; (b) Remove an existing rectangle, change width and height of another rectangle; (c) Shift position of any rectangles; (d) Change widths of any two rectangles; (e) Change heights of any two rectangles; (f) Split a rectangle into two new rectangles; (g) Merge two adjacent rectangles into a new rectangle. The transition probability of these Monte Carlo updates is:","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"beginequation\np(mathcalC to mathcalC) = left(fracDA_mathcalCDA_mathcalCright)^1+d\nendequation","category":"page"},{"location":"theory/som.html","page":"Stochastic Optimization Method","title":"Stochastic Optimization Method","text":"As compared to the maximum entropy method, the likelihood function, entropic term, and model function are absent in the stochastic optimization method. As compared to the stochastic analytical continuation, there are no adjustable parameters, such as Theta in Sandvik's algorithm and alpha in Beach's algorithm. Thus, the simulated results of the stochastic optimization method are less affected by artificial parameters.","category":"page"},{"location":"theory/sac2.html#Stochastic-Analytical-Continuation-2","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"","category":"section"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"info: Info\nIn principle, for given Green's function G, there exists infinitely many spectral densities A(omega) that can be used to reproduce G via mathbfG = mathbfKA. The maximum entropy method tries to pick up the most likely spectral function which maximizes PAbarG (It actually maximizes Q). Here, we would like to introduce an alternative approach, namely the stochastic analytical continuation. It is argued that the weights for all the possible spectral densities are the same if they can give rise to the same chi^2. At first, a sequence of spectral densities will be generated by stochastic method. Then an unbiased thermal average of all possible spectra, Boltzmann weighted according to goodness-of-fit function chi^2, produces an average spectrum. Thus sometimes the method was named as average spectrum method or stochastic sampling method in the references. There are several variants for the stochastic analytical continuation. Next we will introduce two representative algorithms as proposed by A. W. Sandvik and K. S. D. Beach, respectively.","category":"page"},{"location":"theory/sac2.html#Beach's-Algorithm","page":"Stochastic Analytical Continuation 2","title":"Beach's Algorithm","text":"","category":"section"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"K. S. D. Beach proposed another variant of stochastic analytical continuation in 2004. In his approach, the analytical continuation problem is mapped into a system of interacting classic fields at first. Then the classic field is sampled using Monte Carlo method to obtain the final solution. He concluded that the maximum entropy method is simply the mean field limit of the stochastic analytical continuation. Next, this algorithm will be explained concisely.","category":"page"},{"location":"theory/sac2.html#Classic-Fields","page":"Stochastic Analytical Continuation 2","title":"Classic Fields","text":"","category":"section"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"Recalled that the goodness-of-fit functional chi^2A measures how closely the Green's function generated from A(omega) matches the raw input data. Its expression is rewritten as follows:","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"beginequation\nchi^2A = int^beta_0 frac1sigma(tau)^2\nleftint domegaK(tauomega) A(omega) - barG(tau)right^2 dtau\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"At first, a new variable x is introduced. The relation between x and omega is:","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"beginequation\nx = phi(omega) = int^omega_-infty domegam(omega)\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"where m(omega) denotes default model function. Clearly, the phi(omega) function defines a smooth mapping from mathbfR to 01. Since omega = phi^-1(x), a dimensionless classic field n(x) is created:","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"beginequation\nn(x) = fracA(phi^-1(x))m(phi^-1(x))\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"It is easy to prove that both n(x) and A(omega) obey similar normalization condition:","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"beginequation\nint domegaA(omega) = int^1_0 dxn(x) = 1\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"Next, in analogy with the goodness-of-fit functional chi^2A, the Hamiltonian for the system of classic field n(x) can be defined as follows:","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"beginequation\nHn(x) = int^beta_0 fracdtausigma(tau)^2\nleft\nint^1_0 dxK(taux) n(x) - barG(tau)\nright\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"Supposing alpha is an inverse temperature of the system, then the partition function Z is:","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"beginequation\nZ = int mathcalDne^-alpha Hn\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"where","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"beginequation\nint mathcalDn =\nint^infty_0 leftprod_x dn(x)right\ndeltaleft(int^1_0 dxn(x) - 1right)\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"The thermally averaged value of the classic field is:","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"beginequation\nlangle n(x) rangle = frac1Z int mathcalDnn(x) e^-alpha Hn\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"Finally, according to the definition of the classic field, the averaged spectral density langle A(omega) rangle can be expressed as:","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"beginequation\nlangle A(omega) rangle = langle n(phi(omega)) rangle m(omega)\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"So, by introducing the classic field n(x), the analytical continuation problem is converted into a statistical sampling of the classic field, which is easily solved by using the Monte Carlo method.","category":"page"},{"location":"theory/sac2.html#Monte-Carlo-Sampling","page":"Stochastic Analytical Continuation 2","title":"Monte Carlo Sampling","text":"","category":"section"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"Next we clarify how to sample the classic field. Similar to Sandvik's algorithm, n(x) is parameterized as a superposition of many delta functions (see Fig.1 for schematic diagram):","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"beginequation\nn_mathcalC (x) = sum_i gamma_i delta(x - r_i)\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"where gamma_i and r_i denote amplitude (weight) and position of the i-th delta function, respectively. And mathcalC means a configuration space formed by a set of r_i and gamma_i,","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"beginequation\nmathcalC = r_i gamma_i\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"Note that gamma_i and r_i satisfy the following constraints:","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"beginequation\nforall igamma_i  0sum_i gamma_i = 1 0 le r_i le 1\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"Supposed that there is a transition from mathcalC to mathcalC (r_i gamma_i to r_i gamma_i):","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"beginequation\nr_i to r_i =\nr_i + sum_lambda in Lambda delta_ilambda Delta r_lambda\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"beginequation\ngamma_i to gamma_i =\ngamma_i + sum_lambda in Lambda delta_ilambda Delta gamma_lambda\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"where Lambda means a subset of the delta functions, then the Hamiltonian of the system is changed from H_mathcalC to H_mathcalC. According to Eq.(5), H_mathcalC, H_mathcalC, and their difference Delta H can be calculated by:","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"beginequation\nH_mathcalC = int^beta_0 dtauh_mathcalC(tau)^2\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"beginequation\nH_mathcalC = int^beta_0 dtau\nlefth_mathcalC(tau) + Delta h(tau)right^2\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"beginequation\nDelta H = H_mathcalC - H_mathcalC =\nint^beta_0 dtauDelta h(tau)\n2h_mathcalC(tau) + Delta h(tau)\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"Here,","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"beginequation\nh(tau) = frac1sigma(tau) leftint^1_0 dxK(tau x)n(x) - barG(tau)right\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"and","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"beginequation\nDelta h(tau) = frac1sigma(tau)\nsum_lambda in Lambda\nleft\ngamma_lambda K(taur_lambda) - gamma_lambda K(taur_lambda)\nright\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"Finally, the transition probability from mathcalC to mathcalC reads","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"beginequation\np(C to C) = exp(-alpha Delta H)\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"(Image: sac.png)","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"Figure 1 | Typical Monte Carlo field configurations for stochastic analytical continuation (K. S. D. Beach's version). Note that the amplitudes gamma_i of all the delta functions are not identical. Both amplitudes gamma_i and positions r_i (00  r_i  10) can be sampled by Monte Carlo method.","category":"page"},{"location":"theory/sac2.html#Parallel-Tempering","page":"Stochastic Analytical Continuation 2","title":"Parallel Tempering","text":"","category":"section"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"The parallel tempering trick is adopted to improve the Monte Carlo algorithm as described above. It is possible to proceed multiple simulations simultaneously for a sequence of inverse temperature parameters alpha_1 alpha_2 cdots alpha_N . The ratio for two adjacent alpha parameters is a constant: alpha_p+1  alpha_p = R. Note that the field configurations in all simulations evolve in parallel but not independently. We can swap the field configurations between two adjacent layers. Of course, the detailed balance is always preserved, and each simulation will eventually settle into thermal equilibrium at given alpha. The transition probability of such a global Monte Carlo update is:","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"beginequation\np(mathcalC to mathcalC) = exp(alpha_p - alpha_q)(H_p - H_q)\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"where p and q are layer indices, and p = q pm 1. Parallel tempering eliminates the need for an initial annealing stage. Another advantage of parallel tempering is that it yields a complete temperature profile of all the important thermodynamic variables (such as specific heat and internal energy), which can be used to estimate the critical alpha and final spectral function langle A(omega) rangle.","category":"page"},{"location":"theory/sac2.html#Critical-Inverse-Temperature","page":"Stochastic Analytical Continuation 2","title":"Critical Inverse Temperature","text":"","category":"section"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"Clearly, langle n(x) rangle strongly depends on the inverse temperature alpha. How to use these alpha-dependent langle n(x) rangle to construct the final spectral function? Beach proposed a new algorithm. During parallel tempering process, the internal energy of the system is also measured in addition to langle n(x) rangle:","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"beginequation\nU(alpha_p) = langle H n rangle_alpha_p\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"Let us plot log_10U(alpha) as a function of log_10 (alpha). We find that log_10U(alpha) drops quickly at first when log_10 (alpha) increases, and then it approaches to a constant value slowly. The knee in log_10U(alpha) function, occurring in the vicinity of alpha = alpha^* (the corresponding layer index p = p^*), signals a jump in specific heat (a thermodynamic phase transition). Then the averaged spectral function is constructed by:","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"beginequation\nlangle langle n(x) rangle rangle =\nfracsum^N-1_p = p* U(alpha_p) - U(alpha_p+1) langle n(x) rangle_alpha_p\nU(alpha_p*) - U(alpha_N)\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"where N is the total number of alpha, and alpha_p* (equiv alpha^*) is the critical inverse temperature.","category":"page"},{"location":"theory/sac2.html#Likelihood-Function","page":"Stochastic Analytical Continuation 2","title":"Likelihood Function","text":"","category":"section"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"Neither of the Sandvik's and Beach's algorithms needs extra entropic term to regulate spectral density. All the stochastically generated spectra are treated on the same footing. Thus, the calculated spectral function retains more subtle structures than that obtained by the maximum entropy method. Actually, in stochastic analytical continuation,","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"beginequation\nlangle A rangle = int mathcalD APAbarG A\nendequation","category":"page"},{"location":"theory/sac2.html","page":"Stochastic Analytical Continuation 2","title":"Stochastic Analytical Continuation 2","text":"The weight of the candidate spectral function A is given by the likelihood function PAbarG. Eq.(20) can be viewed as likelihood functions in stochastic analytical continuation.","category":"page"},{"location":"examples/green1.html","page":"Matsubara Green's Function","title":"Matsubara Green's Function","text":"info: Info\nIn order to demonstrate usefulness of the ACFlow toolkit, four examples are illustrated in this section. These examples cover typical application scenarios of the ACFlow toolkit, including analytical continuations ofMatsubara self-energy function\nMatsubara Green's function\nImaginary time Green's function\nCurrent-current correlation functionwithin the script mode or standard mode. All of the necessary source codes and data files, which can be used to reproduce the results as shown in this section, are placed in the /home/your_home/acflow/test/T* folders.","category":"page"},{"location":"examples/green1.html#Matsubara-Green's-Function","page":"Matsubara Green's Function","title":"Matsubara Green's Function","text":"","category":"section"},{"location":"examples/green1.html","page":"Matsubara Green's Function","title":"Matsubara Green's Function","text":"The purpose of the second example is to treat the Matsubara Green's function by using the StochOM solver.","category":"page"},{"location":"examples/green1.html","page":"Matsubara Green's Function","title":"Matsubara Green's Function","text":"At first, please consider the following spectral density with two gaussian peaks:","category":"page"},{"location":"examples/green1.html","page":"Matsubara Green's Function","title":"Matsubara Green's Function","text":"A(omega) =\nA_1 expleftfrac-(omega - epsilon_1)^22 Gamma^2_1right +\nA_2 expleftfrac-(omega - epsilon_2)^22 Gamma^2_2right","category":"page"},{"location":"examples/green1.html","page":"Matsubara Green's Function","title":"Matsubara Green's Function","text":"with A_1 = 10, A_2 = 03, epsilon_1 = 05, epsilon_2 = -25, Gamma_1 = 02, and Gamma_2 = 08. Then the Matsubara Green's function G(iomega_n) is evaluated by using mathbfG = mathbfKA with beta = 100. Random noises, built by formula 00001 r_1 exp(i 2pi r_2 ) where r_1 and r_2 are random numbers in (0.0,1.0), are added to G(iomega_n). The error bar of G(iomega_n) is fixed to 1e-4. The generated data for G(iomega_n) are written in giw.data.","category":"page"},{"location":"examples/green1.html","page":"Matsubara Green's Function","title":"Matsubara Green's Function","text":"Next, we are going to use the standard mode, such that a configure file (ac.toml) must be prepared. It is listed as follows. Since the StochOM solver is chosen, the [BASE] and [StochOM] blocks must be present at the same time.","category":"page"},{"location":"examples/green1.html","page":"Matsubara Green's Function","title":"Matsubara Green's Function","text":"[BASE]\nfinput = \"giw.data\"\nsolver = \"StochOM\"\nktype  = \"fermi\"\nmtype  = \"flat\"\ngrid   = \"ffreq\"\nmesh   = \"linear\"\nngrid  = 10\nnmesh  = 501\nwmax   = 5.0\nwmin   = -5.0\nbeta   = 10.0\noffdiag = false\n\n[StochOM]\nntry  = 100000\nnstep = 1000\nnbox  = 100\nsbox  = 0.005\nwbox  = 0.02\nnorm  = -1.0","category":"page"},{"location":"examples/green1.html","page":"Matsubara Green's Function","title":"Matsubara Green's Function","text":"Then we use the acrun.jl or Pacrun.jl script to perform analytical continuation simulation. The calculated results are shown in Fig.1. As is seen in Fig.1(a), both the sharp peak around 0.5 eV and the broad peak around -2.5 eV are correctly reproduced by the StochOM solver. In Fig.1(b), the reconstructed Matsubara Green's function agrees quite well with the raw input data.","category":"page"},{"location":"examples/green1.html","page":"Matsubara Green's Function","title":"Matsubara Green's Function","text":"(Image: T_E2.png)","category":"page"},{"location":"examples/green1.html","page":"Matsubara Green's Function","title":"Matsubara Green's Function","text":"Figure 1 | Analytical continuation of Matsubara Green's function by using the stochastic optimization method. (a) Simulated and exact spectral functions. (b) Reconstructed and synthetic Matsubara Green's functions. Only the imaginary parts are presented in this figure.","category":"page"},{"location":"man/param.html#param","page":"Parameters","title":"Parameters","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"A comprehensive dictionary about parameters","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"The official configuration file for the ACFlow toolkit is case.toml. This page contains all the valid parameters that can appear in case.toml. As for the format of case.toml, please look at case.toml.","category":"page"},{"location":"man/param.html#Contents","page":"Parameters","title":"Contents","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Pages = [\"param.md\"]\nDepth = 3","category":"page"},{"location":"man/param.html#[BASE]-Block","page":"Parameters","title":"[BASE] Block","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"note: Note\nThis block is mandatory. The parameters in this block is useful for all the solvers.","category":"page"},{"location":"man/param.html#finput","page":"Parameters","title":"finput","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Filename for the input data. The input data should be stored in a column-wised and formated (CSV-like) text file.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"String.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"finput = \"gtau.data\"","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#solver","page":"Parameters","title":"solver","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter specifies the solvers that used to solve the analytical continuation problem. Now the ACFlow toolkit supports five different solvers. They are as follows:MaxEnt\nStochAC\nStochSK\nStochOM\nStochPXHere, MaxEnt means the maximum entropy method. The MaxEnt solver can be used to treat the correlators in Matsubara frequency or imaginary time axis. If solver = \"MaxEnt\", then the [MaxEnt] block must be available in the configuration file.StochAC means the stochastic analytical continuation method (K. S. D. Beach's algorithm). The StochAC solver can be used to treat the correlators in Matsubara frequency or imaginary time axis. If solver = \"StochAC\", then the [StochAC] block must be available in the configuration file.StochSK means the stochastic analytical continuation method (A. W. Sandvik's algorithm). The StochSK solver can be used to treat the correlators in Matsubara frequency or imaginary time axis. If solver = \"StochSK\", then the [StochSK] block must be available in the configuration file.StochOM means the stochastic optimization method. The StochOM solver can be used to treat the correlators in Matsubara frequency or imaginary time axis. If solver = \"StochOM\", then the [StochOM] block must be available in the configuration file.StochPX means the stochastic pole expansion method. The StochPX solver can be used to treat the correlators in Matsubara frequency axis only. If solver = \"StochPX\", then the [StochPX] block must be available in the configuration file.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"warning: Warning\nFor the StochOM solver, if the correlators are defined in imaginary time axis, they must be bosonic. In other words, the StochOM solver does not support analytical continuation of fermionic imaginary time correlation function.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"String.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"solver = \"MaxEnt\"","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#ktype","page":"Parameters","title":"ktype","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"It denotes the type of kernel functions. Now the ACFlow toolkit supports three types of kernel functions. They are:fermi\nboson\nbsymmHere, fermi means fermionic kernel function, which readsK(tauomega) = frace^-tauomega1 + e^-betaomegaandK(omega_nomega) = frac1iomega_n - omegaboson means bosonic kernel function, which readsK(tauomega) = fracomega e^-tauomega1 - e^-betaomegaandK(omega_nomega) = fracomegaiomega_n - omegabsymm means symmetric bosonic kernel function, which readsK(tauomega) = fracomega e^-tauomega + e^-(beta - tau)omega 1 - e^-betaomegaandK(omega_n omega) = frac-2omega^2omega_n^2 + omega^2As for detailed formula for these kernel functions, please refer to the comments in src/kernel.jl.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"String.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"ktype = \"fermi\"","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. It must be compatible with the grid parameter.","category":"page"},{"location":"man/param.html#mtype","page":"Parameters","title":"mtype","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"It denotes the type of default model functions. Now the ACFlow toolkit supports the following choices:flat\ngauss\n1gauss\n2gauss\nlorentz\n1lorentz\n2lorentz\nrisedecay\nfileHere, flat means the flat model (i.e., constant), gauss means the Gaussian model, 1gauss means the Shifted Gaussian model, 2gauss means the Two Gaussians model, lorentz means the Lorentzian model, 1lorentz means the Shifted Lorentzian model, 2lorentz means the Two Lorentzians model, and risedecay means the Rise-And-Decay model.Besides flat and file, all the other model functions need additional parameters to customize them (Of course, the ACFlow toolkit will supplement default parameters). The parameters can be specified by the pmodel parameter.Especially, if mtype = \"file\", then the default model function is encoded in model.inp. ACFlow will read this file and initialize the default model function automatically. Be careful, the mesh for this model function must be consistent with the one used in the analytical continuation calculations.As for detailed formula for these models, please refer to the comments in src/model.jl.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"String.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"mtype = \"flat\"","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. Only the MaxEnt solver need these model functions. The StochAC solver only supports the flat model. The StochSK, StochOM, and StochPX solvers are free of model functions.","category":"page"},{"location":"man/param.html#grid","page":"Parameters","title":"grid","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter specifies the grid's type for input data in imaginary axis. Now the ACFlow toolkit supports the following choices:ftime\nfpart\nbtime\nbpart\nffreq\nffrag\nbfreq\nbfragHere, ftime means fermionic and imaginary time, btime means bosonic and imaginary time, ffreq means fermionic and Matsubara frequency, and bfreq means bosonic and Matsubara frequency. fpart means fermionic and imaginary time as well, but the grid of imaginary time might be incomplete. bpart is similar to fpart, but it is for the bosonic case. ffrag means fermionic and Matsubara frequency as well, but the grid of Matsubara frequency might be incomplete. bfrag is similar to ffrag, but it is for the bosonic case.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"String.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"grid = \"ftime\"","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. It must be compatible with the ktype parameter. If grid is \"bfrag\", the first Matsubara frequency point, i.e. iomega_0 = 0, should be kept. See also ngrid.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"warning: Warning\nIf the StochOM solver is employed, the grid parameter should not be \"ftime\" or \"fpart\".","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"warning: Warning\nIf the StochPX solver is employed, the grid parameter should be \"ffreq\", \"ffrag\", \"bfreq\", or \"bfrag\".","category":"page"},{"location":"man/param.html#mesh","page":"Parameters","title":"mesh","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter specifies the mesh's type for output data (usually the spectral functions) in real axis. Now the ACFlow toolkit supports the following choices:linear\ntangent\nlorentz\nhalflorentzHere, linear means the Linear mesh, tangent means the Tangent mesh, lorentz means the Lorentzian mesh, and halflorentz means the Half-Lorentzian mesh.Notes that only the linear mesh is uniform, the other three meshes are non-uniform. And the halflorentz mesh is defined on the positive-half axis only.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"String.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"mesh = \"linear\"","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. See also nmesh.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"warning: Warning\nAs for the StochOM solver , it seems that the linear mesh works better.","category":"page"},{"location":"man/param.html#ngrid","page":"Parameters","title":"ngrid","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of grid points. The parameter, together with the beta and grid parameters, controls the generation of grid for input data.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"ngrid = 10","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. It must be compatible with the input data. See also grid.","category":"page"},{"location":"man/param.html#nmesh","page":"Parameters","title":"nmesh","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of mesh points. The parameter, together with the wmax, wmin, and mesh parameters, controls the generation of mesh for output data.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"nmesh = 501","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. See also mesh.","category":"page"},{"location":"man/param.html#wmax","page":"Parameters","title":"wmax","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Right boundary (maximum value) of mesh. Note that wmax should be always greater than wmin.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"wmax = 10.0","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#wmin","page":"Parameters","title":"wmin","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Left boundary (minimum value) of mesh. Note that wmax should be always greater than wmin.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"wmin = -10.0","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"warning: Warning\nIf the ktype = \"bsymm\", the wmin parameter should be 0.0. In other words, the spectral density is defined on the half positive axis.","category":"page"},{"location":"man/param.html#beta","page":"Parameters","title":"beta","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Inverse temperature beta. It is equal to 1T.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"beta = 10.0","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. This parameter must be compatible with the input data and grid. Specifically, for the imaginary time axis, the last grid point should be beta. As for the Matsubara frequency axis, the difference between two successive grid points should be pibeta.","category":"page"},{"location":"man/param.html#offdiag","page":"Parameters","title":"offdiag","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Is the input correlator the offdiagonal part in matrix-valued function? As for the offdiagonal correlator, the corresponding spectral function might be not positive-definite. Some tricks have been implemented to cure this issue.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Bool.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"offdiag = false","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. This parameter is useful for the MaxEnt solver only.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"warning: Warning\nNow only the MaxEnt solver supports this parameter.","category":"page"},{"location":"man/param.html#fwrite","page":"Parameters","title":"fwrite","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Are the analytical continuation results written into external files? If it is false, then only the terminal output is retained and all the other outputs are disable. By default (if this parameter is missing or true), the files should be generated.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Bool.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"fwrite = false","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is optional.","category":"page"},{"location":"man/param.html#pmodel","page":"Parameters","title":"pmodel","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Additional parameters for customizing the model functions. Note that the gauss, lorentz, and risedecay models need one parameter Gamma. The 1gauss and 1lorentz models need two parameters, Gamma and s. The 2gauss and 2lorentz models need three parameters, Gamma, s_1, and s_2.The pmodel parameter is used to define these parameters. If there is only one element in pmodel, then Gamma = pmodel[1]. If there are two elements in pmodel, then Gamma = pmodel[1] and s = pmodel[2]. If there are three elements in pmodel, then Gamma = pmodel[1], s_1 = pmodel[2], and s_2 = pmodel[3].","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Array.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"pmodel = [1.0]","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is optional.  The default values for Gamma, s, s_1, and s_2 are 2.0, 2.0, -2.0, and 2.0, respectively.","category":"page"},{"location":"man/param.html#pmesh","page":"Parameters","title":"pmesh","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Additional parameters for customizing the mesh. The tangent mesh needs the f_1 parameter. The lorentz and halflorentz meshes need the cut parameter. The pmesh parameter can be used to setup the two parameters. If pmesh contains one element or more than one elements, then f_1 equiv cut equiv pmesh[1].","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Array.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"pmesh = [2.1]","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is optional. The default values for f_1 and cut are 2.1 and 0.01, respectively. See also mesh.","category":"page"},{"location":"man/param.html#exclude","page":"Parameters","title":"exclude","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Restriction of the energy range of the calculated spectral functions. This features is implemented by the StochAC, StochSK, StochOM, and StochPX solvers. In these solvers, the delta or box functions, which are used to mimic the spectral functions, are restricted to live out of the given energy ranges. For example, exclude = [8.0,16.0] means that the energy range [8.0,16.0] is strictly forbidden.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Array.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"exclude = [[-8.0,-4.0],[4.0,8.0]]","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is optional. If you are using the MaxEnt solver, this parameter will be ignored.","category":"page"},{"location":"man/param.html#[MaxEnt]-Block","page":"Parameters","title":"[MaxEnt] Block","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"note: Note\nThe parameters in this block is valid for the MaxEnt solver only.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"warning: Warning\nIf solver = \"Maxent\", the [MaxEnt] block must be available.","category":"page"},{"location":"man/param.html#method","page":"Parameters","title":"method","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"How to determine the optimized alpha parameter? The MaxEnt solver supports four different algorithms. They arehistoric\nclassic\nbryan\nchi2kinkUsually, the chi2kink algorithm is preferred.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"String.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"method = \"bryan\"","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. As for the underlying principles of these algorithms, please see Maximum Entropy Method.","category":"page"},{"location":"man/param.html#stype","page":"Parameters","title":"stype","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type of the entropic factor. The MaxEnt solver supports two schemes. They aresj\nbrHere, sj means the Shannon-Jaynes entropy, while br means the Bayesian Reconstruction entropy. Usually, the Shannon-Jaynes entropy is preferred, since with it the positivity of the generated spectrum is always guaranteed.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"String.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"stype = \"sj\"","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. As for the underlying principles of these entropic factors, please see Maximum Entropy Method.","category":"page"},{"location":"man/param.html#nalph","page":"Parameters","title":"nalph","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Total number of the chosen alpha parameters.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"nalph = 12","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. Only the chi2kink algorithm needs this parameter to control the number of alpha parameters.","category":"page"},{"location":"man/param.html#alpha","page":"Parameters","title":"alpha","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Starting value for the alpha parameter. The MaxEnt solver always starts with a huge alpha parameter, and then decreases it gradually.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"alpha = 1e9","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. It should be a very large number, such as 10^9 sim 10^13.","category":"page"},{"location":"man/param.html#ratio","page":"Parameters","title":"ratio","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Scaling factor for the alpha parameter. The next alpha is equal to the current alpha divided by ratio.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"ratio = 10.0","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. It muse be larger than 1.0.","category":"page"},{"location":"man/param.html#blur","page":"Parameters","title":"blur","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Sometimes, the kernel functions and spectral functions can be preblurred to obtain smoother results. Shall we preblur them? If blur is larger than zero, then it means the blur parameter. If blur is smaller than zero, then it means that the preblur feature is disable.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"blur = -1.0","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#[StochAC]-Block","page":"Parameters","title":"[StochAC] Block","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"note: Note\nThe parameters in this block is valid for the StochAC solver only.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"warning: Warning\nIf solver = \"StochAC\", the [StochAC] block must be available.","category":"page"},{"location":"man/param.html#nfine","page":"Parameters","title":"nfine","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of points of a very fine linear mesh. This mesh is for the delta functions.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"nfine = 10000","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#ngamm","page":"Parameters","title":"ngamm","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of delta functions. Their superposition is used to mimic the spectral functions.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"ngamm = 512","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#nwarm","page":"Parameters","title":"nwarm","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of Monte Carlo thermalization steps.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"nwarm = 4000","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#nstep","page":"Parameters","title":"nstep","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of Monte Carlo sweeping steps.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"nstep = 4000000","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#ndump","page":"Parameters","title":"ndump","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Intervals for monitoring Monte Carlo sweeps. For every ndump steps, the StochAC solver will try to output some useful information to help diagnosis.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"ndump = 40000","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#nalph-2","page":"Parameters","title":"nalph","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Total number of the chosen alpha parameters.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"nalph = 20","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#alpha-2","page":"Parameters","title":"alpha","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Starting value for the alpha parameter. The StochAC solver always starts with a small alpha parameter, and then increases it gradually.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"alpha = 1.0","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#ratio-2","page":"Parameters","title":"ratio","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Scaling factor for the alpha parameter. It should be larger than 1.0.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"ratio = 1.2","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#[StochSK]-Block","page":"Parameters","title":"[StochSK] Block","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"note: Note\nThe parameters in this block is valid for the StochSK solver only.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"warning: Warning\nIf solver = \"StochSK\", the [StochSK] block must be available.","category":"page"},{"location":"man/param.html#method-2","page":"Parameters","title":"method","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"How to determine the optimized Theta parameter? The StochSK solver supports two different algorithms. They arechi2min\nchi2kinkUsually, the chi2min algorithm is preferred. This algorithm is suggested by Shao and Sandvik et al. See Stochastic Analytical Continuation 1 for more details.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"String.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"method = \"chi2min\"","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#nfine-2","page":"Parameters","title":"nfine","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of points of a very fine linear mesh. This mesh is for the delta functions.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"nfine = 100000","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#ngamm-2","page":"Parameters","title":"ngamm","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of delta functions. Their superposition is used to mimic the spectral functions.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"ngamm = 1000","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#nwarm-2","page":"Parameters","title":"nwarm","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of Monte Carlo thermalization steps.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"nwarm = 1000","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#nstep-2","page":"Parameters","title":"nstep","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of Monte Carlo sweeping steps.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"nstep = 20000","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#ndump-2","page":"Parameters","title":"ndump","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Intervals for monitoring Monte Carlo sweeps. For every ndump steps, the StochSK solver will try to output some useful information to help diagnosis.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"ndump = 200","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#retry","page":"Parameters","title":"retry","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"How often to recalculate the goodness-of-fit function (it is actually chi^2) to avoid numerical deterioration.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"retry = 10","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#theta","page":"Parameters","title":"theta","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Starting value for the Theta parameter. The StochSK solver always starts with a huge Theta parameter, and then decreases it gradually.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"theta = 1e+6","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#ratio-3","page":"Parameters","title":"ratio","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Scaling factor for the Theta parameter. It should be less than 1.0.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"ratio = 0.9","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#[StochOM]-Block","page":"Parameters","title":"[StochOM] Block","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"note: Note\nThe parameters in this block is valid for the StochOM solver only.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"warning: Warning\nIf solver = \"StochOM\", the [StochOM] block must be available.","category":"page"},{"location":"man/param.html#ntry","page":"Parameters","title":"ntry","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of attempts to figure out the solution.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"ntry = 2000","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#nstep-3","page":"Parameters","title":"nstep","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of Monte Carlo steps per try.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"nstep = 1000","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#nbox","page":"Parameters","title":"nbox","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of boxes. Their superposition is used to construct the spectral functions.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"nbox = 100","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#sbox","page":"Parameters","title":"sbox","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Minimum area of the randomly generated boxes.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"sbox = 0.005","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#wbox","page":"Parameters","title":"wbox","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Minimum width of the randomly generated boxes.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"wbox = 0.02","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#norm","page":"Parameters","title":"norm","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Is the norm calculated? If norm is larger than 0.0, it denotes the normalization factor. If norm is smaller than 0.0, it means that the normalization condition is ignored.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"norm = -1.0","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#[StochPX]-Block","page":"Parameters","title":"[StochPX] Block","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"note: Note\nThe parameters in this block is valid for the StochPX solver only.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"warning: Warning\nIf solver = \"StochPX\", the [StochPX] block must be available.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"warning: Warning\nThe StochPX solver is still in development. Please use it at your own risk.","category":"page"},{"location":"man/param.html#method-3","page":"Parameters","title":"method","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"How to evaluate the final spectral density? The StochPX solver supports two different algorithms. They aremean\nbestIf method = \"mean\", then the solver will try to calculate an averaged spectrum from some selected good solutions. If method = \"best\", then the solver will pick up the best solution (which should exhibit the smallest goodness-of-fit functional chi^2).","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"String.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"method = \"mean\"","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. Note that the \"mean\" method is suitable for the condensed matter cases (broad and smooth peaks), while the \"best\" method is useful for the molecule cases (sharp peaks).","category":"page"},{"location":"man/param.html#nfine-3","page":"Parameters","title":"nfine","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of points of a very fine linear mesh. This mesh is for the poles.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"nfine = 100000","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#npole","page":"Parameters","title":"npole","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of poles on the real axis, which is used to mimic the Matsubara Green's function.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"npole = 200","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. For condensed matter cases, npole should be quite large. While for molecule cases, npole should be small.","category":"page"},{"location":"man/param.html#ntry-2","page":"Parameters","title":"ntry","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of attempts to figure out the solution.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"ntry = 1000","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#nstep-4","page":"Parameters","title":"nstep","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of Monte Carlo sweeping steps per attempt / try.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"nstep = 1000000","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. This parameter is related to the npole parameter. If npole is large, nstep could be small. If npole is small, nstep should be large.","category":"page"},{"location":"man/param.html#theta-2","page":"Parameters","title":"theta","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Artificial inverse temperature Theta. When it is increased, the transition probabilities of Monte Carlo updates will decrease.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"theta = 1e+6","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory. The users can check the stat.data file to judge whether the theta parameter is reasonable.","category":"page"},{"location":"man/param.html#eta","page":"Parameters","title":"eta","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Tiny distance from the real axis eta, which is used to reconstruct the retarded Green's function and the spectral density. When it is increased, the spectral density will be become more and more smooth.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Example:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"eta = 1e-4","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"library/outline.html#Outline","page":"Outline","title":"Outline","text":"","category":"section"},{"location":"library/outline.html#Contents","page":"Outline","title":"Contents","text":"","category":"section"},{"location":"library/outline.html","page":"Outline","title":"Outline","text":"Pages = [\"acflow.md\",\n         \"global.md\",\n         \"type.md\",\n         \"base.md\",\n         \"solver.md\",\n         \"grid.md\",\n         \"mesh.md\",\n         \"model.md\",\n         \"kernel.md\",\n         \"config.md\",\n         \"inout.md\",\n         \"math.md\",\n         \"util.md\"\n        ]\nDepth = 2","category":"page"},{"location":"library/outline.html#Index","page":"Outline","title":"Index","text":"","category":"section"},{"location":"library/outline.html#Modules","page":"Outline","title":"Modules","text":"","category":"section"},{"location":"library/outline.html","page":"Outline","title":"Outline","text":"Modules = [ACFlow]\nOrder = [:module]","category":"page"},{"location":"library/outline.html#Constants","page":"Outline","title":"Constants","text":"","category":"section"},{"location":"library/outline.html","page":"Outline","title":"Outline","text":"Modules = [ACFlow]\nOrder = [:constant]","category":"page"},{"location":"library/outline.html#Types","page":"Outline","title":"Types","text":"","category":"section"},{"location":"library/outline.html","page":"Outline","title":"Outline","text":"Modules = [ACFlow]\nOrder = [:type]","category":"page"},{"location":"library/outline.html#Macros","page":"Outline","title":"Macros","text":"","category":"section"},{"location":"library/outline.html","page":"Outline","title":"Outline","text":"Modules = [ACFlow]\nOrder = [:macro]","category":"page"},{"location":"library/outline.html#Functions","page":"Outline","title":"Functions","text":"","category":"section"},{"location":"library/outline.html","page":"Outline","title":"Outline","text":"Modules = [ACFlow]\nOrder = [:function]","category":"page"},{"location":"examples/green2.html","page":"Imaginary Time Green's Function","title":"Imaginary Time Green's Function","text":"info: Info\nIn order to demonstrate usefulness of the ACFlow toolkit, four examples are illustrated in this section. These examples cover typical application scenarios of the ACFlow toolkit, including analytical continuations ofMatsubara self-energy function\nMatsubara Green's function\nImaginary time Green's function\nCurrent-current correlation functionwithin the script mode or standard mode. All of the necessary source codes and data files, which can be used to reproduce the results as shown in this section, are placed in the /home/your_home/acflow/test/T* folders.","category":"page"},{"location":"examples/green2.html#Imaginary-Time-Green's-Function","page":"Imaginary Time Green's Function","title":"Imaginary Time Green's Function","text":"","category":"section"},{"location":"examples/green2.html","page":"Imaginary Time Green's Function","title":"Imaginary Time Green's Function","text":"In this example, analytical continuation of imaginary time Green's function will be tested. Note that this example is borrowed from arXiv:0403055 directly.","category":"page"},{"location":"examples/green2.html","page":"Imaginary Time Green's Function","title":"Imaginary Time Green's Function","text":"The exact spectral function reads:","category":"page"},{"location":"examples/green2.html","page":"Imaginary Time Green's Function","title":"Imaginary Time Green's Function","text":"A(omega) =\nbegincases\nfrac1W fracomegasqrtomega^2 - Delta^2quad  textifDelta  omega  W2 \n0  textotherwise\nendcases","category":"page"},{"location":"examples/green2.html","page":"Imaginary Time Green's Function","title":"Imaginary Time Green's Function","text":"Here, W denotes bandwidth, and Delta is used to control size of the energy gap. Let W = 6 and 2Delta = 1. This spectrum should exhibit flat shoulders, steep peaks, and sharp gap edges. Actually, it is the spectrum of a BCS superconductor.","category":"page"},{"location":"examples/green2.html","page":"Imaginary Time Green's Function","title":"Imaginary Time Green's Function","text":"First, the imaginary time Green's function G(tau) is generated using mathbfG = mathbfKA. Then a normally-distributed random noise is add to G(tau). Maximum amplitude of the noise is 1e-4. The error bar of G(tau) is fixed to 1e-3. The data are written in gtau.data.","category":"page"},{"location":"examples/green2.html","page":"Imaginary Time Green's Function","title":"Imaginary Time Green's Function","text":"Next, we try to prepare the configure file (ac.toml). In this case, we would like to benchmark the StochAC solver, so the solver parameter is set to ''StochAC'' and the grid parameter is set to ''ftime''. Furthermore, the exclude parameter is enabled to impose some a priori constraints to the spectrum. The full ac.toml is listed as follows:","category":"page"},{"location":"examples/green2.html","page":"Imaginary Time Green's Function","title":"Imaginary Time Green's Function","text":"[BASE]\nfinput = \"giw.data\"\nsolver = \"MaxEnt\"\nktype  = \"fermi\"\nmtype  = \"flat\"\ngrid   = \"ffreq\"\nmesh   = \"linear\"\nngrid  = 10\nnmesh  = 501\nwmax   = 5.0\nwmin   = -5.0\nbeta   = 10.0\noffdiag = false\nexclude = [[-5.0,-3.0], [-0.5,0.5], [3.0,5.0]]\n\n[StochAC]\nnfine = 10000\nngamm = 512\nnwarm = 4000\nnstep = 10000000\nndump = 40000\nnalph = 40\nalpha = 1.00\nratio = 1.20","category":"page"},{"location":"examples/green2.html","page":"Imaginary Time Green's Function","title":"Imaginary Time Green's Function","text":"We perform analytical continuation simulation by running the acrun.jl or Pacrun.jl script. In order to obtain smooth spectral density, it is useful to increase number of delta functions (See ngamm parameter) and number of Monte Carlo sampling steps (See nstep parameter).","category":"page"},{"location":"examples/green2.html","page":"Imaginary Time Green's Function","title":"Imaginary Time Green's Function","text":"Figure 1 shows the calculated results. In Fig.1(a), the exact spectral function is compared with the simulated spectrum. Note that besides the StochAC solver, the other three solvers are also tested. Their results are also plotted in this figure for a direct comparison. It is remarkable that the StochAC and StochSK solvers do a superior job of modelling the spectrum. The major characteristics of the spectrum, including flat regions, steep peaks, and sharp gap edges, are well captured by the two solvers. Especially, we have finished more tests without any constraints on the spectral density. The gap in the spectrum can be reproduced as well. On the other hand, the spectra obtained by the MaxEnt and StochOM solvers are much too smooth, and show extra shoulder peaks around pm 2.0. Figure 1(b) shows alpha-resolved spectral functions A_alpha(omega) for selected alpha parameters. Fluctuation in the flat regions of the calculated spectral density grows when alpha increases. Figure 1(c) shows internal energy U as a function of alpha. From this figure, the critical alpha is estimated, which is indicated by the vertical bar. Finally, the reproduced Green's function tildeG(tau) agrees quite well with the raw input data, which is shown in Fig.1(d).","category":"page"},{"location":"examples/green2.html","page":"Imaginary Time Green's Function","title":"Imaginary Time Green's Function","text":"(Image: T_E3.png)","category":"page"},{"location":"examples/green2.html","page":"Imaginary Time Green's Function","title":"Imaginary Time Green's Function","text":"Figure 1 | Analytical continuation of imaginary time Green's function by using the stochastic analytical continuation (Beach's algorithm). (a) Simulated and exact spectral functions. (b) alpha-dependent spectral functions. (c) Internal energy U as a function of alpha. The vertical bar indicates the optimal alpha parameter. (d) Simulated and exact imaginary time Green's functions.","category":"page"},{"location":"intro/background.html#Background","page":"Background","title":"Background","text":"","category":"section"},{"location":"intro/background.html#Analytical-Continuation-Problem","page":"Background","title":"Analytical Continuation Problem","text":"","category":"section"},{"location":"intro/background.html","page":"Background","title":"Background","text":"It is well-known that quantum Monte Carlo (QMC) method is a powerful and exact numerical approach, and has been widely used in many research fields, such as nuclear physics, condense matter physics, and many-body physics. Here, we just focus on the finite temperature QMC algorithms, which are used to solve interacting lattice models or quantum impurity models. Generally speaking, the simulated results of QMC methods are some sorts of single-particle or two-particle correlation functions, which are usually defined on imaginary time axis (tau equiv -it) or Matsubara frequency axis (iomega_n). Therefore, they can't be compared directly with the correspondingly experimental results, including but not limited to electronic density of states A(omega), optical conductivity sigma(omega), dynamical structure factor S(mathbfqomega), and so on. It is necessary to convert the QMC simulated results from imaginary time axis or Matsubara frequency axis to real axis (i.e. tau to omega or iomega_n to omega), which is the origin of the analytical continuation problem.","category":"page"},{"location":"intro/background.html#Fredholm-Integral-Equation","page":"Background","title":"Fredholm Integral Equation","text":"","category":"section"},{"location":"intro/background.html","page":"Background","title":"Background","text":"Let's concentrate on the following Fredholm integral equation of the first kind:","category":"page"},{"location":"intro/background.html","page":"Background","title":"Background","text":"g(y) = int K(yx) f(x)dx","category":"page"},{"location":"intro/background.html","page":"Background","title":"Background","text":"Here, K(yx) is the known kernel function, f(x) is the model function, and g(y) denotes raw data. Given f(x), it is quite easy to get g(y) via numerical integration. However, given g(y), solving the Fredholm integral equation reversely to get f(x) is not as easy as expected. There is no universal solution. In some cases, even the existence of solution can not be guaranteed.","category":"page"},{"location":"intro/background.html#Available-Analytical-Continuation-Methods","page":"Background","title":"Available Analytical Continuation Methods","text":"","category":"section"},{"location":"intro/background.html","page":"Background","title":"Background","text":"The so-called analytical continuation problem can be reformulated in terms of the Fredholm integral equation. Thus, its objective is to seek a reasonable f(x) to satisfy the above equation. The QMC simulated data g(y) are noisy and the kernel function K(yx) is ill conditioned, which make analytical continuation of QMC simulated data a huge challenge. In order to solve this problem, in the past decades peoples have developed numerous methods, including the least square fitting method, singular value decomposition, Padtexte approximation, Tikhonov-Philips regularization method, maximum entropy method, stochastic analytical continuation, stochastic optimization method, sparse modelling method, and machine learning method, etc. However, each method has its pros and cons. None of these methods can override the others. The analytical continuation problem is still far away from being completely solved.","category":"page"},{"location":"intro/background.html#Our-Motivations","page":"Background","title":"Our Motivations","text":"","category":"section"},{"location":"intro/background.html","page":"Background","title":"Background","text":"In recent years, quite a few analytical continuation codes have been released, including maxent (by Mark Jarrell), OmegaMaxent, ana_cont, ALPSCore/maxent, TRIQS/som, ALF, just to name a few. We note that the maximum entropy method has dominated this field for quite a long time. Thus most of these codes only support the maximum entropy method. It is rather difficult to crosscheck the simulated results obtained by various analytical continuation methods. In addition, the features of the available codes are quite limited and hard to be extended. In order to fill in this gap, we would like to present a new open source toolkit, called ACFlow, for analytical continuation. This toolkit implements three primary analytical continuation methods, namely the maximum entropy method, stochastic analytical continuation, and stochastic optimization method, within an united framework. It provides an easy-to-used library and application interface. Some diagnostic and analytical tools are also available. With ACFlow, the users can easily setup and execute analytical continuation calculations, and validate the calculated results. We believe that this toolkit will play a vital role in solving analytical continuation problems.","category":"page"},{"location":"intro/background.html","page":"Background","title":"Background","text":"info: Info\nQuite recently, a new analytical continuation method, namely the stochastic pole expansion, has been implemented in the ACFlow toolkit. So, now it supports four analytical continuation methods :-).","category":"page"},{"location":"library/base.html#Core","page":"Core","title":"Core","text":"","category":"section"},{"location":"library/base.html","page":"Core","title":"Core","text":"Provide basic user's interfaces for the ACFlow toolkit.","category":"page"},{"location":"library/base.html#Contents","page":"Core","title":"Contents","text":"","category":"section"},{"location":"library/base.html","page":"Core","title":"Core","text":"Pages = [\"base.md\"]\nDepth = 2","category":"page"},{"location":"library/base.html#Index","page":"Core","title":"Index","text":"","category":"section"},{"location":"library/base.html","page":"Core","title":"Core","text":"Pages = [\"base.md\"]","category":"page"},{"location":"library/base.html#Solvers","page":"Core","title":"Solvers","text":"","category":"section"},{"location":"library/base.html","page":"Core","title":"Core","text":"solve(grid::Vector{F64}, Gval::Vector{T}, Gerr::Vector{T}) where {T}\nsolve(grid::Vector{F64}, Gval::Vector{T}, err::T) where {T}\nsolve(grid::Vector{F64}, Gval::Vector{T}) where {T}\nsolve(rd::RawData)","category":"page"},{"location":"library/base.html#ACFlow.solve-Union{Tuple{T}, Tuple{Vector{Float64}, Vector{T}, Vector{T}}} where T","page":"Core","title":"ACFlow.solve","text":"solve(grid::Vector{F64}, Gval::Vector{T}, Gerr::Vector{T})\n\nSolve the analytical continuation problem. The arguments grid, Gval, and Gerr are the grid, value, and error bar, respectively.\n\n\n\n\n\n","category":"method"},{"location":"library/base.html#ACFlow.solve-Union{Tuple{T}, Tuple{Vector{Float64}, Vector{T}, T}} where T","page":"Core","title":"ACFlow.solve","text":"solve(grid::Vector{F64}, Gval::Vector{T}, err::T)\n\nSolve the analytical continuation problem. The arguments grid, Gval, and err are the grid, value, and error bar, respectively.\n\n\n\n\n\n","category":"method"},{"location":"library/base.html#ACFlow.solve-Union{Tuple{T}, Tuple{Vector{Float64}, Vector{T}}} where T","page":"Core","title":"ACFlow.solve","text":"solve(grid::Vector{F64}, Gval::Vector{T})\n\nSolve the analytical continuation problem. The arguments grid and Gval are the grid and value, respectively. Furthermore, the error bar is set to a fixed value 1.0e-4.\n\n\n\n\n\n","category":"method"},{"location":"library/base.html#ACFlow.solve-Tuple{RawData}","page":"Core","title":"ACFlow.solve","text":"solve(rd::RawData)\n\nSolve the analytical continuation problem. The input data are encapsulated in a Rawdata struct.\n\nSee also: RawData.\n\n\n\n\n\n","category":"method"},{"location":"library/base.html#Parameters","page":"Core","title":"Parameters","text":"","category":"section"},{"location":"library/base.html","page":"Core","title":"Core","text":"setup_param\nread_param","category":"page"},{"location":"library/base.html#ACFlow.setup_param","page":"Core","title":"ACFlow.setup_param","text":"setup_param(C::Dict{String,Any}, S::Dict{String,Any}, reset::Bool = true)\n\nSetup the configuration dictionaries via function call. Here C contains parameters for general setup, while S contains parameters for selected analytical continuation solver. If reset is true, then the configuration dictionaries will be reset to their default values at first. Later, C S will be used to customized the dictionaries further.\n\nSee also: read_param, rev_dict.\n\n\n\n\n\n","category":"function"},{"location":"library/base.html#ACFlow.read_param","page":"Core","title":"ACFlow.read_param","text":"read_param()\n\nSetup the configuration dictionaries via an external file. The valid format of a configuration file is toml.\n\nSee also: read_param.\n\n\n\n\n\n","category":"function"},{"location":"library/base.html#Data","page":"Core","title":"Data","text":"","category":"section"},{"location":"library/base.html","page":"Core","title":"Core","text":"read_data\nmake_data","category":"page"},{"location":"library/base.html#ACFlow.read_data","page":"Core","title":"ACFlow.read_data","text":"read_data(only_real_part::Bool = true)\n\nRead data in imaginary axis and return a RawData struct.\n\nSee also: RawData.\n\n\n\n\n\n","category":"function"},{"location":"library/base.html#ACFlow.make_data","page":"Core","title":"ACFlow.make_data","text":"make_data(rd::RawData)\n\nConvert RawData struct to GreenData struct. Note that RawData is provided by the users directly, while GreenData is more suitable for various analytical continuation solvers and algorithms. Note that the GreenData struct is accessed and manipulated by this code internally, while the RawData struct is exposed to the users.\n\nSee also: RawData, GreenData.\n\n\n\n\n\n","category":"function"},{"location":"library/base.html#Grids","page":"Core","title":"Grids","text":"","category":"section"},{"location":"library/base.html","page":"Core","title":"Core","text":"make_grid","category":"page"},{"location":"library/base.html#ACFlow.make_grid","page":"Core","title":"ACFlow.make_grid","text":"make_grid(rd::RawData)\n\nExtract grid for input data from a RawData struct. It will return a sub-type of the AbstractGrid struct.\n\nSee also: RawData, AbstractGrid.\n\n\n\n\n\n","category":"function"},{"location":"library/base.html#Meshes","page":"Core","title":"Meshes","text":"","category":"section"},{"location":"library/base.html","page":"Core","title":"Core","text":"make_mesh","category":"page"},{"location":"library/base.html#ACFlow.make_mesh","page":"Core","title":"ACFlow.make_mesh","text":"make_mesh()\n\nTry to generate an uniform (linear) or non-uniform (non-linear) mesh for the spectral function in real axis.\n\nSee also: LinearMesh, TangentMesh, LorentzMesh.\n\n\n\n\n\n","category":"function"},{"location":"library/base.html#Models","page":"Core","title":"Models","text":"","category":"section"},{"location":"library/base.html","page":"Core","title":"Core","text":"make_model","category":"page"},{"location":"library/base.html#ACFlow.make_model","page":"Core","title":"ACFlow.make_model","text":"make_model(am::AbstractMesh)\n\nTry to generate a default model function at given mesh am through various schemes.\n\nSee also: AbstractMesh.\n\n\n\n\n\n","category":"function"},{"location":"library/base.html#Kernels","page":"Core","title":"Kernels","text":"","category":"section"},{"location":"library/base.html","page":"Core","title":"Core","text":"make_kernel","category":"page"},{"location":"library/base.html#ACFlow.make_kernel","page":"Core","title":"ACFlow.make_kernel","text":"make_kernel(am::AbstractMesh, ag::AbstractGrid)\n\nTry to generate various kernel functions.\n\nSee also: AbstractMesh, AbstractGrid.\n\n\n\n\n\n","category":"function"},{"location":"library/base.html#Postprocessing","page":"Core","title":"Postprocessing","text":"","category":"section"},{"location":"library/base.html","page":"Core","title":"Core","text":"reprod\nkramers","category":"page"},{"location":"library/base.html#ACFlow.reprod","page":"Core","title":"ACFlow.reprod","text":"reprod(am::AbstractMesh, kernel::Matrix{F64}, A::Vector{F64})\n\nTry to reproduce the input data using the calculated spectrum function A. kernel is the kernel function, and am is the mesh in which the spectrum is defined.\n\nSee also: AbstractMesh.\n\n\n\n\n\n","category":"function"},{"location":"library/base.html#ACFlow.kramers","page":"Core","title":"ACFlow.kramers","text":"kramers(am::AbstractMesh, A::Vector{F64})\n\nTry to calculate the real part of the green's function from its imaginary part via the Kramers-Kronig relations.\n\n\n\n\n\n","category":"function"},{"location":"man/impl.html#Implementations","page":"Implementations","title":"Implementations","text":"","category":"section"},{"location":"man/impl.html#Powered-by-Julia","page":"Implementations","title":"Powered by Julia","text":"","category":"section"},{"location":"man/impl.html","page":"Implementations","title":"Implementations","text":"The ACFlow toolkit is developed with pure Julia language. Thanks to powerful type system and multiple dispatch paradigm of the Julia language, the five different analytical continuation solvers are integrated into an united software architecture. Redundant codes are greatly reduced. It is quite easy to implement new analytical continuation solver or add new features to the existing solvers if necessary. Distributed computing is a built-in feature of Julia. So, it is straightforward to realize parallel calculations in the ACFlow toolkit. Now except for the MaxEnt solver, all the other solvers are parallelized.","category":"page"},{"location":"man/impl.html#Code-Repository","page":"Implementations","title":"Code Repository","text":"","category":"section"},{"location":"man/impl.html","page":"Implementations","title":"Implementations","text":"The official code repository of the ACFlow toolkit is:","category":"page"},{"location":"man/impl.html","page":"Implementations","title":"Implementations","text":"https://github.com/huangli712/ACFlow","category":"page"},{"location":"man/impl.html#Core-Codes","page":"Implementations","title":"Core Codes","text":"","category":"section"},{"location":"man/impl.html","page":"Implementations","title":"Implementations","text":"The source codes of the ACFlow toolkit are placed in the acflow/src folder. Their functions are summarized in Table 1.","category":"page"},{"location":"man/impl.html","page":"Implementations","title":"Implementations","text":"Filename Description\nACFlow.jl Entry of the ACFlow module.\nmaxent.jl Maximum entropy method.\nsac.jl Stochastic analytical continuation (K. S. D. Beach's algorithm).\nsan.jl Stochastic analytical continuation (A. W. Sandvik's algorithm).\nsom.jl Stochastic optimization method.\nspx.jl Stochastic pole expansion.\nglobal.jl Numerical and physical constants.\ntypes.jl Basic data structures and computational parameters.\nbase.jl Driver for analytical continuation simulation.\ninout.jl Read input data and write calculated results.\nconfig.jl Parse configuration file and extract computational parameters.\nmath.jl Root finding, numerical integration, interpolation, Einstein summation, and curve fitting.\nutil.jl Some utility functions.\nmesh.jl Meshes for spectral density.\ngrid.jl Grids for input data.\nmodel.jl Default model functions.\nkernel.jl Kernel functions.","category":"page"},{"location":"man/impl.html","page":"Implementations","title":"Implementations","text":"Table 1 | List of source codes of the ACFlow toolkit.","category":"page"},{"location":"man/impl.html","page":"Implementations","title":"Implementations","text":"note: Note\nThere are two more scripts (acrun.jl and Pacrun.jl) in the acflow/util folder. They are used to launch the analytical continuation tasks.","category":"page"},{"location":"man/impl.html#Documentation","page":"Implementations","title":"Documentation","text":"","category":"section"},{"location":"man/impl.html","page":"Implementations","title":"Implementations","text":"The documentation of the ACFlow toolkit is written by using the Markdown language and the Documenter.jl package. The source codes are placed in the acflow/docs folder. The users can build documentation by themselves. Please see Installation for how to do that. Or they can read the latest documentation in the following website:","category":"page"},{"location":"man/impl.html","page":"Implementations","title":"Implementations","text":"https://huangli712.github.io/projects/acflow/index.html","category":"page"},{"location":"man/impl.html#Tests-and-Examples","page":"Implementations","title":"Tests and Examples","text":"","category":"section"},{"location":"man/impl.html","page":"Implementations","title":"Implementations","text":"Ten tests and four tutorials are also shipped with the ACFlow toolkit. Their source codes are placed in the acflow/test folder. See acflow/test/test.md and acflow/test/tutor.md for more details.","category":"page"},{"location":"man/feature.html#Main-Features","page":"Main Features","title":"Main Features","text":"","category":"section"},{"location":"man/feature.html","page":"Main Features","title":"Main Features","text":"Now the ACFlow toolkit supports four analytical continuation methods as introduced before. It includes five different analytical continuation solvers, namely","category":"page"},{"location":"man/feature.html","page":"Main Features","title":"Main Features","text":"MaxEnt\nStochAC\nStochSK\nStochOM\nStochPX","category":"page"},{"location":"man/feature.html","page":"Main Features","title":"Main Features","text":"Just as their names suggested, the MaxEnt solver implements the maximum entropy method. The StochAC and StochSK solvers implement the K. S. D. Beach's algorithm and A. W. Sandvik's algorithm of the stochastic analytical continuation, respectively. The StochOM solver implements the stochastic optimization method. The StochPX solver implements the stochastic pole expansion method. The ACFlow toolkit also provides a convenient library, which can be used to prepare and carry out analytical continuation calculations flexibly. The major features of the present ACFlow toolkit (v1.3.0 and above) are summarized in Table 1.","category":"page"},{"location":"man/feature.html","page":"Main Features","title":"Main Features","text":"Features MaxEnt StochAC StochSK StochOM StochPX\nMatrix-valued Green's function Y N N N N\nImaginary time grid Y Y Y Y N\nMatsubara frequency grid Y Y Y Y Y\nLinear mesh Y Y Y Y Y\nNonlinear mesh Y Y Y Y Y\nFermionic kernel Y Y Y Y Y\nBosonic kernel Y Y Y Y Y\nSelf-defined model function Y N N N N\nConstrained analytical continuation N Y Y Y Y\nRegeneration of input data Y Y Y Y Y\nKramers-Kronig transformation Y Y Y Y Y\nParallel computing N Y Y Y Y\nParallel tempering N Y N N N\nInteractive mode Y Y Y Y Y\nScript mode Y Y Y Y Y\nStandard mode Y Y Y Y Y","category":"page"},{"location":"man/feature.html","page":"Main Features","title":"Main Features","text":"Table 1 | Major features of the ACFlow toolkit. MaxEnt, StochAC, StochSK, StochOM, and StochPX are the five analytical continuation solvers as implemented in this toolkit.","category":"page"},{"location":"man/feature.html","page":"Main Features","title":"Main Features","text":"In Table 1, Y means yes while N means no. Interactive mode, Script mode, and Standard model are three running modes supported by the ACFlow toolkit. We will introduce them later. The MaxEnt solver supports the historic, classic, bryan, and chi2kink algorithms to determine the alpha parameter. The StochAC solver is only compatible with a flat model function, while the StochSK, StochOM, and StochPX solvers don't rely on any default model functions. The StochOM solver does not support analytical continuation of fermionic imaginary time Green's function for the moment.","category":"page"},{"location":"man/feature.html","page":"Main Features","title":"Main Features","text":"info: Info\nNote that analytical continuation problem is a hotspot in computational physics and many-body physics all the time. Many efforts have been devoted to solve it in recent years. Noticeable achievements include maximum quantum entropy method, Nevanlinna analytical continuation, blocked-mode sampling and grid point sampling in stochastic analytical continuation, constrained stochastic analytical continuation, machine learning assisted analytical continuation, and so on. We would like to incorporate these new progresses into the ACFlow toolkit in the near future. BTW, contriibutions from the other users are always welcomed.","category":"page"},{"location":"library/grid.html#Grids","page":"Grids","title":"Grids","text":"","category":"section"},{"location":"library/grid.html","page":"Grids","title":"Grids","text":"Grids on imaginary axis.","category":"page"},{"location":"library/grid.html","page":"Grids","title":"Grids","text":"In the ACFlow toolkit, the input correlators are defined on grid, while the calculated spectral functions are defined on mesh. The ACFlow toolkit supports both imaginary time and Matsubara frequency grids. Note that for Matsubara frequency grid, the bosonic and fermionic grids are different.","category":"page"},{"location":"library/grid.html#Contents","page":"Grids","title":"Contents","text":"","category":"section"},{"location":"library/grid.html","page":"Grids","title":"Grids","text":"Pages = [\"grid.md\"]\nDepth = 2","category":"page"},{"location":"library/grid.html#Index","page":"Grids","title":"Index","text":"","category":"section"},{"location":"library/grid.html","page":"Grids","title":"Grids","text":"Pages = [\"grid.md\"]","category":"page"},{"location":"library/grid.html#Types","page":"Grids","title":"Types","text":"","category":"section"},{"location":"library/grid.html","page":"Grids","title":"Grids","text":"AbstractGrid\nFermionicImaginaryTimeGrid\nFermionicFragmentTimeGrid\nFermionicMatsubaraGrid\nFermionicFragmentMatsubaraGrid\nBosonicImaginaryTimeGrid\nBosonicFragmentTimeGrid\nBosonicMatsubaraGrid\nBosonicFragmentMatsubaraGrid","category":"page"},{"location":"library/grid.html#ACFlow.AbstractGrid","page":"Grids","title":"ACFlow.AbstractGrid","text":"AbstractGrid\n\nAn abstract type representing the imaginary axis. It is used to build the internal type system.\n\n\n\n\n\n","category":"type"},{"location":"library/grid.html#ACFlow.FermionicImaginaryTimeGrid","page":"Grids","title":"ACFlow.FermionicImaginaryTimeGrid","text":"FermionicImaginaryTimeGrid\n\nMutable struct. It represents the fermionic imaginary time grid.\n\nMembers\n\nntime -> Number of time slices.\nβ     -> Inverse temperature.\nτ     -> Vector of grid points.\n\nSee also: FermionicFragmentTimeGrid.\n\n\n\n\n\n","category":"type"},{"location":"library/grid.html#ACFlow.FermionicFragmentTimeGrid","page":"Grids","title":"ACFlow.FermionicFragmentTimeGrid","text":"FermionicFragmentTimeGrid\n\nMutable struct. It represents part of the fermionic imaginary time grid.\n\nMembers\n\nntime -> Number of time slices.\nβ     -> Inverse temperature.\nτ     -> Vector of grid points.\n\nSee also: FermionicImaginaryTimeGrid.\n\n\n\n\n\n","category":"type"},{"location":"library/grid.html#ACFlow.FermionicMatsubaraGrid","page":"Grids","title":"ACFlow.FermionicMatsubaraGrid","text":"FermionicMatsubaraGrid\n\nMutable struct. It represents the fermionic Matsubara frequency grid.\n\nMembers\n\nnfreq -> Number of Matsubara frequency points.\nβ     -> Inverse temperature.\nω     -> Vector of grid points.\n\nSee also: FermionicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"type"},{"location":"library/grid.html#ACFlow.FermionicFragmentMatsubaraGrid","page":"Grids","title":"ACFlow.FermionicFragmentMatsubaraGrid","text":"FermionicFragmentMatsubaraGrid\n\nMutable struct. It represents part of the fermionic Matsubara frequency grid.\n\nMembers\n\nnfreq -> Number of Matsubara frequency points.\nβ     -> Inverse temperature.\nω     -> Vector of grid points.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\n","category":"type"},{"location":"library/grid.html#ACFlow.BosonicImaginaryTimeGrid","page":"Grids","title":"ACFlow.BosonicImaginaryTimeGrid","text":"BosonicImaginaryTimeGrid\n\nMutable struct. It represents the bosonic imaginary time grid.\n\nMembers\n\nntime -> Number of time slices.\nβ     -> Inverse temperature.\nτ     -> Vector of grid points.\n\nSee also: BosonicFragmentTimeGrid.\n\n\n\n\n\n","category":"type"},{"location":"library/grid.html#ACFlow.BosonicFragmentTimeGrid","page":"Grids","title":"ACFlow.BosonicFragmentTimeGrid","text":"BosonicFragmentTimeGrid\n\nMutable struct. It represents part of the bosonic imaginary time grid.\n\nMembers\n\nntime -> Number of time slices.\nβ     -> Inverse temperature.\nτ     -> Vector of grid points.\n\nSee also: BosonicImaginaryTimeGrid.\n\n\n\n\n\n","category":"type"},{"location":"library/grid.html#ACFlow.BosonicMatsubaraGrid","page":"Grids","title":"ACFlow.BosonicMatsubaraGrid","text":"BosonicMatsubaraGrid\n\nMutable struct. It represents the bosonic Matsubara frequency grid.\n\nMembers\n\nnfreq -> Number of Matsubara frequency points.\nβ     -> Inverse temperature.\nω     -> Vector of grid points.\n\nSee also: BosonicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"type"},{"location":"library/grid.html#ACFlow.BosonicFragmentMatsubaraGrid","page":"Grids","title":"ACFlow.BosonicFragmentMatsubaraGrid","text":"BosonicFragmentMatsubaraGrid\n\nMutable struct. It represents part of the bosonic Matsubara frequency grid.\n\nMembers\n\nnfreq -> Number of Matsubara frequency points.\nβ     -> Inverse temperature.\nω     -> Vector of grid points.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\n","category":"type"},{"location":"library/grid.html#Constructors","page":"Grids","title":"Constructors","text":"","category":"section"},{"location":"library/grid.html","page":"Grids","title":"Grids","text":"FermionicImaginaryTimeGrid(ntime::I64, β::F64)\nFermionicFragmentTimeGrid(β::F64, τ::Vector{F64})\nFermionicMatsubaraGrid(nfreq::I64, β::F64)\nFermionicFragmentMatsubaraGrid(β::F64, ω::Vector{F64})\nBosonicImaginaryTimeGrid(ntime::I64, β::F64)\nBosonicFragmentTimeGrid(β::F64, τ::Vector{F64})\nBosonicMatsubaraGrid(nfreq::I64, β::F64)\nBosonicFragmentMatsubaraGrid(β::F64, ω::Vector{F64})","category":"page"},{"location":"library/grid.html#ACFlow.FermionicImaginaryTimeGrid-Tuple{Int64, Float64}","page":"Grids","title":"ACFlow.FermionicImaginaryTimeGrid","text":"FermionicImaginaryTimeGrid(ntime::I64, β::F64)\n\nA constructor for the FermionicImaginaryTimeGrid struct, which is defined in src/types.jl.\n\nSee also: FermionicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#ACFlow.FermionicFragmentTimeGrid-Tuple{Float64, Vector{Float64}}","page":"Grids","title":"ACFlow.FermionicFragmentTimeGrid","text":"FermionicFragmentTimeGrid(β::F64, τ::Vector{F64})\n\nA constructor for the FermionicFragmentTimeGrid struct, which is defined in src/types.jl.\n\nSee also: FermionicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#ACFlow.FermionicMatsubaraGrid-Tuple{Int64, Float64}","page":"Grids","title":"ACFlow.FermionicMatsubaraGrid","text":"FermionicMatsubaraGrid(nfreq::I64, β::F64)\n\nA constructor for the FermionicMatsubaraGrid struct, which is defined in src/types.jl. The Matsubara grid is evaluated as ωₙ = (2n - 1) π / β.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#ACFlow.FermionicFragmentMatsubaraGrid-Tuple{Float64, Vector{Float64}}","page":"Grids","title":"ACFlow.FermionicFragmentMatsubaraGrid","text":"FermionicFragmentMatsubaraGrid(β::F64, ω::Vector{F64})\n\nA constructor for the FermionicFragmentMatsubaraGrid struct, which is defined in src/types.jl. The Matsubara grid is from input.\n\nSee also: FermionicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#ACFlow.BosonicImaginaryTimeGrid-Tuple{Int64, Float64}","page":"Grids","title":"ACFlow.BosonicImaginaryTimeGrid","text":"BosonicImaginaryTimeGrid(ntime::I64, β::F64)\n\nA constructor for the BosonicImaginaryTimeGrid struct, which is defined in src/types.jl.\n\nSee also: BosonicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#ACFlow.BosonicFragmentTimeGrid-Tuple{Float64, Vector{Float64}}","page":"Grids","title":"ACFlow.BosonicFragmentTimeGrid","text":"BosonicFragmentTimeGrid(β::F64, τ::Vector{F64})\n\nA constructor for the BosonicFragmentTimeGrid struct, which is defined in src/types.jl.\n\nSee also: BosonicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#ACFlow.BosonicMatsubaraGrid-Tuple{Int64, Float64}","page":"Grids","title":"ACFlow.BosonicMatsubaraGrid","text":"BosonicMatsubaraGrid(nfreq::I64, β::F64)\n\nA constructor for the BosonicMatsubaraGrid struct, which is defined in src/types.jl. The Matsubara grid is evaluated as ωₙ = (2n - 2) π / β.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#ACFlow.BosonicFragmentMatsubaraGrid-Tuple{Float64, Vector{Float64}}","page":"Grids","title":"ACFlow.BosonicFragmentMatsubaraGrid","text":"BosonicFragmentMatsubaraGrid(β::F64, ω::Vector{F64})\n\nA constructor for the BosonicFragmentMatsubaraGrid struct, which is defined in src/types.jl. The Matsubara grid is from input.\n\nSee also: BosonicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.*-Functions","page":"Grids","title":"Base.* Functions","text":"","category":"section"},{"location":"library/grid.html","page":"Grids","title":"Grids","text":"Base.length(fg::FermionicImaginaryTimeGrid)\nBase.length(fg::FermionicFragmentTimeGrid)\nBase.length(fg::FermionicMatsubaraGrid)\nBase.length(fg::FermionicFragmentMatsubaraGrid)\nBase.length(bg::BosonicImaginaryTimeGrid)\nBase.length(bg::BosonicFragmentTimeGrid)\nBase.length(bg::BosonicMatsubaraGrid)\nBase.length(bg::BosonicFragmentMatsubaraGrid)\nBase.iterate(fg::FermionicImaginaryTimeGrid)\nBase.iterate(fg::FermionicFragmentTimeGrid)\nBase.iterate(fg::FermionicMatsubaraGrid)\nBase.iterate(fg::FermionicFragmentMatsubaraGrid)\nBase.iterate(bg::BosonicImaginaryTimeGrid)\nBase.iterate(bg::BosonicFragmentTimeGrid)\nBase.iterate(bg::BosonicMatsubaraGrid)\nBase.iterate(bg::BosonicFragmentMatsubaraGrid)\nBase.iterate(fg::FermionicImaginaryTimeGrid, i::I64)\nBase.iterate(fg::FermionicFragmentTimeGrid, i::I64)\nBase.iterate(fg::FermionicMatsubaraGrid, i::I64)\nBase.iterate(fg::FermionicFragmentMatsubaraGrid, i::I64)\nBase.iterate(bg::BosonicImaginaryTimeGrid, i::I64)\nBase.iterate(bg::BosonicFragmentTimeGrid, i::I64)\nBase.iterate(bg::BosonicMatsubaraGrid, i::I64)\nBase.iterate(bg::BosonicFragmentMatsubaraGrid, i::I64)\nBase.eachindex(fg::FermionicImaginaryTimeGrid)\nBase.eachindex(fg::FermionicFragmentTimeGrid)\nBase.eachindex(fg::FermionicMatsubaraGrid)\nBase.eachindex(fg::FermionicFragmentMatsubaraGrid)\nBase.eachindex(bg::BosonicImaginaryTimeGrid)\nBase.eachindex(bg::BosonicFragmentTimeGrid)\nBase.eachindex(bg::BosonicMatsubaraGrid)\nBase.eachindex(bg::BosonicFragmentMatsubaraGrid)\nBase.firstindex(fg::FermionicImaginaryTimeGrid)\nBase.firstindex(fg::FermionicFragmentTimeGrid)\nBase.firstindex(fg::FermionicMatsubaraGrid)\nBase.firstindex(fg::FermionicFragmentMatsubaraGrid)\nBase.firstindex(bg::BosonicImaginaryTimeGrid)\nBase.firstindex(bg::BosonicFragmentTimeGrid)\nBase.firstindex(bg::BosonicMatsubaraGrid)\nBase.firstindex(bg::BosonicFragmentMatsubaraGrid)\nBase.lastindex(fg::FermionicImaginaryTimeGrid)\nBase.lastindex(fg::FermionicFragmentTimeGrid)\nBase.lastindex(fg::FermionicMatsubaraGrid)\nBase.lastindex(fg::FermionicFragmentMatsubaraGrid)\nBase.lastindex(bg::BosonicImaginaryTimeGrid)\nBase.lastindex(bg::BosonicFragmentTimeGrid)\nBase.lastindex(bg::BosonicMatsubaraGrid)\nBase.lastindex(bg::BosonicFragmentMatsubaraGrid)\nBase.getindex(fg::FermionicImaginaryTimeGrid, ind::I64)\nBase.getindex(fg::FermionicFragmentTimeGrid, ind::I64)\nBase.getindex(fg::FermionicMatsubaraGrid, ind::I64)\nBase.getindex(fg::FermionicFragmentMatsubaraGrid, ind::I64)\nBase.getindex(bg::BosonicImaginaryTimeGrid, ind::I64)\nBase.getindex(bg::BosonicFragmentTimeGrid, ind::I64)\nBase.getindex(bg::BosonicMatsubaraGrid, ind::I64)\nBase.getindex(bg::BosonicFragmentMatsubaraGrid, ind::I64)\nBase.getindex(fg::FermionicImaginaryTimeGrid, I::UnitRange{I64})\nBase.getindex(fg::FermionicFragmentTimeGrid, I::UnitRange{I64})\nBase.getindex(fg::FermionicMatsubaraGrid, I::UnitRange{I64})\nBase.getindex(fg::FermionicFragmentMatsubaraGrid, I::UnitRange{I64})\nBase.getindex(bg::BosonicImaginaryTimeGrid, I::UnitRange{I64})\nBase.getindex(bg::BosonicFragmentTimeGrid, I::UnitRange{I64})\nBase.getindex(bg::BosonicMatsubaraGrid, I::UnitRange{I64})\nBase.getindex(bg::BosonicFragmentMatsubaraGrid, I::UnitRange{I64})","category":"page"},{"location":"library/grid.html#Base.length-Tuple{FermionicImaginaryTimeGrid}","page":"Grids","title":"Base.length","text":"Base.length(fg::FermionicImaginaryTimeGrid)\n\nReturn number of grid points in a FermionicImaginaryTimeGrid struct.\n\nSee also: FermionicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.length-Tuple{FermionicFragmentTimeGrid}","page":"Grids","title":"Base.length","text":"Base.length(fg::FermionicFragmentTimeGrid)\n\nReturn number of grid points in a FermionicFragmentTimeGrid struct.\n\nSee also: FermionicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.length-Tuple{FermionicMatsubaraGrid}","page":"Grids","title":"Base.length","text":"Base.length(fg::FermionicMatsubaraGrid)\n\nReturn number of grid points in a FermionicMatsubaraGrid struct.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.length-Tuple{FermionicFragmentMatsubaraGrid}","page":"Grids","title":"Base.length","text":"Base.length(fg::FermionicFragmentMatsubaraGrid)\n\nReturn number of grid points in a FermionicFragmentMatsubaraGrid struct.\n\nSee also: FermionicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.length-Tuple{BosonicImaginaryTimeGrid}","page":"Grids","title":"Base.length","text":"Base.length(bg::BosonicImaginaryTimeGrid)\n\nReturn number of grid points in a BosonicImaginaryTimeGrid struct.\n\nSee also: BosonicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.length-Tuple{BosonicFragmentTimeGrid}","page":"Grids","title":"Base.length","text":"Base.length(bg::BosonicFragmentTimeGrid)\n\nReturn number of grid points in a BosonicFragmentTimeGrid struct.\n\nSee also: BosonicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.length-Tuple{BosonicMatsubaraGrid}","page":"Grids","title":"Base.length","text":"Base.length(bg::BosonicMatsubaraGrid)\n\nReturn number of grid points in a BosonicMatsubaraGrid struct.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.length-Tuple{BosonicFragmentMatsubaraGrid}","page":"Grids","title":"Base.length","text":"Base.length(bg::BosonicFragmentMatsubaraGrid)\n\nReturn number of grid points in a BosonicFragmentMatsubaraGrid struct.\n\nSee also: BosonicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{FermionicImaginaryTimeGrid}","page":"Grids","title":"Base.iterate","text":"Base.iterate(fg::FermionicImaginaryTimeGrid)\n\nAdvance the iterator of a FermionicImaginaryTimeGrid struct to obtain the next grid point.\n\nSee also: FermionicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{FermionicFragmentTimeGrid}","page":"Grids","title":"Base.iterate","text":"Base.iterate(fg::FermionicFragmentTimeGrid)\n\nAdvance the iterator of a FermionicFragmentTimeGrid struct to obtain the next grid point.\n\nSee also: FermionicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{FermionicMatsubaraGrid}","page":"Grids","title":"Base.iterate","text":"Base.iterate(fg::FermionicMatsubaraGrid)\n\nAdvance the iterator of a FermionicMatsubaraGrid struct to obtain the next grid point.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{FermionicFragmentMatsubaraGrid}","page":"Grids","title":"Base.iterate","text":"Base.iterate(fg::FermionicFragmentMatsubaraGrid)\n\nAdvance the iterator of a FermionicFragmentMatsubaraGrid struct to obtain the next grid point.\n\nSee also: FermionicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{BosonicImaginaryTimeGrid}","page":"Grids","title":"Base.iterate","text":"Base.iterate(bg::BosonicImaginaryTimeGrid)\n\nAdvance the iterator of a BosonicImaginaryTimeGrid struct to obtain the next grid point.\n\nSee also: BosonicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{BosonicFragmentTimeGrid}","page":"Grids","title":"Base.iterate","text":"Base.iterate(bg::BosonicFragmentTimeGrid)\n\nAdvance the iterator of a BosonicFragmentTimeGrid struct to obtain the next grid point.\n\nSee also: BosonicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{BosonicMatsubaraGrid}","page":"Grids","title":"Base.iterate","text":"Base.iterate(bg::BosonicMatsubaraGrid)\n\nAdvance the iterator of a BosonicMatsubaraGrid struct to obtain the next grid point.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{BosonicFragmentMatsubaraGrid}","page":"Grids","title":"Base.iterate","text":"Base.iterate(bg::BosonicFragmentMatsubaraGrid)\n\nAdvance the iterator of a BosonicFragmentMatsubaraGrid struct to obtain the next grid point.\n\nSee also: BosonicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{FermionicImaginaryTimeGrid, Int64}","page":"Grids","title":"Base.iterate","text":"Base.iterate(fg::FermionicImaginaryTimeGrid, i::I64)\n\nThis is the key method that allows a FermionicImaginaryTimeGrid struct to be iterated, yielding a sequences of grid points.\n\nSee also: FermionicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{FermionicFragmentTimeGrid, Int64}","page":"Grids","title":"Base.iterate","text":"Base.iterate(fg::FermionicFragmentTimeGrid, i::I64)\n\nThis is the key method that allows a FermionicFragmentTimeGrid struct to be iterated, yielding a sequences of grid points.\n\nSee also: FermionicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{FermionicMatsubaraGrid, Int64}","page":"Grids","title":"Base.iterate","text":"Base.iterate(fg::FermionicMatsubaraGrid, i::I64)\n\nCreate an iterable object for visiting each index of a FermionicMatsubaraGrid struct.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{FermionicFragmentMatsubaraGrid, Int64}","page":"Grids","title":"Base.iterate","text":"Base.iterate(fg::FermionicFragmentMatsubaraGrid, i::I64)\n\nCreate an iterable object for visiting each index of a FermionicFragmentMatsubaraGrid struct.\n\nSee also: FermionicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{BosonicImaginaryTimeGrid, Int64}","page":"Grids","title":"Base.iterate","text":"Base.iterate(bg::BosonicImaginaryTimeGrid, i::I64)\n\nCreate an iterable object for visiting each index of a BosonicImaginaryTimeGrid struct.\n\nSee also: BosonicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{BosonicFragmentTimeGrid, Int64}","page":"Grids","title":"Base.iterate","text":"Base.iterate(bg::BosonicFragmentTimeGrid, i::I64)\n\nCreate an iterable object for visiting each index of a BosonicFragmentTimeGrid struct.\n\nSee also: BosonicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{BosonicMatsubaraGrid, Int64}","page":"Grids","title":"Base.iterate","text":"Base.iterate(bg::BosonicMatsubaraGrid, i::I64)\n\nCreate an iterable object for visiting each index of a BosonicMatsubaraGrid struct.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{BosonicFragmentMatsubaraGrid, Int64}","page":"Grids","title":"Base.iterate","text":"Base.iterate(bg::BosonicFragmentMatsubaraGrid, i::I64)\n\nCreate an iterable object for visiting each index of a BosonicFragmentMatsubaraGrid struct.\n\nSee also: BosonicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.eachindex-Tuple{FermionicImaginaryTimeGrid}","page":"Grids","title":"Base.eachindex","text":"Base.eachindex(fg::FermionicImaginaryTimeGrid)\n\nCreate an iterable object for visiting each index of a FermionicImaginaryTimeGrid struct.\n\nSee also: FermionicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.eachindex-Tuple{FermionicFragmentTimeGrid}","page":"Grids","title":"Base.eachindex","text":"Base.eachindex(fg::FermionicFragmentTimeGrid)\n\nCreate an iterable object for visiting each index of a FermionicFragmentTimeGrid struct.\n\nSee also: FermionicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.eachindex-Tuple{FermionicMatsubaraGrid}","page":"Grids","title":"Base.eachindex","text":"Base.eachindex(fg::FermionicMatsubaraGrid)\n\nCreate an iterable object for visiting each index of a FermionicMatsubaraGrid struct.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.eachindex-Tuple{FermionicFragmentMatsubaraGrid}","page":"Grids","title":"Base.eachindex","text":"Base.eachindex(fg::FermionicFragmentMatsubaraGrid)\n\nCreate an iterable object for visiting each index of a FermionicFragmentMatsubaraGrid struct.\n\nSee also: FermionicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.eachindex-Tuple{BosonicImaginaryTimeGrid}","page":"Grids","title":"Base.eachindex","text":"Base.eachindex(bg::BosonicImaginaryTimeGrid)\n\nCreate an iterable object for visiting each index of a BosonicImaginaryTimeGrid struct.\n\nSee also: BosonicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.eachindex-Tuple{BosonicFragmentTimeGrid}","page":"Grids","title":"Base.eachindex","text":"Base.eachindex(bg::BosonicFragmentTimeGrid)\n\nCreate an iterable object for visiting each index of a BosonicFragmentTimeGrid struct.\n\nSee also: BosonicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.eachindex-Tuple{BosonicMatsubaraGrid}","page":"Grids","title":"Base.eachindex","text":"Base.eachindex(bg::BosonicMatsubaraGrid)\n\nCreate an iterable object for visiting each index of a BosonicMatsubaraGrid struct.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.eachindex-Tuple{BosonicFragmentMatsubaraGrid}","page":"Grids","title":"Base.eachindex","text":"Base.eachindex(bg::BosonicFragmentMatsubaraGrid)\n\nCreate an iterable object for visiting each index of a BosonicFragmentMatsubaraGrid struct.\n\nSee also: BosonicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.firstindex-Tuple{FermionicImaginaryTimeGrid}","page":"Grids","title":"Base.firstindex","text":"Base.firstindex(fg::FermionicImaginaryTimeGrid)\n\nReturn the first index of a FermionicImaginaryTimeGrid struct.\n\nSee also: FermionicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.firstindex-Tuple{FermionicFragmentTimeGrid}","page":"Grids","title":"Base.firstindex","text":"Base.firstindex(fg::FermionicFragmentTimeGrid)\n\nReturn the first index of a FermionicFragmentTimeGrid struct.\n\nSee also: FermionicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.firstindex-Tuple{FermionicMatsubaraGrid}","page":"Grids","title":"Base.firstindex","text":"Base.firstindex(fg::FermionicMatsubaraGrid)\n\nReturn the first index of a FermionicMatsubaraGrid struct.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.firstindex-Tuple{FermionicFragmentMatsubaraGrid}","page":"Grids","title":"Base.firstindex","text":"Base.firstindex(fg::FermionicFragmentMatsubaraGrid)\n\nReturn the first index of a FermionicFragmentMatsubaraGrid struct.\n\nSee also: FermionicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.firstindex-Tuple{BosonicImaginaryTimeGrid}","page":"Grids","title":"Base.firstindex","text":"Base.firstindex(bg::BosonicImaginaryTimeGrid)\n\nReturn the first index of a BosonicImaginaryTimeGrid struct.\n\nSee also: BosonicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.firstindex-Tuple{BosonicFragmentTimeGrid}","page":"Grids","title":"Base.firstindex","text":"Base.firstindex(bg::BosonicFragmentTimeGrid)\n\nReturn the first index of a BosonicFragmentTimeGrid struct.\n\nSee also: BosonicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.firstindex-Tuple{BosonicMatsubaraGrid}","page":"Grids","title":"Base.firstindex","text":"Base.firstindex(bg::BosonicMatsubaraGrid)\n\nReturn the first index of a BosonicMatsubaraGrid struct.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.firstindex-Tuple{BosonicFragmentMatsubaraGrid}","page":"Grids","title":"Base.firstindex","text":"Base.firstindex(bg::BosonicFragmentMatsubaraGrid)\n\nReturn the first index of a BosonicFragmentMatsubaraGrid struct.\n\nSee also: BosonicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.lastindex-Tuple{FermionicImaginaryTimeGrid}","page":"Grids","title":"Base.lastindex","text":"Base.lastindex(fg::FermionicImaginaryTimeGrid)\n\nReturn the last index of a FermionicImaginaryTimeGrid struct.\n\nSee also: FermionicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.lastindex-Tuple{FermionicFragmentTimeGrid}","page":"Grids","title":"Base.lastindex","text":"Base.lastindex(fg::FermionicFragmentTimeGrid)\n\nReturn the last index of a FermionicFragmentTimeGrid struct.\n\nSee also: FermionicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.lastindex-Tuple{FermionicMatsubaraGrid}","page":"Grids","title":"Base.lastindex","text":"Base.lastindex(fg::FermionicMatsubaraGrid)\n\nReturn the last index of a FermionicMatsubaraGrid struct.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.lastindex-Tuple{FermionicFragmentMatsubaraGrid}","page":"Grids","title":"Base.lastindex","text":"Base.lastindex(fg::FermionicFragmentMatsubaraGrid)\n\nReturn the last index of a FermionicFragmentMatsubaraGrid struct.\n\nSee also: FermionicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.lastindex-Tuple{BosonicImaginaryTimeGrid}","page":"Grids","title":"Base.lastindex","text":"Base.lastindex(bg::BosonicImaginaryTimeGrid)\n\nReturn the last index of a BosonicImaginaryTimeGrid struct.\n\nSee also: BosonicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.lastindex-Tuple{BosonicFragmentTimeGrid}","page":"Grids","title":"Base.lastindex","text":"Base.lastindex(bg::BosonicFragmentTimeGrid)\n\nReturn the last index of a BosonicFragmentTimeGrid struct.\n\nSee also: BosonicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.lastindex-Tuple{BosonicMatsubaraGrid}","page":"Grids","title":"Base.lastindex","text":"Base.lastindex(bg::BosonicMatsubaraGrid)\n\nReturn the last index of a BosonicMatsubaraGrid struct.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.lastindex-Tuple{BosonicFragmentMatsubaraGrid}","page":"Grids","title":"Base.lastindex","text":"Base.lastindex(bg::BosonicFragmentMatsubaraGrid)\n\nReturn the last index of a BosonicFragmentMatsubaraGrid struct.\n\nSee also: BosonicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{FermionicImaginaryTimeGrid, Int64}","page":"Grids","title":"Base.getindex","text":"Base.getindex(fg::FermionicImaginaryTimeGrid, ind::I64)\n\nRetrieve the value(s) stored at the given key or index within a FermionicImaginaryTimeGrid struct.\n\nSee also: FermionicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{FermionicFragmentTimeGrid, Int64}","page":"Grids","title":"Base.getindex","text":"Base.getindex(fg::FermionicFragmentTimeGrid, ind::I64)\n\nRetrieve the value(s) stored at the given key or index within a FermionicFragmentTimeGrid struct.\n\nSee also: FermionicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{FermionicMatsubaraGrid, Int64}","page":"Grids","title":"Base.getindex","text":"Base.getindex(fg::FermionicMatsubaraGrid, ind::I64)\n\nRetrieve the value(s) stored at the given key or index within a FermionicMatsubaraGrid struct.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{FermionicFragmentMatsubaraGrid, Int64}","page":"Grids","title":"Base.getindex","text":"Base.getindex(fg::FermionicFragmentMatsubaraGrid, ind::I64)\n\nRetrieve the value(s) stored at the given key or index within a FermionicFragmentMatsubaraGrid struct.\n\nSee also: FermionicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{BosonicImaginaryTimeGrid, Int64}","page":"Grids","title":"Base.getindex","text":"Base.getindex(bg::BosonicImaginaryTimeGrid, ind::I64)\n\nRetrieve the value(s) stored at the given key or index within a BosonicImaginaryTimeGrid struct.\n\nSee also: BosonicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{BosonicFragmentTimeGrid, Int64}","page":"Grids","title":"Base.getindex","text":"Base.getindex(bg::BosonicFragmentTimeGrid, ind::I64)\n\nRetrieve the value(s) stored at the given key or index within a BosonicFragmentTimeGrid struct.\n\nSee also: BosonicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{BosonicMatsubaraGrid, Int64}","page":"Grids","title":"Base.getindex","text":"Base.getindex(bg::BosonicMatsubaraGrid, ind::I64)\n\nRetrieve the value(s) stored at the given key or index within a BosonicMatsubaraGrid struct.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{BosonicFragmentMatsubaraGrid, Int64}","page":"Grids","title":"Base.getindex","text":"Base.getindex(bg::BosonicFragmentMatsubaraGrid, ind::I64)\n\nRetrieve the value(s) stored at the given key or index within a BosonicFragmentMatsubaraGrid struct.\n\nSee also: BosonicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{FermionicImaginaryTimeGrid, UnitRange{Int64}}","page":"Grids","title":"Base.getindex","text":"Base.getindex(fg::FermionicImaginaryTimeGrid, I::UnitRange{I64})\n\nReturn a subset of a FermionicImaginaryTimeGrid struct as specified by I.\n\nSee also: FermionicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{FermionicFragmentTimeGrid, UnitRange{Int64}}","page":"Grids","title":"Base.getindex","text":"Base.getindex(fg::FermionicFragmentTimeGrid, I::UnitRange{I64})\n\nReturn a subset of a FermionicFragmentTimeGrid struct as specified by I.\n\nSee also: FermionicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{FermionicMatsubaraGrid, UnitRange{Int64}}","page":"Grids","title":"Base.getindex","text":"Base.getindex(fg::FermionicMatsubaraGrid, I::UnitRange{I64})\n\nReturn a subset of a FermionicMatsubaraGrid struct as specified by I.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{FermionicFragmentMatsubaraGrid, UnitRange{Int64}}","page":"Grids","title":"Base.getindex","text":"Base.getindex(fg::FermionicFragmentMatsubaraGrid, I::UnitRange{I64})\n\nReturn a subset of a FermionicFragmentMatsubaraGrid struct as specified by I.\n\nSee also: FermionicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{BosonicImaginaryTimeGrid, UnitRange{Int64}}","page":"Grids","title":"Base.getindex","text":"Base.getindex(bg::BosonicImaginaryTimeGrid, I::UnitRange{I64})\n\nReturn a subset of a BosonicImaginaryTimeGrid struct as specified by I.\n\nSee also: BosonicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{BosonicFragmentTimeGrid, UnitRange{Int64}}","page":"Grids","title":"Base.getindex","text":"Base.getindex(bg::BosonicFragmentTimeGrid, I::UnitRange{I64})\n\nReturn a subset of a BosonicFragmentTimeGrid struct as specified by I.\n\nSee also: BosonicFragmentTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{BosonicMatsubaraGrid, UnitRange{Int64}}","page":"Grids","title":"Base.getindex","text":"Base.getindex(bg::BosonicMatsubaraGrid, I::UnitRange{I64})\n\nReturn a subset of a BosonicMatsubaraGrid struct as specified by I.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{BosonicFragmentMatsubaraGrid, UnitRange{Int64}}","page":"Grids","title":"Base.getindex","text":"Base.getindex(bg::BosonicFragmentMatsubaraGrid, I::UnitRange{I64})\n\nReturn a subset of a BosonicFragmentMatsubaraGrid struct as specified by I.\n\nSee also: BosonicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Utilities","page":"Grids","title":"Utilities","text":"","category":"section"},{"location":"library/grid.html","page":"Grids","title":"Grids","text":"rebuild","category":"page"},{"location":"library/grid.html#ACFlow.rebuild","page":"Grids","title":"ACFlow.rebuild","text":"rebuild(fg::FermionicImaginaryTimeGrid, ntime::I64, β::F64)\n\nRebuild the FermionicImaginaryTimeGrid struct via new ntime and β parameters.\n\nSee also: FermionicImaginaryTimeGrid.\n\n\n\n\n\nrebuild(fg::FermionicFragmentTimeGrid, ntime::I64, β::F64)\n\nRebuild the FermionicFragmentTimeGrid struct via new ntime and β parameters. Now its imaginary time points are continuous.\n\nSee also: FermionicFragmentTimeGrid.\n\n\n\n\n\nrebuild(fg::FermionicMatsubaraGrid, nfreq::I64, β::F64)\n\nRebuild the FermionicMatsubaraGrid struct via new nfreq and β parameters.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\nrebuild(fg::FermionicFragmentMatsubaraGrid, nfreq::I64, β::F64)\n\nRebuild the FermionicFragmentMatsubaraGrid struct via new nfreq and β parameters.\n\nSee also: FermionicFragmentMatsubaraGrid.\n\n\n\n\n\nrebuild(bg::BosonicImaginaryTimeGrid, ntime::I64, β::F64)\n\nRebuild the BosonicImaginaryTimeGrid struct via new ntime and β parameters.\n\nSee also: BosonicImaginaryTimeGrid.\n\n\n\n\n\nrebuild(bg::BosonicFragmentTimeGrid, ntime::I64, β::F64)\n\nRebuild the BosonicFragmentTimeGrid struct via new ntime and β parameters. Now its imaginary time points are continuous.\n\nSee also: BosonicFragmentTimeGrid.\n\n\n\n\n\nrebuild(bg::BosonicMatsubaraGrid, nfreq::I64, β::F64)\n\nRebuild the BosonicMatsubaraGrid struct via new nfreq and β parameters.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\nrebuild(bg::BosonicFragmentMatsubaraGrid, nfreq::I64, β::F64)\n\nRebuild the BosonicFragmentMatsubaraGrid struct via new nfreq and β parameters.\n\nSee also: BosonicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"function"},{"location":"theory/maxent.html#mem","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"","category":"section"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"Perhaps the maximum entropy method is the most frequently used approach for analytical continuation problems because of its high computational efficiency. Next, we will discuss the basic principles and several variants of it.","category":"page"},{"location":"theory/maxent.html#Bayesian-Inference","page":"Maximum Entropy Method","title":"Bayesian Inference","text":"","category":"section"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"Bayes's theorem is the cornerstone of the maximum entropy method. Given two events a and b, Bayes's theorem says:","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"beginequation\nPabPb = PbaPa\nendequation","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"where Pa is the probability of event a, Pab is the conditional probability of event a with given event b. In the scenario of analytical continuation problem, barG(tau) and A(omega) are treated as two events, where barG(tau) denotes the measured value of G(tau). So the best solution for A(omega) is of course the one that maximizes PAbarG, which is called the posterior probability. According to the Bayes's theorem, we get","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"beginequation\nPAbarG = fracPbarGAPAPbarG\nendequation","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"where PbarGA is the likelihood function, PA is the prior probability, and PbarG is the evidence. Since the evidence is a normalization constant depending on the prior probability and the likelihood function only, it is ignored in the following discussions. Thus,","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"beginequation\nPAbarG propto PbarGAPA\nendequation","category":"page"},{"location":"theory/maxent.html#Posterior-Probability","page":"Maximum Entropy Method","title":"Posterior Probability","text":"","category":"section"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"In the maximum entropy method, the likelihood function PbarGA is assumed to be in direct proportion to e^-chi^22. chi^2 is named as goodness-of-fit function, which measures distance between barG(tau) and reconstructed imaginary time Green's function tildeG(tau):","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"beginequation\nchi^2 = sum^L_i = 1 leftfracbarG_i(tau) - tildeG_i(tau)sigma_iright^2\nendequation","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"beginequation\ntildeG_i = sum_j K_ij A_j\nendequation","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"Here, L is number of imaginary time points, sigma denotes the error bar (standard deviation) of barG(tau). K_ij and A_j are discrete kernel and spectral functions, respectively. On the other hand, the prior probability PA is supposed to be in direct proportion to e^alpha S, where alpha is a regulation parameter and S means entropy. Sometimes S is also known as the Kullback-Leibler distance (or the Shannon-Jaynes entropy). Its formula is as follows:","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"beginequation\nS= int domega left(A(omega) - m(omega) - A(omega)logleftfracA(omega)m(omega)rightright)\nendequation","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"where m(omega) is the default model function. The ACFlow toolkit also supports another kind of entropy, i.e., the Bayesian Reconstruction entropy. It reads:","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"beginequation\nS = int domega left(1 - fracA(omega)m(omega) + log leftfracA(omega)m(omega)rightright)\nendequation","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"According to the Bayes's theorem, the posterior probability PAbarG propto e^Q and","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"beginequation\nQ = alpha S - fracchi^22\nendequation","category":"page"},{"location":"theory/maxent.html#Various-Algorithms","page":"Maximum Entropy Method","title":"Various Algorithms","text":"","category":"section"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"Now the original analytical continuation problem becomes how to figure out the optimal A(omega) that maximizes Q. In other words, we have to solve the following equation:","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"beginequation\nfracpartial Qpartial A bigg_A = hatA = 0\nendequation","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"where hatA(omega) is the optimal A(omega). Eq.(9) can be easily solved by using standard Newton method. However, the obtained hatA(omega) is alpha-dependent. That is to say, for a given alpha, there is always a hatA(omega) that satisfies Eq.(9). So, new problem arises because we have to find out a way to generate the final spectral function from these alpha-resolved hatA(omega). Now there exist four algorithms, namely historic, classic, bryan, and chi2kink. Next we will introduce them one by one.","category":"page"},{"location":"theory/maxent.html#Historic-Algorithm","page":"Maximum Entropy Method","title":"Historic Algorithm","text":"","category":"section"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"The historic algorithm is quite simple. The alpha parameter will be adjusted iteratively to meet the following criterion:","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"beginequation\nchi^2 = N\nendequation","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"where N is the number of mesh points for spectral density A(omega).","category":"page"},{"location":"theory/maxent.html#Classic-Algorithm","page":"Maximum Entropy Method","title":"Classic Algorithm","text":"","category":"section"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"The basic equation for the classic algorithm reads","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"beginequation\n-2 alpha S(A_alpha) = textTr\nleft\nfracLambda(A_alpha)alpha I + Lambda(A_alpha)\nright\nendequation","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"where I is an identity matrix. The elements of Lambda matrix are calculated as follows:","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"beginequation\nLambda_ij = sqrtA_i left(sum_kl K_ki C^-1_kl K_ljright) sqrtA_j\nendequation","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"where C is the covariance matrix. Eq.(10) will be iteratively solved until the optimal alpha and hatA(omega) are figured out.","category":"page"},{"location":"theory/maxent.html#Bryan-Algorithm","page":"Maximum Entropy Method","title":"Bryan Algorithm","text":"","category":"section"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"In both historic and classic algorithms, the spectral function hatA(omega) is always related to an optimal alpha parameter. However, the spirit of the bryan algorithm is completely different. It tries to yield a series of alpha parameters and calculate the corresponding A_alpha(omega). Then the final spectral function A(omega) is obtained by evaluating the following integration:","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"beginequation\noverlineA(omega) = int dalphaA_alpha(omega) Palpha  barG\nendequation","category":"page"},{"location":"theory/maxent.html#Chi2kink-Algorithm","page":"Maximum Entropy Method","title":"Chi2kink Algorithm","text":"","category":"section"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"This algorithm was proposed by Bergeron and Tremblay recently. The first step is to generate a series of alpha parameters and evaluate the corresponding spectral functions A_alpha(omega) and goodness-of-fit functions chi^2A_alpha. Then we plot log_10(chi^2) as a function of log_10(alpha). Usually this plot is split into three different regions: (1) Default model region. In the limit of alpha to infty, chi^2 goes to a constant high value. It means that the likelihood function e^-chi^22 has negligible weight, such that the prior probability e^alpha S becomes dominant and minimizes QA. At that time, the calculated A(omega) resembles the default model function m(omega). (2) Noise-fitting region. In the limit of alpha to 0, chi^2 is relatively flat and approaches its global minimum. In this region, the minimization algorithm tends to fit the noise in G(tau). (3) Information-fitting region. alpha S is comparable with chi^22, so that chi^2 is strongly dependent on alpha. Bergeron et al. suggested that the optimal alpha parameter situates in the crossover between noise-fitting region and information-fitting region. So the second derivative of chi^2 with respect to alpha is calculated, and the maximum value in the resulting curve indicates the optimal value of alpha. Quite recently, Kaufmann and Held proposed a more numerically stable and flexible approach to compute the optimal alpha. They use the following function to fit log_10chi^2(alpha)-log_10(alpha):","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"beginequation\nphi(xabcd) = a + fracb1 + e^-d(x-c)\nendequation","category":"page"},{"location":"theory/maxent.html","page":"Maximum Entropy Method","title":"Maximum Entropy Method","text":"where a, b, c, and d are fitting parameters. Then the optimal alpha is approximated by 10^c-fd, where f is an empirical constant (The favorite value of f lies in 225).","category":"page"},{"location":"library/util.html#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"library/util.html","page":"Utilities","title":"Utilities","text":"Provide some utility macros and functions for the ACFlow toolkit.","category":"page"},{"location":"library/util.html#Contents","page":"Utilities","title":"Contents","text":"","category":"section"},{"location":"library/util.html","page":"Utilities","title":"Utilities","text":"Pages = [\"util.md\"]\nDepth = 2","category":"page"},{"location":"library/util.html#Index","page":"Utilities","title":"Index","text":"","category":"section"},{"location":"library/util.html","page":"Utilities","title":"Utilities","text":"Pages = [\"util.md\"]","category":"page"},{"location":"library/util.html#Color-Constants","page":"Utilities","title":"Color Constants","text":"","category":"section"},{"location":"library/util.html","page":"Utilities","title":"Utilities","text":"COLORS\nMODES","category":"page"},{"location":"library/util.html#ACFlow.COLORS","page":"Utilities","title":"ACFlow.COLORS","text":"COLORS\n\nA global dict, which is used to specify the system colors.\n\n\n\n\n\n","category":"constant"},{"location":"library/util.html#ACFlow.MODES","page":"Utilities","title":"ACFlow.MODES","text":"MODES\n\nA global dict, which is used to specify the mode for output characters.\n\n\n\n\n\n","category":"constant"},{"location":"library/util.html#Macros","page":"Utilities","title":"Macros","text":"","category":"section"},{"location":"library/util.html","page":"Utilities","title":"Utilities","text":"@cswitch\n@time_call\n@pcs","category":"page"},{"location":"library/util.html#ACFlow.@cswitch","page":"Utilities","title":"ACFlow.@cswitch","text":"@cswitch(constexpr, body)\n\nProvides a C-like switch statement with the falling through behavior. This implementation was borrowed from the following github repository:\n\nhttps://github.com/Gnimuc/CSyntax.jl\n\nExamples\n\nengine = get_d(\"engine\")\n@cswitch engine begin\n    @case \"vasp\"\n        just_do_it()\n        break\n\n    @default\n        sorry()\n        break\nend\n\n\n\n\n\n","category":"macro"},{"location":"library/util.html#ACFlow.@time_call","page":"Utilities","title":"ACFlow.@time_call","text":"@time_call(ex)\n\nEvaluate a function call (ex), and then print the elapsed time (number of seconds) it took to execute.\n\nThis macro is a variation of the standard @elapsed macro.\n\n\n\n\n\n","category":"macro"},{"location":"library/util.html#ACFlow.@pcs","page":"Utilities","title":"ACFlow.@pcs","text":"@pcs(x...)\n\nTry to print colorful strings. Here x is a combination of strings and colors. Its format likes string1 color1 string2 color2 (repeat). For the supported colors, please check the global dict COLORS.\n\nExamples\n\njulia> @pcs \"Hello world!\" blue\njulia> @pcs \"Hello \" red \"world!\" green\n\nSee also: COLORS, welcome.\n\n\n\n\n\n","category":"macro"},{"location":"library/util.html#Query-Runtime-Environment","page":"Utilities","title":"Query Runtime Environment","text":"","category":"section"},{"location":"library/util.html","page":"Utilities","title":"Utilities","text":"require\nsetup_args\nquery_args","category":"page"},{"location":"library/util.html#ACFlow.require","page":"Utilities","title":"ACFlow.require","text":"require()\n\nCheck the version of julia runtime environment. It should be higher than v1.6.x. One of the most important philosophies of the ACFlow toolkit is minimizing the dependence on the third-party libraries as far as possible. Note that the ACFlow toolkit relys on the TOML package to parse the *.toml file. Only in v1.6.0 and higher versions, julia includes the TOML package in its standard library.\n\n\n\n\n\n","category":"function"},{"location":"library/util.html#ACFlow.setup_args","page":"Utilities","title":"ACFlow.setup_args","text":"setup_args(x::Vararg{String})\n\nSetup ARGS manually. This function is used only in REPL environment. We can use this function to update ARGS, so that the query_args() and the other related functions can work correctly.\n\nExamples\n\njulia> setup_args(\"ac.toml\")\n1-element Array{String,1}:\n \"ac.toml\"\n\nSee also: query_args.\n\n\n\n\n\n","category":"function"},{"location":"library/util.html#ACFlow.query_args","page":"Utilities","title":"ACFlow.query_args","text":"query_args()\n\nCheck whether the configuration file (case.toml) is provided.\n\nSee also: setup_args.\n\n\n\n\n\n","category":"function"},{"location":"library/util.html#Colorful-Outputs","page":"Utilities","title":"Colorful Outputs","text":"","category":"section"},{"location":"library/util.html","page":"Utilities","title":"Utilities","text":"welcome\noverview\ngoodbye\nsorry\nprompt","category":"page"},{"location":"library/util.html#ACFlow.welcome","page":"Utilities","title":"ACFlow.welcome","text":"welcome()\n\nPrint out the welcome messages to the screen.\n\n\n\n\n\n","category":"function"},{"location":"library/util.html#ACFlow.overview","page":"Utilities","title":"ACFlow.overview","text":"overview()\n\nPrint out the overview of ACFlow to the screen.\n\n\n\n\n\n","category":"function"},{"location":"library/util.html#ACFlow.goodbye","page":"Utilities","title":"ACFlow.goodbye","text":"goodbye()\n\nPrint the goodbye messages to the screen.\n\n\n\n\n\n","category":"function"},{"location":"library/util.html#ACFlow.sorry","page":"Utilities","title":"ACFlow.sorry","text":"sorry()\n\nPrint an error message to the screen.\n\n\n\n\n\n","category":"function"},{"location":"library/util.html#ACFlow.prompt","page":"Utilities","title":"ACFlow.prompt","text":"prompt(msg::String)\n\nPrint a stylized ACFlow message to the screen.\n\n\n\n\n\n","category":"function"},{"location":"library/util.html#Input/output-Operations","page":"Utilities","title":"Input/output Operations","text":"","category":"section"},{"location":"library/util.html","page":"Utilities","title":"Utilities","text":"line_to_array","category":"page"},{"location":"library/util.html#ACFlow.line_to_array","page":"Utilities","title":"ACFlow.line_to_array","text":"line_to_array(io::IOStream)\n\nConvert a line (reading from an IOStream) to a string array.\n\n\n\n\n\nline_to_array(str::AbstractString)\n\nConvert a string (AbstractString) to a string array.\n\n\n\n\n\n","category":"function"},{"location":"library/util.html#Color-Tools","page":"Utilities","title":"Color Tools","text":"","category":"section"},{"location":"library/util.html","page":"Utilities","title":"Utilities","text":"colorize","category":"page"},{"location":"library/util.html#ACFlow.colorize","page":"Utilities","title":"ACFlow.colorize","text":"colorize(c::String, s::String; bg::String = \"default\", m::String=\"default\")\n\nReturn some escape sequences, which will be displayed as colorized texts in the terminal.\n\n\n\n\n\ncolorize(c::String, s::String; bg::String = \"default\", m::String=\"default\")\n\nReturn some escape sequences, which will be displayed as colorized texts in the terminal.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#Math","page":"Math","title":"Math","text":"","category":"section"},{"location":"library/math.html","page":"Math","title":"Math","text":"Define some essential mathematical functions.","category":"page"},{"location":"library/math.html#Contents","page":"Math","title":"Contents","text":"","category":"section"},{"location":"library/math.html","page":"Math","title":"Math","text":"Pages = [\"math.md\"]\nDepth = 3","category":"page"},{"location":"library/math.html#Index","page":"Math","title":"Index","text":"","category":"section"},{"location":"library/math.html","page":"Math","title":"Math","text":"Pages = [\"math.md\"]","category":"page"},{"location":"library/math.html#Root-Finding","page":"Math","title":"Root Finding","text":"","category":"section"},{"location":"library/math.html","page":"Math","title":"Math","text":"secant\nnewton","category":"page"},{"location":"library/math.html#ACFlow.secant","page":"Math","title":"ACFlow.secant","text":"secant(func, x0, args...)\n\nIt implements the well-known secant algorithm to locate root of a given polynomial function. Here, func means the function, x0 is the initial guess, and args... denotes the required arguments for function call to func. In addition, the maximum iterations and tolerance are controled by maxiter and tol, respectively. Be careful, func must be a single variable function.\n\nSee also: newton.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#ACFlow.newton","page":"Math","title":"ACFlow.newton","text":"newton(fun::Function, guess, kwargs...;\n       maxiter::I64 = 20000, mixing::F64 = 0.5)\n\nIt implements the well-known newton algorithm to locate root of a given polynomial function. Here, fun means the function, guess is the initial solution, and kwargs... denotes the required arguments for fun. Please be careful, func is a multiple variable function. It not only returns the value, but also the jacobian matrix of the function.\n\nSee also: secant.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#Numerical-Integrations","page":"Math","title":"Numerical Integrations","text":"","category":"section"},{"location":"library/math.html","page":"Math","title":"Math","text":"trapz\nsimpson","category":"page"},{"location":"library/math.html#ACFlow.trapz","page":"Math","title":"ACFlow.trapz","text":"trapz(x::AbstractMesh, y::AbstractVector{T})\n\nPerform numerical integration by using the composite trapezoidal rule.\n\nSee also: simpson.\n\n\n\n\n\ntrapz(x::Vector{F64}, y::Vector{T}, linear::Bool = false)\n\nPerform numerical integration by using the composite trapezoidal rule.\n\nSee also: simpson.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#ACFlow.simpson","page":"Math","title":"ACFlow.simpson","text":"simpson(x::AbstractVector{F64}, y::AbstractVector{T})\n\nPerform numerical integration by using the simpson rule. Note that the length of x and y must be odd numbers. And x must be a linear and uniform mesh.\n\nSee also: trapz.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#Interpolations","page":"Math","title":"Interpolations","text":"","category":"section"},{"location":"library/math.html#Structs","page":"Math","title":"Structs","text":"","category":"section"},{"location":"library/math.html","page":"Math","title":"Math","text":"AbstractInterpolation\nLinearInterpolation\nQuadraticInterpolation\nCubicSplineInterpolation","category":"page"},{"location":"library/math.html#ACFlow.AbstractInterpolation","page":"Math","title":"ACFlow.AbstractInterpolation","text":"AbstractInterpolation\n\nIt represents an abstract interpolation engine, which is used to build the internal type system.\n\n\n\n\n\n","category":"type"},{"location":"library/math.html#ACFlow.LinearInterpolation","page":"Math","title":"ACFlow.LinearInterpolation","text":"LinearInterpolation\n\nIt represents the linear interpolation algorithm.\n\n\n\n\n\n","category":"type"},{"location":"library/math.html#ACFlow.QuadraticInterpolation","page":"Math","title":"ACFlow.QuadraticInterpolation","text":"QuadraticInterpolation\n\nIt represents the quadratic interpolation algorithm.\n\n\n\n\n\n","category":"type"},{"location":"library/math.html#ACFlow.CubicSplineInterpolation","page":"Math","title":"ACFlow.CubicSplineInterpolation","text":"CubicSplineInterpolation\n\nIt represents the cubic spline interpolation algorithm.\n\n\n\n\n\n","category":"type"},{"location":"library/math.html#Constructors","page":"Math","title":"Constructors","text":"","category":"section"},{"location":"library/math.html","page":"Math","title":"Math","text":"LinearInterpolation(u::AbstractVector, t::AbstractVector)\nQuadraticInterpolation(u::AbstractVector, t::AbstractVector)\nCubicSplineInterpolation(u::AbstractVector, t::AbstractVector)","category":"page"},{"location":"library/math.html#ACFlow.LinearInterpolation-Tuple{AbstractVector, AbstractVector}","page":"Math","title":"ACFlow.LinearInterpolation","text":"LinearInterpolation(u::AbstractVector, t::AbstractVector)\n\nCreate a LinearInterpolation struct. Note that u and t denote f(x) and x, respectively.\n\n\n\n\n\n","category":"method"},{"location":"library/math.html#ACFlow.QuadraticInterpolation-Tuple{AbstractVector, AbstractVector}","page":"Math","title":"ACFlow.QuadraticInterpolation","text":"QuadraticInterpolation(u::AbstractVector, t::AbstractVector)\n\nCreate a QuadraticInterpolation struct. Note that u and t denote f(x) and x, respectively.\n\n\n\n\n\n","category":"method"},{"location":"library/math.html#ACFlow.CubicSplineInterpolation-Tuple{AbstractVector, AbstractVector}","page":"Math","title":"ACFlow.CubicSplineInterpolation","text":"CubicSplineInterpolation(u::AbstractVector, t::AbstractVector)\n\nCreate a CubicSplineInterpolation struct. Note that u and t denote f(x) and x, respectively.\n\n\n\n\n\n","category":"method"},{"location":"library/math.html#Functions","page":"Math","title":"Functions","text":"","category":"section"},{"location":"library/math.html","page":"Math","title":"Math","text":"munge_data\n_interp","category":"page"},{"location":"library/math.html#ACFlow.munge_data","page":"Math","title":"ACFlow.munge_data","text":"munge_data(u::AbstractVector{<:Real}, t::AbstractVector{<:Real})\n\nPreprocess the input data. Note that u and t denote f(x) and x, respectively.\n\n\n\n\n\nmunge_data(u::AbstractVector, t::AbstractVector)\n\nPreprocess the input data. Note that u and t denote f(x) and x, respectively.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#ACFlow._interp","page":"Math","title":"ACFlow._interp","text":"_interp(A::LinearInterpolation{<:AbstractVector}, t::Number)\n\nTo implement the linear interpolation algorithm.\n\nSee also: LinearInterpolation.\n\n\n\n\n\n_interp(A::QuadraticInterpolation{<:AbstractVector}, t::Number)\n\nTo implement the quadratic interpolation algorithm.\n\nSee also: QuadraticInterpolation.\n\n\n\n\n\n_interp(A::CubicSplineInterpolation{<:AbstractVector{<:Number}}, t::Number)\n\nTo implement the cubic spline interpolation algorithm.\n\nSee also: CubicSplineInterpolation.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#Einstein-Summation-Convention","page":"Math","title":"Einstein Summation Convention","text":"","category":"section"},{"location":"library/math.html","page":"Math","title":"Math","text":"@einsum","category":"page"},{"location":"library/math.html#ACFlow.@einsum","page":"Math","title":"ACFlow.@einsum","text":"@einsum(ex)\n\nPerform Einstein summation like operations on Julia Arrays.\n\nExamples\n\nBasic matrix multiplication can be implemented as:\n\n@einsum A[i, j] := B[i, k] * C[k, j]\n\nIf the destination array is preallocated, then use =:\n\nA = ones(5, 6, 7) # Preallocated space\nX = randn(5, 2)\nY = randn(6, 2)\nZ = randn(7, 2)\n\n# Store the result in A, overwriting as necessary:\n@einsum A[i, j, k] = X[i, r] * Y[j, r] * Z[k, r]\n\nIf destination is not preallocated, then use := to automatically create a new array for the result:\n\nX = randn(5, 2)\nY = randn(6, 2)\nZ = randn(7, 2)\n\n# Create new array B with appropriate dimensions:\n@einsum B[i, j, k] := X[i, r] * Y[j, r] * Z[k, r]\n\n\n\n\n\n","category":"macro"},{"location":"library/math.html#Curve-Fitting","page":"Math","title":"Curve Fitting","text":"","category":"section"},{"location":"library/math.html#Structs-2","page":"Math","title":"Structs","text":"","category":"section"},{"location":"library/math.html","page":"Math","title":"Math","text":"OnceDifferentiable\nOptimizationResults\nLsqFitResult","category":"page"},{"location":"library/math.html#ACFlow.OnceDifferentiable","page":"Math","title":"ACFlow.OnceDifferentiable","text":"OnceDifferentiable\n\nMutable struct. It is used for objectives and solvers where the gradient is available/exists.\n\nMembers\n\nℱ! -> Objective. It is actually a function call and return objective.\n𝒥! -> It is a function call as well and returns jacobian of objective.\n𝐹  -> Cache for ℱ! output.\n𝐽  -> Cache for 𝒥! output.\n\n\n\n\n\n","category":"type"},{"location":"library/math.html#ACFlow.OptimizationResults","page":"Math","title":"ACFlow.OptimizationResults","text":"OptimizationResults{T,N}\n\nIt is used to save the optimization results of the levenberg_marquardt algorithm.\n\nMembers\n\nx₀         -> Initial guess for the solution.\nminimizer  -> Final results for the solution.\nminimum    -> Residual.\niterations -> Number of iterations.\nxconv      -> If the convergence criterion 1 is satisfied.\ngconv      -> If the convergence criterion 2 is satisfied.\n\n\n\n\n\n","category":"type"},{"location":"library/math.html#ACFlow.LsqFitResult","page":"Math","title":"ACFlow.LsqFitResult","text":"LsqFitResult\n\nIt encapsulates the results for curve fitting.\n\nMembers\n\nparam     -> Fitted results, i.e, the fitting parameters.\nresid     -> Residuals.\njacobian  -> Jacobian matrix.\nconverged -> If the curve-fitting algorithm is converged.\n\n\n\n\n\n","category":"type"},{"location":"library/math.html#Constructors-2","page":"Math","title":"Constructors","text":"","category":"section"},{"location":"library/math.html","page":"Math","title":"Math","text":"OnceDifferentiable(𝑓, p0::AbstractArray, 𝐹::AbstractArray)","category":"page"},{"location":"library/math.html#ACFlow.OnceDifferentiable-Tuple{Any, AbstractArray, AbstractArray}","page":"Math","title":"ACFlow.OnceDifferentiable","text":"OnceDifferentiable(𝑓, p0::AbstractArray, 𝐹::AbstractArray)\n\nConstructor for OnceDifferentiable struct. 𝑓 is the function, p0 is the inital guess, 𝐹 = 𝑓(p0) is the cache for 𝑓's output.\n\n\n\n\n\n","category":"method"},{"location":"library/math.html#Functions-2","page":"Math","title":"Functions","text":"","category":"section"},{"location":"library/math.html","page":"Math","title":"Math","text":"value\nvalue!\njacobian\njacobian!\nlevenberg_marquardt\ncurve_fit","category":"page"},{"location":"library/math.html#ACFlow.value","page":"Math","title":"ACFlow.value","text":"value(obj::OnceDifferentiable)\n\nReturn obj.𝐹. obj will not be affected.\n\n\n\n\n\nvalue(obj::OnceDifferentiable, 𝐹, x)\n\nReturn 𝑓(x). obj will not be affected, but 𝐹 is updated.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#ACFlow.value!","page":"Math","title":"ACFlow.value!","text":"value!(obj::OnceDifferentiable, x)\n\nReturn 𝑓(x). obj.𝐹 will be updated and returned.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#ACFlow.jacobian","page":"Math","title":"ACFlow.jacobian","text":"jacobian(obj::OnceDifferentiable)\n\nReturn obj.𝐽. obj will not be affected.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#ACFlow.jacobian!","page":"Math","title":"ACFlow.jacobian!","text":"jacobian!(obj::OnceDifferentiable, x)\n\nReturn jacobian. obj.𝐽 will be updated and returned.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#ACFlow.levenberg_marquardt","page":"Math","title":"ACFlow.levenberg_marquardt","text":"levenberg_marquardt(df::OnceDifferentiable, x₀::AbstractVector{T})\n\nReturns the argmin over x of sum(f(x).^2) using the Levenberg-Marquardt algorithm. The function f is encoded in df. x₀ is an initial guess for the solution.\n\nSee also: OnceDifferentiable.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#ACFlow.curve_fit","page":"Math","title":"ACFlow.curve_fit","text":"curve_fit(model, x, y, p0)\n\nFit data to a non-linear model. p0 is an initial model parameter guess. The return object is a composite type (LsqFitResult).\n\nSee also: LsqFitResult.\n\n\n\n\n\n","category":"function"},{"location":"theory/basic.html#Basic-Principles","page":"Basic Principles","title":"Basic Principles","text":"","category":"section"},{"location":"theory/basic.html#Finite-Temperature-Green's-Functions","page":"Basic Principles","title":"Finite Temperature Green's Functions","text":"","category":"section"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"Under the Wick's rotation t to itau, the time evolution operator in the Heisenberg picture e^itH will be replaced by e^-tau H. Such a transformation will increase efficiency of QMC random walking and suppress numerical oscillation (when t is large, the periodic oscillation of e^itH is quite obvious). This is an important reason why most of the finite temperature QMC algorithms are formulated in imaginary time axis. The outputs of finite temperature QMC simulations are usually single-particle or two-particle correlation functions. For example, the imaginary time Green's function G(tau) is defined as follows:","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nG(tau) = langle mathcalT_tau d(tau) d^dagger(0) rangle\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"where tau denotes imaginary time, mathcalT_tau denotes time-ordered operator, and d and d^dagger are annihilation and creation operators, respectively. The Matsubara Green's function G(iomega_n) can be measured by QMC simulations or constructed from G(tau) via direct Fourier transformation:","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nG(iomega_n) = int^beta_0 dtaue^-iomega_n tau G(tau)\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nG(tau) = frac1beta sum_n e^iomega_n tau G(iomega_n)\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"Here, beta means the inverse temperature (beta equiv 1T) and omega_n is the Matsubara frequency. Note that omega_n is equal to (2n + 1) pi  beta for fermions and 2npi beta for bosons (n is an integer).","category":"page"},{"location":"theory/basic.html#spectrum","page":"Basic Principles","title":"Spectral Density","text":"","category":"section"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"Clearly, neither G(tau) nor G(iomega_n) can be observed experimentally. We have to extract dynamical response function, i.e., the spectral density A(omega), from them. A(omega) is indeed an observable quantity. It is related to G(tau) via the following Laplace transformation:","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nG(tau) = int^+infty_-infty domega frace^-tauomega1 pm e^-betaomega A(omega)\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"where +(-) in the denominator is for fermionic (bosonic) system. G(iomega_n) and A(omega) manifest similar relation:","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nG(iomega_n) = int^+infty_-infty domega fracA(omega)iomega_n - omega\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"It is obvious that Eq.(4) and Eq.(5) are indeed special forms of the Fredholm integral equation of the first kind. So, the central problem of analytical continuation is to search optimal A(omega) for given G(tau) or G(iomega_n).","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"Sometimes the spectral density A(omega) is called as spectral function in the references. It is tied to the imaginary part of real frequency Green's function G(omega):","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nA(omega) = -frac1pi rmImG(omega)\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"From ImG(omega), ReG(omega) could be calculated via the Kramers-Kronig transformation:","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nmathrmRe G(omega) = frac1pi mathcalP\n  int_-infty^infty domega\n  fracmathrmIm G(omega)omega-omega\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"where mathcalP means Cauchy principal value. Besides Eq.(4) and Eq.(5), A(omega) has to obey some additional constraints or sum-rules. For fermionic systems, the spectral functions must be positive:","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nA(omega) ge 0\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"While for bosonic systems, the above condition turns into:","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\ntextsign(omega) A(omega) ge 0\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"In addition, the spectral function A(omega) is always bounded,","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nint^+infty_-infty domegaA(omega)  infty\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"It can be utilized to normalize the final spectral function.","category":"page"},{"location":"theory/basic.html#Kernel-functions","page":"Basic Principles","title":"Kernel functions","text":"","category":"section"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"Eq.(4) and Eq.(5) can be reformulated as follows:","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nG(tau) = int^+infty_-infty domegaK(tauomega) A(omega)\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"and","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nG(iomega_n) = int^+infty_-infty domegaK(omega_nomega) A(omega)\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"where K(tauomega) and K(omega_n omega) are the so-called kernel functions. Their definitions are as follows:","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nK(tauomega) = frace^-tauomega1 pm e^-betaomega\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"and","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"beginequation\nK(omega_nomega) = frac1iomega_n - omega\nendequation","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"where +(-) in the denominator of Eq.(13) stands for fermions (bosons).","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"As mentioned above, the kernel function is quite strange. The values of K(tauomega) could change by tens of orders of magnitude. Especially, at large positive and negative frequencies, K(tauomega) is exponentially small. It implies that at large omega the features of A(omega) depend upon the fine structures of G(tau). However, the G(tau) data provided by QMC simulations are always fluctuant and noisy. Tiny deviations in G(tau) from its expected values can lead to enormous changes in A(omega). Thus, analytical continuation is often characterized as an ill-posed problem.","category":"page"},{"location":"theory/basic.html","page":"Basic Principles","title":"Basic Principles","text":"In principle, for incomplete and noise G(tau) or G(iomega_n), the number of spectral functions A(omega) that satisfy Eq.(11) and Eq.(12) is infinite. So the question becomes which A(omega) should be chosen. Now there are two different strategies to solve this problem. The first one is to choose the most likely A(omega). The second one is to evaluate the average of all the candidate spectral functions.","category":"page"},{"location":"intro/ack.html#Acknowledgements","page":"Acknowledgements","title":"Acknowledgements","text":"","category":"section"},{"location":"intro/ack.html","page":"Acknowledgements","title":"Acknowledgements","text":"This project has been supported by the following foundations:","category":"page"},{"location":"intro/ack.html","page":"Acknowledgements","title":"Acknowledgements","text":"CAEP Foundation (under Grant No.CX20210033)\nNational Science Foundation of China (under Grants No.11874329).\nNational Science Foundation of China (under Grants No.11934020).","category":"page"},{"location":"man/install.html#install","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"It is an easy task to install the ACFlow toolkit. First, since it is written in pure Julia language, it is necessary to install the Julia runtime environment at first. The newest version of Julia is always preferred (version > 1.60). Since the core codes only rely on Julia's built-in standard library, no the third-party packages are needed. Second, just download source codes of the ACFlow toolkit from its github repository. It should be a compressed file, such as acflow.zip or acflow.tar.gz. Please uncompress it in your favorite directory by using the following commands:","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"$ unzip acflow.zip","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"or","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"$ tar xvfz acflow.tar.gz","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"Third, the users have to announce a new environment variable ACFLOW_HOME. Supposed that the root directory of the ACFLow toolkit is /home/your_home/acflow, then ACFLOW_HOME should be declared as follows:","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"$ export ACFLOW_HOME=/home/your_home/acflow/src","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"Finally, in order to generate the documentation, the users should type the following commands in the terminal:","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"$ pwd\n/home/your_home/acflow\n$ cd docs\n$ julia make.jl","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"After a few seconds, the documentation is built and saved in the acflow/docs/build directory if everything is OK. The home page of the documentation is acflow/docs/build/index.html. The users can open it with any web browsers.","category":"page"},{"location":"theory/spx.html#Stochastic-Pole-Expansion","page":"Stochastic Pole Expansion","title":"Stochastic Pole Expansion","text":"","category":"section"},{"location":"library/kernel.html#Kernels","page":"Kernels","title":"Kernels","text":"","category":"section"},{"location":"library/kernel.html","page":"Kernels","title":"Kernels","text":"Build kernel functions.","category":"page"},{"location":"library/kernel.html","page":"Kernels","title":"Kernels","text":"The ACFlow toolkit supports six types of kernel functions. They are:","category":"page"},{"location":"library/kernel.html","page":"Kernels","title":"Kernels","text":"Fermionic imaginary time kernel (ktype = \"fermi\", grid = \"ftime\")\nFermionic Matsubara kernel (ktype = \"fermi\", grid = \"ffreq\")\nBosonic imaginary time kernel (ktype = \"boson\", grid = \"btime\")\nBosonc Matsubara kernel (ktype = \"boson\", grid = \"bfreq\")\nSymmetric bosonic imaginary time kernel (ktype = \"bsymm\", grid = \"btime\")\nSymmetric bosonic Matsubara kernel (ktype = \"bsymm\", grid = \"bfreq\")","category":"page"},{"location":"library/kernel.html","page":"Kernels","title":"Kernels","text":"Note that the MaxEnt, StochAC, and StochSK solvers rely on the make_kernel() function to provide the kernel function. However, the kernel function or matrix used in the StochOM and StochPX solvers are implemented in their own calc_lambda() functions.","category":"page"},{"location":"library/kernel.html#Contents","page":"Kernels","title":"Contents","text":"","category":"section"},{"location":"library/kernel.html","page":"Kernels","title":"Kernels","text":"Pages = [\"kernel.md\"]\nDepth = 2","category":"page"},{"location":"library/kernel.html#Index","page":"Kernels","title":"Index","text":"","category":"section"},{"location":"library/kernel.html","page":"Kernels","title":"Kernels","text":"Pages = [\"kernel.md\"]","category":"page"},{"location":"library/kernel.html#Making-Kernels","page":"Kernels","title":"Making Kernels","text":"","category":"section"},{"location":"library/kernel.html","page":"Kernels","title":"Kernels","text":"build_kernel\nbuild_kernel_symm","category":"page"},{"location":"library/kernel.html#ACFlow.build_kernel","page":"Kernels","title":"ACFlow.build_kernel","text":"build_kernel(am::AbstractMesh, fg::FermionicImaginaryTimeGrid)\n\nTry to build fermionic kernel function in imaginary time axis.\n\nSee also: AbstractMesh, FermionicImaginaryTimeGrid.\n\n\n\n\n\nbuild_kernel(am::AbstractMesh, fg::FermionicFragmentTimeGrid)\n\nTry to build fermionic kernel function in imaginary time axis. Note that fg contains incomplete imaginary time data.\n\nSee also: AbstractMesh, FermionicFragmentTimeGrid.\n\n\n\n\n\nbuild_kernel(am::AbstractMesh, fg::FermionicMatsubaraGrid)\n\nTry to build fermionic kernel function in Matsubara frequency axis. This function support preblur algorithm.\n\nSee also: AbstractMesh, FermionicMatsubaraGrid.\n\n\n\n\n\nbuild_kernel(am::AbstractMesh, fg::FermionicFragmentMatsubaraGrid)\n\nTry to build fermionic kernel function in Matsubara frequency axis. This function support preblur algorithm.\n\nSee also: AbstractMesh, FermionicFragmentMatsubaraGrid.\n\n\n\n\n\nbuild_kernel(am::AbstractMesh, bg::BosonicImaginaryTimeGrid)\n\nTry to build bosonic kernel function in imaginary time axis.\n\nSee also: AbstractMesh, BosonicImaginaryTimeGrid.\n\n\n\n\n\nbuild_kernel(am::AbstractMesh, bg::BosonicFragmentTimeGrid)\n\nTry to build bosonic kernel function in imaginary time axis. Note that bg contains incomplete imaginary time data.\n\nSee also: AbstractMesh, BosonicFragmentTimeGrid.\n\n\n\n\n\nbuild_kernel(am::AbstractMesh, bg::BosonicMatsubaraGrid)\n\nTry to build bosonic kernel function in Matsubara frequency axis.\n\nSee also: AbstractMesh, BosonicMatsubaraGrid.\n\n\n\n\n\nbuild_kernel(am::AbstractMesh, bg::BosonicFragmentMatsubaraGrid)\n\nTry to build bosonic kernel function in Matsubara frequency axis.\n\nSee also: AbstractMesh, BosonicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"function"},{"location":"library/kernel.html#ACFlow.build_kernel_symm","page":"Kernels","title":"ACFlow.build_kernel_symm","text":"build_kernel_symm(am::AbstractMesh, bg::BosonicImaginaryTimeGrid)\n\nTry to build bosonic kernel function in imaginary time axis (just for correlator of Hermitian operator only).\n\nSee also: AbstractMesh, BosonicImaginaryTimeGrid.\n\n\n\n\n\nbuild_kernel_symm(am::AbstractMesh, bg::BosonicFragmentTimeGrid)\n\nTry to build bosonic kernel function in imaginary time axis (just for correlator of Hermitian operator only). Note that bg contains incomplete imaginary time data.\n\nSee also: AbstractMesh, BosonicFragmentTimeGrid.\n\n\n\n\n\nbuild_kernel_symm(am::AbstractMesh, bg::BosonicMatsubaraGrid)\n\nTry to build bosonic kernel function in Matsubara frequency axis (just for correlator of Hermitian operator only). This function support preblur algorithm.\n\nSee also: AbstractMesh, BosonicMatsubaraGrid.\n\n\n\n\n\nbuild_kernel_symm(am::AbstractMesh, bg::BosonicFragmentMatsubaraGrid)\n\nTry to build bosonic kernel function in Matsubara frequency axis (just for correlator of Hermitian operator only). This function support preblur algorithm.\n\nSee also: AbstractMesh, BosonicFragmentMatsubaraGrid.\n\n\n\n\n\n","category":"function"},{"location":"library/kernel.html#Utilities","page":"Kernels","title":"Utilities","text":"","category":"section"},{"location":"library/kernel.html","page":"Kernels","title":"Kernels","text":"make_blur\nmake_singular_space\nmake_gauss_peaks","category":"page"},{"location":"library/kernel.html#ACFlow.make_blur","page":"Kernels","title":"ACFlow.make_blur","text":"make_blur(am::AbstractMesh, A::Vector{F64}, blur::F64)\n\nTry to blur the given spectrum A, which is defined in am. And blur is the blur parameter.\n\n\n\n\n\n","category":"function"},{"location":"library/kernel.html#ACFlow.make_singular_space","page":"Kernels","title":"ACFlow.make_singular_space","text":"make_singular_space(kernel::Matrix{F64})\n\nPerform singular value decomposition for the input matrix.\n\n\n\n\n\n","category":"function"},{"location":"library/kernel.html#ACFlow.make_gauss_peaks","page":"Kernels","title":"ACFlow.make_gauss_peaks","text":"make_gauss_peaks(blur::F64)\n\nTry to generate a series of gaussian peaks along a linear mesh, whose energy range is [-5 * blur, +5 * blur].\n\n\n\n\n\n","category":"function"},{"location":"library/model.html#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"library/model.html","page":"Models","title":"Models","text":"For default model functions.","category":"page"},{"location":"library/model.html","page":"Models","title":"Models","text":"The ACFlow toolkit supports various model functions, such as flat, Gaussian, Lorentzian, and a few unusual models. They are useful for the MaxEnt and StochAC solvers. In order to build these model functions, we need some additional parameters, including Gamma, s, s_1, and s_2. They should be setup by using the parameter pmodel.","category":"page"},{"location":"library/model.html#Contents","page":"Models","title":"Contents","text":"","category":"section"},{"location":"library/model.html","page":"Models","title":"Models","text":"Pages = [\"model.md\"]\nDepth = 2","category":"page"},{"location":"library/model.html#Index","page":"Models","title":"Index","text":"","category":"section"},{"location":"library/model.html","page":"Models","title":"Models","text":"Pages = [\"model.md\"]","category":"page"},{"location":"library/model.html#Flat-Model","page":"Models","title":"Flat Model","text":"","category":"section"},{"location":"library/model.html","page":"Models","title":"Models","text":"build_flat_model","category":"page"},{"location":"library/model.html#ACFlow.build_flat_model","page":"Models","title":"ACFlow.build_flat_model","text":"build_flat_model(am::AbstractMesh)\n\nTry to build a flat model in am. Then this model function is normalized. Only this model function is suitable for the StochAC solver.\n\nSee also: AbstractMesh.\n\n\n\n\n\n","category":"function"},{"location":"library/model.html#Gaussian-Models","page":"Models","title":"Gaussian Models","text":"","category":"section"},{"location":"library/model.html","page":"Models","title":"Models","text":"note: Note\nThis class includes the standard Gaussian model, shifted Gaussian model, and two-Gaussians model.","category":"page"},{"location":"library/model.html","page":"Models","title":"Models","text":"build_gaussian_model\nbuild_1gaussian_model\nbuild_2gaussians_model","category":"page"},{"location":"library/model.html#ACFlow.build_gaussian_model","page":"Models","title":"ACFlow.build_gaussian_model","text":"build_gaussian_model(am::AbstractMesh, Γ::F64)\n\nTry to build a Gaussian model, which is then normalized. The argument Γ is used to control the width of the Gaussian peak.\n\nSee also: AbstractMesh.\n\n\n\n\n\n","category":"function"},{"location":"library/model.html#ACFlow.build_1gaussian_model","page":"Models","title":"ACFlow.build_1gaussian_model","text":"build_1gaussian_model(am::AbstractMesh, Γ::F64, s::F64)\n\nTry to build a shifted Gaussian model, which is then normalized. The argument Γ is used to control the width of the Gaussian peak, and s means the shift of the central peak. If s > 0, the peak is shifted to positive half-axis, and vice versa.\n\nSee also: AbstractMesh.\n\n\n\n\n\n","category":"function"},{"location":"library/model.html#ACFlow.build_2gaussians_model","page":"Models","title":"ACFlow.build_2gaussians_model","text":"build_2gaussians_model(am::AbstractMesh, Γ::F64, s₁::F64, s₂::F64)\n\nTry to build a Two Gaussians model, which is then normalized. The argument Γ is used to control the width of the Gaussian peak, and s₁ and s₂ denote the centers of the two peaks.\n\nSee also: AbstractMesh.\n\n\n\n\n\n","category":"function"},{"location":"library/model.html#Lorentzian-Models","page":"Models","title":"Lorentzian Models","text":"","category":"section"},{"location":"library/model.html","page":"Models","title":"Models","text":"note: Note\nThis class includes the standard Lorentzian model, shifted Lorentzian model, and two-Lorentzians model.","category":"page"},{"location":"library/model.html","page":"Models","title":"Models","text":"build_lorentzian_model\nbuild_1lorentzian_model\nbuild_2lorentzians_model","category":"page"},{"location":"library/model.html#ACFlow.build_lorentzian_model","page":"Models","title":"ACFlow.build_lorentzian_model","text":"build_lorentzian_model(am::AbstractMesh, Γ::F64)\n\nTry to build a Lorentzian model, which is then normalized. The argument Γ is used to control the width of the Lorentzian peak.\n\nSee also: AbstractMesh.\n\n\n\n\n\n","category":"function"},{"location":"library/model.html#ACFlow.build_1lorentzian_model","page":"Models","title":"ACFlow.build_1lorentzian_model","text":"build_1lorentzian_model(am::AbstractMesh, Γ::F64, s::F64)\n\nTry to build a shifted Lorentzian model, which is then normalized. The argument Γ is used to control the width of the Lorentzian peak, and s means the shift of the central peak. If s > 0, the peak is shifted to positive half-axis, and vice versa.\n\nSee also: AbstractMesh.\n\n\n\n\n\n","category":"function"},{"location":"library/model.html#ACFlow.build_2lorentzians_model","page":"Models","title":"ACFlow.build_2lorentzians_model","text":"build_2lorentzians_model(am::AbstractMesh, Γ::F64, s₁::F64, s₂::F64)\n\nTry to build a Two-Lorentzians model, which is then normalized. The argument Γ is used to control the width of the Lorentzian peak, and s₁ and s₂ denote the centers of the two peaks.\n\nSee also: AbstractMesh.\n\n\n\n\n\n","category":"function"},{"location":"library/model.html#Unusual-Models","page":"Models","title":"Unusual Models","text":"","category":"section"},{"location":"library/model.html","page":"Models","title":"Models","text":"note: Note\nThis class includes the Rise-And-Decay model, file model, and function model.","category":"page"},{"location":"library/model.html","page":"Models","title":"Models","text":"build_risedecay_model\nbuild_file_model\nbuild_func_model","category":"page"},{"location":"library/model.html#ACFlow.build_risedecay_model","page":"Models","title":"ACFlow.build_risedecay_model","text":"build_risedecay_model(am::AbstractMesh, Γ::F64)\n\nTry to build a Rise-And-Decay model, which is then normalized. This model function is defined on positive half-axis, so it is more suitable for the bosonic response function.\n\nSee also: AbstractMesh.\n\n\n\n\n\n","category":"function"},{"location":"library/model.html#ACFlow.build_file_model","page":"Models","title":"ACFlow.build_file_model","text":"build_file_model(am::AbstractMesh, fn::String)\n\nTry to read a model function from external file (specified by fn). Note that the mesh used to generate the model function must be compatible with am. In addition, the model function will not be normalized.\n\nSee also: AbstractMesh.\n\n\n\n\n\n","category":"function"},{"location":"library/model.html#ACFlow.build_func_model","page":"Models","title":"ACFlow.build_func_model","text":"build_func_model(fun::Function, am::AbstractMesh, kwargs...)\n\nTry to build a model function by customized function fun. kwargs denotes the arguments required by fun. Actually, this feature does not really work.\n\nSee also: AbstractMesh.\n\n\n\n\n\n","category":"function"},{"location":"library/global.html#Constants","page":"Constants","title":"Constants","text":"","category":"section"},{"location":"library/global.html","page":"Constants","title":"Constants","text":"Define some type aliases and string constants for the ACFlow toolkit.","category":"page"},{"location":"library/global.html#Contents","page":"Constants","title":"Contents","text":"","category":"section"},{"location":"library/global.html","page":"Constants","title":"Constants","text":"Pages = [\"global.md\"]\nDepth = 2","category":"page"},{"location":"library/global.html#Index","page":"Constants","title":"Index","text":"","category":"section"},{"location":"library/global.html","page":"Constants","title":"Constants","text":"Pages = [\"global.md\"]","category":"page"},{"location":"library/global.html#Numerical-Types","page":"Constants","title":"Numerical Types","text":"","category":"section"},{"location":"library/global.html","page":"Constants","title":"Constants","text":"I32\nI64\nF32\nF64\nC32\nC64\nR32\nR64\nN32\nN64","category":"page"},{"location":"library/global.html#ACFlow.I32","page":"Constants","title":"ACFlow.I32","text":"I32\n\nAlias of Integer type (32 bit).\n\nSee also: R32, R64, N32, N64.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACFlow.I64","page":"Constants","title":"ACFlow.I64","text":"I64\n\nAlias of Integer type (64 bit).\n\nSee also: R32, R64, N32, N64.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACFlow.F32","page":"Constants","title":"ACFlow.F32","text":"F32\n\nAlias of Float type (32 bit).\n\nSee also: R32, R64, N32, N64.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACFlow.F64","page":"Constants","title":"ACFlow.F64","text":"F64\n\nAlias of Float type (64 bit).\n\nSee also: R32, R64, N32, N64.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACFlow.C32","page":"Constants","title":"ACFlow.C32","text":"C32\n\nAlias of Complex type (32 bit).\n\nSee also: N32, N64.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACFlow.C64","page":"Constants","title":"ACFlow.C64","text":"C64\n\nAlias of Complex type (64 bit).\n\nSee also: N32, N64.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACFlow.R32","page":"Constants","title":"ACFlow.R32","text":"R32\n\nAlias of Integer and Float types (32 bit). Here R means Real.\n\nSee also: N32, N64.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACFlow.R64","page":"Constants","title":"ACFlow.R64","text":"R64\n\nAlias of Integer and Float types (64 bit). Here R means Real.\n\nSee also: N32, N64.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACFlow.N32","page":"Constants","title":"ACFlow.N32","text":"N32\n\nAlias of Integer, Float, and Complex types (32 bit). Here N means Number.\n\nSee also: R32, R64.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACFlow.N64","page":"Constants","title":"ACFlow.N64","text":"N64\n\nAlias of Integer, Float, and Complex types (64 bit). Here N means Number.\n\nSee also: R32, R64.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#String-Constants","page":"Constants","title":"String Constants","text":"","category":"section"},{"location":"library/global.html","page":"Constants","title":"Constants","text":"__LIBNAME__\n__VERSION__\n__RELEASE__\n__AUTHORS__","category":"page"},{"location":"library/global.html#ACFlow.__LIBNAME__","page":"Constants","title":"ACFlow.__LIBNAME__","text":"__LIBNAME__\n\nName of this julia toolkit.\n\nSee also: __VERSION__.\n\n\n\n\n\n","category":"constant"},{"location":"library/global.html#ACFlow.__VERSION__","page":"Constants","title":"ACFlow.__VERSION__","text":"__VERSION__\n\nVersion of this julia toolkit.\n\nSee also: __RELEASE__.\n\n\n\n\n\n","category":"constant"},{"location":"library/global.html#ACFlow.__RELEASE__","page":"Constants","title":"ACFlow.__RELEASE__","text":"__RELEASE__\n\nRelease date of this julia toolkit.\n\nSee also: __AUTHORS__.\n\n\n\n\n\n","category":"constant"},{"location":"library/global.html#ACFlow.__AUTHORS__","page":"Constants","title":"ACFlow.__AUTHORS__","text":"__AUTHORS__\n\nCore authors of this julia toolkit.\n\nSee also: __LIBNAME__.\n\n\n\n\n\n","category":"constant"},{"location":"library/global.html#Utilities","page":"Constants","title":"Utilities","text":"","category":"section"},{"location":"library/global.html","page":"Constants","title":"Constants","text":"authors","category":"page"},{"location":"library/global.html#ACFlow.authors","page":"Constants","title":"ACFlow.authors","text":"authors()\n\nPrint authors / contributors of the ACFlow toolkit.\n\nSee also: __AUTHORS__.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"Define various solvers for the ACFlow toolkit.","category":"page"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"Now the ACFlow toolkit supports five analytical continuation solvers. They are:","category":"page"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"MaxEnt (Maximum Entropy Method, see maxent.jl)\nStochAC (Stochastic Analytical Continuations, see sac.jl)\nStochSK (Stochastic Analytical Continuation, see san.jl)\nStochOM (Stochastic Optimization Method, see som.jl)\nStochPX (Stochastic Pole Expansion, see spx.jl)","category":"page"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"Note that the StochAC solver is based on the Beach's variant, while the StochSK solver is based on the Sandvik's variant.","category":"page"},{"location":"library/solver.html#Contents","page":"Solvers","title":"Contents","text":"","category":"section"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"Pages = [\"solver.md\"]\nDepth = 3","category":"page"},{"location":"library/solver.html#Index","page":"Solvers","title":"Index","text":"","category":"section"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"Pages = [\"solver.md\"]","category":"page"},{"location":"library/solver.html#Abstract-Structs","page":"Solvers","title":"Abstract Structs","text":"","category":"section"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"AbstractSolver\nAbstractMC","category":"page"},{"location":"library/solver.html#ACFlow.AbstractSolver","page":"Solvers","title":"ACFlow.AbstractSolver","text":"AbstractSolver\n\nAn abstract type representing the solver for analytical continuation problem. It is used to build the internal type system. All the other solvers are its sub-types.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#ACFlow.AbstractMC","page":"Solvers","title":"ACFlow.AbstractMC","text":"AbstractMC\n\nAn abstract type representing the Monte Carlo engine. It is used to build the internal type system.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#MaxEnt-Solver","page":"Solvers","title":"MaxEnt Solver","text":"","category":"section"},{"location":"library/solver.html#Structs","page":"Solvers","title":"Structs","text":"","category":"section"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"MaxEntSolver\nMaxEntContext","category":"page"},{"location":"library/solver.html#ACFlow.MaxEntSolver","page":"Solvers","title":"ACFlow.MaxEntSolver","text":"MaxEntSolver\n\nIt represents the analytical continuation solver that implements the maximum entropy method.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#ACFlow.MaxEntContext","page":"Solvers","title":"ACFlow.MaxEntContext","text":"MaxEntContext\n\nMutable struct. It is used within the MaxEnt solver only.\n\nMembers\n\nGᵥ     -> Input data for correlator.\nσ²     -> Actually 1.0 / σ².\ngrid   -> Grid for input data.\nmesh   -> Mesh for output spectrum.\nmodel  -> Default model function.\nkernel -> Default kernel function.\nVₛ     -> Matrix from singular value decomposition.\nW₂     -> Precomputed array.\nW₃     -> Precomputed array.\nBₘ     -> Precomputed array.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#Functions","page":"Solvers","title":"Functions","text":"","category":"section"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"solve(S::MaxEntSolver, rd::RawData)\ninit(S::MaxEntSolver, rd::RawData)\nACFlow.run(mec::MaxEntContext)\nACFlow.last(mec::MaxEntContext, svec::Vector, sol::Dict)\nhistoric\nclassic\nbryan\nchi2kink\noptimizer\nprecompute\nf_and_J\nf_and_J_offdiag\nsvd_to_real\nsvd_to_real_offdiag\ncalc_entropy\ncalc_entropy_offdiag\ncalc_bayes\ncalc_bayes_offdiag\ncalc_chi2(mec::MaxEntContext, A::Vector{F64})","category":"page"},{"location":"library/solver.html#ACFlow.solve-Tuple{MaxEntSolver, RawData}","page":"Solvers","title":"ACFlow.solve","text":"solve(S::MaxEntSolver, rd::RawData)\n\nSolve the analytical continuation problem by the maximum entropy method.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init-Tuple{MaxEntSolver, RawData}","page":"Solvers","title":"ACFlow.init","text":"init(S::MaxEntSolver, rd::RawData)\n\nInitialize the MaxEnt solver and return a MaxEntContext struct.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.run-Tuple{MaxEntContext}","page":"Solvers","title":"ACFlow.run","text":"run(mec::MaxEntContext)\n\nPerform maximum entropy simulation with different algorithms. Now it supports the historic, classic, bryan, and chi2kink algorithms.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.last-Tuple{MaxEntContext, Vector, Dict}","page":"Solvers","title":"ACFlow.last","text":"last(mec::MaxEntContext, svec::Vector, sol::Dict)\n\nPostprocess the results generated during the maximum entropy simulations. Here sol is the final solution for the analytical continuation problem, while svec contains all the intermediate results (it is a vector of dictionary actually).\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.historic","page":"Solvers","title":"ACFlow.historic","text":"historic(mec::MaxEntContext)\n\nApply the historic algorithm to solve the analytical continuation problem. It choose α in a way that χ² ≈ N.\n\nFor the historic algorithm, alpha is usually 10⁶, and ratio is 10.0. It is compatible with the Bayesian Reconstruction entropy.\n\nSee also: MaxEntContext.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.classic","page":"Solvers","title":"ACFlow.classic","text":"classic(mec::MaxEntContext)\n\nApply the classic algorithm to solve the analytical continuation problem.\n\nClassic algorithm uses Bayes statistics to approximately determine the most probable value of α. We always start at a large value of α, where the optimization yields basically the default model, therefore u_vec is only a few steps away from 0 (= default model). And then we gradually decrease α, step by step moving away from the default model towards data fitting. Using u_vec as start for the next (smaller) α brings a great speedup into this procedure.\n\nFor the classic algorithm, alpha is usually 10⁶, and ratio is 10.0. It is incompatible with the Bayesian Reconstruction entropy.\n\nSee also: MaxEntContext.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.bryan","page":"Solvers","title":"ACFlow.bryan","text":"bryan(mec::MaxEntContext)\n\nApply the bryan algorithm to solve the analytical continuation problem.\n\nBryan's maxent calculates an average of spectral functions, weighted by their Bayesian probability.\n\nFor the bryan algorithm, alpha is usually 500, and ratio is 1.1. It is incompatible with the Bayesian Reconstruction entropy.\n\nSee also: MaxEntContext.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.chi2kink","page":"Solvers","title":"ACFlow.chi2kink","text":"chi2kink(mec::MaxEntContext)\n\nApply the chi2kink algorithm to solve the analytical continuation problem.\n\nWe start with an optimization at a large value of α, where we should get only the default model. And then, α is decreased step-by-step, until the minimal value of α is reached. Then, we fit a function\n\nϕ(x; a, b, c, d) = a + b / [1 + exp(-d*(x-c))],\n\nfrom which the optimal α is determined by\n\nx_opt = c - fit_position / d,\n\nand\n\nalpha_opt = 10^x_opt.\n\nFor the chi2kink algorithm, alpha is usually 10⁹, ratio is 10.0, the number of alpha parameters is 12. It is compatible with the Bayesian Reconstruction entropy.\n\nSee also: MaxEntContext.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.optimizer","page":"Solvers","title":"ACFlow.optimizer","text":"optimizer(mec::MaxEntContext, α::F64, us::Vector{F64}, use_bayes::Bool)\n\nOptimization of maxent functional for a given value of α. Since a priori the best value of α is unknown, this function has to be called several times in order to find a good value.\n\nα means a weight factor of the entropy. us is a vector in singular space. It is used as a starting value for the optimization. For the very first optimization, done at large α, we use zeros, which corresponds to the default model. Then we use the result of the previous optimization as a starting value. use_bayes determines whether to use the Bayesian inference parameters for α.\n\nThis function will return a dictionary object that holds the results of the optimization, e.g. spectral function, χ² deviation.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.precompute","page":"Solvers","title":"ACFlow.precompute","text":"precompute(Gᵥ::Vector{F64}, σ²::Vector{F64},\n           am::AbstractMesh,\n           D::Vector{F64},\n           K::Matrix{F64})\n\nPrecompute some key coefficients. Here Gᵥ and σ² are input data, am is the mesh for spectrum, D is the default model, and K is the kernel function.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.f_and_J","page":"Solvers","title":"ACFlow.f_and_J","text":"f_and_J(u::Vector{F64}, mec::MaxEntContext, α::F64)\n\nThis function evaluates the function whose root we want to find. Here u is a singular space vector that parametrizes the spectral function, and α is a (positive) weight factor of the entropy.\n\nIt returns f, value of the function whose zero we want to find, and J, jacobian at the current position.\n\nSee also: f_and_J_offdiag.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.f_and_J_offdiag","page":"Solvers","title":"ACFlow.f_and_J_offdiag","text":"f_and_J_offdiag(u::Vector{F64}, mec::MaxEntContext, α::F64)\n\nThis function evaluates the function whose root we want to find. Here u is a singular space vector that parametrizes the spectral function, and α is a (positive) weight factor of the entropy.\n\nIt returns f, value of the function whose zero we want to find, and J, jacobian at the current position.\n\nThis function is similar to f_and_J, but for offdiagonal elements.\n\nSee also: f_and_J.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.svd_to_real","page":"Solvers","title":"ACFlow.svd_to_real","text":"svd_to_real(mec::MaxEntContext, u::Vector{F64})\n\nGo from singular value space to real space. It will transform the singular space vector u into real-frequency space (to get the spectral function) by A(ω) = D(ω) eⱽᵘ, where D(ω) is the default model V is the matrix from the singular value decomposition. The argument u means a singular space vector that parametrizes the spectral function.\n\nSee also: svd_to_real_offdiag.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.svd_to_real_offdiag","page":"Solvers","title":"ACFlow.svd_to_real_offdiag","text":"svd_to_real_offdiag(mec::MaxEntContext, u::Vector{F64})\n\nGo from singular value space to real space. It will transform the singular space vector u into real-frequency space in the case of an offdiagonal element. It will return the spectral function.\n\nSee also: svd_to_real.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_entropy","page":"Solvers","title":"ACFlow.calc_entropy","text":"calc_entropy(mec::MaxEntContext, A::Vector{F64}, u::Vector{F64})\n\nIt computes entropy for positive definite spectral function. Here the arguments A means spectral function and u means a singular space vector that parametrizes the spectral function.\n\nSee also: calc_entropy_offdiag.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_entropy_offdiag","page":"Solvers","title":"ACFlow.calc_entropy_offdiag","text":"calc_entropy_offdiag(mec::MaxEntContext, A::Vector{F64})\n\nIt compute positive-negative entropy for spectral function with norm 0. Here the argument A means spectral function.\n\nSee also: calc_entropy.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_bayes","page":"Solvers","title":"ACFlow.calc_bayes","text":"calc_bayes(mec::MaxEntContext,\n           A::Vector{F64},\n           S::F64, χ²::F64, α::F64)\n\nIt calculates Bayesian convergence criterion (ng, tr, and conv) for classic maxent (maximum of probablility distribution) and then Bayesian a-posteriori probability (log_prob) for α after optimization of A.\n\nHere, A is the spectral function, S the entropy, χ² the deviation, and α weight factor of the entropy.\n\nSee also: calc_bayes_offdiag.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_bayes_offdiag","page":"Solvers","title":"ACFlow.calc_bayes_offdiag","text":"calc_bayes_offdiag(mec::MaxEntContext,\n                   A::Vector{F64},\n                   S::F64, χ²::F64, α::F64)\n\nIt calculates Bayesian convergence criterion (ng, tr, and conv) for classic maxent (maximum of probablility distribution) and then Bayesian a-posteriori probability (log_prob) for α after optimization of A.\n\nHere, A is the spectral function, S the entropy, χ² the deviation, and α weight factor of the entropy.\n\nIt is just a offdiagonal version of calc_bayes().\n\nSee also: calc_bayes.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_chi2-Tuple{MaxEntContext, Vector{Float64}}","page":"Solvers","title":"ACFlow.calc_chi2","text":"calc_chi2(mec::MaxEntContext, A::Vector{F64})\n\nIt computes the χ²-deviation of the spectral function A.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#StochAC-Solver","page":"Solvers","title":"StochAC Solver","text":"","category":"section"},{"location":"library/solver.html#Structs-2","page":"Solvers","title":"Structs","text":"","category":"section"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"StochACSolver\nStochACMC\nStochACElement\nStochACContext","category":"page"},{"location":"library/solver.html#ACFlow.StochACSolver","page":"Solvers","title":"ACFlow.StochACSolver","text":"StochACSolver\n\nIt represents the analytical continuation solver that implements the stochastic analytical continuation method (K. S. D. Beach's version).\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#ACFlow.StochACMC","page":"Solvers","title":"ACFlow.StochACMC","text":"StochACMC\n\nMutable struct. It is used within the StochAC solver. It includes random number generator and some counters.\n\nMembers\n\nrng  -> Random number generator.\nMacc -> Counter for move operation (accepted).\nMtry -> Counter for move operation (tried).\nSacc -> Counter for swap operation (accepted).\nStry -> Counter for swap operation (tried).\n\nSee also: StochACSolver.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#ACFlow.StochACElement","page":"Solvers","title":"ACFlow.StochACElement","text":"StochACElement\n\nMutable struct. It is used to record the field configurations, which will be sampled by  Monte Carlo sweeping procedure.\n\nMembers\n\nΓₚ -> It means the positions of the δ functions.\nΓₐ -> It means the weights / amplitudes of the δ functions.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#ACFlow.StochACContext","page":"Solvers","title":"ACFlow.StochACContext","text":"StochACContext\n\nMutable struct. It is used within the StochAC solver only.\n\nMembers\n\nGᵥ     -> Input data for correlator.\nσ¹     -> Actually 1.0 / σ¹.\nallow  -> Allowable indices.\ngrid   -> Grid for input data.\nmesh   -> Mesh for output spectrum.\nmodel  -> Default model function.\nkernel -> Default kernel function.\nAout   -> Calculated spectral function, it is actually ⟨n(x)⟩.\nΔ      -> Precomputed δ functions.\nhτ     -> α-resolved h(τ).\nHα     -> α-resolved Hc.\nUα     -> α-resolved internal energy, it is actually ⟨Hα⟩.\nαₗ     -> Vector of the α parameters.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#Functions-2","page":"Solvers","title":"Functions","text":"","category":"section"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"solve(S::StochACSolver, rd::RawData)\ninit(S::StochACSolver, rd::RawData)\nACFlow.run(MC::StochACMC, SE::StochACElement, SC::StochACContext)\nprun(S::StochACSolver, p1::Dict{String,Vector{Any}}, p2::Dict{String,Vector{Any}}, MC::StochACMC, SE::StochACElement, SC::StochACContext)\naverage(step::F64, SC::StochACContext)\nACFlow.last(SC::StochACContext, Aout::Array{F64,2}, Uα::Vector{F64})\nwarmup(MC::StochACMC, SE::StochACElement, SC::StochACContext)\nsample(MC::StochACMC, SE::StochACElement, SC::StochACContext)\nmeasure(SE::StochACElement, SC::StochACContext)\ninit_mc(S::StochACSolver)\ninit_element(S::StochACSolver, rng::AbstractRNG, allow::Vector{I64})\ninit_iodata(S::StochACSolver, rd::RawData)\ncalc_fmesh(S::StochACSolver)\ncalc_phi\ncalc_delta\ncalc_hamil\ncalc_htau\ncalc_alpha\nconstraints(S::StochACSolver, fmesh::AbstractMesh)\ntry_move_a(i::I64, MC::StochACMC, SE::StochACElement, SC::StochACContext)\ntry_move_p(i::I64, MC::StochACMC, SE::StochACElement, SC::StochACContext)\ntry_move_x(MC::StochACMC, SE::StochACElement, SC::StochACContext)","category":"page"},{"location":"library/solver.html#ACFlow.solve-Tuple{StochACSolver, RawData}","page":"Solvers","title":"ACFlow.solve","text":"solve(S::StochACSolver, rd::RawData)\n\nSolve the analytical continuation problem by the stochastic analytical continuation algorithm (K. S. D. Beach's version).\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init-Tuple{StochACSolver, RawData}","page":"Solvers","title":"ACFlow.init","text":"init(S::StochACSolver, rd::RawData)\n\nInitialize the StochAC solver and return the StochACMC, StochACElement, and StochACContext structs.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.run-Tuple{StochACMC, StochACElement, StochACContext}","page":"Solvers","title":"ACFlow.run","text":"run(MC::StochACMC, SE::StochACElement, SC::StochACContext)\n\nPerform stochastic analytical continuation simulation, sequential version.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.prun-Tuple{StochACSolver, Dict{String, Vector{Any}}, Dict{String, Vector{Any}}, StochACMC, StochACElement, StochACContext}","page":"Solvers","title":"ACFlow.prun","text":"prun(S::StochACSolver,\n     p1::Dict{String,Vector{Any}},\n     p2::Dict{String,Vector{Any}},\n     MC::StochACMC, SE::StochACElement, SC::StochACContext)\n\nPerform stochastic analytical continuation simulation, parallel version. The arguments p1 and p2 are copies of PBASE and PStochAC, respectively.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.average-Tuple{Float64, StochACContext}","page":"Solvers","title":"ACFlow.average","text":"average(step::F64, SC::StochACContext)\n\nPostprocess the results generated during the stochastic analytical continuation simulations. It will calculate the spectral functions, and internal energies.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.last-Tuple{StochACContext, Matrix{Float64}, Vector{Float64}}","page":"Solvers","title":"ACFlow.last","text":"last(SC::StochACContext, Aout::Array{F64,2}, Uα::Vector{F64})\n\nIt will process and write the calculated results by the StochAC solver, including effective hamiltonian, final spectral function, reproduced correlator.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.warmup-Tuple{StochACMC, StochACElement, StochACContext}","page":"Solvers","title":"ACFlow.warmup","text":"warmup(MC::StochACMC, SE::StochACElement, SC::StochACContext)\n\nWarmup the Monte Carlo engine to acheieve thermalized equilibrium.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.sample-Tuple{StochACMC, StochACElement, StochACContext}","page":"Solvers","title":"ACFlow.sample","text":"sample(MC::StochACMC, SE::StochACElement, SC::StochACContext)\n\nPerform Monte Carlo sweeps and sample the field configurations.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.measure-Tuple{StochACElement, StochACContext}","page":"Solvers","title":"ACFlow.measure","text":"measure(SE::StochACElement, SC::StochACContext)\n\nMeasure the spectral functions and internal energies.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init_mc-Tuple{StochACSolver}","page":"Solvers","title":"ACFlow.init_mc","text":"init_mc(S::StochACSolver)\n\nTry to create a StochACMC struct.\n\nSee also: StochACMC.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init_element-Tuple{StochACSolver, AbstractRNG, Vector{Int64}}","page":"Solvers","title":"ACFlow.init_element","text":"init_element(S::StochACSolver, rng::AbstractRNG, allow::Vector{I64})\n\nRandomize the configurations for future Monte Carlo sampling. It will return a StochACElement object.\n\nSee also: StochACElement.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init_iodata-Tuple{StochACSolver, RawData}","page":"Solvers","title":"ACFlow.init_iodata","text":"init_iodata(S::StochACSolver, rd::RawData)\n\nPreprocess the input data (rd), then allocate memory for the α-resolved spectral functions.\n\nSee also: RawData.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.calc_fmesh-Tuple{StochACSolver}","page":"Solvers","title":"ACFlow.calc_fmesh","text":"calc_fmesh(S::StochACSolver)\n\nTry to calculate very fine (dense) mesh in [wmin, wmax], which is used internally to build the kernel function. Note that this mesh could be non-uniform. If the file fmesh.inp exists, the code will try to load it to initialize the mesh. Or else the code will try to create a linear mesh automatically.\n\nSee also: LinearMesh, DynamicMesh.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.calc_phi","page":"Solvers","title":"ACFlow.calc_phi","text":"calc_phi(am::AbstractMesh, model::Vector{F64})\n\nTry to calculate ϕ(ω) function. am is the mesh for calculated spectrum, and model means the default model function.\n\nSee also: AbstractMesh, calc_delta.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_delta","page":"Solvers","title":"ACFlow.calc_delta","text":"calc_delta(fmesh::AbstractMesh, ϕ::Vector{F64})\n\nPrecompute the δ functions. fmesh is a very dense mesh in [wmin, wmax] and ϕ is the ϕ function.\n\nSee also: calc_phi.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_hamil","page":"Solvers","title":"ACFlow.calc_hamil","text":"calc_hamil(Γₚ, Γₐ, kernel, Gᵥ, σ¹)\n\nInitialize h(τ) and H(α) using Eq.(35) and Eq.(36), respectively. Γₚ and Γₐ represent n(x), kernel means the kernel function, Gᵥ is the correlator. Note that kernel and Gᵥ have been rotated into singular space. Please see comments in init() for more details.\n\nSee also: calc_htau.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_htau","page":"Solvers","title":"ACFlow.calc_htau","text":"calc_htau(Γₚ, Γₐ, kernel, Gᵥ)\n\nTry to calculate α-dependent h(τ) via Eq.(36). Γₚ and Γₐ represent n(x), kernel means the kernel function, Gᵥ is the correlator. Note that kernel and Gᵥ have been rotated into singular space. Please see comments in init() for more details.\n\nSee also: calc_hamil.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_alpha","page":"Solvers","title":"ACFlow.calc_alpha","text":"calc_alpha()\n\nGenerate a list for the α parameters\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.constraints-Tuple{StochACSolver, AbstractMesh}","page":"Solvers","title":"ACFlow.constraints","text":"constraints(S::StochACSolver, fmesh::AbstractMesh)\n\nTry to implement the constrained stochastic analytical continuation method. This function will return a collection. It contains all the allowable indices. Be careful, the constrained stochastic analytical continuation method is compatible with the self-adaptive mesh.\n\nSee also: StochACSolver.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.try_move_a-Tuple{Int64, StochACMC, StochACElement, StochACContext}","page":"Solvers","title":"ACFlow.try_move_a","text":"try_move_a(i::I64, MC::StochACMC, SE::StochACElement, SC::StochACContext)\n\nSelect two δ functions randomly and then change their weights. Here i means the index for α parameters.\n\nSee also: try_move_p.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.try_move_p-Tuple{Int64, StochACMC, StochACElement, StochACContext}","page":"Solvers","title":"ACFlow.try_move_p","text":"try_move_p(i::I64, MC::StochACMC, SE::StochACElement, SC::StochACContext)\n\nSelect two δ functions randomly and then change their positions. Here i means the index for α parameters.\n\nSee also: try_move_a.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.try_move_x-Tuple{StochACMC, StochACElement, StochACContext}","page":"Solvers","title":"ACFlow.try_move_x","text":"try_move_x(MC::StochACMC, SE::StochACElement, SC::StochACContext)\n\nTry to exchange field configurations between two adjacent layers.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#StochSK-Solver","page":"Solvers","title":"StochSK Solver","text":"","category":"section"},{"location":"library/solver.html#Structs-3","page":"Solvers","title":"Structs","text":"","category":"section"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"StochSKSolver\nStochSKMC\nStochSKElement\nStochSKContext","category":"page"},{"location":"library/solver.html#ACFlow.StochSKSolver","page":"Solvers","title":"ACFlow.StochSKSolver","text":"StochSKSolver\n\nIt represents the analytical continuation solver that implements the stochastic analytical continuation method (A. W. Sandvik's version).\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#ACFlow.StochSKMC","page":"Solvers","title":"ACFlow.StochSKMC","text":"StochSKMC\n\nMutable struct. It is used within the StochSK solver. It includes random number generator and some counters.\n\nMembers\n\nrng  -> Random number generator.\nSacc -> Counter for single-updated operation (accepted).\nStry -> Counter for single-updated operation (tried).\nPacc -> Counter for pair-updated operation (accepted).\nPtry -> Counter for pair-updated operation (tried).\nQacc -> Counter for quadruple-updated operation (accepted).\nQtry -> Counter for quadruple-updated operation (tried).\n\nSee also: StochSKSolver.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#ACFlow.StochSKElement","page":"Solvers","title":"ACFlow.StochSKElement","text":"StochSKElement\n\nMutable struct. It is used to record the field configurations, which will be sampled by Monte Carlo sweeping procedure.\n\nMembers\n\nP -> It means the positions of the δ functions.\nA -> It means the weights / amplitudes of the δ functions.\nW -> It denotes the window that is used to shift the δ functions.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#ACFlow.StochSKContext","page":"Solvers","title":"ACFlow.StochSKContext","text":"StochSKContext\n\nMutable struct. It is used within the StochSK solver only.\n\nMembers\n\nGᵥ     -> Input data for correlator.\nGᵧ     -> Generated correlator.\nσ¹     -> Actually 1.0 / σ¹.\nallow  -> Allowable indices.\ngrid   -> Grid for input data.\nmesh   -> Mesh for output spectrum.\nkernel -> Default kernel function.\nAout   -> Calculated spectral function.\nχ²     -> Current goodness function.\nχ²min  -> Mininum goodness function.\nχ²vec  -> Vector of goodness function.\nΘ      -> Current Θ parameter.\nΘvec   -> Vector of Θ parameter.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#Functions-3","page":"Solvers","title":"Functions","text":"","category":"section"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"solve(S::StochSKSolver, rd::RawData)\ninit(S::StochSKSolver, rd::RawData)\nACFlow.run(MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)\nprun(S::StochSKSolver, p1::Dict{String,Vector{Any}}, p2::Dict{String,Vector{Any}}, MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)\naverage(step::F64, SC::StochSKContext)\nACFlow.last(SC::StochSKContext, Asum::Vector{F64}, χ²vec::Vector{F64}, Θvec::Vector{F64})\nwarmup(MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)\nsample(MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)\nmeasure(SE::StochSKElement, SC::StochSKContext)\nACFlow.shuffle(MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)\ninit_mc(S::StochSKSolver)\ninit_element(S::StochSKSolver, rng::AbstractRNG, allow::Vector{I64})\ninit_iodata(S::StochSKSolver, rd::RawData)\ncalc_fmesh(S::StochSKSolver)\ncalc_correlator\ncalc_goodness\ncalc_theta\nconstraints(S::StochSKSolver, fmesh::AbstractMesh)\ntry_move_s(MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)\ntry_move_p(MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)\ntry_move_q(MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)","category":"page"},{"location":"library/solver.html#ACFlow.solve-Tuple{StochSKSolver, RawData}","page":"Solvers","title":"ACFlow.solve","text":"solve(S::StochSKSolver, rd::RawData)\n\nSolve the analytical continuation problem by the stochastic analytical continuation algorithm (A. W. Sandvik's version).\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init-Tuple{StochSKSolver, RawData}","page":"Solvers","title":"ACFlow.init","text":"init(S::StochSKSolver, rd::RawData)\n\nInitialize the StochSK solver and return the StochSKMC, StochSKElement, and StochSKContext structs.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.run-Tuple{StochSKMC, StochSKElement, StochSKContext}","page":"Solvers","title":"ACFlow.run","text":"run(MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)\n\nPerform stochastic analytical continuation simulation, sequential version.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.prun-Tuple{StochSKSolver, Dict{String, Vector{Any}}, Dict{String, Vector{Any}}, StochSKMC, StochSKElement, StochSKContext}","page":"Solvers","title":"ACFlow.prun","text":"prun(S::StochSKSolver,\n     p1::Dict{String,Vector{Any}},\n     p2::Dict{String,Vector{Any}},\n     MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)\n\nPerform stochastic analytical continuation simulation, parallel version. The arguments p1 and p2 are copies of PBASE and PStochSK, respectively.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.average-Tuple{Float64, StochSKContext}","page":"Solvers","title":"ACFlow.average","text":"average(step::F64, SC::StochSKContext)\n\nPostprocess the results generated during the stochastic analytical continuation simulations. It will generate the spectral functions.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.last-Tuple{StochSKContext, Vector{Float64}, Vector{Float64}, Vector{Float64}}","page":"Solvers","title":"ACFlow.last","text":"last(SC::StochSKContext,\n     Asum::Vector{F64},\n     χ²vec::Vector{F64}, Θvec::Vector{F64})\n\nIt will process and write the calculated results by the StochSK solver, including final spectral function and reproduced correlator.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.warmup-Tuple{StochSKMC, StochSKElement, StochSKContext}","page":"Solvers","title":"ACFlow.warmup","text":"warmup(MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)\n\nWarmup the Monte Carlo engine to acheieve thermalized equilibrium. Then it will try to figure out the optimized Θ and the corresponding Monte Carlo field configuration.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.sample-Tuple{StochSKMC, StochSKElement, StochSKContext}","page":"Solvers","title":"ACFlow.sample","text":"sample(MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)\n\nPerform Monte Carlo sweeps and sample the field configurations.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.measure-Tuple{StochSKElement, StochSKContext}","page":"Solvers","title":"ACFlow.measure","text":"measure(SE::StochSKElement, SC::StochSKContext)\n\nMeasure the final spectral functions.\n\nSee also: nearest.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.shuffle-Tuple{StochSKMC, StochSKElement, StochSKContext}","page":"Solvers","title":"ACFlow.shuffle","text":"shuffle(MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)\n\nTry to shuffle the Monte Carlo field configuration via the Metropolis algorithm. Then the window for shifting the δ functions is adjusted.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init_mc-Tuple{StochSKSolver}","page":"Solvers","title":"ACFlow.init_mc","text":"init_mc(S::StochSKSolver)\n\nTry to create a StochSKMC struct.\n\nSee also: StochSKMC.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init_element-Tuple{StochSKSolver, AbstractRNG, Vector{Int64}}","page":"Solvers","title":"ACFlow.init_element","text":"init_element(S::StochSKSolver, rng::AbstractRNG, allow::Vector{I64})\n\nRandomize the configurations for future Monte Carlo sampling. It will return a StochSKElement object.\n\nSee also: StochSKElement.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init_iodata-Tuple{StochSKSolver, RawData}","page":"Solvers","title":"ACFlow.init_iodata","text":"init_iodata(S::StochSKSolver, rd::RawData)\n\nPreprocess the input data (rd), then allocate memory for the calculated spectral functions.\n\nSee also: RawData.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.calc_fmesh-Tuple{StochSKSolver}","page":"Solvers","title":"ACFlow.calc_fmesh","text":"calc_fmesh(S::StochSKSolver)\n\nTry to calculate very fine (dense) linear mesh in [wmin, wmax], which is used internally to build the kernel function. Note that the stochastic analytical continuation method (A. W. Sandvik's version) does not support the self-adaptive mesh.\n\nSee also: LinearMesh, DynamicMesh.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.calc_correlator","page":"Solvers","title":"ACFlow.calc_correlator","text":"calc_correlator(SE::StochSKElement, kernel::Array{F64,2})\n\nTry to calculate correlator with the kernel function and the Monte Carlo field configuration. This correlator will then be used to evaluate the goodness function.\n\nSee also: calc_goodness.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_goodness","page":"Solvers","title":"ACFlow.calc_goodness","text":"calc_goodness(Gₙ::Vector{F64}, Gᵥ::Vector{F64})\n\nTry to calculate the goodness function (i.e, χ²), which measures the distance between input and regenerated correlators.\n\nSee also: calc_correlator.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_theta","page":"Solvers","title":"ACFlow.calc_theta","text":"calc_theta(len::I64, SC::StochSKContext)\n\nTry to locate the optimal Θ and χ². This function implements the chi2min and chi2kink algorithms. Note that the chi2min algorithm is preferred.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.constraints-Tuple{StochSKSolver, AbstractMesh}","page":"Solvers","title":"ACFlow.constraints","text":"constraints(S::StochSKSolver, fmesh::AbstractMesh)\n\nTry to implement the constrained stochastic analytical continuation method. This function will return a collection. It contains all the allowable indices. Be careful, fmesh should be a fine linear mesh.\n\nSee also: StochSKSolver.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.try_move_s-Tuple{StochSKMC, StochSKElement, StochSKContext}","page":"Solvers","title":"ACFlow.try_move_s","text":"try_move_s(MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)\n\nTry to update the Monte Carlo field configurations via the Metropolis algorithm. In each update, only single δ function is shifted.\n\nSee also: try_move_p.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.try_move_p-Tuple{StochSKMC, StochSKElement, StochSKContext}","page":"Solvers","title":"ACFlow.try_move_p","text":"try_move_p(MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)\n\nTry to update the Monte Carlo field configurations via the Metropolis algorithm. In each update, only a pair of δ functions are shifted.\n\nSee also: try_move_s.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.try_move_q-Tuple{StochSKMC, StochSKElement, StochSKContext}","page":"Solvers","title":"ACFlow.try_move_q","text":"try_move_q(MC::StochSKMC, SE::StochSKElement, SC::StochSKContext)\n\nTry to update the Monte Carlo field configurations via the Metropolis algorithm. In each update, four different δ functions are shifted.\n\nSee also: try_move_s.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#StochOM-Solver","page":"Solvers","title":"StochOM Solver","text":"","category":"section"},{"location":"library/solver.html#Structs-4","page":"Solvers","title":"Structs","text":"","category":"section"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"StochOMSolver\nStochOMMC\nBox\nStochOMElement\nStochOMContext","category":"page"},{"location":"library/solver.html#ACFlow.StochOMSolver","page":"Solvers","title":"ACFlow.StochOMSolver","text":"StochOMSolver\n\nIt represents the analytical continuation solver that implements the stochastic optimization method.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#ACFlow.StochOMMC","page":"Solvers","title":"ACFlow.StochOMMC","text":"StochOMMC\n\nMutable struct. It is used within the StochOM solver. It includes random number generator and some counters.\n\nMembers\n\nrng  -> Random number generator.\nMacc -> Counter for move operation (accepted).\nMtry -> Counter for move operation (tried).\n\nSee also: StochOMSolver.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#ACFlow.Box","page":"Solvers","title":"ACFlow.Box","text":"Box\n\nRectangle. The field configuration consists of many boxes. They exhibit various areas (width × height). We use the Metropolis important sampling algorithm to sample them and evaluate their contributions to the spectrum.\n\nMembers\n\nh -> Height of the box.\nw -> Width of the box.\nc -> Position of the box.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#ACFlow.StochOMElement","page":"Solvers","title":"ACFlow.StochOMElement","text":"StochOMElement\n\nMutable struct. It is used to record the field configurations, which will be sampled by Monte Carlo sweeping procedure.\n\nMembers\n\nC -> Field configuration.\nΛ -> Contributions of the field configuration to the correlator.\nG -> Reproduced correlator.\nΔ -> Difference between reproduced and raw correlators.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#ACFlow.StochOMContext","page":"Solvers","title":"ACFlow.StochOMContext","text":"StochOMContext\n\nMutable struct. It is used within the StochOM solver only.\n\nMembers\n\nGᵥ    -> Input data for correlator.\nσ¹    -> Actually 1.0 / σ¹.\ngrid  -> Grid for input data.\nmesh  -> Mesh for output spectrum.\nCᵥ    -> It is used to record the field configurations for all attempts.\nΔᵥ    -> It is used to record the errors for all attempts.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#Functions-4","page":"Solvers","title":"Functions","text":"","category":"section"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"solve(S::StochOMSolver, rd::RawData)\ninit(S::StochOMSolver, rd::RawData)\nACFlow.run(MC::StochOMMC, SC::StochOMContext)\nprun(S::StochOMSolver, p1::Dict{String,Vector{Any}}, p2::Dict{String,Vector{Any}}, MC::StochOMMC, SC::StochOMContext)\naverage(SC::StochOMContext)\nACFlow.last(SC::StochOMContext, Aout::Vector{F64})\nupdate(MC::StochOMMC, SE::StochOMElement, SC::StochOMContext)\ninit_mc(S::StochOMSolver)\ninit_element(MC::StochOMMC, SC::StochOMContext)\ninit_iodata(S::StochOMSolver, rd::RawData)\ninit_context(S::StochOMSolver)\ncalc_lambda\ncalc_error\ncalc_green(Λ::Array{F64,2}, nk::I64)\ncalc_norm\nconstraints(e₁::F64, e₂::F64)\ntry_insert\ntry_remove\ntry_shift\ntry_width\ntry_height\ntry_split\ntry_merge\nPdx","category":"page"},{"location":"library/solver.html#ACFlow.solve-Tuple{StochOMSolver, RawData}","page":"Solvers","title":"ACFlow.solve","text":"solve(S::StochOMSolver, rd::RawData)\n\nSolve the analytical continuation problem by the stochastic optimization method.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init-Tuple{StochOMSolver, RawData}","page":"Solvers","title":"ACFlow.init","text":"init(S::StochOMSolver, rd::RawData)\n\nInitialize the StochOM solver and return the StochOMMC and StochOMContext structs.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.run-Tuple{StochOMMC, StochOMContext}","page":"Solvers","title":"ACFlow.run","text":"run(MC::StochOMMC, SC::StochOMContext)\n\nPerform stochastic optimization simulation, sequential version.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.prun-Tuple{StochOMSolver, Dict{String, Vector{Any}}, Dict{String, Vector{Any}}, StochOMMC, StochOMContext}","page":"Solvers","title":"ACFlow.prun","text":"prun(S::StochOMSolver,\n     p1::Dict{String,Vector{Any}},\n     p2::Dict{String,Vector{Any}},\n     MC::StochOMMC, SC::StochOMContext)\n\nPerform stochastic optimization simulation, parallel version. The arguments p1 and p2 are copies of PBASE and PStochOM, respectively.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.average-Tuple{StochOMContext}","page":"Solvers","title":"ACFlow.average","text":"average(SC::StochOMContext)\n\nPostprocess the collected results after the stochastic optimization simulations. It will generate the spectral functions.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.last-Tuple{StochOMContext, Vector{Float64}}","page":"Solvers","title":"ACFlow.last","text":"last(SC::StochOMContext, Aout::Vector{F64})\n\nIt will process and write the calculated results by the StochOM solver, including final spectral function and reproduced correlator.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.update-Tuple{StochOMMC, StochOMElement, StochOMContext}","page":"Solvers","title":"ACFlow.update","text":"update(MC::StochOMMC, SE::StochOMElement, SC::StochOMContext)\n\nUsing the Metropolis algorithm to update the field configuration, i.e, a collection of hundreds of boxes.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init_mc-Tuple{StochOMSolver}","page":"Solvers","title":"ACFlow.init_mc","text":"init_mc(S::StochOMSolver)\n\nTry to create a StochOMMC struct.\n\nSee also: StochOMMC.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init_element-Tuple{StochOMMC, StochOMContext}","page":"Solvers","title":"ACFlow.init_element","text":"init_element(MC::StochOMMC, SC::StochOMContext)\n\nTry to initialize a StochOMElement struct.\n\nSee also: StochOMElement.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init_iodata-Tuple{StochOMSolver, RawData}","page":"Solvers","title":"ACFlow.init_iodata","text":"init_iodata(S::StochOMSolver, rd::RawData)\n\nPreprocess the input data (rd).\n\nSee also: RawData, GreenData.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init_context-Tuple{StochOMSolver}","page":"Solvers","title":"ACFlow.init_context","text":"init_context(S::StochOMSolver)\n\nTry to initialize the key members of a StochOMContext struct.\n\nSee also: StochOMContext.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.calc_lambda","page":"Solvers","title":"ACFlow.calc_lambda","text":"calc_lambda(r::Box, grid::FermionicMatsubaraGrid)\n\nTry to calculate the contribution of a given box r to the Λ function. This function works for FermionicMatsubaraGrid only.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\ncalc_lambda(r::Box, grid::FermionicImaginaryTimeGrid)\n\nTry to calculate the contribution of a given box r to the Λ function. This function works for FermionicImaginaryTimeGrid only.\n\nSee also: FermionicImaginaryTimeGrid.\n\n\n\n\n\ncalc_lambda(r::Box, grid::BosonicMatsubaraGrid)\n\nTry to calculate the contribution of a given box r to the Λ function. This function works for BosonicMatsubaraGrid only.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\ncalc_lambda(r::Box, grid::BosonicImaginaryTimeGrid)\n\nTry to calculate the contribution of a given box r to the Λ function. This function works for BosonicImaginaryTimeGrid only.\n\nSee also: BosonicImaginaryTimeGrid.\n\n\n\n\n\ncalc_lambda(grid::AbstractGrid, fmesh::AbstractMesh)\n\nPrecompute the kernel matrix Λ (Λ ≡ 1 / (iωₙ - ϵ)). It is for the fermionic systems.\n\n\n\n\n\ncalc_lambda(grid::AbstractGrid,\n            fmesh::AbstractMesh,\n            χ₀::F64,\n            bsymm::Bool)\n\nPrecompute the kernel matrix Λ. Here, χ₀ is actually -G(iωₙ = 0). And the argument bsymm is used to distinguish two different bosonic kernels. If bsymm is false, it means that the kernel is boson. If bsymm is true, the kernel is bsymm. This function is for the bosonic systems.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_error","page":"Solvers","title":"ACFlow.calc_error","text":"calc_error(G::Vector{F64}, Gᵥ::Vector{F64}, σ¹::Vector{F64})\n\nTry to calculate χ². Here Gᵥ and σ¹ denote the raw correlator and related standard deviation. G means the reproduced correlator.\n\nSee also: calc_green.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.calc_green-Tuple{Matrix{Float64}, Int64}","page":"Solvers","title":"ACFlow.calc_green","text":"calc_green(Λ::Array{F64,2}, nk::I64)\n\nTry to reconstruct the correlator via the field configuration.\n\nSee also: calc_error.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.calc_norm","page":"Solvers","title":"ACFlow.calc_norm","text":"calc_norm(C::Vector{Box})\n\nCalculate the total area of all boxes.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.constraints-Tuple{Float64, Float64}","page":"Solvers","title":"ACFlow.constraints","text":"constraints(e₁::F64, e₂::F64)\n\nThis function is used to judege whether a given box overlapes with the forbidden zone. Here e₁ and e₂ denote the left and right boundaries of the box.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.try_insert","page":"Solvers","title":"ACFlow.try_insert","text":"try_insert(MC::StochOMMC,\n           SE::StochOMElement,\n           SC::StochOMContext,\n           dacc::F64)\n\nInsert a new box into the field configuration.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.try_remove","page":"Solvers","title":"ACFlow.try_remove","text":"try_remove(MC::StochOMMC,\n           SE::StochOMElement,\n           SC::StochOMContext,\n           dacc::F64)\n\nRemove an old box from the field configuration.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.try_shift","page":"Solvers","title":"ACFlow.try_shift","text":"try_shift(MC::StochOMMC,\n          SE::StochOMElement,\n          SC::StochOMContext,\n          dacc::F64)\n\nChange the position of given box in the field configuration.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.try_width","page":"Solvers","title":"ACFlow.try_width","text":"try_width(MC::StochOMMC,\n          SE::StochOMElement,\n          SC::StochOMContext,\n          dacc::F64)\n\nChange the width and height of given box in the field configuration. Note that the box's area is kept.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.try_height","page":"Solvers","title":"ACFlow.try_height","text":"try_height(MC::StochOMMC,\n           SE::StochOMElement,\n           SC::StochOMContext,\n           dacc::F64)\n\nChange the heights of two given boxes in the field configuration.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.try_split","page":"Solvers","title":"ACFlow.try_split","text":"try_split(MC::StochOMMC,\n          SE::StochOMElement,\n          SC::StochOMContext,\n          dacc::F64)\n\nSplit a given box into two boxes in the field configuration.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.try_merge","page":"Solvers","title":"ACFlow.try_merge","text":"try_merge(MC::StochOMMC,\n          SE::StochOMElement,\n          SC::StochOMContext,\n          dacc::F64)\n\nMerge two given boxes into one box in the field configuration.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#ACFlow.Pdx","page":"Solvers","title":"ACFlow.Pdx","text":"Pdx(xmin::F64, xmax::F64, rng::AbstractRNG)\n\nTry to calculate the probability density function.\n\n\n\n\n\n","category":"function"},{"location":"library/solver.html#StochPX-Solver","page":"Solvers","title":"StochPX Solver","text":"","category":"section"},{"location":"library/solver.html#Structs-5","page":"Solvers","title":"Structs","text":"","category":"section"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"StochPXSolver\nStochPXMC\nStochPXElement\nStochPXContext","category":"page"},{"location":"library/solver.html#ACFlow.StochPXSolver","page":"Solvers","title":"ACFlow.StochPXSolver","text":"StochPXSolver\n\nIt represents the analytical continuation solver that implements the stochastic pole expansion.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#ACFlow.StochPXMC","page":"Solvers","title":"ACFlow.StochPXMC","text":"StochPXMC\n\nMutable struct. It is used within the StochPX solver. It includes random number generator and some counters.\n\nMembers\n\nrng  -> Random number generator.\nSacc -> Counter for position-updated (type 1) operation (accepted).\nStry -> Counter for position-updated (type 1) operation (tried).\nPacc -> Counter for position-updated (type 2) operation (accepted).\nPtry -> Counter for position-updated (type 2) operation (tried).\nAacc -> Counter for amplitude-updated operation (accepted).\nAtry -> Counter for amplitude-updated operation (tried).\nXacc -> Counter for exchange operation (accepted).\nXtry -> Counter for exchange operation (tried).\n\nSee also: StochPXSolver.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#ACFlow.StochPXElement","page":"Solvers","title":"ACFlow.StochPXElement","text":"StochPXElement\n\nMutable struct. It is used to record the field configurations, which will be sampled by Monte Carlo sweeping procedure.\n\nMembers\n\nP -> It means the positions of the poles.\nA -> It means the weights / amplitudes of the poles.\n𝕊 -> It means the signs of the poles.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#ACFlow.StochPXContext","page":"Solvers","title":"ACFlow.StochPXContext","text":"StochPXContext\n\nMutable struct. It is used within the StochPX solver only.\n\nMembers\n\nGᵥ     -> Input data for correlator.\nGᵧ     -> Generated correlator.\nσ¹     -> Actually 1.0 / σ¹.\nallow  -> Allowable indices.\ngrid   -> Grid for input data.\nmesh   -> Mesh for output spectrum.\nfmesh  -> Very dense mesh for the poles.\nΛ      -> Precomputed kernel matrix.\nΘ      -> Artificial inverse temperature.\nχ²min  -> Minimum of χ²min.\nχ²     -> Vector of goodness function.\nPᵥ     -> Vector of poles' positions.\nAᵥ     -> Vector of poles' amplitudes.\n𝕊ᵥ     -> Vector of poles' signs.\n\n\n\n\n\n","category":"type"},{"location":"library/solver.html#Functions-5","page":"Solvers","title":"Functions","text":"","category":"section"},{"location":"library/solver.html","page":"Solvers","title":"Solvers","text":"solve(S::StochPXSolver, rd::RawData)\ninit(S::StochPXSolver, rd::RawData)\nACFlow.run(MC::StochPXMC, SE::StochPXElement, SC::StochPXContext)\nprun(S::StochPXSolver, p1::Dict{String,Vector{Any}}, p2::Dict{String,Vector{Any}}, MC::StochPXMC, SE::StochPXElement, SC::StochPXContext)\naverage(SC::StochPXContext)\nACFlow.last(SC::StochPXContext, Aout::Vector{F64}, Gout::Vector{C64}, Gᵣ::Vector{F64})\nsample(t::I64, MC::StochPXMC, SE::StochPXElement, SC::StochPXContext)\nmeasure(t::I64, SE::StochPXElement, SC::StochPXContext)\ninit_mc(S::StochPXSolver)\ninit_element(S::StochPXSolver, rng::AbstractRNG, allow::Vector{I64})\ninit_iodata(S::StochPXSolver, rd::RawData)\ninit_context(S::StochPXSolver)\nreset_mc(MC::StochPXMC)\nreset_element(rng::AbstractRNG, allow::Vector{I64}, SE::StochPXElement)\nreset_context(t::I64, SE::StochPXElement, SC::StochPXContext)\ncalc_fmesh(S::StochPXSolver)\ncalc_lambda(grid::AbstractGrid, fmesh::AbstractMesh)\ncalc_lambda(grid::AbstractGrid, fmesh::AbstractMesh, χ₀::F64, bsymm::Bool)\ncalc_green(P::Vector{I64}, A::Vector{F64}, 𝕊::Vector{F64}, Λ::Array{F64,2})\ncalc_green(P::Vector{I64}, A::Vector{F64}, 𝕊::Vector{F64}, mesh::AbstractMesh, fmesh::AbstractMesh)\ncalc_green(P::Vector{I64}, A::Vector{F64}, 𝕊::Vector{F64}, mesh::AbstractMesh, fmesh::AbstractMesh, χ₀::F64, bsymm::Bool)\ncalc_chi2(Gₙ::Vector{F64}, Gᵥ::Vector{F64})\nconstraints(S::StochPXSolver, fmesh::AbstractMesh)\ntry_move_s(t::I64, MC::StochPXMC, SE::StochPXElement, SC::StochPXContext)\ntry_move_p(t::I64, MC::StochPXMC, SE::StochPXElement, SC::StochPXContext)\ntry_move_a(t::I64, MC::StochPXMC, SE::StochPXElement, SC::StochPXContext)\ntry_move_x(t::I64, MC::StochPXMC, SE::StochPXElement, SC::StochPXContext)","category":"page"},{"location":"library/solver.html#ACFlow.solve-Tuple{StochPXSolver, RawData}","page":"Solvers","title":"ACFlow.solve","text":"solve(S::StochPXSolver, rd::RawData)\n\nSolve the analytical continuation problem by the stochastic pole expansion. Note that this solver is still experimental.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init-Tuple{StochPXSolver, RawData}","page":"Solvers","title":"ACFlow.init","text":"init(S::StochPXSolver, rd::RawData)\n\nInitialize the StochPX solver and return the StochPXMC, StochPXElement, and StochPXContext structs.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.run-Tuple{StochPXMC, StochPXElement, StochPXContext}","page":"Solvers","title":"ACFlow.run","text":"run(MC::StochPXMC, SE::StochPXElement, SC::StochPXContext)\n\nPerform stochastic pole expansion simulation, sequential version.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.prun-Tuple{StochPXSolver, Dict{String, Vector{Any}}, Dict{String, Vector{Any}}, StochPXMC, StochPXElement, StochPXContext}","page":"Solvers","title":"ACFlow.prun","text":"prun(S::StochPXSolver,\n     p1::Dict{String,Vector{Any}},\n     p2::Dict{String,Vector{Any}},\n     MC::StochPXMC, SE::StochPXElement, SC::StochPXContext)\n\nPerform stochastic pole expansion simulation, parallel version. The arguments p1 and p2 are copies of PBASE and PStochPX, respectively.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.average-Tuple{StochPXContext}","page":"Solvers","title":"ACFlow.average","text":"average(SC::StochPXContext)\n\nPostprocess the results generated during the stochastic pole expansion simulations. It will generate the spectral functions, real frequency green's function, and imaginary frequency green's function.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.last-Tuple{StochPXContext, Vector{Float64}, Vector{ComplexF64}, Vector{Float64}}","page":"Solvers","title":"ACFlow.last","text":"last(SC::StochPXContext,\n     Aout::Vector{F64},\n     Gout::Vector{C64},\n     Gᵣ::Vector{F64})\n\nIt will write the calculated results by the StochPX solver, including final spectral function and reproduced correlator.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.sample-Tuple{Int64, StochPXMC, StochPXElement, StochPXContext}","page":"Solvers","title":"ACFlow.sample","text":"sample(t::I64, MC::StochPXMC, SE::StochPXElement, SC::StochPXContext)\n\nTry to search the configuration space to locate the minimum by using the simulated annealing algorithm. Here, t means the t-th attempt.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.measure-Tuple{Int64, StochPXElement, StochPXContext}","page":"Solvers","title":"ACFlow.measure","text":"measure(t::I64, SE::StochPXElement, SC::StochPXContext)\n\nStore Monte Carlo field configurations (positions, amplitudes, and signs of many poles) for the t-th attempt.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init_mc-Tuple{StochPXSolver}","page":"Solvers","title":"ACFlow.init_mc","text":"init_mc(S::StochPXSolver)\n\nTry to create a StochPXMC struct.\n\nSee also: StochPXMC.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init_element-Tuple{StochPXSolver, AbstractRNG, Vector{Int64}}","page":"Solvers","title":"ACFlow.init_element","text":"init_element(S::StochPXSolver, rng::AbstractRNG, allow::Vector{I64})\n\nRandomize the configurations for future Monte Carlo sampling. It will return a StochPXElement object.\n\nSee also: StochPXElement.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init_iodata-Tuple{StochPXSolver, RawData}","page":"Solvers","title":"ACFlow.init_iodata","text":"init_iodata(S::StochPXSolver, rd::RawData)\n\nPreprocess the input data (rd).\n\nSee also: RawData.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.init_context-Tuple{StochPXSolver}","page":"Solvers","title":"ACFlow.init_context","text":"init_context(S::StochPXSolver)\n\nTry to initialize the key members of a StochPXContext struct.\n\nSee also: StochPXContext.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.reset_mc-Tuple{StochPXMC}","page":"Solvers","title":"ACFlow.reset_mc","text":"reset_mc(MC::StochPXMC)\n\nReset the counters in StochPXMC struct.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.reset_element-Tuple{AbstractRNG, Vector{Int64}, StochPXElement}","page":"Solvers","title":"ACFlow.reset_element","text":"reset_element(rng::AbstractRNG, allow::Vector{I64}, SE::StochPXElement)\n\nReset the Monte Carlo field configurations (i.e. positions and amplitudes of the poles). Note that the signs of the poles should not be changed.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.reset_context-Tuple{Int64, StochPXElement, StochPXContext}","page":"Solvers","title":"ACFlow.reset_context","text":"reset_context(t::I64, SE::StochPXElement, SC::StochPXContext)\n\nRecalculate imaginary frequency green's function and goodness-of-fit function by new Monte Carlo field configurations for the t-th attempts.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.calc_fmesh-Tuple{StochPXSolver}","page":"Solvers","title":"ACFlow.calc_fmesh","text":"calc_fmesh(S::StochPXSolver)\n\nTry to calculate very fine (dense) mesh in [wmin, wmax], which is used internally to represent the possible positions of poles. Note that this mesh could be non-uniform. If the file fmesh.inp exists, the code will try to load it to initialize the mesh. Or else the code will generate a linear mesh automatically.\n\nSee also: LinearMesh, DynamicMesh.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.calc_lambda-Tuple{AbstractGrid, AbstractMesh}","page":"Solvers","title":"ACFlow.calc_lambda","text":"calc_lambda(grid::AbstractGrid, fmesh::AbstractMesh)\n\nPrecompute the kernel matrix Λ (Λ ≡ 1 / (iωₙ - ϵ)). It is for the fermionic systems.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.calc_lambda-Tuple{AbstractGrid, AbstractMesh, Float64, Bool}","page":"Solvers","title":"ACFlow.calc_lambda","text":"calc_lambda(grid::AbstractGrid,\n            fmesh::AbstractMesh,\n            χ₀::F64,\n            bsymm::Bool)\n\nPrecompute the kernel matrix Λ. Here, χ₀ is actually -G(iωₙ = 0). And the argument bsymm is used to distinguish two different bosonic kernels. If bsymm is false, it means that the kernel is boson. If bsymm is true, the kernel is bsymm. This function is for the bosonic systems.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.calc_green-Tuple{Vector{Int64}, Vector{Float64}, Vector{Float64}, Matrix{Float64}}","page":"Solvers","title":"ACFlow.calc_green","text":"calc_green(P::Vector{I64},\n           A::Vector{F64},\n           𝕊::Vector{F64},\n           Λ::Array{F64,2})\n\nReconstruct green's function at imaginary axis by the pole expansion.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.calc_green-Tuple{Vector{Int64}, Vector{Float64}, Vector{Float64}, AbstractMesh, AbstractMesh}","page":"Solvers","title":"ACFlow.calc_green","text":"calc_green(P::Vector{I64},\n           A::Vector{F64},\n           𝕊::Vector{F64},\n           mesh::AbstractMesh,\n           fmesh::AbstractMesh)\n\nReconstruct green's function at real axis by the pole expansion. It is for the fermionic systems only.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.calc_green-Tuple{Vector{Int64}, Vector{Float64}, Vector{Float64}, AbstractMesh, AbstractMesh, Float64, Bool}","page":"Solvers","title":"ACFlow.calc_green","text":"calc_green(P::Vector{I64},\n           A::Vector{F64},\n           𝕊::Vector{F64},\n           mesh::AbstractMesh,\n           fmesh::AbstractMesh, χ₀::F64, bsymm::Bool)\n\nReconstruct green's function at real axis by the pole expansion. Here, χ₀ is actually -G(iωₙ = 0). And the argument bsymm is used to distinguish two different bosonic kernels. If bsymm is false, it means that the kernel is boson. If bsymm is true, the kernel is bsymm. It is for the bosonic systems only.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.calc_chi2-Tuple{Vector{Float64}, Vector{Float64}}","page":"Solvers","title":"ACFlow.calc_chi2","text":"calc_chi2(Gₙ::Vector{F64}, Gᵥ::Vector{F64})\n\nTry to calculate the goodness function (i.e, χ²), which measures the distance between input and regenerated correlators.\n\nSee also: calc_green.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.constraints-Tuple{StochPXSolver, AbstractMesh}","page":"Solvers","title":"ACFlow.constraints","text":"constraints(S::StochPXSolver, fmesh::AbstractMesh)\n\nTry to implement the constrained stochastic pole expansion. This function will return a collection. It contains all the allowable indices. Be careful, the constrained stochastic pole expansion method is compatible with the self-adaptive mesh.\n\nSee also: StochPXSolver.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.try_move_s-Tuple{Int64, StochPXMC, StochPXElement, StochPXContext}","page":"Solvers","title":"ACFlow.try_move_s","text":"try_move_s(t::I64, MC::StochPXMC, SE::StochPXElement, SC::StochPXContext)\n\nChange the position of one randomly selected pole.\n\nSee also: try_move_p.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.try_move_p-Tuple{Int64, StochPXMC, StochPXElement, StochPXContext}","page":"Solvers","title":"ACFlow.try_move_p","text":"try_move_p(t::I64, MC::StochPXMC, SE::StochPXElement, SC::StochPXContext)\n\nChange the positions of two randomly selected poles.\n\nSee also: try_move_s.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.try_move_a-Tuple{Int64, StochPXMC, StochPXElement, StochPXContext}","page":"Solvers","title":"ACFlow.try_move_a","text":"try_move_a(t::I64, MC::StochPXMC, SE::StochPXElement, SC::StochPXContext)\n\nChange the amplitudes of two randomly selected poles.\n\nSee also: try_move_x.\n\n\n\n\n\n","category":"method"},{"location":"library/solver.html#ACFlow.try_move_x-Tuple{Int64, StochPXMC, StochPXElement, StochPXContext}","page":"Solvers","title":"ACFlow.try_move_x","text":"try_move_x(t::I64, MC::StochPXMC, SE::StochPXElement, SC::StochPXContext)\n\nExchange the amplitudes of two randomly selected poles.\n\nSee also: try_move_a.\n\n\n\n\n\n","category":"method"},{"location":"man/input.html#Input-Files","page":"Input Files","title":"Input Files","text":"","category":"section"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"The input files for the ACFlow toolkit can be divided into two groups: data files and configuration files.","category":"page"},{"location":"man/input.html#Data-Files","page":"Input Files","title":"Data Files","text":"","category":"section"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"The input data should be store in CSV-like text files. For imaginary time Green's function, the data file should contain three columns. They represent tau, barG(tau), and standard deviation of barG(tau). For fermionic Matsubara Green's function, the data file should contain five columns. They represent omega_n, ReG(iomega_n), ImG(iomega_n), standard deviation of ReG(iomega_n), and standard deviation of ImG(iomega_n). For bosonic correlation function chi(iomega_n), the data file should contain three columns. They represent omega_n, Rechi(iomega_n), and standard deviation of Rechi(iomega_n).","category":"page"},{"location":"man/input.html#Configuration-Files","page":"Input Files","title":"Configuration Files","text":"","category":"section"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"The configuration file adopts the TOML format. It is used to customize the computational parameters. It consists of one or more blocks. Possible blocks (or sections) of the configuration file include [BASE], [MaxEnt], [StochAC], [StochSK], [StochOM], and [StochPX]. The [BASE] block is mandatory, while the other blocks are optional. A schematic configuration file (ac.toml) is listed as follows:","category":"page"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"[BASE]\nfinput = \"giw.data\"\nsolver = \"StochOM\"\n...\n\n[MaxEnt]\nmethod = \"chi2kink\"\n...\n\n[StochAC]\nnfine  = 10000\n...\n\n[StochSK]\nmethod = \"chi2min\"\n...\n\n[StochOM]\nntry   = 100000\n...\n\n[StochPX]\nmethod = \"mean\"\n...","category":"page"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"In the [BASE] block, the analytical continuation problem is defined. The solver used to solve the problem must be assigned. The types of mesh, grid, default model function, and kernel function are also determined. The [MaxEnt], [StochAC], [StochSK], [StochOM], and [StochPX] blocks are used to customize the corresponding analytical continuation solvers further. In Table 1-Table 6, all the possible input parameters for these blocks are collected and summarized. As for detailed explanations of these parameters, please see Parameters.","category":"page"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"Parameter Type Default Description\nfinput string ''green.data'' Filename for input data.\nsolver string ''MaxEnt'' Solver for the analytical continuation problem.\nktype string ''fermi'' Type of kernel function.\nmtype string ''flat'' Type of default model function.\ngrid string ''ffreq'' Grid for input data (imaginary axis).\nmesh string ''linear'' Mesh for output data (real axis).\nngrid integer 10 Number of grid points.\nnmesh integer 501 Number of mesh points.\nwmax float 5.0 Right boundary (maximum value) of mesh.\nwmin float -5.0 Left boundary (minimum value) of mesh.\nbeta float 10.0 Inverse temperature.\noffdiag bool false Treat the off-diagonal part of matrix-valued function?\nfwrite bool N/A Are the analytical continuation results written into files?\npmodel array N/A Additional parameters for customizing the default model.\npmesh array N/A Additional parameters for customizing the mesh.\nexclude array N/A Restriction of energy range of the spectrum.","category":"page"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"Table 1 | Possible parameters for the [BASE] block.","category":"page"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"Parameter Type Default Description\nmethod string ''chi2kink'' How to determine the optimized alpha parameter?\nstype string ''sj'' Type of the entropic factor.\nnalph integer 12 Total number of the used alpha parameters.\nalpha float 1e9 Starting value for the alpha parameter.\nratio float 10.0 Scaling factor for the alpha parameter.\nblur float -1.0 Shall we preblur the kernel and spectrum?","category":"page"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"Table 2 | Possible input parameters for the [MaxEnt] block, which are used to configure the solver based on the maximum entropy method.","category":"page"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"Parameter Type Default Description\nnfine integer 10000 Number of points of a very fine linear mesh.\nngamm integer 512 Number of delta functions.\nnwarm integer 4000 Number of Monte Carlo thermalization steps.\nnstep integer 4000000 Number of Monte Carlo sweeping steps.\nndump integer 40000 Intervals for monitoring Monte Carlo sweeps.\nnalph integer 20 Total number of the used alpha parameters.\nalpha float 1.0 Starting value for the alpha parameter.\nratio float 1.2 Scaling factor for the alpha parameter.","category":"page"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"Table 3 | Possible input parameters for the [StochAC] block, which are used to configure the solver based on the stochastic analytical continuation (Beach's algorithm).","category":"page"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"Parameter Type Default Description\nmethod string ''chi2min'' How to determine the optimized Theta parameter?\nnfine integer 100000 Number of points of a very fine linear mesh.\nngamm integer 1000 Number of delta functions.\nnwarm integer 1000 Number of Monte Carlo thermalization steps.\nnstep integer 20000 Number of Monte Carlo sweeping steps.\nndump integer 200 Intervals for monitoring Monte Carlo sweeps.\nretry integer 10 How often to recalculate the goodness-of-fit function.\ntheta float 1e6 Starting value for the Theta parameter.\nratio float 0.9 Scaling factor for the Theta parameter.","category":"page"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"Table 4 | Possible input parameters for the [StochSK] block, which are used to configure the solver based on the stochastic analytical continuation (Sandvik's algorithm).","category":"page"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"Parameter Type Default Description\nntry integer 2000 Number of attempts to figure out the solution.\nnstep integer 1000 Number of Monte Carlo sweeping steps per try.\nnbox integer 100 Number of rectangles to used construct the spectrum.\nsbox float 0.005 Minimum area of the randomly generated rectangles.\nwbox float 0.02 Minimum width of the randomly generated rectangles.\nnorm float -1.0 Is the norm calculated?","category":"page"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"Table 5 | Possible input parameters for the [StochOM] block, which are used to configure the solver based on the stochastic optimization method.","category":"page"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"Parameter Type Default Description\nmethod string ''mean'' How to evaluate the final spectral density?\nnfine integer 100000 Number of points of a very fine linear mesh.\nnpole integer 200 Number of poles.\nntry integer 1000 Number of attempts to figure out the solution.\nnstep integer 1000000 Number of Monte Carlo sweeping steps per attempt / try.\ntheta float 1e+6 Artificial inverse temperature Theta.\neta float 1e-4 Tiny distance from the real axis eta.","category":"page"},{"location":"man/input.html","page":"Input Files","title":"Input Files","text":"Table 6 | Possible input parameters for the [StochPX] block, which are used to configure the solver based on the stochastic pole expansion.","category":"page"},{"location":"examples/current.html","page":"Current-Current Correlation Function","title":"Current-Current Correlation Function","text":"info: Info\nIn order to demonstrate usefulness of the ACFlow toolkit, four examples are illustrated in this section. These examples cover typical application scenarios of the ACFlow toolkit, including analytical continuations ofMatsubara self-energy function\nMatsubara Green's function\nImaginary time Green's function\nCurrent-current correlation functionwithin the script mode or standard mode. All of the necessary source codes and data files, which can be used to reproduce the results as shown in this section, are placed in the /home/your_home/acflow/test/T* folders.","category":"page"},{"location":"examples/current.html#Current-Current-Correlation-Function","page":"Current-Current Correlation Function","title":"Current-Current Correlation Function","text":"","category":"section"},{"location":"examples/current.html","page":"Current-Current Correlation Function","title":"Current-Current Correlation Function","text":"The former three examples only concern fermionic correlators. How about bosonic correlators? In this example, we will demonstrate how to perform analytical continuation simulation for a typical bosonic correlator, the current-current correlation function Pi(tau), to obtain the optical conductivity sigma(omega). Note that this example is taken from Phys. Rev. B 82, 165125 (2010) directly.","category":"page"},{"location":"examples/current.html","page":"Current-Current Correlation Function","title":"Current-Current Correlation Function","text":"The exact optical conductivity sigma(omega) reads:","category":"page"},{"location":"examples/current.html","page":"Current-Current Correlation Function","title":"Current-Current Correlation Function","text":"sigma(omega) =\nleft\nfracW_11 + (omegaGamma_1)^2 +\nfracW_21 + (omega - epsilon)Gamma_2^2 +\nfracW_21 + (omega + epsilon)Gamma_2^2\nright\nfrac11 + (omegaGamma_3)^6","category":"page"},{"location":"examples/current.html","page":"Current-Current Correlation Function","title":"Current-Current Correlation Function","text":"where W_1 = 03, W_2 = 02, Gamma_1 = 03, Gamma_2 = 12, Gamma_3 = 40, and epsilon = 30. The current-current correlation function Pi(tau) can be evaluated from sigma(omega) by using the following equation:","category":"page"},{"location":"examples/current.html","page":"Current-Current Correlation Function","title":"Current-Current Correlation Function","text":"Pi(tau) = int^infty_-infty K(tauomega) sigma(omega)domega","category":"page"},{"location":"examples/current.html","page":"Current-Current Correlation Function","title":"Current-Current Correlation Function","text":"where the kernel function K(tauomega) is different from the general form. It reads:","category":"page"},{"location":"examples/current.html","page":"Current-Current Correlation Function","title":"Current-Current Correlation Function","text":"K(tauomega) = frac1pi fracomega e^-tauomega1- e^-betaomega","category":"page"},{"location":"examples/current.html","page":"Current-Current Correlation Function","title":"Current-Current Correlation Function","text":"In this case, beta is fixed to be 20.0.","category":"page"},{"location":"examples/current.html","page":"Current-Current Correlation Function","title":"Current-Current Correlation Function","text":"At first, we use the above equations to prepare Pi(tau). The error bar of Pi(tau) is fixed to 1e-4. The calculated Pi(tau) is written in chit.data.","category":"page"},{"location":"examples/current.html","page":"Current-Current Correlation Function","title":"Current-Current Correlation Function","text":"Next, we conduct analytical continuation simulation as usual. The used configuration file is attached as follows. Here, the StochSK solver is adopted, so the solver parameter is ''StochSK'' and the grid parameter is ''btime''. And the Shao-Sandvik algorithm is applied to seek optimal Theta, so the method parameter is ''chi2min''. The users can further increase the values of nfine, ngamm, and nstep parameters to improve computational accuracy.","category":"page"},{"location":"examples/current.html","page":"Current-Current Correlation Function","title":"Current-Current Correlation Function","text":"[BASE]\nfinput = \"chit.data\"\nsolver = \"StochSK\"\nktype  = \"bsymm\"\nmtype  = \"flat\"\ngrid   = \"btime\"\nmesh   = \"linear\"\nngrid  = 501\nnmesh  = 801\nwmax   = 8.0\nwmin   = 0.0\nbeta   = 20.0\noffdiag = false\n\n[StochSK]\nmethod = \"chi2min\"\nnfine = 40000\nngamm = 1000\nnwarm = 1000\nnstep = 20000\nndump = 200\nretry = 10\ntheta = 1e+6\nratio = 0.90","category":"page"},{"location":"examples/current.html","page":"Current-Current Correlation Function","title":"Current-Current Correlation Function","text":"The calculated results are illustrated in Fig.1. From Fig.1(a), it is clear that the main features of optical conductivity are successfully captured by the StochSK solver. Both the sharp Drude peak at omega = 0 and a broad satellite peak around omega = 30 are well reproduced. As is seen in Fig.1(b), the reconstructed tildePi(tau) coincides with the original Pi(tau).","category":"page"},{"location":"examples/current.html","page":"Current-Current Correlation Function","title":"Current-Current Correlation Function","text":"(Image: T_E4.png)","category":"page"},{"location":"examples/current.html","page":"Current-Current Correlation Function","title":"Current-Current Correlation Function","text":"Figure 1 | Analytical continuation of current-current correlation function by using the stochastic analytical continuation (Sandvik's algorithm). (a) Simulated and exact optical conductivities sigma(omega). (b) Simulated and exact current-current correlation functions Pi(tau).","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"info: Info\nIn order to demonstrate usefulness of the ACFlow toolkit, four examples are illustrated in this section. These examples cover typical application scenarios of the ACFlow toolkit, including analytical continuations ofMatsubara self-energy function\nMatsubara Green's function\nImaginary time Green's function\nCurrent-current correlation functionwithin the script mode or standard mode. All of the necessary source codes and data files, which can be used to reproduce the results as shown in this section, are placed in the /home/your_home/acflow/test/T* folders.","category":"page"},{"location":"examples/sigma.html#Matsubara-Self-Energy-Function","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"","category":"section"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"Now let us consider the following single-band Hubbard model on a Bethe lattice at first:","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"H = -t sum_langle ij rangle sigma c^dagger_isigmac_jsigma\n - mu sum_i n_i + U sum_i n_iuparrow n_idownarrow","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"where t is the hopping parameter, mu is the chemical potential, U is the Coulomb interaction, n is the occupation number, sigma denotes the spin, i and j are site indices. This model is solved by using the dynamical mean-field theory (dubbed DMFT) with the hybridization expansion continuous-time quantum Monte Carlo solver (dubbed CT-HYB) as implemented in the iQIST package. The parameters used in the DMFT + CT-HYB calculation are t = 05, U = 20, mu = 10, and beta = 100. Once the DMFT self-consistent calculation is finished, the Matsubara self-energy function Sigma(iomega_n) is obtained. We are going to convert it to real frequency self-energy function Sigma(omega). The data of Matsubara self-energy function Sigma(iomega_n) have been preprocessed and stored in siw.data. This file contains five columns, which are used to record the Matsubara frequency omega_n, ReSigma(iomega_n), ImSigma(iomega_n), error bar of ReSigma(iomega_n), error bar of ImSigma(iomega_n), respectively. Only the first twenty Matsubara frequency points are kept, because the high-frequency data are somewhat noisy.","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"The purpose of this example is to demonstrate usage of the MaxEnt solver and the script mode of the ACFlow toolkit. Next we will explain the key steps in detail. As for the complete Julia script, please refer to sigma.jl and gendata.jl in the /home/your_home/acflow/test/T01/ folder.","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"First, we have to load the essential Julia packages. Both the DelimitedFiles and Printf packages belong to Julia's standard library. They are used to read input data and write calculated results, respectively.","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"#!/usr/bin/env julia\n\npush!(LOAD_PATH, ENV[\"ACFLOW_HOME\"])\n\nusing DelimitedFiles\nusing Printf\nusing ACFlow\n\nwelcome() # Print welcome message only","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"Next, the data of Matsubara self-energy function are read from siw.data. The Hartree term Sigma_H should be subtracted from its real part:","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"Sigma(iomega_n) to Sigma(iomega_n) - Sigma_H","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"Note that Sigma_H is approximately equal to the asymptotic value of real part of Sigma(iomega_n) when n goes to infinite.","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"# Deal with self-energy function\n#\n# Read self-energy function\ndlm = readdlm(\"siw.data\")\n#\n# Get grid\ngrid = dlm[:,1]\n#\n# Get self-energy function\nSinp = dlm[:,2] + im * dlm[:,3] # Value\nSerr = dlm[:,4] + im * dlm[:,5] # Error bar\n#\n# Subtract hartree term\nSh = 1.0\n@. Sinp = Sinp - Sh","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"Next, the computational parameters are encapsulated into two dictionaries. The dict B is for the [BASE] block, while the dict S is for the MaxEnt solver. Then the setup_param() function is called, so that these parameters take effect. Here, the MatEnt solver is employed to tackle the analytical continuation problem. But the other stochastic sampling solvers are also applicable. The default model function is gaussian. The mesh for spectral density is non-uniform (A tangent mesh). The number of used alpha parameters is 15, and the optimal alpha parameter is determined by the chi^2kink algorithm.","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"# Setup parameters\n#\n# For [BASE] block\n# See types.jl/_PBASE for default setup\nB = Dict{String,Any}(\n    \"solver\" => \"MaxEnt\",  # Choose MaxEnt solver\n    \"mtype\"  => \"gauss\",   # Default model function\n    \"mesh\"   => \"tangent\", # Mesh for spectral density\n    \"ngrid\"  => 20,        # Number of input points\n    \"nmesh\"  => 801,       # Number of output points\n    \"wmax\"   => 8.0,       # Right boundary of mesh\n    \"wmin\"   => -8.0,      # Left boundary of mesh\n    \"beta\"   => 10.0,      # Inverse temperature\n)\n#\n# For [MaxEnt] block\n# See types.jl/_PMaxEnt for default setup\nS = Dict{String,Any}(\n    \"nalph\"  => 15,        # Number of alpha\n    \"alpha\"  => 1e12,      # Starting value of alpha\n    \"blur\"   => -1.0,      # Enable preblur or not\n)\n#\n# Let the parameters take effect\nsetup_param(B, S)","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"It is quite easy to start the analytical continuation calculation. Just call the solve() function and pass the grid, input data, and error bar data to it. The return values of this function call are real frequency mesh, spectral density, and reconstructed Matsubara self-energy function.","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"# Call the solver\nmesh, Aout, Sout = solve(grid, Sinp, Serr)","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"Finally, the real frequency self-energy function must be supplemented with the Hartree term. Then the final results are written into sigma.data.","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"# Calculate final self-energy function on real axis\n#\n# Add hartree term\n@. Sout = Sout + Sh\n#\n# Write self-energy function to sigma.data\nopen(\"sigma.data\", \"w\") do fout\n    for i in eachindex(mesh)\n        z = Sout[i]\n        @printf(fout, \"%20.16f %20.16f %20.16f\\n\",\n                mesh[i], real(z), imag(z))\n    end\nend","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"The calculated results are displayed in Fig.1. Fig.1(a) and (b) show the real and imaginary parts of the real frequency self-energy function, respectively. Near the Fermi level, ReSigma(omega) exhibits quasi-linear behavior, with which the quasiparticle weight Z and effective mass of electron m^* can be easily evaluated. As for the imaginary part, ImSigma(0) is finite, which indicates that the electron-electron scattering is not trivial. Fig.1(c) shows the alpha-dependent chi^2. The vertical bar in this figure indicates the optimal alpha is around 10^2154. In Fig.(d), the reproduced and raw self-energy functions are compared. It is apparent that they are consistent with each other.","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"(Image: T_E1.png)","category":"page"},{"location":"examples/sigma.html","page":"Matsubara Self-Energy Function","title":"Matsubara Self-Energy Function","text":"Figure 1 | Analytical continuation of Matsubara self-energy function by using the maximum entropy method. (a) Real part of real frequency self-energy function. (b) Imaginary part of real frequency self-energy function. (c) chi^2 as a function of alpha. The vertical bar indicates the optimal alpha parameter chosen by the chi2kink algorithm. (d) Reproduced and original data for imaginary part of the Matsubara self-energy functions.","category":"page"},{"location":"library/mesh.html#Meshes","page":"Meshes","title":"Meshes","text":"","category":"section"},{"location":"library/mesh.html","page":"Meshes","title":"Meshes","text":"Meshes on real axis.","category":"page"},{"location":"library/mesh.html","page":"Meshes","title":"Meshes","text":"The spectral functions are always defined on real axis. The ACFlow toolkit supports various uniform and non-uniform meshes. In order to build these meshes, we need some additional control parameters, including f_1 and cut. They should be setup by using the parameter pmesh.","category":"page"},{"location":"library/mesh.html#Contents","page":"Meshes","title":"Contents","text":"","category":"section"},{"location":"library/mesh.html","page":"Meshes","title":"Meshes","text":"Pages = [\"mesh.md\"]\nDepth = 2","category":"page"},{"location":"library/mesh.html#Index","page":"Meshes","title":"Index","text":"","category":"section"},{"location":"library/mesh.html","page":"Meshes","title":"Meshes","text":"Pages = [\"mesh.md\"]","category":"page"},{"location":"library/mesh.html#Types","page":"Meshes","title":"Types","text":"","category":"section"},{"location":"library/mesh.html","page":"Meshes","title":"Meshes","text":"AbstractMesh\nLinearMesh\nTangentMesh\nLorentzMesh\nHalfLorentzMesh\nDynamicMesh","category":"page"},{"location":"library/mesh.html#ACFlow.AbstractMesh","page":"Meshes","title":"ACFlow.AbstractMesh","text":"AbstractMesh\n\nAn abstract type representing the real axis. It is used to build the internal type system.\n\n\n\n\n\n","category":"type"},{"location":"library/mesh.html#ACFlow.LinearMesh","page":"Meshes","title":"ACFlow.LinearMesh","text":"LinearMesh\n\nMutable struct. A linear and uniform mesh.\n\nMembers\n\nnmesh  -> Number of mesh points\nwmax   -> Right boundary (maximum value).\nwmin   -> Left boundary (minimum value).\nmesh   -> Mesh itself.\nweight -> Precomputed integration weights (composite trapezoidal rule).\n\nSee also: TangentMesh.\n\n\n\n\n\n","category":"type"},{"location":"library/mesh.html#ACFlow.TangentMesh","page":"Meshes","title":"ACFlow.TangentMesh","text":"TangentMesh\n\nMutable struct. A non-linear and non-uniform mesh. Note that it should be defined on both negative and positive half-axis.\n\nMembers\n\nnmesh  -> Number of mesh points\nwmax   -> Right boundary (maximum value).\nwmin   -> Left boundary (minimum value).\nmesh   -> Mesh itself.\nweight -> Precomputed integration weights (composite trapezoidal rule).\n\nSee also: LinearMesh.\n\n\n\n\n\n","category":"type"},{"location":"library/mesh.html#ACFlow.LorentzMesh","page":"Meshes","title":"ACFlow.LorentzMesh","text":"LorentzMesh\n\nMutable struct. A non-linear and non-uniform mesh. Note that it should be defined on both negative and positive half-axis.\n\nMembers\n\nnmesh  -> Number of mesh points\nwmax   -> Right boundary (maximum value).\nwmin   -> Left boundary (minimum value).\nmesh   -> Mesh itself.\nweight -> Precomputed integration weights (composite trapezoidal rule).\n\nSee also: HalfLorentzMesh.\n\n\n\n\n\n","category":"type"},{"location":"library/mesh.html#ACFlow.HalfLorentzMesh","page":"Meshes","title":"ACFlow.HalfLorentzMesh","text":"HalfLorentzMesh\n\nMutable struct. A non-linear and non-uniform mesh. Note that it should be defined on positive half-axis only.\n\nMembers\n\nnmesh  -> Number of mesh points\nwmax   -> Right boundary (maximum value).\nwmin   -> Left boundary (minimum value). It must be 0.0.\nmesh   -> Mesh itself.\nweight -> Precomputed integration weights (composite trapezoidal rule).\n\nSee also: LorentzMesh.\n\n\n\n\n\n","category":"type"},{"location":"library/mesh.html#ACFlow.DynamicMesh","page":"Meshes","title":"ACFlow.DynamicMesh","text":"DynamicMesh\n\nMutable struct. An internal mesh used in stochastic methods. It supports both uniform and non-uniform meshes. The mesh is usually generated by util/gmesh.jl and loaded dynamically in the initialization step. This mesh should not be used as a regular mesh for the spectrum.\n\nMembers\n\nnmesh  -> Number of mesh points\nwmax   -> Right boundary (maximum value).\nwmin   -> Left boundary (minimum value).\nmesh   -> Mesh itself.\nweight -> Precomputed integration weights (composite trapezoidal rule).\n\nSee also: LinearMesh.\n\n\n\n\n\n","category":"type"},{"location":"library/mesh.html#Constructors","page":"Meshes","title":"Constructors","text":"","category":"section"},{"location":"library/mesh.html","page":"Meshes","title":"Meshes","text":"LinearMesh(nmesh::I64, wmin::F64, wmax::F64)\nTangentMesh(nmesh::I64, wmin::F64, wmax::F64, 𝑝::F64 = 2.1)\nLorentzMesh(nmesh::I64, wmin::F64, wmax::F64, 𝑝::F64 = 0.01)\nHalfLorentzMesh(nmesh::I64, wmax::F64, 𝑝::F64 = 0.01)\nDynamicMesh(mesh::Vector{F64})","category":"page"},{"location":"library/mesh.html#ACFlow.LinearMesh-Tuple{Int64, Float64, Float64}","page":"Meshes","title":"ACFlow.LinearMesh","text":"LinearMesh(nmesh::I64, wmin::F64, wmax::F64)\n\nA constructor for the LinearMesh struct, which is announced in src/types.jl.\n\nSee also: LinearMesh.\n\n\n\n\n\n","category":"method"},{"location":"library/mesh.html#ACFlow.TangentMesh-2","page":"Meshes","title":"ACFlow.TangentMesh","text":"TangentMesh(nmesh::I64, wmin::F64, wmax::F64, 𝑝::F64 = 2.1)\n\nA constructor for the TangentMesh struct, which is announced in src/types.jl.\n\nSee also: TangentMesh.\n\n\n\n\n\n","category":"type"},{"location":"library/mesh.html#ACFlow.LorentzMesh-2","page":"Meshes","title":"ACFlow.LorentzMesh","text":"LorentzMesh(nmesh::I64, wmin::F64, wmax::F64, 𝑝::F64 = 0.01)\n\nA constructor for the LorentzMesh struct, which is announced in src/types.jl. The algorithm for generating a lorentzian mesh is taken from:\n\nhttps://github.com/CQMP/Maxent.\n\nSee also: LorentzMesh.\n\n\n\n\n\n","category":"type"},{"location":"library/mesh.html#ACFlow.HalfLorentzMesh-2","page":"Meshes","title":"ACFlow.HalfLorentzMesh","text":"HalfLorentzMesh(nmesh::I64, wmax::F64, 𝑝::F64 = 0.01)\n\nA constructor for the HalfLorentzMesh struct, which is announced in src/types.jl. The algorithm for generating a half-lorentzian mesh is taken from:\n\nhttps://github.com/CQMP/Maxent.\n\nSee also: HalfLorentzMesh.\n\n\n\n\n\n","category":"type"},{"location":"library/mesh.html#ACFlow.DynamicMesh-Tuple{Vector{Float64}}","page":"Meshes","title":"ACFlow.DynamicMesh","text":"DynamicMesh(mesh::Vector{F64})\n\nA constructor for the DynamicMesh struct, which is announced in src/types.jl. The δ peaks in the stochastic analytical continuation or the poles in the stochastic pole expansion method should be placed in this mesh. This mesh should not be used to define the spectrum.\n\nSee also: DynamicMesh.\n\n\n\n\n\n","category":"method"},{"location":"library/mesh.html#Base.*-Functions","page":"Meshes","title":"Base.* Functions","text":"","category":"section"},{"location":"library/mesh.html","page":"Meshes","title":"Meshes","text":"Base.length(am::AbstractMesh)\nBase.iterate(am::AbstractMesh)\nBase.iterate(am::AbstractMesh, i::I64)\nBase.eachindex(am::AbstractMesh)\nBase.firstindex(am::AbstractMesh)\nBase.lastindex(am::AbstractMesh)\nBase.getindex(am::AbstractMesh, ind::I64)\nBase.getindex(am::AbstractMesh, I::UnitRange{I64})","category":"page"},{"location":"library/mesh.html#Base.length-Tuple{AbstractMesh}","page":"Meshes","title":"Base.length","text":"Base.length(am::AbstractMesh)\n\nReturn number of mesh points in a Mesh-like struct.\n\n\n\n\n\n","category":"method"},{"location":"library/mesh.html#Base.iterate-Tuple{AbstractMesh}","page":"Meshes","title":"Base.iterate","text":"Base.iterate(am::AbstractMesh)\n\nAdvance the iterator of a Mesh-like struct to obtain the next mesh point.\n\n\n\n\n\n","category":"method"},{"location":"library/mesh.html#Base.iterate-Tuple{AbstractMesh, Int64}","page":"Meshes","title":"Base.iterate","text":"Base.iterate(am::AbstractMesh, i::I64)\n\nThis is the key method that allows a Mesh-like struct to be iterated, yielding a sequences of mesh points.\n\n\n\n\n\n","category":"method"},{"location":"library/mesh.html#Base.eachindex-Tuple{AbstractMesh}","page":"Meshes","title":"Base.eachindex","text":"Base.eachindex(am::AbstractMesh)\n\nCreate an iterable object for visiting each index of a Mesh-like struct.\n\n\n\n\n\n","category":"method"},{"location":"library/mesh.html#Base.firstindex-Tuple{AbstractMesh}","page":"Meshes","title":"Base.firstindex","text":"Base.firstindex(am::AbstractMesh)\n\nReturn the first index of a Mesh-like struct.\n\n\n\n\n\n","category":"method"},{"location":"library/mesh.html#Base.lastindex-Tuple{AbstractMesh}","page":"Meshes","title":"Base.lastindex","text":"Base.lastindex(am::AbstractMesh)\n\nReturn the last index of a Mesh-like struct.\n\n\n\n\n\n","category":"method"},{"location":"library/mesh.html#Base.getindex-Tuple{AbstractMesh, Int64}","page":"Meshes","title":"Base.getindex","text":"Base.getindex(am::AbstractMesh, ind::I64)\n\nRetrieve the value(s) stored at the given key or index within a Mesh-like struct.\n\n\n\n\n\n","category":"method"},{"location":"library/mesh.html#Base.getindex-Tuple{AbstractMesh, UnitRange{Int64}}","page":"Meshes","title":"Base.getindex","text":"Base.getindex(am::AbstractMesh, I::UnitRange{I64})\n\nReturn a subset of a Mesh-like struct as specified by I.\n\n\n\n\n\n","category":"method"},{"location":"library/mesh.html#Utilities","page":"Meshes","title":"Utilities","text":"","category":"section"},{"location":"library/mesh.html","page":"Meshes","title":"Meshes","text":"nearest","category":"page"},{"location":"library/mesh.html#ACFlow.nearest","page":"Meshes","title":"ACFlow.nearest","text":"nearest(am::AbstractMesh, r::F64)\n\nGiven a position (0.0 ≤ r ≤ 1.0), and return the index of the nearest point in the mesh am.\n\nExamples\n\nam = LinearMesh(1001, -10.0, 10.0)\npos = nearest(am, 0.2) # pos = 201\nprintln(am[pos]) # -6.0\n\nSee also: AbstractMesh.\n\n\n\n\n\n","category":"function"},{"location":"man/output.html#Output-Files","page":"Output Files","title":"Output Files","text":"","category":"section"},{"location":"man/output.html","page":"Output Files","title":"Output Files","text":"Once the analytical continuation simulation is finished, the final spectral function A(omega) is outputted to Aout.data. Note that A(omega) is equivalent to the imaginary part of real frequency Green's function ImG(omega). Then the ACFlow toolkit will automatically calculate the corresponding real part ReG(omega) via the Kramers-Kronig transformation. The full Green's function at real axis G(omega) is stored in Gout.data. The spectral function is also used to reconstruct the imaginary time or Matsubara Green's functions [tildeG(tau) or tildeG(iomega_n)], which is stored in repr.data. Besides the three output files, the ACFlow toolkit will generate quite a few output files, which can be used to analyze and diagnose the calculated results. All of the possible output files of the ACFlow toolkit are collected and explained in Table 1.","category":"page"},{"location":"man/output.html","page":"Output Files","title":"Output Files","text":"Filename Description\nAout.data Final spectral function A(omega).\nAout.data.alpha_i alpha-resolved spectral function A_alpha(omega) for the StochAC solver.\nrepr.data Reproduced Green's function tildeG at imaginary time or frequency axis.\nGout.data Full Green's function at real axis G(omega).\nchi2.data log_10(chi^2) vs log_10(alpha).\ngoodness.dat log_10(chi^2) vs log_10(Theta) for the StochSK solver.\nmodel.data Default model m(omega).\nhamil.data U(alpha) vs alpha for the StochAC solver.\npassed.data Indices of selected solutions for the StochOM and the StochPX solvers.\npole.data Amplitudes and positions of the poles for the StochPX solver.\nprob.data PalphabarG vs alpha for the MaxEnt solver (bryan algorithm).\nstat.data Monte Carlo statistical information for stochastic sampling methods.","category":"page"},{"location":"man/output.html","page":"Output Files","title":"Output Files","text":"Table 1 | Possible output files of the ACFlow toolkit.","category":"page"},{"location":"man/output.html","page":"Output Files","title":"Output Files","text":"warning: Warning\nFor bosonic systems, the MaxEnt, StochAC, StochSK, and StochOM solvers will generate and output tildeA(omega), instead of traditional A(omega). That is to say, in Aout.data, the data are actually tildeA(omega). If the users want to retrieve A(omega), they have to do the transformation by themselves:tildeA(omega) = fracA(omega)omegaor resort to Gout.data. On the other hand, the StochPX solver will always generate and output A(omega), irrespective of bosonic and fermionic systems.","category":"page"},{"location":"library/type.html#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"library/type.html","page":"Types","title":"Types","text":"Define some fundamental types and structs for the ACFlow toolkit.","category":"page"},{"location":"library/type.html#Contents","page":"Types","title":"Contents","text":"","category":"section"},{"location":"library/type.html","page":"Types","title":"Types","text":"Pages = [\"type.md\"]\nDepth = 2","category":"page"},{"location":"library/type.html#Index","page":"Types","title":"Index","text":"","category":"section"},{"location":"library/type.html","page":"Types","title":"Types","text":"Pages = [\"type.md\"]","category":"page"},{"location":"library/type.html#Data-Types","page":"Types","title":"Data Types","text":"","category":"section"},{"location":"library/type.html","page":"Types","title":"Types","text":"DType\nADT\nAbstractData\nRawData\nGreenData","category":"page"},{"location":"library/type.html#ACFlow.DType","page":"Types","title":"ACFlow.DType","text":"Customized types. It is used to define the following dicts.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#ACFlow.ADT","page":"Types","title":"ACFlow.ADT","text":"Customized types. It is used to define the following dicts.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#ACFlow.AbstractData","page":"Types","title":"ACFlow.AbstractData","text":"AbstractData\n\nAn abstract type representing the input data in imaginary axis. It is used to build the internal type system.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#ACFlow.RawData","page":"Types","title":"ACFlow.RawData","text":"RawData\n\nMutable struct. It represent the raw input data. The datatype of raw data may be float or complex.\n\nMembers\n\n_grid -> Raw grid for the input data, such as τ or iωₙ.\nvalue -> Raw input data, such as G(τ), G(iωₙ), or Σ(iωₙ).\nerror -> Error bar (standard deviation) of raw input data, σ.\n\nSee also: GreenData.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#ACFlow.GreenData","page":"Types","title":"ACFlow.GreenData","text":"GreenData\n\nMutable struct. It represents the preprocessed input data.\n\nMembers\n\nvalue -> Preprocessed input data.\nerror -> Preprocessed error bar.\ncovar -> Diagonal parts of the covariance matrix, σ².\n\nSee also: RawData.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#Dictionaries","page":"Types","title":"Dictionaries","text":"","category":"section"},{"location":"library/type.html","page":"Types","title":"Types","text":"PBASE\nPMaxEnt\nPStochAC\nPStochSK\nPStochOM\nPStochPX","category":"page"},{"location":"library/type.html#ACFlow.PBASE","page":"Types","title":"ACFlow.PBASE","text":"PBASE\n\nDictionary for configuration parameters: general setup.\n\n\n\n\n\n","category":"constant"},{"location":"library/type.html#ACFlow.PMaxEnt","page":"Types","title":"ACFlow.PMaxEnt","text":"PMaxEnt\n\nDictionary for configuration parameters: the maximum entropy method.\n\n\n\n\n\n","category":"constant"},{"location":"library/type.html#ACFlow.PStochAC","page":"Types","title":"ACFlow.PStochAC","text":"PStochAC\n\nDictionary for configuration parameters: the stochastic analytical continuation method (K. S. D. Beach's version).\n\n\n\n\n\n","category":"constant"},{"location":"library/type.html#ACFlow.PStochSK","page":"Types","title":"ACFlow.PStochSK","text":"PStochSK\n\nDictionary for configuration parameters: the stochastic analytical continuation method (A. W. Sandvik's version).\n\n\n\n\n\n","category":"constant"},{"location":"library/type.html#ACFlow.PStochOM","page":"Types","title":"ACFlow.PStochOM","text":"PStochOM\n\nDictionary for configuration parameters: the stochastic optimization method.\n\n\n\n\n\n","category":"constant"},{"location":"library/type.html#ACFlow.PStochPX","page":"Types","title":"ACFlow.PStochPX","text":"PStochPX\n\nDictionary for configuration parameters: the stochastic pole expansion.\n\n\n\n\n\n","category":"constant"},{"location":"index.html#ACFlow","page":"Home","title":"ACFlow","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"A full-fledged analytical continuation toolkit in Julia","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"note: Note\nThank you for using ACFlow. This documentation will help you to be familiar with and explore the ACFlow toolkit.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"warning: Warning\nThe ACFlow toolkit is in heavy development. Please use it at your own risk.","category":"page"},{"location":"index.html#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"intro/background.md\",\n    \"intro/ack.md\",\n    \"intro/cite.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"man/feature.md\",\n    \"man/impl.md\",\n    \"man/install.md\",\n    \"man/run.md\",\n    \"man/input.md\",\n    \"man/output.md\",\n    \"man/param.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"examples/sigma.md\",\n    \"examples/green1.md\",\n    \"examples/green2.md\",\n    \"examples/current.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#Theory","page":"Home","title":"Theory","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"theory/basic.md\",\n    \"theory/maxent.md\",\n    \"theory/sac1.md\",\n    \"theory/sac2.md\",\n    \"theory/som.md\",\n    \"theory/spx.md\",\n    \"theory/reference.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#Library","page":"Home","title":"Library","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"library/outline.md\",\n    \"library/acflow.md\",\n    \"library/global.md\",\n    \"library/types.md\",\n    \"library/base.md\",\n    \"library/solver.md\",\n    \"library/grid.md\",\n    \"library/mesh.md\",\n    \"library/model.md\",\n    \"library/kernel.md\",\n    \"library/config.md\",\n    \"library/inout.md\",\n    \"library/math.md\",\n    \"library/util.md\",\n]\nDepth = 1","category":"page"}]
}

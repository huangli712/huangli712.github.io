<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Stochastic Pole Expansion · ACFlow</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">ACFlow</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><span class="tocitem">Introduction</span><ul><li><a class="tocitem" href="../intro/background.html">Background</a></li><li><a class="tocitem" href="../intro/ack.html">Acknowledgements</a></li><li><a class="tocitem" href="../intro/cite.html">Citation</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../man/feature.html">Main Features</a></li><li><a class="tocitem" href="../man/impl.html">Implementations</a></li><li><a class="tocitem" href="../man/install.html">Installation</a></li><li><a class="tocitem" href="../man/run.html">Running Modes</a></li><li><a class="tocitem" href="../man/input.html">Input Files</a></li><li><a class="tocitem" href="../man/output.html">Output Files</a></li><li><a class="tocitem" href="../man/param.html">Parameters</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/sigma.html">Matsubara Self-Energy Function</a></li><li><a class="tocitem" href="../examples/green1.html">Matsubara Green&#39;s Function</a></li><li><a class="tocitem" href="../examples/green2.html">Imaginary Time Green&#39;s Function</a></li><li><a class="tocitem" href="../examples/current.html">Current-Current Correlation Function</a></li></ul></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="basic.html">Basic Principles</a></li><li><a class="tocitem" href="maxent.html">Maximum Entropy Method</a></li><li><a class="tocitem" href="sac1.html">Stochastic Analytical Continuation 1</a></li><li><a class="tocitem" href="sac2.html">Stochastic Analytical Continuation 2</a></li><li><a class="tocitem" href="som.html">Stochastic Optimization Method</a></li><li class="is-active"><a class="tocitem" href="spx.html">Stochastic Pole Expansion</a><ul class="internal"><li><a class="tocitem" href="#Stochastic-optimization"><span>Stochastic optimization</span></a></li><li><a class="tocitem" href="#Constrained-sampling-algorithm"><span>Constrained sampling algorithm</span></a></li><li><a class="tocitem" href="#Self-adaptive-sampling-algorithm"><span>Self-adaptive sampling algorithm</span></a></li><li><a class="tocitem" href="#Relevant-parameters"><span>Relevant parameters</span></a></li></ul></li><li><a class="tocitem" href="reference.html">References</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../library/outline.html">Outline</a></li><li><a class="tocitem" href="../library/acflow.html">ACFlow</a></li><li><a class="tocitem" href="../library/global.html">Constants</a></li><li><a class="tocitem" href="../library/type.html">Types</a></li><li><a class="tocitem" href="../library/base.html">Core</a></li><li><a class="tocitem" href="../library/solver.html">Solvers</a></li><li><a class="tocitem" href="../library/grid.html">Grids</a></li><li><a class="tocitem" href="../library/mesh.html">Meshes</a></li><li><a class="tocitem" href="../library/model.html">Models</a></li><li><a class="tocitem" href="../library/kernel.html">Kernels</a></li><li><a class="tocitem" href="../library/config.html">Configuration</a></li><li><a class="tocitem" href="../library/inout.html">Input and output</a></li><li><a class="tocitem" href="../library/math.html">Math</a></li><li><a class="tocitem" href="../library/util.html">Utilities</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Theory</a></li><li class="is-active"><a href="spx.html">Stochastic Pole Expansion</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="spx.html">Stochastic Pole Expansion</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/huangli712/ACFlow/blob/master/docs/src/theory/spx.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Stochastic-Pole-Expansion"><a class="docs-heading-anchor" href="#Stochastic-Pole-Expansion">Stochastic Pole Expansion</a><a id="Stochastic-Pole-Expansion-1"></a><a class="docs-heading-anchor-permalink" href="#Stochastic-Pole-Expansion" title="Permalink"></a></h1><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The StochPX solver is experimental. Please use it at your own risk.</p></div></div><h2 id="Stochastic-optimization"><a class="docs-heading-anchor" href="#Stochastic-optimization">Stochastic optimization</a><a id="Stochastic-optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Stochastic-optimization" title="Permalink"></a></h2><p>Supposed that the input Matsubara Green&#39;s function is <span>$\mathcal{G}(i\omega_n)$</span>, where <span>$n =$</span> 1, 2, <span>$\cdots$</span>, <span>$N_{\omega}$</span>, the objective of analytic continuation is to fit the (possibly noisy and incomplete) Matsubara data into the pole representation under some constraints. In mathematical language, we should solve the following multivariate optimization problem:</p><p class="math-container">\[\begin{equation}
\mathop{\arg\min}\limits_{ \left\{A_{\gamma}, P_{\gamma}\right\}^{N_p}_{\gamma = 1} } \chi^{2}\left[\left\{A_{\gamma}, P_{\gamma}\right\}^{N_p}_{\gamma = 1}\right].
\end{equation}\]</p><p>Here, <span>$\chi^{2}\left[\left\{A_{\gamma}, P_{\gamma}\right\}^{N_p}_{\gamma = 1}\right]$</span> is the so-called goodness-of-fit function or loss function. Its definition is as follows:</p><p class="math-container">\[\begin{equation}
\chi^{2}
\left[\left\{A_{\gamma}, P_{\gamma}\right\}^{N_p}_{\gamma = 1}\right] 
= \frac{1}{N_{\omega}}\sum^{N_{\omega}}_{n = 1}
\left|\left|
\mathcal{G}(i\omega_n) - \sum^{N_p}_{\gamma = 1} \frac{A_{\gamma}}{i\omega_n - P_{\gamma}} 
\right|\right|^2_{F},
\end{equation}\]</p><p>where <span>$||\cdot||_{F}$</span> denotes the Frobenius norm. The minimization of Eq.(2) is highly non-convex. Traditional gradient-based optimization methods, such as non-negative least squares method, conjugate gradient method, Newton and quasi-Newton methods, are frequently trapped in local minima. Their optimized results strongly depend on the initial guess. The semi-definite relaxation (SDR) fitting method, adaptive Antoulas-Anderson (AAA) algorithm, and conformal mapping plus Prony&#39;s method, which have been employed to search the locations of poles in previous works, are also tested. But these methods usually fail when <span>$N_p$</span> is huge [<span>$N_p \sim O(10^3)$</span>] or the Matsubara data are noisy.</p><p>In order to overcome the above obstacles, we employ the simulated annealing method to locate the global minimum of <span>$\chi^{2}$</span>. The core idea is as follows: First of all, a set of <span>$\{A_{\gamma}, P_{\gamma}\}$</span> parameters are generated randomly. These parameters form a configuration space <span>$\mathcal{C} = \{A_{\gamma}, P_{\gamma}\}$</span>. Second, this configuration space is sampled by using the Metropolis Monte Carlo algorithm. In the present SPX method, four Monte Carlo updates are supported (see Figure 1). They include: (i) Select one pole randomly and shift its location. (ii) Select two poles randomly and shift their locations. (iii) Select two poles randomly and change their amplitudes. The sum-rules for fermionic and bosonic correlatores, should be respected in this update. (iv) Select two poles randomly and exchange their amplitudes. Assumed that the current Monte Carlo configuration is <span>$\mathcal{C} = \{A_{\gamma}, P_{\gamma}\}$</span>, the new one is <span>$\mathcal{C}&#39; = \{A&#39;_{\gamma}, P&#39;_{\gamma}\}$</span>, and <span>$\Delta \chi^2 = \chi^2(\mathcal{C}&#39;) - \chi^2(\mathcal{C})$</span>, then the transition probability reads:</p><p class="math-container">\[\begin{equation}
p(\mathcal{C} \to \mathcal{C}&#39;) =
\left\{
    \begin{array}{lr}
        \exp\left(-\frac{\Delta \chi^2}{2\Theta}\right), &amp; \text{if}~\Delta \chi^2 &gt; 0, \\
        1.0, &amp; \text{if}~\Delta \chi^2 \le 0,
    \end{array}
\right.
\end{equation}\]</p><p>where <span>$\Theta$</span> is an artificial system temperature and <span>$\chi^2$</span> is interpreted as energy of the system. Third, the above two steps should be restarted periodically to avoid trapped by local minima. Fourth, once all the Monte Carlo sampling tasks are finished, we should pick up the <em>best</em>  solution which exhibits the smallest <span>$\chi^2$</span>, or select some <em>good</em> solutions with small <span>$\chi^2$</span> and evaluate their arithmetic average. Finally, with the optimized <span>$N_{p}$</span>, and <span>$A_{\gamma}$</span>, and <span>$P_{\gamma}$</span> parameters, the retarded Green&#39;s function <span>$G^{R}(\omega)$</span> can be easily evaluated by replacing <span>$i\omega_n$</span> with <span>$\omega + i\eta$</span> in the pole representation, where <span>$\eta$</span> is a positive infinitesimal number. And the spectral density <span>$A(\omega)$</span> is calculated by:</p><p class="math-container">\[\begin{equation}
A(\omega) = - \frac{1}{\pi} \text{Im} G^{R}(\omega).
\end{equation}\]</p><p><img src="../assets/spx.png" alt="spx.png"/></p><p><strong>Figure 1 |</strong> Schematic picture for the pole representation of the Matsubara Green&#39;s function. The poles are visualized by vertical colorful bars. <code>Move 1</code>, <code>Move 2</code>, and <code>Move 4</code> denote three possible Monte Carlo updates: (i) shift a randomly selected pole, (ii) shift two randomly selected poles, and (iii)~swap two randomly selected poles. See main text for more details.</p><h2 id="Constrained-sampling-algorithm"><a class="docs-heading-anchor" href="#Constrained-sampling-algorithm">Constrained sampling algorithm</a><a id="Constrained-sampling-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Constrained-sampling-algorithm" title="Permalink"></a></h2><p>In the SPX method, the amplitudes and locations of the poles should be optimized by the Monte Carlo algorithm under some constraints (i.e., the sum-rules). We note that these constraints are from the canonical relations for the fermionic and bosonic operators. They should be satisfied, or else the causality of the spectrum is not guaranteed. But beyond that, more constraints are allowable. Further restrictions on the amplitudes and locations of the poles can greatly reduce the configuration space that need to be sampled and enhance the possibility to reach the global minimum of the optimization problem. The possible strategies include: (1) Restrict <span>$\{A_{\gamma}\}$</span> only; (2) Restrict <span>$\{P_{\gamma}\}$</span> only; and (3) Restrict <span>$\{A_{\gamma}\}$</span> and <span>$\{P_{\gamma}\}$</span> at the same time. These extra constraints can be deduced from <em>a priori</em> knowledge about the Matsubara Green&#39;s function <span>$G(i\omega_n)$</span> and the spectral density <span>$A(\omega)$</span>. For example, for a molecule system, the amplitudes of the poles are likely close. On the other hand, if we know nothing about the input data, we can always try some constraints. The universal trend is that the more reasonable the constraints, the smaller the <span>$\chi^2$</span> function. This is the so-called <code>constrained sampling algorithm</code>. By combined it with the SPX method (dubbed <code>C-SPX</code>), the ability of resolving fine features in the spectra will be greatly enhanced. To the best of our knowledge, the constrained sampling algorithm was firstly proposed by A. W. Sandvik. And then it is broadly used in the analytic continuations of spin susceptibilities of quantum many-body systems. Quite recently, Shao and Sandvik summarized various approaches to apply the constraints and benchmark their performances in a comprehensive review concerning the SAC method. Due to the similarities of the SPX and SAC methods, it is believed that all the constraint schemes as suggested in previous works should be useful for the SPX method.</p><h2 id="Self-adaptive-sampling-algorithm"><a class="docs-heading-anchor" href="#Self-adaptive-sampling-algorithm">Self-adaptive sampling algorithm</a><a id="Self-adaptive-sampling-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Self-adaptive-sampling-algorithm" title="Permalink"></a></h2><p>In analogy to the SAC method, the poles in the SPX method are distributed randomly in a real frequency grid. This grid must be extremely dense, and is usually linear. But in principle a nonuniform grid is possible. For example, Shao and Sandvik have suggested a nonlinear grid with monotonically increasing spacing for the <span>$\delta$</span> functions which are used to parameterize a spectrum that exhibits a sharp band edge. Since a spectral density can be viewed as a probability distribution and we notice that the distribution of the poles looks quite similar to the spectrum. So, it is natural to adjust the frequency grid dynamically to make sure that the grid density has approximate distribution with the spectral density as obtained in previous run. We adopt the following algorithm to update the frequency grid: (1) Create a new function <span>$\phi(\epsilon)$</span>:</p><p class="math-container">\[\begin{equation}
\phi(\epsilon) = \int^{\epsilon}_{\omega_{\text{min}}} A(\omega) d\omega,~\epsilon \in [\omega_{\text{min}},\omega_{\text{max}}].
\end{equation}\]</p><p>(2) The new frequency grid <span>$f_i$</span> is evaluated by:</p><p class="math-container">\[\begin{equation}
f_i = \phi^{-1}(\lambda_i),~i = 1, \cdots, N_f, 
\end{equation}\]</p><p>where <span>$\lambda_i$</span> is a linear mesh in <span>$[\phi(\omega_{\text{min}}),\phi(\omega_{\text{max}})]$</span>. Next we should perform the analytic continuation simulation again and extract a new spectrum. We find that the <span>$\chi^2$</span> drops quickly in the first a few iterations, and then approaches to a constant value slowly. At the same time, the spectrum is refined gradually. In the iterations, the frequency grid for the poles is adaptively modified according to the given spectrum, thus we call it the <code>self-adaptive sampling algorithm</code>. It is actually a new variation of the constrained sampling algorithm. More important, it is quite effective. Based on our experiences, <span>$3 \sim 5$</span> iterations are enough to obtain a convergent solution. In practice, we often use the spectrum generated by the MaxEnt method to initialize the frequency grid, and then employ the SPX method (dubbed <code>SA-SPX</code>) to refine this spectrum further.</p><h2 id="Relevant-parameters"><a class="docs-heading-anchor" href="#Relevant-parameters">Relevant parameters</a><a id="Relevant-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Relevant-parameters" title="Permalink"></a></h2><p>See <a href="../man/param.html#stochpx_block">[StochPX] Block</a></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="som.html">« Stochastic Optimization Method</a><a class="docs-footer-nextpage" href="reference.html">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 23 June 2023 21:09">Friday 23 June 2023</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

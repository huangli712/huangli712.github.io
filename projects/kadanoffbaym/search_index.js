var documenterSearchIndex = {"docs":
[{"location":"library/global.html","page":"Constants","title":"Constants","text":"Define some type aliases and string constants for the KadanoffBaym library.","category":"page"},{"location":"library/global.html","page":"Constants","title":"Constants","text":"Pages = [\"global.md\"]","category":"page"},{"location":"library/global.html#Numerical-Types","page":"Constants","title":"Numerical Types","text":"","category":"section"},{"location":"library/global.html#KadanoffBaym.I32","page":"Constants","title":"KadanoffBaym.I32","text":"I32\n\nAlias of Integer type (32 bit).\n\nSee also: R32, N32.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#KadanoffBaym.I64","page":"Constants","title":"KadanoffBaym.I64","text":"I64\n\nAlias of Integer type (64 bit).\n\nSee also: R64, N64.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#KadanoffBaym.API","page":"Constants","title":"KadanoffBaym.API","text":"API\n\nAlias of Integer type (Arbitrary Precision Integer).\n\nSee also: APF, APC.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#KadanoffBaym.F32","page":"Constants","title":"KadanoffBaym.F32","text":"F32\n\nAlias of Float type (32 bit).\n\nSee also: R32, N32.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#KadanoffBaym.F64","page":"Constants","title":"KadanoffBaym.F64","text":"F64\n\nAlias of Float type (64 bit).\n\nSee also: R64, N64.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#KadanoffBaym.APF","page":"Constants","title":"KadanoffBaym.APF","text":"APF\n\nAlias of Float type (Arbitrary Precision Float).\n\nSee also: API, APC.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#KadanoffBaym.C32","page":"Constants","title":"KadanoffBaym.C32","text":"C32\n\nAlias of Complex type (32 bit).\n\nSee also: R32, N32.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#KadanoffBaym.C64","page":"Constants","title":"KadanoffBaym.C64","text":"C64\n\nAlias of Complex type (64 bit).\n\nSee also: R64, N64.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#KadanoffBaym.APC","page":"Constants","title":"KadanoffBaym.APC","text":"APC\n\nAlias of Complex type (Arbitrary Precision Complex).\n\nSee also: API, APF.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#KadanoffBaym.R32","page":"Constants","title":"KadanoffBaym.R32","text":"R32\n\nAlias of Integer and Float types (32 bit). Here R means Real.\n\nSee also: N32, N64, APN.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#KadanoffBaym.R64","page":"Constants","title":"KadanoffBaym.R64","text":"R64\n\nAlias of Integer and Float types (64 bit). Here R means Real.\n\nSee also: N32, N64, APN.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#KadanoffBaym.APR","page":"Constants","title":"KadanoffBaym.APR","text":"APR\n\nAlias of Integer and Float types (Arbitrary Precision). Here R means Real.\n\nSee also: N32, N64, APN.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#KadanoffBaym.N32","page":"Constants","title":"KadanoffBaym.N32","text":"N32\n\nAlias of Integer, Float, and Complex types (32 bit). Here N means Number.\n\nSee also: R32, R64, APR.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#KadanoffBaym.N64","page":"Constants","title":"KadanoffBaym.N64","text":"N64\n\nAlias of Integer, Float, and Complex types (64 bit). Here N means Number.\n\nSee also: R32, R64, APR.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#KadanoffBaym.APN","page":"Constants","title":"KadanoffBaym.APN","text":"APN\n\nAlias of Integer, Float, and Complex types (Arbitrary Precision). Here N means Number.\n\nSee also: R32, R64, APR.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#KadanoffBaym.FERMI","page":"Constants","title":"KadanoffBaym.FERMI","text":"FERMI\n\nBasic physical constant.\n\n\n\n\n\n","category":"constant"},{"location":"library/global.html#KadanoffBaym.BOSE","page":"Constants","title":"KadanoffBaym.BOSE","text":"BOSE\n\nBasic physical constant.\n\n\n\n\n\n","category":"constant"},{"location":"library/global.html#String-Constants","page":"Constants","title":"String Constants","text":"","category":"section"},{"location":"library/global.html#KadanoffBaym.__LIBNAME__","page":"Constants","title":"KadanoffBaym.__LIBNAME__","text":"__LIBNAME__\n\nName of this julia toolkit.\n\nSee also: __VERSION__.\n\n\n\n\n\n","category":"constant"},{"location":"library/global.html#KadanoffBaym.__VERSION__","page":"Constants","title":"KadanoffBaym.__VERSION__","text":"__VERSION__\n\nVersion of this julia toolkit.\n\nSee also: __RELEASE__.\n\n\n\n\n\n","category":"constant"},{"location":"library/global.html#KadanoffBaym.__RELEASE__","page":"Constants","title":"KadanoffBaym.__RELEASE__","text":"__RELEASE__\n\nRelease date of this julia toolkit.\n\nSee also: __AUTHORS__.\n\n\n\n\n\n","category":"constant"},{"location":"library/global.html#KadanoffBaym.__AUTHORS__","page":"Constants","title":"KadanoffBaym.__AUTHORS__","text":"__AUTHORS__\n\nCore authors of this julia toolkit.\n\nSee also: __LIBNAME__.\n\n\n\n\n\n","category":"constant"},{"location":"library/global.html#Utilities","page":"Constants","title":"Utilities","text":"","category":"section"},{"location":"library/global.html#KadanoffBaym.authors","page":"Constants","title":"KadanoffBaym.authors","text":"authors()\n\nPrint authors / contributors of the KadanoffBaym toolkit.\n\nSee also: __AUTHORS__.\n\n\n\n\n\n","category":"function"},{"location":"library/util.html","page":"Utilities","title":"Utilities","text":"Provide some utility macros and functions for the KadanoffBaym library.","category":"page"},{"location":"library/util.html","page":"Utilities","title":"Utilities","text":"Pages = [\"util.md\"]","category":"page"},{"location":"library/util.html#Color-Constants","page":"Utilities","title":"Color Constants","text":"","category":"section"},{"location":"library/util.html#KadanoffBaym.COLORS","page":"Utilities","title":"KadanoffBaym.COLORS","text":"COLORS\n\nA global dict, which is used to specify the system colors.\n\n\n\n\n\n","category":"constant"},{"location":"library/util.html#KadanoffBaym.MODES","page":"Utilities","title":"KadanoffBaym.MODES","text":"MODES\n\nA global dict, which is used to specify the mode for output characters.\n\n\n\n\n\n","category":"constant"},{"location":"library/util.html#Macros","page":"Utilities","title":"Macros","text":"","category":"section"},{"location":"library/util.html#KadanoffBaym.@cswitch","page":"Utilities","title":"KadanoffBaym.@cswitch","text":"@cswitch(constexpr, body)\n\nProvides a C-like switch statement with the falling through behavior. This implementation was borrowed from the following github repository:\n\nhttps://github.com/Gnimuc/CSyntax.jl\n\nExamples\n\nengine = get_d(\"engine\")\n@cswitch engine begin\n    @case \"vasp\"\n        just_do_it()\n        break\n\n    @default\n        sorry()\n        break\nend\n\n\n\n\n\n","category":"macro"},{"location":"library/util.html#KadanoffBaym.@time_call","page":"Utilities","title":"KadanoffBaym.@time_call","text":"@time_call(ex)\n\nEvaluate a function call (ex), and then print the elapsed time (number of seconds) it took to execute.\n\nThis macro is a variation of the standard @elapsed macro.\n\n\n\n\n\n","category":"macro"},{"location":"library/util.html#KadanoffBaym.@pcs","page":"Utilities","title":"KadanoffBaym.@pcs","text":"@pcs(x...)\n\nTry to print colorful strings. Here x is a combination of strings and colors. Its format likes string1 color1 string2 color2 (repeat). For the supported colors, please check the global dict COLORS.\n\nExamples\n\njulia> @pcs \"Hello world!\" blue\njulia> @pcs \"Hello \" red \"world!\" green\n\nSee also: COLORS, welcome.\n\n\n\n\n\n","category":"macro"},{"location":"library/util.html#Colorful-Outputs","page":"Utilities","title":"Colorful Outputs","text":"","category":"section"},{"location":"library/util.html#KadanoffBaym.welcome","page":"Utilities","title":"KadanoffBaym.welcome","text":"welcome()\n\nPrint out the welcome messages to the screen.\n\nArguments\n\nN/A\n\nReturns\n\nN/A\n\n\n\n\n\n","category":"function"},{"location":"library/util.html#KadanoffBaym.sorry","page":"Utilities","title":"KadanoffBaym.sorry","text":"sorry()\n\nPrint an error message to the screen.\n\n\n\n\n\n","category":"function"},{"location":"library/util.html#KadanoffBaym.prompt","page":"Utilities","title":"KadanoffBaym.prompt","text":"prompt(msg::String)\n\nPrint a stylized KadanoffBaym message to the screen.\n\n\n\n\n\n","category":"function"},{"location":"library/util.html#Input/Output-Operations","page":"Utilities","title":"Input/Output Operations","text":"","category":"section"},{"location":"library/util.html#KadanoffBaym.line_to_array","page":"Utilities","title":"KadanoffBaym.line_to_array","text":"line_to_array(io::IOStream)\n\nConvert a line (reading from an IOStream) to a string array.\n\n\n\n\n\nline_to_array(str::AbstractString)\n\nConvert a string (AbstractString) to a string array.\n\n\n\n\n\n","category":"function"},{"location":"library/util.html#Color-Tools","page":"Utilities","title":"Color Tools","text":"","category":"section"},{"location":"library/util.html#KadanoffBaym.colorize","page":"Utilities","title":"KadanoffBaym.colorize","text":"colorize(\n    c::String,\n    s::String;\n    bg::String = \"default\",\n    m::String = \"default\"\n    )\n\nReturn some escape sequences, which will be displayed as colorized texts in the terminal.\n\nArguments\n\nc  -> Color names.\ns  -> The string that want to be printed.\nbg -> Background color.\nm  -> Mode for output string.\n\n\n\n\n\ncolorize(\n    c::Symbol,\n    s::String;\n    bg::String = \"default\",\n    m::String = \"default\"\n    )\n\nReturn some escape sequences, which will be displayed as colorized texts in the terminal.\n\n\n\n\n\n","category":"function"},{"location":"library/weight.html","page":"Integration Weights","title":"Integration Weights","text":"Define integration weights for the KadanoffBaym library.","category":"page"},{"location":"library/weight.html","page":"Integration Weights","title":"Integration Weights","text":"Pages = [\"weight.md\"]","category":"page"},{"location":"library/weight.html#Data-Types","page":"Integration Weights","title":"Data Types","text":"","category":"section"},{"location":"library/weight.html#KadanoffBaym.AbstractWeights","page":"Integration Weights","title":"KadanoffBaym.AbstractWeights","text":"AbstractWeights\n\nAbstract weights for numerical interpolation, differentiation, and integration. The purpose of this abstract type is to construct the type system.\n\n\n\n\n\n","category":"type"},{"location":"library/weight.html#KadanoffBaym.PolynomialInterpolationWeights","page":"Integration Weights","title":"KadanoffBaym.PolynomialInterpolationWeights","text":"PolynomialInterpolationWeights\n\nWeights for polynomial interpolation.\n\n\n\n\n\n","category":"type"},{"location":"library/weight.html#KadanoffBaym.PolynomialDifferentiationWeights","page":"Integration Weights","title":"KadanoffBaym.PolynomialDifferentiationWeights","text":"PolynomialDifferentiationWeights\n\nWeights for polynomial differentiation.\n\n\n\n\n\n","category":"type"},{"location":"library/weight.html#KadanoffBaym.PolynomialIntegrationWeights","page":"Integration Weights","title":"KadanoffBaym.PolynomialIntegrationWeights","text":"PolynomialIntegrationWeights\n\nWeights for polynomial integration.\n\n\n\n\n\n","category":"type"},{"location":"library/weight.html#KadanoffBaym.BackwardDifferentiationWeights","page":"Integration Weights","title":"KadanoffBaym.BackwardDifferentiationWeights","text":"BackwardDifferentiationWeights\n\nWeights for backward differentiation.\n\n\n\n\n\n","category":"type"},{"location":"library/weight.html#KadanoffBaym.GregoryIntegrationWeights","page":"Integration Weights","title":"KadanoffBaym.GregoryIntegrationWeights","text":"GregoryIntegrationWeights\n\nWeights for Gregory integration.\n\n\n\n\n\n","category":"type"},{"location":"library/weight.html#KadanoffBaym.BoundaryConvolutionWeights","page":"Integration Weights","title":"KadanoffBaym.BoundaryConvolutionWeights","text":"BoundaryConvolutionWeights\n\nWeights for boundary convolution.\n\n\n\n\n\n","category":"type"},{"location":"library/weight.html#KadanoffBaym.calc_poly_interpolation","page":"Integration Weights","title":"KadanoffBaym.calc_poly_interpolation","text":"calc_poly_interpolation(k::I64)\n\nCalculate polynomial interpolation weights.\n\nReferences :\n\nSee [NESSi] Eq.~(80).\n\n\n\n\n\n","category":"function"},{"location":"library/weight.html#KadanoffBaym.calc_poly_differentiation","page":"Integration Weights","title":"KadanoffBaym.calc_poly_differentiation","text":"calc_poly_differentiation(k::I64, Wi::Matrix{F64})\n\nCalculate polynomial differentiation weights.\n\nReferences :\n\nSee [NESSi] Eq.~(85).\n\n\n\n\n\n","category":"function"},{"location":"library/weight.html#KadanoffBaym.calc_poly_integration","page":"Integration Weights","title":"KadanoffBaym.calc_poly_integration","text":"calc_poly_integration(k::I64, Wi::Matrix{F64})\n\nCalculate polynomial integration weights.\n\nReferences :\n\nSee [NESSi] Eq.~(89).\n\n\n\n\n\n","category":"function"},{"location":"library/weight.html#KadanoffBaym.calc_backward_differentiation","page":"Integration Weights","title":"KadanoffBaym.calc_backward_differentiation","text":"calc_backward_differentiation(k::I64, Wi::Matrix{F64})\n\nCalculate backward differentiation weights.\n\nReferences :\n\nSee [NESSi] Eq.~(90).\n\n\n\n\n\n","category":"function"},{"location":"library/weight.html#KadanoffBaym.calc_gregory_integration","page":"Integration Weights","title":"KadanoffBaym.calc_gregory_integration","text":"calc_gregory_integration(k::I64, Wt::Array{F64,3})\n\nCalculate Gregory integration weights.\n\nReferences :\n\nSee Remarks.\n\n\n\n\n\n","category":"function"},{"location":"library/weight.html#KadanoffBaym.calc_gregory_weights","page":"Integration Weights","title":"KadanoffBaym.calc_gregory_weights","text":"calc_gregory_weights(k::I64, n::I64)\n\nTry to calculate the integration weights based on Gregory quadrature rule for 𝑘-order and 𝑛 + 1 nodes. This function only works for 𝑛 > 𝑘. It just returns a vector with 𝑛 + 1 elements (They are all Rational numbers).\n\nReferences :\n\nSee Remarks.\n\n\n\n\n\n","category":"function"},{"location":"library/weight.html#KadanoffBaym.calc_boundary_convolution","page":"Integration Weights","title":"KadanoffBaym.calc_boundary_convolution","text":"calc_boundary_convolution(k::I64, Wi::Matrix{F64})\n\nCalculate integration weights for boundary convolution.\n\nReferences :\n\nSee [NESSi] Eq.~(104).\n\n\n\n\n\n","category":"function"},{"location":"library/weight.html#KadanoffBaym.trapezoid","page":"Integration Weights","title":"KadanoffBaym.trapezoid","text":"trapezoid(n::I64)\n\nReturn integration weights based on the trapezoid rule. Note that the return value of this function is a Rational number.\n\nReferences :\n\nSee [REVIEW] Eq.~(A9).\n\n\n\n\n\n","category":"function"},{"location":"library/weight.html#KadanoffBaym.Λ","page":"Integration Weights","title":"KadanoffBaym.Λ","text":"Λ(k::I64)\n\nTry to calculate the Laplace coefficients Λ. This a recursive function. Note that the return value is a Rational number.\n\nReferences :\n\nSee [MABOOK] Eqs.~(8.4.37), (8.4.50), and (8.4.54).\n\n\n\n\n\n","category":"function"},{"location":"library/weight.html#KadanoffBaym.γⱼ","page":"Integration Weights","title":"KadanoffBaym.γⱼ","text":"γⱼ(k::I64)\n\nTry to calculate the 𝑘th order coefficients γⱼ, where 𝑗 ∈ [0,𝑘].\n\nReferences :\n\nSee [QUADRATURE] Eqs.~(2.5) and (2.6).\n\n\n\n\n\n","category":"function"},{"location":"library/weight.html#KadanoffBaym.𝐑","page":"Integration Weights","title":"KadanoffBaym.𝐑","text":"𝐑(m::I64, a::I64, b::I64)\n\nTry to calculate integration ∫^{m}{0} dx (m-x)ᵃxᵇ. We note that this integration appears in [NESSi] Eq.~(104). This function is called by `calcboundary_convolution()` internally. It should not be exported.\n\nReferences :\n\nSee [NESSi] Eq.~(104).\n\n\n\n\n\n","category":"function"},{"location":"library/weight.html#KadanoffBaym.Γ","page":"Integration Weights","title":"KadanoffBaym.Γ","text":"Γ(n::I64)\n\nTry to calculate Γ function. This function should not be exported. Note that the function name for the calculation of Γ function is :tgamma, instead of :gamma. This is quite strange.\n\nReferences :\n\nSee [MATABLE] Section 6.21.\n\n\n\n\n\n","category":"function"},{"location":"library/type.html","page":"Types","title":"Types","text":"Define some fundamental types and structs for the KadanoffBaym library.","category":"page"},{"location":"library/type.html","page":"Types","title":"Types","text":"Pages = [\"type.md\"]","category":"page"},{"location":"library/type.html#Data-Types","page":"Types","title":"Data Types","text":"","category":"section"},{"location":"library/type.html#KadanoffBaym.Element","page":"Types","title":"KadanoffBaym.Element","text":"Element{T}\n\nType definition. A matrix.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#KadanoffBaym.MatArray","page":"Types","title":"KadanoffBaym.MatArray","text":"MatArray{T}\n\nType definition. A matrix of matrix.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#KadanoffBaym.VecArray","page":"Types","title":"KadanoffBaym.VecArray","text":"VecArray{T}\n\nType definition. A vector of matrix.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#KadanoffBaym.CnAbstractType","page":"Types","title":"KadanoffBaym.CnAbstractType","text":"CnAbstractType\n\nTop abstract type for all objects defined on contour.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#KadanoffBaym.CnAbstractMatrix","page":"Types","title":"KadanoffBaym.CnAbstractMatrix","text":"CnAbstractMatrix{T}\n\nAbstract matrix type defined on contour.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#KadanoffBaym.CnAbstractVector","page":"Types","title":"KadanoffBaym.CnAbstractVector","text":"CnAbstractVector{T}\n\nAbstract vector type defined on contour.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#KadanoffBaym.CnAbstractFunction","page":"Types","title":"KadanoffBaym.CnAbstractFunction","text":"CnAbstractFunction{T}\n\nAbstract contour function.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#KadanoffBaym.Cn","page":"Types","title":"KadanoffBaym.Cn","text":"Cn\n\n𝐿-shape Kadanoff-Baym contour. It includes the following members:\n\nntime -> Number of time slices in real time axis [0, 𝑡max].\nntau -> Number of time slices in imaginary time axis [0, β].\nndim1 -> Size of operators that stored in the contour.\nndim2 -> Size of operators that stored in the contour.\ntmax -> Maximum 𝑡.\nbeta -> β, inverse temperature.\ndt -> δ𝑡, time step in real axis.\ndtau -> δτ, time step in imaginary axis.\n\nSee also: CnAbstractType.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#KadanoffBaym.Cf","page":"Types","title":"KadanoffBaym.Cf","text":"Cf{T}\n\nIt is a square-matrix-valued or rectangle-matrix-valued function of time.\n\nSee also: ℱ, 𝒻.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#KadanoffBaym.Gᵐᵃᵗ","page":"Types","title":"KadanoffBaym.Gᵐᵃᵗ","text":"Gᵐᵃᵗ{T}\n\nMatsubara component (G^M) of contour Green's function. We usually call this component mat. Here we just assume au  0. While for au  0, please turn to the Gᵐᵃᵗᵐ{T} struct.\n\nSee also: Gʳᵉᵗ, Gˡᵐⁱˣ, Gˡᵉˢˢ.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#KadanoffBaym.Gʳᵉᵗ","page":"Types","title":"KadanoffBaym.Gʳᵉᵗ","text":"Gʳᵉᵗ{T}\n\nRetarded component (G^R) of contour Green's function. We usually call this component ret.\n\nSee also: Gᵐᵃᵗ, Gˡᵐⁱˣ, Gˡᵉˢˢ.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#KadanoffBaym.Gˡᵐⁱˣ","page":"Types","title":"KadanoffBaym.Gˡᵐⁱˣ","text":"Gˡᵐⁱˣ{T}\n\nLeft-mixing component (G^) of contour Green's function. We usually call this component lmix.\n\nSee also: Gᵐᵃᵗ, Gʳᵉᵗ, Gˡᵉˢˢ.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#KadanoffBaym.Gˡᵉˢˢ","page":"Types","title":"KadanoffBaym.Gˡᵉˢˢ","text":"Gˡᵉˢˢ{T}\n\nLesser component (G^) of contour Green's function. We usually call this component less.\n\nSee also: Gᵐᵃᵗ, Gʳᵉᵗ, Gˡᵐⁱˣ.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#KadanoffBaym.Gᵐᵃᵗᵐ","page":"Types","title":"KadanoffBaym.Gᵐᵃᵗᵐ","text":"Gᵐᵃᵗᵐ{T}\n\nMatsubara component (G^M) of contour Green's function. It is designed for au  0 case. It is not an independent component. It can be inferred or deduced from the Gᵐᵃᵗ{T} struct. We usually call this component matm.\n\nSee also: Gʳᵉᵗ, Gˡᵐⁱˣ, Gˡᵉˢˢ.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#KadanoffBaym.Gᵃᵈᵛ","page":"Types","title":"KadanoffBaym.Gᵃᵈᵛ","text":"Gᵃᵈᵛ{T}\n\nAdvanced component (G^A) of contour Green's function. We usually call this component adv.\n\nNote that currently we do not need this component explicitly. However, for the sake of completeness, we still define an empty struct for it.\n\nSee also: Gᵐᵃᵗ, Gˡᵐⁱˣ, Gˡᵉˢˢ.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#KadanoffBaym.Gʳᵐⁱˣ","page":"Types","title":"KadanoffBaym.Gʳᵐⁱˣ","text":"Gʳᵐⁱˣ{T}\n\nRight-mixing component (G^) of contour Green's function. We usually call this component rmix.\n\nSee also: Gᵐᵃᵗ, Gʳᵉᵗ, Gˡᵉˢˢ.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#KadanoffBaym.Gᵍᵗʳ","page":"Types","title":"KadanoffBaym.Gᵍᵗʳ","text":"Gᵍᵗʳ{T}\n\nGreater component (G^) of contour Green's function. We usually call this component gtr.\n\nSee also: Gʳᵉᵗ, Gˡᵐⁱˣ, Gˡᵉˢˢ.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#KadanoffBaym.gᵐᵃᵗ","page":"Types","title":"KadanoffBaym.gᵐᵃᵗ","text":"gᵐᵃᵗ{S}\n\nMatsubara component (G^M) of contour Green's function at given time step tstp. Actually, gᵐᵃᵗ{S} is equivalent to Gᵐᵃᵗ{T}.\n\nSee also: gʳᵉᵗ, gˡᵐⁱˣ, gˡᵉˢˢ.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#KadanoffBaym.gʳᵉᵗ","page":"Types","title":"KadanoffBaym.gʳᵉᵗ","text":"gʳᵉᵗ{S}\n\nRetarded component (G^R) of contour Green's function at given time step tstp. Actually, it denotes G^R(tᵢ = tstp tⱼ).\n\nSee also: gᵐᵃᵗ, gˡᵐⁱˣ, gˡᵉˢˢ.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#KadanoffBaym.gˡᵐⁱˣ","page":"Types","title":"KadanoffBaym.gˡᵐⁱˣ","text":"gˡᵐⁱˣ{S}\n\nLeft-mixing component (G^) of contour Green's function at given time step tstp. Actually, it denotes G^(tᵢ  tstp τⱼ).\n\nSee also: gᵐᵃᵗ, gʳᵉᵗ, gˡᵉˢˢ.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#KadanoffBaym.gˡᵉˢˢ","page":"Types","title":"KadanoffBaym.gˡᵉˢˢ","text":"gˡᵉˢˢ{S}\n\nLesser component (G^) of contour Green's function at given time step tstp. Actually, it denotes G^(tᵢ tⱼ  tstp).\n\nSee also: gᵐᵃᵗ, gʳᵉᵗ, gˡᵐⁱˣ.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#KadanoffBaym.gᵐᵃᵗᵐ","page":"Types","title":"KadanoffBaym.gᵐᵃᵗᵐ","text":"gᵐᵃᵗᵐ{S}\n\nMatsubara component (G^M) of contour Green's function at given time step tstp = 0. It is designed for au  0 case. It is not an independent component. It can be constructed from the gᵐᵃᵗ{T} struct.\n\nSee also: gʳᵉᵗ, gˡᵐⁱˣ, gˡᵉˢˢ.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#KadanoffBaym.gᵃᵈᵛ","page":"Types","title":"KadanoffBaym.gᵃᵈᵛ","text":"gᵃᵈᵛ{S}\n\nAdvanced component (G^A) of contour Green's function at given time step tstp.\n\nNote that currently we do not need this component explicitly. However, for the sake of completeness, we still define an empty struct for it.\n\nSee also: gᵐᵃᵗ, gˡᵐⁱˣ, gˡᵉˢˢ.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#KadanoffBaym.gʳᵐⁱˣ","page":"Types","title":"KadanoffBaym.gʳᵐⁱˣ","text":"gʳᵐⁱˣ{S}\n\nRight-mixing component (G^) of contour Green's function at given time step tstp. Actually, it denotes G^(τᵢ tⱼ  tstp)\n\nSee also: gᵐᵃᵗ, gʳᵉᵗ, gˡᵉˢˢ.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#KadanoffBaym.gᵍᵗʳ","page":"Types","title":"KadanoffBaym.gᵍᵗʳ","text":"gᵍᵗʳ{S}\n\nGreater component (G^) of contour Green's function at given time step tstp.\n\nSee also: gʳᵉᵗ, gˡᵐⁱˣ, gˡᵉˢˢ.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#KadanoffBaym.ℱ","page":"Types","title":"KadanoffBaym.ℱ","text":"ℱ{T}\n\nStandard contour-ordered Green's function. It includes four independent components, namely mat, ret, lmix, and less.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#KadanoffBaym.𝒻","page":"Types","title":"KadanoffBaym.𝒻","text":"𝒻{S}\n\nStandard contour-ordered Green's function at given time step tstp. It includes four independent components, namely mat, ret, lmix, and less. If tstp = 0, it denotes the equilibrium state (only the mat component is valid). On the other hand, tstp > 0 means nonequilibrium state.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#Functions","page":"Types","title":"Functions","text":"","category":"section"},{"location":"library/type.html#KadanoffBaym.refresh!","page":"Types","title":"KadanoffBaym.refresh!","text":"refresh!(C::Cn)\n\nUpdate the dt and dtau parameters of contour.\n\nSee also: Cn.\n\n\n\n\n\n","category":"function"},{"location":"library/type.html#KadanoffBaym.getdims","page":"Types","title":"KadanoffBaym.getdims","text":"getdims(C::Cn)\n\nReturn the dimensional parameters of contour.\n\nSee also: Cn.\n\n\n\n\n\ngetdims(cf::Cf{T})\n\nReturn the dimensional parameters of contour function.\n\nSee also: Cf.\n\n\n\n\n\ngetdims(mat::Gᵐᵃᵗ{T})\n\nReturn the dimensional parameters of contour function.\n\nSee also: Gᵐᵃᵗ.\n\n\n\n\n\ngetdims(ret::Gʳᵉᵗ{T})\n\nReturn the dimensional parameters of contour function.\n\nSee also: Gʳᵉᵗ.\n\n\n\n\n\ngetdims(lmix::Gˡᵐⁱˣ{T})\n\nReturn the dimensional parameters of contour function.\n\nSee also: Gˡᵐⁱˣ.\n\n\n\n\n\ngetdims(less::Gˡᵉˢˢ{T})\n\nReturn the dimensional parameters of contour function.\n\nSee also: Gˡᵉˢˢ.\n\n\n\n\n\ngetdims(cfm::ℱ{T})\n\nReturn the dimensional parameters of contour Green's function.\n\nSee also: ℱ.\n\n\n\n\n\ngetdims(mat::gᵐᵃᵗ{S})\n\nReturn the dimensional parameters of contour function.\n\nSee also: gᵐᵃᵗ.\n\n\n\n\n\ngetdims(ret::gʳᵉᵗ{S})\n\nReturn the dimensional parameters of contour function.\n\nSee also: gʳᵉᵗ.\n\n\n\n\n\ngetdims(lmix::gˡᵐⁱˣ{S})\n\nReturn the dimensional parameters of contour function.\n\nSee also: gˡᵐⁱˣ.\n\n\n\n\n\ngetdims(less::gˡᵉˢˢ{S})\n\nReturn the dimensional parameters of contour function.\n\nSee also: gˡᵉˢˢ.\n\n\n\n\n\ngetdims(cfv::𝒻{S})\n\nReturn the dimensional parameters of contour Green's function.\n\nSee also: 𝒻.\n\n\n\n\n\n","category":"function"},{"location":"library/type.html#KadanoffBaym.getntime","page":"Types","title":"KadanoffBaym.getntime","text":"getntime(cfm::ℱ{T})\n\nReturn the ntime parameter of contour Green's function.\n\n\n\n\n\n","category":"function"},{"location":"library/type.html#KadanoffBaym.getntau","page":"Types","title":"KadanoffBaym.getntau","text":"getntau(cfm::ℱ{T})\n\nReturn the ntau parameter of contour Green's function.\n\n\n\n\n\ngetntau(cfv::𝒻{S})\n\nReturn the ntau parameter of contour Green's function.\n\n\n\n\n\n","category":"function"},{"location":"library/type.html#KadanoffBaym.getsign","page":"Types","title":"KadanoffBaym.getsign","text":"getsign(cfm::ℱ{T})\n\nReturn the sign parameter of contour Green's function.\n\n\n\n\n\ngetsign(cfv::𝒻{S})\n\nReturn the sign parameter of contour Green's function.\n\n\n\n\n\n","category":"function"},{"location":"library/type.html#KadanoffBaym.getsize","page":"Types","title":"KadanoffBaym.getsize","text":"getsize(cf::Cf{T})\n\nReturn the nominal size of contour function, i.e ntime. Actually, the real size of contour function should be ntime + 1.\n\nSee also: Cf.\n\n\n\n\n\ngetsize(mat::Gᵐᵃᵗ{T})\n\nReturn the size of contour function. Here, it should be ntau.\n\nSee also: Gᵐᵃᵗ.\n\n\n\n\n\ngetsize(ret::Gʳᵉᵗ{T})\n\nReturn the size of contour function.\n\nSee also: Gʳᵉᵗ.\n\n\n\n\n\ngetsize(lmix::Gˡᵐⁱˣ{T})\n\nReturn the size of contour function.\n\nSee also: Gˡᵐⁱˣ.\n\n\n\n\n\ngetsize(less::Gˡᵉˢˢ{T})\n\nReturn the size of contour function.\n\nSee also: Gˡᵉˢˢ.\n\n\n\n\n\ngetsize(mat::gᵐᵃᵗ{S})\n\nReturn the size of contour function.\n\nSee also: gᵐᵃᵗ.\n\n\n\n\n\ngetsize(ret::gʳᵉᵗ{S})\n\nReturn the size of contour function.\n\nSee also: gʳᵉᵗ.\n\n\n\n\n\ngetsize(lmix::gˡᵐⁱˣ{S})\n\nReturn the size of contour function.\n\nSee also: gˡᵐⁱˣ.\n\n\n\n\n\ngetsize(less::gˡᵉˢˢ{S})\n\nReturn the size of contour function.\n\nSee also: gˡᵉˢˢ.\n\n\n\n\n\n","category":"function"},{"location":"library/type.html#KadanoffBaym.gettstp","page":"Types","title":"KadanoffBaym.gettstp","text":"gettstp(cfv::𝒻{S})\n\nReturn the tstp parameter of contour Green's function.\n\n\n\n\n\n","category":"function"},{"location":"library/type.html#KadanoffBaym.equaldims","page":"Types","title":"KadanoffBaym.equaldims","text":"equaldims(C::Cn)\n\nReturn whether the dimensional parameters are equal.\n\nSee also: Cn.\n\n\n\n\n\nequaldims(cf::Cf{T})\n\nReturn whether the dimensional parameters are equal.\n\nSee also: Cf.\n\n\n\n\n\nequaldims(mat::Gᵐᵃᵗ{T})\n\nReturn whether the dimensional parameters are equal.\n\nSee also: Gᵐᵃᵗ.\n\n\n\n\n\nequaldims(ret::Gʳᵉᵗ{T})\n\nReturn whether the dimensional parameters are equal.\n\nSee also: Gʳᵉᵗ.\n\n\n\n\n\nequaldims(lmix::Gˡᵐⁱˣ{T})\n\nReturn whether the dimensional parameters are equal.\n\nSee also: Gˡᵐⁱˣ.\n\n\n\n\n\nequaldims(less::Gˡᵉˢˢ{T})\n\nReturn whether the dimensional parameters are equal.\n\nSee also: Gˡᵉˢˢ.\n\n\n\n\n\nequaldims(cfm::ℱ{T})\n\nReturn whether the dimensional parameters are equal.\n\nSee also: ℱ.\n\n\n\n\n\nequaldims(mat::gᵐᵃᵗ{S})\n\nReturn whether the dimensional parameters are equal.\n\nSee also: gᵐᵃᵗ.\n\n\n\n\n\nequaldims(ret::gʳᵉᵗ{S})\n\nReturn whether the dimensional parameters are equal.\n\nSee also: gʳᵉᵗ.\n\n\n\n\n\nequaldims(lmix::gˡᵐⁱˣ{S})\n\nReturn whether the dimensional parameters are equal.\n\nSee also: gˡᵐⁱˣ.\n\n\n\n\n\nequaldims(less::gˡᵉˢˢ{S})\n\nReturn whether the dimensional parameters are equal.\n\nSee also: gˡᵉˢˢ.\n\n\n\n\n\nequaldims(cfv::𝒻{S})\n\nReturn whether the dimensional parameters are equal.\n\nSee also: 𝒻.\n\n\n\n\n\n","category":"function"},{"location":"library/type.html#KadanoffBaym.iscompatible","page":"Types","title":"KadanoffBaym.iscompatible","text":"iscompatible(cf1::Cf{T}, cf2::Cf{T})\n\nJudge whether two Cf objects are compatible.\n\n\n\n\n\niscompatible(C::Cn, cf::Cf{T})\n\nJudge whether C (which is a Cn object) is compatible with cf (which is a Cf{T} object).\n\n\n\n\n\niscompatible(cf::Cf{T}, C::Cn)\n\nJudge whether C (which is a Cn object) is compatible with cf (which is a Cf{T} object).\n\n\n\n\n\niscompatible(mat1::Gᵐᵃᵗ{T}, mat2::Gᵐᵃᵗ{T})\n\nJudge whether two Gᵐᵃᵗ objects are compatible.\n\n\n\n\n\niscompatible(C::Cn, mat::Gᵐᵃᵗ{T})\n\nJudge whether C (which is a Cn object) is compatible with mat (which is a Gᵐᵃᵗ{T} object).\n\n\n\n\n\niscompatible(mat::Gᵐᵃᵗ{T}, C::Cn)\n\nJudge whether C (which is a Cn object) is compatible with mat (which is a Gᵐᵃᵗ{T} object).\n\n\n\n\n\niscompatible(ret1::Gʳᵉᵗ{T}, ret2::Gʳᵉᵗ{T})\n\nJudge whether two Gʳᵉᵗ objects are compatible.\n\n\n\n\n\niscompatible(C::Cn, ret::Gʳᵉᵗ{T})\n\nJudge whether C (which is a Cn object) is compatible with ret (which is a Gʳᵉᵗ{T} object).\n\n\n\n\n\niscompatible(ret::Gʳᵉᵗ{T}, C::Cn)\n\nJudge whether C (which is a Cn object) is compatible with ret (which is a Gʳᵉᵗ{T} object).\n\n\n\n\n\niscompatible(lmix1::Gˡᵐⁱˣ{T}, lmix2::Gˡᵐⁱˣ{T})\n\nJudge whether two Gˡᵐⁱˣ objects are compatible.\n\n\n\n\n\niscompatible(C::Cn, lmix::Gˡᵐⁱˣ{T})\n\nJudge whether C (which is a Cn object) is compatible with lmix (which is a Gˡᵐⁱˣ{T} object).\n\n\n\n\n\niscompatible(lmix::Gˡᵐⁱˣ{T}, C::Cn)\n\nJudge whether C (which is a Cn object) is compatible with lmix (which is a Gˡᵐⁱˣ{T} object).\n\n\n\n\n\niscompatible(less1::Gˡᵉˢˢ{T}, less2::Gˡᵉˢˢ{T})\n\nJudge whether two Gˡᵉˢˢ objects are compatible.\n\n\n\n\n\niscompatible(C::Cn, less::Gˡᵉˢˢ{T})\n\nJudge whether C (which is a Cn object) is compatible with less (which is a Gˡᵉˢˢ{T} object).\n\n\n\n\n\niscompatible(less::Gˡᵉˢˢ{T}, C::Cn)\n\nJudge whether C (which is a Cn object) is compatible with less (which is a Gˡᵉˢˢ{T} object).\n\n\n\n\n\niscompatible(mat1::gᵐᵃᵗ{S}, mat2::gᵐᵃᵗ{S})\n\nJudge whether two gᵐᵃᵗ objects are compatible.\n\n\n\n\n\niscompatible(mat1::gᵐᵃᵗ{S}, mat2::Gᵐᵃᵗ{S})\n\nJudge whether the gᵐᵃᵗ and Gᵐᵃᵗ objects are compatible.\n\n\n\n\n\niscompatible(mat1::Gᵐᵃᵗ{S}, mat2::gᵐᵃᵗ{S})\n\nJudge whether the gᵐᵃᵗ and Gᵐᵃᵗ objects are compatible.\n\n\n\n\n\niscompatible(C::Cn, mat::gᵐᵃᵗ{S})\n\nJudge whether C (which is a Cn object) is compatible with mat (which is a gᵐᵃᵗ{S} object).\n\n\n\n\n\niscompatible(mat::gᵐᵃᵗ{S}, C::Cn)\n\nJudge whether C (which is a Cn object) is compatible with mat (which is a gᵐᵃᵗ{S} object).\n\n\n\n\n\niscompatible(ret1::gʳᵉᵗ{S}, ret2::gʳᵉᵗ{S})\n\nJudge whether two gʳᵉᵗ objects are compatible.\n\n\n\n\n\niscompatible(ret1::gʳᵉᵗ{S}, ret2::Gʳᵉᵗ{S})\n\nJudge whether the gʳᵉᵗ and Gʳᵉᵗ objects are compatible.\n\n\n\n\n\niscompatible(ret1::Gʳᵉᵗ{S}, ret2::gʳᵉᵗ{S})\n\nJudge whether the gʳᵉᵗ and Gʳᵉᵗ objects are compatible.\n\n\n\n\n\niscompatible(C::Cn, ret::gʳᵉᵗ{S})\n\nJudge whether C (which is a Cn object) is compatible with ret (which is a gʳᵉᵗ{S} object).\n\n\n\n\n\niscompatible(ret::gʳᵉᵗ{S}, C::Cn)\n\nJudge whether C (which is a Cn object) is compatible with ret (which is a gʳᵉᵗ{S} object).\n\n\n\n\n\niscompatible(lmix1::gˡᵐⁱˣ{S}, lmix2::gˡᵐⁱˣ{S})\n\nJudge whether two gˡᵐⁱˣ objects are compatible.\n\n\n\n\n\niscompatible(lmix1::gˡᵐⁱˣ{S}, lmix2::Gˡᵐⁱˣ{S})\n\nJudge whether the gˡᵐⁱˣ and Gˡᵐⁱˣ objects are compatible.\n\n\n\n\n\niscompatible(lmix1::Gˡᵐⁱˣ{S}, lmix2::gˡᵐⁱˣ{S})\n\nJudge whether the gˡᵐⁱˣ and Gˡᵐⁱˣ objects are compatible.\n\n\n\n\n\niscompatible(C::Cn, lmix::gˡᵐⁱˣ{S})\n\nJudge whether C (which is a Cn object) is compatible with lmix (which is a gˡᵐⁱˣ{S} object).\n\n\n\n\n\niscompatible(lmix::gˡᵐⁱˣ{S}, C::Cn)\n\nJudge whether C (which is a Cn object) is compatible with lmix (which is a gˡᵐⁱˣ{S} object).\n\n\n\n\n\niscompatible(less1::gˡᵉˢˢ{S}, less2::gˡᵉˢˢ{S})\n\nJudge whether two gˡᵉˢˢ objects are compatible.\n\n\n\n\n\niscompatible(less1::gˡᵉˢˢ{S}, less2::Gˡᵉˢˢ{S})\n\nJudge whether the gˡᵉˢˢ and Gˡᵉˢˢ objects are compatible.\n\n\n\n\n\niscompatible(less1::Gˡᵉˢˢ{S}, less2::gˡᵉˢˢ{S})\n\nJudge whether the gˡᵉˢˢ and Gˡᵉˢˢ objects are compatible.\n\n\n\n\n\niscompatible(C::Cn, less::gˡᵉˢˢ{S})\n\nJudge whether C (which is a Cn object) is compatible with less (which is a gˡᵉˢˢ{S} object).\n\n\n\n\n\niscompatible(less::gˡᵉˢˢ{S}, C::Cn)\n\nJudge whether C (which is a Cn object) is compatible with less (which is a gˡᵉˢˢ{S} object).\n\n\n\n\n\n","category":"function"},{"location":"library/type.html#KadanoffBaym.density","page":"Types","title":"KadanoffBaym.density","text":"density(cfm::ℱ{T}, tstp::I64)\n\nReturns the density matrix at given time step tstp. If tstp = 0, it denotes the equilibrium state. However, when tstp > 0, it means the nonequilibrium state.\n\nSee also: Gᵐᵃᵗ, Gˡᵉˢˢ.\n\n\n\n\n\ndensity(cfv::𝒻{S}, tstp::I64)\n\nReturns the density matrix at given time step tstp. If tstp = 0, it denotes the equilibrium state. However, when tstp > 0, it means the nonequilibrium state.\n\nSee also: gᵐᵃᵗ, gˡᵉˢˢ.\n\n\n\n\n\n","category":"function"},{"location":"library/type.html#KadanoffBaym.distance","page":"Types","title":"KadanoffBaym.distance","text":"distance(mat1::Gᵐᵃᵗ{T}, mat2::Gᵐᵃᵗ{T})\n\nCalculate distance between two Gᵐᵃᵗ objects.\n\n\n\n\n\ndistance(ret1::Gʳᵉᵗ{T}, ret2::Gʳᵉᵗ{T}, tstp::I64)\n\nCalculate distance between two Gʳᵉᵗ objects at given time step tstp.\n\n\n\n\n\ndistance(lmix1::Gˡᵐⁱˣ{T}, lmix2::Gˡᵐⁱˣ{T}, tstp::I64)\n\nCalculate distance between two Gˡᵐⁱˣ objects at given time step tstp.\n\n\n\n\n\ndistance(less1::Gˡᵉˢˢ{T}, less2::Gˡᵉˢˢ{T}, tstp::I64)\n\nCalculate distance between two Gˡᵉˢˢ objects at given time step tstp.\n\n\n\n\n\ndistance(cfm1::ℱ{T}, cfm2::ℱ{T}, tstp::I64)\n\nCalculate distance between two ℱ objects at given time step tstp.\n\n\n\n\n\ndistance(mat1::gᵐᵃᵗ{S}, mat2::gᵐᵃᵗ{S})\n\nCalculate distance between two gᵐᵃᵗ objects.\n\n\n\n\n\ndistance(mat1::gᵐᵃᵗ{S}, mat2::Gᵐᵃᵗ{S})\n\nCalculate distance between a gᵐᵃᵗ object and a Gᵐᵃᵗ object.\n\n\n\n\n\ndistance(mat1::Gᵐᵃᵗ{S}, mat2::gᵐᵃᵗ{S})\n\nCalculate distance between a gᵐᵃᵗ object and a Gᵐᵃᵗ object.\n\n\n\n\n\ndistance(ret1::gʳᵉᵗ{S}, ret2::gʳᵉᵗ{S})\n\nCalculate distance between two gʳᵉᵗ objects.\n\n\n\n\n\ndistance(ret1::gʳᵉᵗ{S}, ret2::Gʳᵉᵗ{S}, tstp::I64)\n\nCalculate distance between a gʳᵉᵗ object and a Gʳᵉᵗ object at given time step tstp.\n\n\n\n\n\ndistance(ret1::Gʳᵉᵗ{S}, ret2::gʳᵉᵗ{S}, tstp::I64)\n\nCalculate distance between a gʳᵉᵗ object and a Gʳᵉᵗ object at given time step tstp.\n\n\n\n\n\ndistance(lmix1::gˡᵐⁱˣ{S}, lmix2::gˡᵐⁱˣ{S})\n\nCalculate distance between two gˡᵐⁱˣ objects.\n\n\n\n\n\ndistance(lmix1::gˡᵐⁱˣ{S}, lmix2::Gˡᵐⁱˣ{S}, tstp::I64)\n\nCalculate distance between a gˡᵐⁱˣ object and a Gˡᵐⁱˣ object at given time step tstp.\n\n\n\n\n\ndistance(lmix1::Gˡᵐⁱˣ{S}, lmix2::gˡᵐⁱˣ{S}, tstp::I64)\n\nCalculate distance between a gˡᵐⁱˣ object and a Gˡᵐⁱˣ object at given time step tstp.\n\n\n\n\n\ndistance(less1::gˡᵉˢˢ{S}, less2::gˡᵉˢˢ{S})\n\nCalculate distance between two gˡᵉˢˢ objects.\n\n\n\n\n\ndistance(less1::gˡᵉˢˢ{S}, less2::Gˡᵉˢˢ{S}, tstp::I64)\n\nCalculate distance between a gˡᵉˢˢ object and a Gˡᵉˢˢ object at given time step tstp.\n\n\n\n\n\ndistance(less1::Gˡᵉˢˢ{S}, less2::gˡᵉˢˢ{S}, tstp::I64)\n\nCalculate distance between a gˡᵉˢˢ object and a Gˡᵉˢˢ object at given time step tstp.\n\n\n\n\n\ndistance(cfv1::𝒻{S}, cfv2::𝒻{S}, tstp::I64)\n\nCalculate distance between two 𝒻 objects at given time step tstp.\n\n\n\n\n\ndistance(cfv1::𝒻{S}, cfm2::ℱ{S}, tstp::I64)\n\nCalculate distance between a 𝒻 object and a ℱ object at given time step tstp.\n\n\n\n\n\ndistance(cfm1::ℱ{S}, cfv2::𝒻{S}, tstp::I64)\n\nCalculate distance between a 𝒻 object and a ℱ object at given time step tstp.\n\n\n\n\n\n","category":"function"},{"location":"library/type.html#KadanoffBaym.memset!","page":"Types","title":"KadanoffBaym.memset!","text":"memset!(cf::Cf{T}, x)\n\nReset all the matrix elements of cf to x. x should be a scalar number.\n\n\n\n\n\nmemset!(mat::Gᵐᵃᵗ{T}, x)\n\nReset all the matrix elements of mat to x. x should be a scalar number.\n\n\n\n\n\nmemset!(ret::Gʳᵉᵗ{T}, x)\n\nReset all the matrix elements of ret to x. x should be a scalar number.\n\n\n\n\n\nmemset!(ret::Gʳᵉᵗ{T}, tstp::I64, x)\n\nReset the matrix elements of ret at given time step tstp (and at all t where t < tstp) to x. x should be a scalar number.\n\n\n\n\n\nmemset!(lmix::Gˡᵐⁱˣ{T}, x)\n\nReset all the matrix elements of lmix to x. x should be a scalar number.\n\n\n\n\n\nmemset!(lmix::Gˡᵐⁱˣ{T}, tstp::I64, x)\n\nReset the matrix elements of lmix at given time step tstp to x. x should be a scalar number.\n\n\n\n\n\nmemset!(less::Gˡᵉˢˢ{T}, x)\n\nReset all the matrix elements of less to x. x should be a scalar number.\n\n\n\n\n\nmemset!(less::Gˡᵉˢˢ{T}, tstp::I64, x)\n\nReset the matrix elements of less at given time step tstp (and at all t where t < tstp) to x. x should be a scalar number.\n\n\n\n\n\nmemset!(cfm::ℱ{T}, x)\n\nReset all the matrix elements of cfm to x. x should be a scalar number.\n\n\n\n\n\nmemset!(cfm::ℱ{T}, tstp::I64, x)\n\nReset the matrix elements of cfm at given time step tstp to x. x should be a scalar number. Note that tstp = 0 means the equilibrium state, at this time this function will reset the Matsubara component only (mat). However, when tstp > 0, the ret, lmix, and less components will be changed.\n\n\n\n\n\nmemset!(mat::gᵐᵃᵗ{S}, x)\n\nReset all the vector elements of mat to x. x should be a scalar number.\n\n\n\n\n\nmemset!(ret::gʳᵉᵗ{S}, x)\n\nReset all the vector elements of ret to x. x should be a scalar number.\n\n\n\n\n\nmemset!(lmix::gˡᵐⁱˣ{S}, x)\n\nReset all the matrix elements of lmix to x. x should be a scalar number.\n\n\n\n\n\nmemset!(less::gˡᵉˢˢ{S}, x)\n\nReset all the matrix elements of less to x. x should be a scalar number.\n\n\n\n\n\nmemset!(cfv::𝒻{S}, x)\n\nReset all the matrix elements of cfv to x. x should be a scalar number.\n\n\n\n\n\nmemset!(cfv::𝒻{S}, tstp::I64, x)\n\nReset all the matrix elements of cfv to x. x should be a scalar number. If tstp = 0, only the mat component is updated. On the other hand, if tstp > 0, the ret, lmix, and less components will be updated.\n\n\n\n\n\n","category":"function"},{"location":"library/type.html#KadanoffBaym.zeros!","page":"Types","title":"KadanoffBaym.zeros!","text":"zeros!(cf::Cf{T})\n\nReset all the matrix elements of cf to zero.\n\n\n\n\n\nzeros!(mat::Gᵐᵃᵗ{T})\n\nReset all the matrix elements of mat to zero.\n\n\n\n\n\nzeros!(ret::Gʳᵉᵗ{T})\n\nReset all the matrix elements of ret to zero.\n\n\n\n\n\nzeros!(ret::Gʳᵉᵗ{T}, tstp::I64)\n\nReset the matrix elements of ret at given time step tstp (and at all t where t < tstp) to zero.\n\n\n\n\n\nzeros!(lmix::Gˡᵐⁱˣ{T})\n\nReset all the matrix elements of lmix to zero.\n\n\n\n\n\nzeros!(lmix::Gˡᵐⁱˣ{T}, tstp::I64)\n\nReset the matrix elements of lmix at given time step tstp to zero.\n\n\n\n\n\nzeros!(less::Gˡᵉˢˢ{T})\n\nReset all the matrix elements of less to zero.\n\n\n\n\n\nzeros!(less::Gˡᵉˢˢ{T}, tstp::I64)\n\nReset the matrix elements of less at given time step tstp (and at all t where t < tstp) to zero.\n\n\n\n\n\nzeros!(cfm::ℱ{T})\n\nReset all the matrix elements of cfm to zero.\n\n\n\n\n\nzeros!(cfm::ℱ{T}, tstp::I64)\n\nReset the matrix elements of cfm at given time step tstp to zero.\n\n\n\n\n\nzeros!(mat::gᵐᵃᵗ{S})\n\nReset all the vector elements of mat to zero.\n\n\n\n\n\nzeros!(ret::gʳᵉᵗ{S})\n\nReset all the vector elements of ret to zero.\n\n\n\n\n\nzeros!(lmix::gˡᵐⁱˣ{S})\n\nReset all the matrix elements of lmix to zero.\n\n\n\n\n\nzeros!(less::gˡᵉˢˢ{S})\n\nReset all the matrix elements of less to zero.\n\n\n\n\n\nzeros!(cfv::𝒻{S})\n\nReset all the matrix elements of cfv to zero.\n\n\n\n\n\nzeros!(cfv::𝒻{S}, tstp::I64)\n\nReset all the matrix elements of cfv to zero at given time step tstp.\n\n\n\n\n\n","category":"function"},{"location":"library/type.html#KadanoffBaym.memcpy!","page":"Types","title":"KadanoffBaym.memcpy!","text":"memcpy!(src::Cf{T}, dst::Cf{T})\n\nCopy all the matrix elements from src to dst.\n\n\n\n\n\nmemcpy!(src::Gᵐᵃᵗ{T}, dst::Gᵐᵃᵗ{T})\n\nCopy all the matrix elements from src to dst.\n\n\n\n\n\nmemcpy!(src::Gʳᵉᵗ{T}, dst::Gʳᵉᵗ{T})\n\nCopy all the matrix elements from src to dst.\n\n\n\n\n\nmemcpy!(src::Gʳᵉᵗ{T}, dst::Gʳᵉᵗ{T}, tstp::I64)\n\nCopy some matrix elements from src to dst. Only the matrix elements at given time step tstp (and at all t where t < tstp) are copied.\n\n\n\n\n\nmemcpy!(src::Gˡᵐⁱˣ{T}, dst::Gˡᵐⁱˣ{T})\n\nCopy all the matrix elements from src to dst.\n\n\n\n\n\nmemcpy!(src::Gˡᵐⁱˣ{T}, dst::Gˡᵐⁱˣ{T}, tstp::I64)\n\nCopy some matrix elements from src to dst. Only the matrix elements at given time step tstp are copied.\n\n\n\n\n\nmemcpy!(src::Gˡᵉˢˢ{T}, dst::Gˡᵉˢˢ{T})\n\nCopy all the matrix elements from src to dst.\n\n\n\n\n\nmemcpy!(src::Gˡᵉˢˢ{T}, dst::Gˡᵉˢˢ{T}, tstp::I64)\n\nCopy some matrix elements from src to dst. Only the matrix elements at given time step tstp (and at all t where t < tstp) are copied.\n\n\n\n\n\nmemcpy!(src::ℱ{T}, dst::ℱ{T}, tstp::I64)\n\nCopy contour Green's function at given time step tstp. Note that tstp = 0 means the equilibrium state, at this time this function will copy the Matsubara component only (mat). However, when tstp > 0, the ret, lmix, and less components will be copied.\n\n\n\n\n\nmemcpy!(src::gᵐᵃᵗ{S}, dst::gᵐᵃᵗ{S})\n\nCopy all the matrix elements from src to dst.\n\n\n\n\n\nmemcpy!(src::Gᵐᵃᵗ{S}, dst::gᵐᵃᵗ{S})\n\nCopy all the matrix elements from src to dst.\n\n\n\n\n\nmemcpy!(src::gᵐᵃᵗ{S}, dst::Gᵐᵃᵗ{S})\n\nCopy all the matrix elements from src to dst.\n\n\n\n\n\nmemcpy!(src::gʳᵉᵗ{S}, dst::gʳᵉᵗ{S})\n\nCopy all the matrix elements from src to dst.\n\n\n\n\n\nmemcpy!(src::Gʳᵉᵗ{S}, dst::gʳᵉᵗ{S})\n\nCopy all the matrix elements from src to dst.\n\n\n\n\n\nmemcpy!(src::gʳᵉᵗ{S}, dst::Gʳᵉᵗ{S})\n\nCopy all the matrix elements from src to dst.\n\n\n\n\n\nmemcpy!(src::gˡᵐⁱˣ{S}, dst::gˡᵐⁱˣ{S})\n\nCopy all the matrix elements from src to dst.\n\n\n\n\n\nmemcpy!(src::Gˡᵐⁱˣ{S}, dst::gˡᵐⁱˣ{S}, tstp::I64)\n\nCopy all the matrix elements from src to dst.\n\n\n\n\n\nmemcpy!(src::gˡᵐⁱˣ{S}, dst::Gˡᵐⁱˣ{S}, tstp::I64)\n\nCopy all the matrix elements from src to dst.\n\n\n\n\n\nmemcpy!(src::gˡᵉˢˢ{S}, dst::gˡᵉˢˢ{S})\n\nCopy all the matrix elements from src to dst.\n\n\n\n\n\nmemcpy!(src::Gˡᵉˢˢ{S}, dst::gˡᵉˢˢ{S})\n\nCopy all the matrix elements from src to dst.\n\n\n\n\n\nmemcpy!(src::gˡᵉˢˢ{S}, dst::Gˡᵉˢˢ{S})\n\nCopy all the matrix elements from src to dst.\n\n\n\n\n\nmemcpy!(src::𝒻{S}, dst::𝒻{S}, tstp::I64)\n\nExtract data from a 𝒻 object (at given time step tstp), then copy them to another 𝒻 object.\n\nSee also: 𝒻.\n\n\n\n\n\nmemcpy!(cfm::ℱ{S}, cfv::𝒻{S}, tstp::I64)\n\nExtract data from a ℱ object (at given time step tstp), then copy them to a 𝒻 object.\n\nSee also: ℱ, 𝒻.\n\n\n\n\n\nmemcpy!(cfv::𝒻{S}, cfm::ℱ{S}, tstp::I64)\n\nExtract data from a 𝒻 object, then copy them to a ℱ object (at given time step tstp).\n\nSee also: ℱ, 𝒻.\n\n\n\n\n\n","category":"function"},{"location":"library/type.html#KadanoffBaym.incr!","page":"Types","title":"KadanoffBaym.incr!","text":"incr!(cf1::Cf{T}, cf2::Cf{T}, α::T)\n\nAdd a Cf with given weight (α) to another Cf. Finally, cf1 will be changed.\n\n\n\n\n\nincr!(mat1::Gᵐᵃᵗ{T}, mat2::Gᵐᵃᵗ{T}, α::T)\n\nAdd a Gᵐᵃᵗ with given weight (α) to another Gᵐᵃᵗ.\n\nG^M_1  G^M_1 + α * G^M_2\n\n\n\n\n\nincr!(ret1::Gʳᵉᵗ{T}, ret2::Gʳᵉᵗ{T}, tstp::I64, α::T)\n\nAdd a Gʳᵉᵗ with given weight (α) at given time step tstp (and at all t where t < tstp) to another Gʳᵉᵗ.\n\n\n\n\n\nincr!(lmix1::Gˡᵐⁱˣ{T}, lmix2::Gˡᵐⁱˣ{T}, tstp::I64, α::T)\n\nAdd a Gˡᵐⁱˣ with given weight (α) at given time step tstp to another Gˡᵐⁱˣ.\n\n\n\n\n\nincr!(less1::Gˡᵉˢˢ{T}, less2::Gˡᵉˢˢ{T}, tstp::I64, α::T)\n\nAdd a Gˡᵉˢˢ with given weight (α) at given time step tstp (and at all t where t < tstp) to another Gˡᵉˢˢ.\n\n\n\n\n\nincr!(cfm1::ℱ{T}, cfm2::ℱ{T}, tstp::I64, α)\n\nAdds a ℱ with given weight (α) to another ℱ (at given time step tstp).\n\n\n\n\n\nincr!(cfm1::ℱ{T}, cfm2::ℱ{T}, α)\n\nAdds a ℱ with given weight (α) to another ℱ (at all possible time step tstp).\n\n\n\n\n\nincr!(mat1::gᵐᵃᵗ{S}, mat2::gᵐᵃᵗ{S}, α::S)\n\nAdd a gᵐᵃᵗ with given weight (α) to another gᵐᵃᵗ.\n\n\n\n\n\nincr!(mat1::Gᵐᵃᵗ{S}, mat2::gᵐᵃᵗ{S}, α::S)\n\nAdd a gᵐᵃᵗ with given weight (α) to a Gᵐᵃᵗ.\n\n\n\n\n\nincr!(mat1::gᵐᵃᵗ{S}, mat2::Gᵐᵃᵗ{S}, α::S)\n\nAdd a Gᵐᵃᵗ with given weight (α) to a gᵐᵃᵗ.\n\n\n\n\n\nincr!(ret1::gʳᵉᵗ{S}, ret2::gʳᵉᵗ{S}, α::S)\n\nAdd a gʳᵉᵗ with given weight (α) to another gʳᵉᵗ.\n\n\n\n\n\nincr!(ret1::Gʳᵉᵗ{S}, ret2::gʳᵉᵗ{S}, α::S)\n\nAdd a gʳᵉᵗ with given weight (α) to a Gʳᵉᵗ.\n\n\n\n\n\nincr!(ret1::gʳᵉᵗ{S}, ret2::Gʳᵉᵗ{S}, α::S)\n\nAdd a Gʳᵉᵗ with given weight (α) to a gʳᵉᵗ.\n\n\n\n\n\nincr!(lmix1::gˡᵐⁱˣ{S}, lmix2::gˡᵐⁱˣ{S}, α::S)\n\nAdd a gˡᵐⁱˣ with given weight (α) to another gˡᵐⁱˣ.\n\n\n\n\n\nincr!(lmix1::Gˡᵐⁱˣ{S}, lmix2::gˡᵐⁱˣ{S}, tstp::I64, α::S)\n\nAdd a gˡᵐⁱˣ with given weight (α) to a Gˡᵐⁱˣ.\n\n\n\n\n\nincr!(lmix1::gˡᵐⁱˣ{S}, lmix2::Gˡᵐⁱˣ{S}, tstp::I64, α::S)\n\nAdd a Gˡᵐⁱˣ with given weight (α) to a gˡᵐⁱˣ.\n\n\n\n\n\nincr!(less1::gˡᵉˢˢ{S}, less2::gˡᵉˢˢ{S}, α::S)\n\nAdd a gˡᵉˢˢ with given weight (α) to another gˡᵉˢˢ.\n\n\n\n\n\nincr!(less1::Gˡᵉˢˢ{S}, less2::gˡᵉˢˢ{S}, α::S)\n\nAdd a gˡᵉˢˢ with given weight (α) to a Gˡᵉˢˢ.\n\n\n\n\n\nincr!(less1::gˡᵉˢˢ{S}, less2::Gˡᵉˢˢ{S}, α::S)\n\nAdd a Gˡᵉˢˢ with given weight (α) to a gˡᵉˢˢ.\n\n\n\n\n\nincr!(cfv1::𝒻{S}, cfv2::𝒻{S}, tstp::I64, α)\n\nAdds a 𝒻 with given weight (α) to another 𝒻 (at given time step tstp).\n\n\n\n\n\nincr!(cfm::ℱ{S}, cfv::𝒻{S}, tstp::I64, α)\n\nAdds a 𝒻 with given weight (α) to a ℱ (at given time step tstp).\n\n\n\n\n\nincr!(cfv::𝒻{S}, cfm::ℱ{S}, tstp::I64, α)\n\nAdds a ℱ with given weight (α) to a 𝒻 (at given time step tstp).\n\n\n\n\n\n","category":"function"},{"location":"library/type.html#KadanoffBaym.smul!","page":"Types","title":"KadanoffBaym.smul!","text":"smul!(cf::Cf{T}, α::T)\n\nMultiply a Cf with given weight (α).\n\n\n\n\n\nsmul!(x::Element{T}, cf::Cf{T})\n\nLeft multiply a Cf with given weight (x).\n\n\n\n\n\nsmul!(cf::Cf{T}, x::Element{T})\n\nRight multiply a Cf with given weight (x).\n\n\n\n\n\nsmul!(mat::Gᵐᵃᵗ{T}, α::T)\n\nMultiply a Gᵐᵃᵗ with given weight (α).\n\nG^M  α * G^M\n\n\n\n\n\nsmul!(x::Element{T}, mat::Gᵐᵃᵗ{T})\n\nLeft multiply a Gᵐᵃᵗ with given weight (x), which is actually a matrix.\n\n\n\n\n\nsmul!(mat::Gᵐᵃᵗ{T}, x::Element{T})\n\nRight multiply a Gᵐᵃᵗ with given weight (x), which is actually a matrix.\n\n\n\n\n\nsmul!(ret::Gʳᵉᵗ{T}, tstp::I64, α::T)\n\nMultiply a Gʳᵉᵗ with given weight (α) at given time step tstp (and at all t where t < tstp).\n\n\n\n\n\nsmul!(x::Element{T}, ret::Gʳᵉᵗ{T}, tstp::I64)\n\nLeft multiply a Gʳᵉᵗ with given weight (x) at given time step tstp (and at all t where t < tstp).\n\n\n\n\n\nsmul!(ret::Gʳᵉᵗ{T}, x::Cf{T}, tstp::I64)\n\nRight multiply a Gʳᵉᵗ with given weight (x) at given time step tstp (and at all t where t < tstp).\n\n\n\n\n\nsmul!(lmix::Gˡᵐⁱˣ{T}, tstp::I64, α::T)\n\nMultiply a Gˡᵐⁱˣ with given weight (α) at given time step tstp.\n\n\n\n\n\nsmul!(x::Element{T}, lmix::Gˡᵐⁱˣ{T}, tstp::I64)\n\nLeft multiply a Gˡᵐⁱˣ with given weight (x) at given time step tstp.\n\n\n\n\n\nsmul!(lmix::Gˡᵐⁱˣ{T}, x::Element{T}, tstp::I64)\n\nRight multiply a Gˡᵐⁱˣ with given weight (x) at given time step tstp.\n\n\n\n\n\nsmul!(less::Gˡᵉˢˢ{T}, tstp::I64, α::T)\n\nMultiply a Gˡᵉˢˢ with given weight (α) at given time step tstp (and at all t where t < tstp).\n\n\n\n\n\nsmul!(x::Cf{T}, less::Gˡᵉˢˢ{T}, tstp::I64)\n\nLeft multiply a Gˡᵉˢˢ with given weight (x) at given time step tstp (and at all t where t < tstp).\n\n\n\n\n\nsmul!(less::Gˡᵉˢˢ{T}, x::Element{T}, tstp::I64)\n\nRight multiply a Gˡᵉˢˢ with given weight (x) at given time step tstp (and at all t where t < tstp).\n\n\n\n\n\nsmul!(cfm::ℱ{T}, tstp::I64, α)\n\nMultiply a ℱ with given weight (α) at given time step tstp.\n\n\n\n\n\nsmul!(cff::Cf{T}, cfm::ℱ{T}, tstp::I64)\n\nLeft multiply a ℱ with given weight (Cf) at given time step tstp.\n\n\n\n\n\nsmul!(cfm::ℱ{T}, cff::Cf{T}, tstp::I64)\n\nRight multiply a ℱ with given weight (Cf) at given time step tstp.\n\n\n\n\n\nsmul!(mat::gᵐᵃᵗ{S}, α::S)\n\nMultiply a gᵐᵃᵗ with given weight (α).\n\n\n\n\n\nsmul!(x::Element{S}, mat::gᵐᵃᵗ{S})\n\nLeft multiply a gᵐᵃᵗ with given weight (x).\n\n\n\n\n\nsmul!(mat::gᵐᵃᵗ{S}, x::Element{S})\n\nRight multiply a gᵐᵃᵗ with given weight (x).\n\n\n\n\n\nsmul!(ret::gʳᵉᵗ{S}, α::S)\n\nMultiply a gʳᵉᵗ with given weight (α).\n\n\n\n\n\nsmul!(x::Element{S}, ret::gʳᵉᵗ{S})\n\nLeft multiply a gʳᵉᵗ with given weight (x).\n\n\n\n\n\nsmul!(ret::gʳᵉᵗ{S}, x::Cf{S})\n\nRight multiply a gʳᵉᵗ with given weight (x).\n\n\n\n\n\nsmul!(lmix::gˡᵐⁱˣ{S}, α::S)\n\nMultiply a gˡᵐⁱˣ with given weight (α).\n\n\n\n\n\nsmul!(x::Element{S}, lmix::gˡᵐⁱˣ{S})\n\nLeft multiply a gˡᵐⁱˣ with given weight (x).\n\n\n\n\n\nsmul!(lmix::gˡᵐⁱˣ{S}, x::Element{S})\n\nRight multiply a gˡᵐⁱˣ with given weight (x).\n\n\n\n\n\nsmul!(less::gˡᵉˢˢ{S}, α::S)\n\nMultiply a gˡᵉˢˢ with given weight (α).\n\n\n\n\n\nsmul!(x::Cf{S}, less::gˡᵉˢˢ{S})\n\nLeft multiply a gˡᵉˢˢ with given weight (x).\n\n\n\n\n\nsmul!(less::gˡᵉˢˢ{S}, x::Element{S})\n\nRight multiply a gˡᵉˢˢ with given weight (x).\n\n\n\n\n\nsmul!(cfv::𝒻{S}, tstp::I64, α)\n\nMultiply a 𝒻 with given weight (α) at given time step tstp.\n\n\n\n\n\nsmul!(cff::Cf{S}, cfv::𝒻{S}, tstp::I64)\n\nLeft multiply a 𝒻 with given weight (Cf) at given time step tstp.\n\n\n\n\n\nsmul!(cfv::𝒻{S}, cff::Cf{S}, tstp::I64)\n\nRight multiply a 𝒻 with given weight (Cf) at given time step tstp.\n\n\n\n\n\n","category":"function"},{"location":"library/type.html#KadanoffBaym.read!","page":"Types","title":"KadanoffBaym.read!","text":"read!(fname::AbstractString, cfm::ℱ{T})\n\nRead the contour Green's functions from given file.\n\n\n\n\n\nread!(fname::AbstractString, cfv::𝒻{S})\n\nRead the contour Green's functions from given file.\n\n\n\n\n\n","category":"function"},{"location":"library/type.html#KadanoffBaym.write","page":"Types","title":"KadanoffBaym.write","text":"write(fname::AbstractString, cfm::ℱ{T})\n\nWrite the contour Green's functions to given file.\n\n\n\n\n\nwrite(fname::AbstractString, cfv::𝒻{S})\n\nWrite the contour Green's functions to given file.\n\n\n\n\n\n","category":"function"},{"location":"library/type.html#Base.getindex","page":"Types","title":"Base.getindex","text":"Base.getindex(cf::Cf{T}, i::I64)\n\nVisit the element stored in Cf object. If i = 0, it returns the element at Matsubara axis. On the other hand, if i > 0, it will return elements at real time axis.\n\n\n\n\n\nBase.getindex(mat::Gᵐᵃᵗ{T}, ind::I64)\n\nVisit the element stored in Gᵐᵃᵗ object.\n\n\n\n\n\nBase.getindex(ret::Gʳᵉᵗ{T}, i::I64, j::I64)\n\nVisit the element stored in Gʳᵉᵗ object. Here i and j are indices for real times.\n\n\n\n\n\nBase.getindex(lmix::Gˡᵐⁱˣ{T}, i::I64, j::I64)\n\nVisit the element stored in Gˡᵐⁱˣ object.\n\n\n\n\n\nBase.getindex(less::Gˡᵉˢˢ{T}, i::I64, j::I64)\n\nVisit the element stored in Gˡᵉˢˢ object.\n\n\n\n\n\nBase.getindex(matm::Gᵐᵃᵗᵐ{T}, ind::I64)\n\nVisit the element stored in Gᵐᵃᵗᵐ object.\n\n\n\n\n\nBase.getindex(adv::Gᵃᵈᵛ{T}, ind::I64)\n\nVisit the element stored in Gᵃᵈᵛ object.\n\n\n\n\n\nBase.getindex(rmix::Gʳᵐⁱˣ{T}, i::I64, j::I64)\n\nVisit the element stored in Gʳᵐⁱˣ object.\n\n\n\n\n\nBase.getindex(gtr::Gᵍᵗʳ{T}, i::I64, j::I64)\n\nVisit the element stored in Gᵍᵗʳ object.\n\n\n\n\n\nBase.getindex(mat::gᵐᵃᵗ{S}, ind::I64)\n\nVisit the element stored in gᵐᵃᵗ object.\n\n\n\n\n\nBase.getindex(ret::gʳᵉᵗ{S}, j::I64)\n\nVisit the element stored in gʳᵉᵗ object. Here j is index for real times.\n\n\n\n\n\nBase.getindex(ret::gʳᵉᵗ{S}, i::I64, tstp::I64)\n\nVisit the element stored in gʳᵉᵗ object. Here i is index for real times.\n\n\n\n\n\nBase.getindex(lmix::gˡᵐⁱˣ{S}, j::I64)\n\nVisit the element stored in gˡᵐⁱˣ object.\n\n\n\n\n\nBase.getindex(less::gˡᵉˢˢ{S}, i::I64)\n\nVisit the element stored in gˡᵉˢˢ object.\n\n\n\n\n\nBase.getindex(less::gˡᵉˢˢ{S}, tstp::I64, j::I64)\n\nVisit the element stored in gˡᵉˢˢ object.\n\n\n\n\n\nBase.getindex(matm::gᵐᵃᵗᵐ{S}, ind::I64)\n\nVisit the element stored in gᵐᵃᵗᵐ object.\n\n\n\n\n\nBase.getindex(adv::gᵃᵈᵛ{S}, ind::I64)\n\nVisit the element stored in gᵃᵈᵛ object.\n\n\n\n\n\nBase.getindex(rmix::gʳᵐⁱˣ{S}, i::I64)\n\nVisit the element stored in gʳᵐⁱˣ object.\n\n\n\n\n\nBase.getindex(gtr::gᵍᵗʳ{S}, i::I64)\n\nVisit the element stored in gᵍᵗʳ object.\n\n\n\n\n\nBase.getindex(gtr::gᵍᵗʳ{S}, tstp::I64, j::I64)\n\nVisit the element stored in gᵍᵗʳ object.\n\n\n\n\n\nBase.getindex(cfm::ℱ{T}, tstp::I64)\n\nReturn contour Green's function at given time step tstp.\n\nSee also: ℱ, 𝒻.\n\n\n\n\n\nBase.getindex(AW::AbstractWeights, inds::Vararg{I64})\n\nProvide a fast access to the weights. AW denotes the type of weights, and inds is for the indices. This function works for the following structs only:\n\nPolynomialInterpolationWeights\nPolynomialDifferentiationWeights\nPolynomialIntegrationWeights\nBackwardDifferentiationWeights\nBoundaryConvolutionWeights\n\n\n\n\n\nBase.getindex(GW::GregoryIntegrationWeights, inds::Vararg{I64})\n\nProvide a fast access to the weights. GW denotes the type of weights, and inds is for the indices. This function works for the following structs only:\n\nGregoryIntegrationWeights\n\nReferences :\n\nSee Remarks : Gregory Integration.\n\n\n\n\n\n","category":"function"},{"location":"library/type.html#Base.setindex!","page":"Types","title":"Base.setindex!","text":"Base.setindex!(cf::Cf{T}, x::Element{T}, i::I64)\n\nSetup the element in Cf object. If i = 0, it will setup the element at Matsubara axis to x. On the other hand, if i > 0, it will setup elements at real time axis.\n\n\n\n\n\nBase.setindex!(cf::Cf{T}, v::T, i::I64)\n\nSetup the element in Cf object. If i = 0, it will setup the element at Matsubara axis to v. On the other hand, if i > 0, it will setup elements at real time axis. Here, v should be a scalar number.\n\n\n\n\n\nBase.setindex!(mat::Gᵐᵃᵗ{T}, x::Element{T}, ind::I64)\n\nSetup the element in Gᵐᵃᵗ object.\n\n\n\n\n\nBase.setindex!(mat::Gᵐᵃᵗ{T}, v::T, ind::I64)\n\nSetup the element in Gᵐᵃᵗ object.\n\n\n\n\n\nBase.setindex!(ret::Gʳᵉᵗ{T}, x::Element{T}, i::I64, j::I64)\n\nSetup the element in Gʳᵉᵗ object.\n\n\n\n\n\nBase.setindex!(ret::Gʳᵉᵗ{T}, v::T, i::I64, j::I64)\n\nSetup the element in Gʳᵉᵗ object.\n\n\n\n\n\nBase.setindex!(lmix::Gˡᵐⁱˣ{T}, x::Element{T}, i::I64, j::I64)\n\nSetup the element in Gˡᵐⁱˣ object.\n\n\n\n\n\nBase.setindex!(lmix::Gˡᵐⁱˣ{T}, v::T, i::I64, j::I64)\n\nSetup the element in Gˡᵐⁱˣ object.\n\n\n\n\n\nBase.setindex!(less::Gˡᵉˢˢ{T}, x::Element{T}, i::I64, j::I64)\n\nSetup the element in Gˡᵉˢˢ object.\n\n\n\n\n\nBase.setindex!(less::Gˡᵉˢˢ{T}, v::T, i::I64, j::I64)\n\nSetup the element in Gˡᵉˢˢ object.\n\n\n\n\n\nBase.setindex!(mat::gᵐᵃᵗ{S}, x::Element{S}, ind::I64)\n\nSetup the element in gᵐᵃᵗ object.\n\n\n\n\n\nBase.setindex!(mat::gᵐᵃᵗ{S}, v::S, ind::I64)\n\nSetup the element in gᵐᵃᵗ object.\n\n\n\n\n\nBase.setindex!(ret::gʳᵉᵗ{S}, x::Element{S}, j::I64)\n\nSetup the element in gʳᵉᵗ object.\n\n\n\n\n\nBase.setindex!(ret::gʳᵉᵗ{S}, v::S, j::I64)\n\nSetup the element in gʳᵉᵗ object.\n\n\n\n\n\nBase.setindex!(lmix::gˡᵐⁱˣ{S}, x::Element{S}, j::I64)\n\nSetup the element in gˡᵐⁱˣ object.\n\n\n\n\n\nBase.setindex!(lmix::gˡᵐⁱˣ{S}, v::S, j::I64)\n\nSetup the element in gˡᵐⁱˣ object.\n\n\n\n\n\nBase.setindex!(less::gˡᵉˢˢ{S}, x::Element{S}, i::I64)\n\nSetup the element in gˡᵉˢˢ object.\n\n\n\n\n\nBase.setindex!(less::gˡᵉˢˢ{S}, v::S, i::I64)\n\nSetup the element in gˡᵉˢˢ object.\n\n\n\n\n\nBase.setindex!(cfm::ℱ{S}, cfv::𝒻{S}, tstp::I64)\n\nSetup contout Green's function at given time step tstp.\n\nSee also: ℱ, 𝒻.\n\n\n\n\n\n","category":"function"},{"location":"library/type.html#Base.getproperty","page":"Types","title":"Base.getproperty","text":"Base.getproperty(cfm::ℱ{T}, symbol::Symbol)\n\nVisit the properties stored in ℱ object. It provides access to the Matsubara (minus, matm), advanced (adv), right-mixing (rmix), and greater (gtr) components of the contour-ordered Green's function.\n\n\n\n\n\nBase.getproperty(cfv::𝒻{S}, symbol::Symbol)\n\nVisit the properties stored in 𝒻 object. It provides access to the Matsubara (minus, matm), advanced (adv), right-mixing (rmix), and greater (gtr) components of the contour-ordered Green's function at given time step tstp..\n\n\n\n\n\n","category":"function"},{"location":"library/type.html#Base.show","page":"Types","title":"Base.show","text":"Base.show(io::IO, C::Cn)\n\nDisplay Cn struct on the terminal.\n\nSee also: Cn.\n\n\n\n\n\n","category":"function"},{"location":"library/type.html#Base.:+","page":"Types","title":"Base.:+","text":"Base.:+(cf1::Cf{T}, cf2::Cf{T})\n\nOperation + for two Cf objects.\n\n\n\n\n\nBase.:+(mat1::Gᵐᵃᵗ{T}, mat2::Gᵐᵃᵗ{T})\n\nOperation + for two Gᵐᵃᵗ objects.\n\n\n\n\n\nBase.:+(ret1::Gʳᵉᵗ{T}, ret2::Gʳᵉᵗ{T})\n\nOperation + for two Gʳᵉᵗ objects.\n\n\n\n\n\nBase.:+(lmix1::Gˡᵐⁱˣ{T}, lmix2::Gˡᵐⁱˣ{T})\n\nOperation + for two Gˡᵐⁱˣ objects.\n\n\n\n\n\nBase.:+(less1::Gˡᵉˢˢ{T}, less2::Gˡᵉˢˢ{T})\n\nOperation + for two Gˡᵉˢˢ objects.\n\n\n\n\n\nBase.:+(mat1::gᵐᵃᵗ{S}, mat2::gᵐᵃᵗ{S})\n\nOperation + for two gᵐᵃᵗ objects.\n\n\n\n\n\nBase.:+(ret1::gʳᵉᵗ{S}, ret2::gʳᵉᵗ{S})\n\nOperation + for two gʳᵉᵗ objects.\n\n\n\n\n\nBase.:+(lmix1::gˡᵐⁱˣ{S}, lmix2::gˡᵐⁱˣ{S})\n\nOperation + for two gˡᵐⁱˣ objects.\n\n\n\n\n\nBase.:+(less1::gˡᵉˢˢ{S}, less2::gˡᵉˢˢ{S})\n\nOperation + for two gˡᵉˢˢ objects.\n\n\n\n\n\n","category":"function"},{"location":"library/type.html#Base.:-","page":"Types","title":"Base.:-","text":"Base.:-(cf1::Cf{T}, cf2::Cf{T})\n\nOperation - for two Cf objects.\n\n\n\n\n\nBase.:-(mat1::Gᵐᵃᵗ{T}, mat2::Gᵐᵃᵗ{T})\n\nOperation - for two Gᵐᵃᵗ objects.\n\n\n\n\n\nBase.:-(ret1::Gʳᵉᵗ{T}, ret2::Gʳᵉᵗ{T})\n\nOperation - for two Gʳᵉᵗ objects.\n\n\n\n\n\nBase.:-(lmix1::Gˡᵐⁱˣ{T}, lmix2::Gˡᵐⁱˣ{T})\n\nOperation - for two Gˡᵐⁱˣ objects.\n\n\n\n\n\nBase.:-(less1::Gˡᵉˢˢ{T}, less2::Gˡᵉˢˢ{T})\n\nOperation - for two Gˡᵉˢˢ objects.\n\n\n\n\n\nBase.:-(mat1::gᵐᵃᵗ{S}, mat2::gᵐᵃᵗ{S})\n\nOperation - for two gᵐᵃᵗ objects.\n\n\n\n\n\nBase.:-(ret1::gʳᵉᵗ{S}, ret2::gʳᵉᵗ{S})\n\nOperation - for two gʳᵉᵗ objects.\n\n\n\n\n\nBase.:-(lmix1::gˡᵐⁱˣ{S}, lmix2::gˡᵐⁱˣ{S})\n\nOperation - for two gˡᵐⁱˣ objects.\n\n\n\n\n\nBase.:-(less1::gˡᵉˢˢ{S}, less2::gˡᵉˢˢ{S})\n\nOperation - for two gˡᵉˢˢ objects.\n\n\n\n\n\n","category":"function"},{"location":"library/type.html#Base.:*","page":"Types","title":"Base.:*","text":"Base.:*(cf::Cf{T}, x)\n\nOperation * for a Cf object and a scalar value.\n\n\n\n\n\nBase.:*(x, cf::Cf{T})\n\nOperation * for a scalar value and a Cf object.\n\n\n\n\n\nBase.:*(mat::Gᵐᵃᵗ{T}, x)\n\nOperation * for a Gᵐᵃᵗ object and a scalar value.\n\n\n\n\n\nBase.:*(x, mat::Gᵐᵃᵗ{T})\n\nOperation * for a scalar value and a Gᵐᵃᵗ object.\n\n\n\n\n\nBase.:*(ret::Gʳᵉᵗ{T}, x)\n\nOperation * for a Gʳᵉᵗ object and a scalar value.\n\n\n\n\n\nBase.:*(x, ret::Gʳᵉᵗ{T})\n\nOperation * for a scalar value and a Gʳᵉᵗ object.\n\n\n\n\n\nBase.:*(lmix::Gˡᵐⁱˣ{T}, x)\n\nOperation * for a Gˡᵐⁱˣ object and a scalar value.\n\n\n\n\n\nBase.:*(x, lmix::Gˡᵐⁱˣ{T})\n\nOperation * for a scalar value and a Gˡᵐⁱˣ object.\n\n\n\n\n\nBase.:*(less::Gˡᵉˢˢ{T}, x)\n\nOperation * for a Gˡᵉˢˢ object and a scalar value.\n\n\n\n\n\nBase.:*(x, less::Gˡᵉˢˢ{T})\n\nOperation * for a scalar value and a Gˡᵉˢˢ object.\n\n\n\n\n\nBase.:*(mat::gᵐᵃᵗ{S}, x)\n\nOperation * for a gᵐᵃᵗ object and a scalar value.\n\n\n\n\n\nBase.:*(x, mat::gᵐᵃᵗ{S})\n\nOperation * for a scalar value and a gᵐᵃᵗ object.\n\n\n\n\n\nBase.:*(ret::gʳᵉᵗ{S}, x)\n\nOperation * for a gʳᵉᵗ object and a scalar value.\n\n\n\n\n\nBase.:*(x, ret::gʳᵉᵗ{S})\n\nOperation * for a scalar value and a gʳᵉᵗ object.\n\n\n\n\n\nBase.:*(lmix::gˡᵐⁱˣ{S}, x)\n\nOperation * for a gˡᵐⁱˣ object and a scalar value.\n\n\n\n\n\nBase.:*(x, lmix::gˡᵐⁱˣ{S})\n\nOperation * for a scalar value and a gˡᵐⁱˣ object.\n\n\n\n\n\nBase.:*(less::gˡᵉˢˢ{S}, x)\n\nOperation * for a gˡᵉˢˢ object and a scalar value.\n\n\n\n\n\nBase.:*(x, less::gˡᵉˢˢ{S})\n\nOperation * for a scalar value and a gˡᵉˢˢ object.\n\n\n\n\n\n","category":"function"},{"location":"index.html#KadanoffBaym","page":"Welcome","title":"KadanoffBaym","text":"","category":"section"},{"location":"index.html","page":"Welcome","title":"Welcome","text":"A non-equilibrium dynamical mean-field theory engine in Julia","category":"page"},{"location":"index.html","page":"Welcome","title":"Welcome","text":"info: Info\nThank you for using KadanoffBaym. This documentation will help you to be familiar with and explore the KadanoffBaym library. It is just compatible with KadanoffBaym v0.1.1-devel.250930.","category":"page"},{"location":"index.html","page":"Welcome","title":"Welcome","text":"warning: Warning\nThe KadanoffBaym library is in heavy development. Please use it at your own risk. If you encounter any bugs or troubles, or require new features, please consult me directly: huangli at caep.cn","category":"page"},{"location":"library/kadanoffbaym.html","page":"KadanoffBaym","title":"KadanoffBaym","text":"Declare the module and public members.","category":"page"},{"location":"library/kadanoffbaym.html#Modules","page":"KadanoffBaym","title":"Modules","text":"","category":"section"},{"location":"library/kadanoffbaym.html#KadanoffBaym","page":"KadanoffBaym","title":"KadanoffBaym","text":"KadanoffBaym\n\nThe KadanoffBaym package is a state-of-the-art computational framework for simulating the non-equilibrium strongly correlated electron systems. It provides some useful application programming interfaces to manipulate the non-equilibrium Green's functions defined on the 𝐿-shape Kadanoff-Baym contour, including:\n\nBasic integration and differentiation rules\nBasic operations for Contour Green's functions\nBasic diagrammatic algorithms based on many-body perturbation theory\nSolve Volterra integral equations\nSolve Volterra integro-differential equations\nConvolution between two contour Green's functions\n\nThis package is inspired by the NESSi (The Non-Equilibrium Systems Simulation package) code, which was developed and maintained by Martin Eckstein et al. Actually, it can be regarded as a replacement of the NESSi package for those peoples who don't like or aren't familiar with C++.\n\nReferences\n\n[NESSi] Martin Eckstein, et al., NESSi: The Non-Equilibrium Systems Simulation package, Computer Physics Communications 257, 107484 (2020)\n\n[REVIEW] Philipp Werner, et al., Nonequilibrium dynamical mean-field theory and its applications, Reviews of Modern Physics 86, 779 (2014)\n\n[MABOOK] Johan de Villiers, Mathematics of Approximation, Atlantis Press (2012)\n\n[MATABLE] Dan Zwillinger (editor), CRC Standard Mathematical Tables and Formulas (33rd edition), CRC Press (Taylor & Francis Group) (2018)\n\n[QUADRATURE] Ruben J. Espinosa-Maldonado and George D. Byrne, On the Convergence of Quadrature Formulas, SIAM J. Numer. Anal. 8, 110 (1971)\n\n\n\n\n\n","category":"module"},{"location":"library/kadanoffbaym.html#Initialization","page":"KadanoffBaym","title":"Initialization","text":"","category":"section"},{"location":"library/kadanoffbaym.html#KadanoffBaym._precompile","page":"KadanoffBaym","title":"KadanoffBaym._precompile","text":"_precompile()\n\nHere, we would like to precompile the whole KadanoffBaym toolkit to reduce the runtime latency and speed up the successive calculations.\n\n\n\n\n\n","category":"function"},{"location":"library/kadanoffbaym.html#KadanoffBaym.__init__","page":"KadanoffBaym","title":"KadanoffBaym.__init__","text":"__init__()\n\nThis function would be executed immediately after the module is loaded at runtime for the first time. It works at the REPL mode only.\n\n\n\n\n\n","category":"function"}]
}

var documenterSearchIndex = {"docs":
[{"location":"examples/generate.html#Generating-spectra-and-correlators","page":"Generating spectra and correlators","title":"Generating spectra and correlators","text":"","category":"section"},{"location":"examples/generate.html","page":"Generating spectra and correlators","title":"Generating spectra and correlators","text":"info: Info\nIn the actest/tests directory, there are seven typical test cases. Users can modify them to meet their requirements. This section will use an independent example to demonstrate the basic usage of the ACTest toolkit.","category":"page"},{"location":"examples/generate.html","page":"Generating spectra and correlators","title":"Generating spectra and correlators","text":"Now let us test the performance of the maximum entropy method in the ACFlow toolkit. We just consider four typical scenarios: (1) Fermionic Green's functions, A(omega)  0; (2) Fermionic Green's functions, A(omega) is non-positive definite; (3) Bosonic Green's functions, A(omega)  0; (4) Bosonic Green's functions, A(omega) is non-positive definite. For each scenario, we apply the ACTest toolkit to randomly generate 100 spectral functions and corresponding Green's functions. The spectral functions are continuum. They are constructed with Gaussian peaks. The number of possible peaks in each A(omega) ranges from 1 to 6. The synthetic Green's functions are on the Matsubara frequency axis. The number of Matsubara frequency points is 10. The noise level is 10^-6. The act.toml file for scenario (3) is shown below.","category":"page"},{"location":"examples/generate.html","page":"Generating spectra and correlators","title":"Generating spectra and correlators","text":"[Test]\nsolver  = \"MaxEnt\" # Analytic continuation solver in the ACFlow toolkit\nptype   = \"gauss\"  # Type of peaks\nktype   = \"boson\"  # Type of kernels\ngrid    = \"bfreq\"  # Type of grids\nmesh    = \"linear\" # Type of meshes\nngrid   = 10       # Number of grid points\nnmesh   = 801      # Number of mesh points\nntest   = 100      # Number of tests\nwmax    = 8.0      # Right boundary of frequency mesh\nwmin    = -8.0     # Left boundary of frequency mesh\npmax    = 4.0      # Right boundary of peaks\npmin    = -4.0     # Left boundary of peaks\nbeta    = 20.0     # Inverse temperature\nnoise   = 1.0e-6   # Noise level\noffdiag = false    # Whether the spectrum is positive\nlpeak   = [1,2,3,4,5,6] # Possible number of peaks","category":"page"},{"location":"examples/generate.html","page":"Generating spectra and correlators","title":"Generating spectra and correlators","text":"Once the \\texttt{act.toml} file is prepared, the following command should be executed in the terminal:","category":"page"},{"location":"examples/generate.html","page":"Generating spectra and correlators","title":"Generating spectra and correlators","text":"$ actest/util/acgen.jl act.toml","category":"page"},{"location":"examples/generate.html","page":"Generating spectra and correlators","title":"Generating spectra and correlators","text":"Then, the ACTest toolkit will generate the required data in the present directory. Now there are 100 image.data.i and green.data.i files, where i ranges from 1 to 100. These correspond to A(omega) and G(iomega_n) for bosonic systems. We can further verify the data to make sure A(omega)  0. Finally, we have to copy the act.toml file to another directory, change the ktype, grid, and offdiag parameters in it, and then execute the above command again to generate testing datasets for the other scenarios.","category":"page"},{"location":"library/config.html#Configuration","page":"Configuration","title":"Configuration","text":"","category":"section"},{"location":"library/config.html","page":"Configuration","title":"Configuration","text":"Read, parse, and extract the configuration parameters.","category":"page"},{"location":"library/config.html#Contents","page":"Configuration","title":"Contents","text":"","category":"section"},{"location":"library/config.html","page":"Configuration","title":"Configuration","text":"Pages = [\"config.md\"]\nDepth = 2","category":"page"},{"location":"library/config.html#Index","page":"Configuration","title":"Index","text":"","category":"section"},{"location":"library/config.html","page":"Configuration","title":"Configuration","text":"Pages = [\"config.md\"]","category":"page"},{"location":"library/config.html#Parser","page":"Configuration","title":"Parser","text":"","category":"section"},{"location":"library/config.html","page":"Configuration","title":"Configuration","text":"inp_toml\nfil_dict\nrev_dict\nsee_dict","category":"page"},{"location":"library/config.html#ACTest.inp_toml","page":"Configuration","title":"ACTest.inp_toml","text":"inp_toml(f::String, necessary::Bool)\n\nParse the configuration file (in toml format). It reads the whole file.\n\nArguments\n\nf -> Filename of configuration.\nnecessary -> If it is true and configuration is absent, raise an error.\n\nReturns\n\ndict -> A Dictionary struct that contains all the key-value pairs.\n\n\n\n\n\n","category":"function"},{"location":"library/config.html#ACTest.fil_dict","page":"Configuration","title":"ACTest.fil_dict","text":"fil_dict(cfg::Dict{String,Any})\n\nTransfer configurations from dict cfg to internal dict (PTEST). In other words, all the relevant internal dicts should be filled / updated in this function.\n\nArguments\n\ncfg -> A dict struct that contains all the configurations (from act.toml).\n\nReturns\n\nN/A\n\n\n\n\n\n","category":"function"},{"location":"library/config.html#ACTest.rev_dict","page":"Configuration","title":"ACTest.rev_dict","text":"rev_dict(TEST::Dict{String,Any})\n\nSetup the configuration dictionary: PTEST.\n\nArguments\n\nTEST -> A dict struct that contains configurations from the [Test] block.\n\nReturns\n\nN/A\n\nSee also: PTEST.\n\n\n\n\n\nrev_dict(TEST::Dict{String,Vector{Any}})\n\nSetup the configuration dictionary: PTEST.\n\nArguments\n\nTEST -> A dict struct that contains configurations from the [Test] block.\n\nReturns\n\nN/A\n\nSee also: PTEST.\n\n\n\n\n\n","category":"function"},{"location":"library/config.html#ACTest.see_dict","page":"Configuration","title":"ACTest.see_dict","text":"see_dict()\n\nDisplay all of the relevant configuration parameters to the terminal.\n\nArguments\n\nN/A\n\nReturns\n\nN/A\n\nSee also: fil_dict.\n\n\n\n\n\n","category":"function"},{"location":"library/config.html#Validation","page":"Configuration","title":"Validation","text":"","category":"section"},{"location":"library/config.html","page":"Configuration","title":"Configuration","text":"chk_dict\n_v","category":"page"},{"location":"library/config.html#ACTest.chk_dict","page":"Configuration","title":"ACTest.chk_dict","text":"chk_dict()\n\nValidate the correctness and consistency of configurations.\n\nArguments\n\nN/A\n\nReturns\n\nN/A\n\nSee also: fil_dict, _v.\n\n\n\n\n\n","category":"function"},{"location":"library/config.html#ACTest._v","page":"Configuration","title":"ACTest._v","text":"_v(key::String, val::Array{Any,1})\n\nVerify the value array. Called by chk_dict() function only.\n\nArguments\n\nkey -> Key of parameter.\nval -> Value of parameter.\n\nReturns\n\nN/A\n\nSee also: chk_dict.\n\n\n\n\n\n","category":"function"},{"location":"library/config.html#Extraction","page":"Configuration","title":"Extraction","text":"","category":"section"},{"location":"library/config.html","page":"Configuration","title":"Configuration","text":"get_t","category":"page"},{"location":"library/config.html#ACTest.get_t","page":"Configuration","title":"ACTest.get_t","text":"get_t(key::String)\n\nExtract configurations from dict: PTEST.\n\nArguments\n\nkey -> Key of parameter.\n\nReturns\n\nvalue -> Value of parameter.\n\nSee also: PTEST.\n\n\n\n\n\n","category":"function"},{"location":"theory/kernel.html#Kernels","page":"Kernels","title":"Kernels","text":"","category":"section"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"Just as stated above, the spectral function and the imaginary time or Matsubara Green's function are related with each other by the Laplace transformation:","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"beginequation\nG(x) = int domegaK(xomega) A(omega)\nendequation","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"Here K(xomega) is the so-called kernel function. It plays a key role in this equation. In this section, we would like to introduce the kernels that have been implemented in ACTest.","category":"page"},{"location":"theory/kernel.html#Fermionic-kernels","page":"Kernels","title":"Fermionic kernels","text":"","category":"section"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"For fermionic Green's function, we have","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"beginequation\nG(tau) = int^+infty_-infty domega\n          frace^-tauomega1 + e^-betaomega A(omega)\nendequation","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"and","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"beginequation\nG(iomega_n) = int^+infty_-infty domega\n               frac1iomega_n - omega A(omega)\nendequation","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"The kernels are defined as","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"beginequation\nK(tauomega) = frace^-tauomega1 + e^-betaomega\nendequation","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"and","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"beginequation\nK(omega_nomega) = frac1iomega_n - omega\nendequation","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"For fermionic systems, A(omega) is defined on (-inftyinfty). It is causal, i.e., A(omega) ge 0.","category":"page"},{"location":"theory/kernel.html#Bosonic-kernels","page":"Kernels","title":"Bosonic kernels","text":"","category":"section"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"For bosonic system, the spectral function obeys the following constraint:","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"beginequation\ntextsign(omega) A(omega) ge 0\nendequation","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"It is quite convenient to introduce a new variable tildeA(omega):","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"beginequation\ntildeA(omega) = fracA(omega)omega\nendequation","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"Clearly, tildeA(omega) ge 0. It means that tildeA(omega) is positive definite. So, we have","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"beginequation\nG(tau)\n= int^+infty_-infty domega\n          frace^-tauomega1 - e^-betaomega\n          A(omega)\n=int^+infty_-infty domega\n          fracomega e^-tauomega1 - e^-betaomega\n          tildeA(omega)\nendequation","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"and","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"beginequation\nG(iomega_n) = int^+infty_-infty domega\n               frac1iomega_n - omega A(omega)\n                 = int^+infty_-infty domega\n               fracomegaiomega_n - omega tildeA(omega)\nendequation","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"The corresponding kernels read:","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"beginequation\nK(tauomega) = fracomega e^-tauomega1 - e^-betaomega\nendequation","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"and","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"beginequation\nK(omega_nomega) = fracomegaiomega_n - omega\nendequation","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"Especially,","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"beginequation\nK(tauomega = 0) equiv frac1beta\nendequation","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"and","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"beginequation\nK(omega_n = 0omega = 0) equiv -1\nendequation","category":"page"},{"location":"theory/kernel.html#Symmetric-bosonic-kernels","page":"Kernels","title":"Symmetric bosonic kernels","text":"","category":"section"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"This is a special case for the bosonic Green's function with Hermitian bosonic operators. Here, the spectral function A(omega) is an odd function. Let us introduce tildeA(omega) = A(omega)omega again. Since tildeA(omega) is an even function, we can restrict it in (0infty). Now we have","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"beginequation\nG(tau)\n= int^infty_0 domega\n              fracomega e^-tauomega + e^-(beta - tau)omega\n                   1 - e^-betaomega\n              tildeA(omega)\nendequation","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"and","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"beginequation\nG(iomega_n) = int^infty_0 domega\n                   frac-2omega^2omega_n^2 + omega^2 tildeA(omega)\nendequation","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"The corresponding kernel functions read:","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"beginequation\nK(tauomega) =\n    fracomega e^-tauomega + e^-(beta - tau)omega\n    1 - e^-betaomega\nendequation","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"and","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"beginequation\nK(omega_n omega) = frac-2omega^2omega_n^2 + omega^2\nendequation","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"There are two special cases:","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"beginequation\nK(tauomega = 0) = frac2beta\nendequation","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"and","category":"page"},{"location":"theory/kernel.html","page":"Kernels","title":"Kernels","text":"beginequation\nK(omega_n = 0omega = 0) = -2\nendequation","category":"page"},{"location":"library/inout.html#Input-and-output","page":"Input and output","title":"Input and output","text":"","category":"section"},{"location":"library/inout.html","page":"Input and output","title":"Input and output","text":"Define input and output functions for the ACTest toolkit.","category":"page"},{"location":"library/inout.html#Contents","page":"Input and output","title":"Contents","text":"","category":"section"},{"location":"library/inout.html","page":"Input and output","title":"Input and output","text":"Pages = [\"inout.md\"]\nDepth = 2","category":"page"},{"location":"library/inout.html#Index","page":"Input and output","title":"Index","text":"","category":"section"},{"location":"library/inout.html","page":"Input and output","title":"Input and output","text":"Pages = [\"inout.md\"]","category":"page"},{"location":"library/inout.html#Write-Data","page":"Input and output","title":"Write Data","text":"","category":"section"},{"location":"library/inout.html","page":"Input and output","title":"Input and output","text":"write_spectrum\nwrite_backward","category":"page"},{"location":"library/inout.html#ACTest.write_spectrum","page":"Input and output","title":"ACTest.write_spectrum","text":"write_spectrum(am::AbstractMesh, Aout::Vector{F64})\n\nWrite spectrum A(ω) to image.data. The grid is defined in am, and the spectral data are contained in Aout.\n\nArguments\n\nam   -> Real frequency mesh, ω.\nAout -> Spectral function, A(ω).\n\nReturns\n\nN/A\n\n\n\n\n\nwrite_spectrum(ind::I64, sf::SpectralFunction)\n\nWrite spectrum A(ω) to image.data.i. All information about the spectral function is included in sf.\n\nArguments\n\nind -> Index for the spectral function.\nsf -> A SpectralFunction struct.\n\nReturns\n\nN/A\n\n\n\n\n\n","category":"function"},{"location":"library/inout.html#ACTest.write_backward","page":"Input and output","title":"ACTest.write_backward","text":"write_backward(ag::AbstractGrid, G::Vector{F64})\n\nWe can use the calculated spectrum in real axis to generate the Green's function data in imaginary axis. This function will write the data to green.data, which can be fed into the analytic continuation tools. Here, G is the constructed Green's function data.\n\nArguments\n\nag -> Grid for input data.\nG  -> Constructed Green's function.\n\nReturns\n\nN/A\n\nSee also: reprod.\n\n\n\n\n\nwrite_backward(ind::I64, gf::GreenFunction)\n\nWrite the Green's function data to green.data.i. All information about the Green's function is included in gf.\n\nArguments\n\nind -> Index for the Green's function.\ngf -> A GreenFunction struct.\n\nReturns\n\nN/A\n\nSee also: reprod.\n\n\n\n\n\n","category":"function"},{"location":"intro/cite.html#Citation","page":"Citation","title":"Citation","text":"","category":"section"},{"location":"intro/cite.html","page":"Citation","title":"Citation","text":"Please cite the following papers:","category":"page"},{"location":"intro/cite.html","page":"Citation","title":"Citation","text":"","category":"page"},{"location":"intro/cite.html","page":"Citation","title":"Citation","text":"[1] Li Huang, ACTest: A testing toolkit for analytic continuation methods and codes, arXiv:2411.16412 (2024).","category":"page"},{"location":"examples/acflow.html#Analytic-continuation-simulations","page":"Analytic continuation simulations","title":"Analytic continuation simulations","text":"","category":"section"},{"location":"examples/acflow.html","page":"Analytic continuation simulations","title":"Analytic continuation simulations","text":"info: Info\nIn the actest/tests directory, there are seven typical test cases. Users can modify them to meet their requirements. This section will use an independent example to demonstrate the basic usage of the ACTest toolkit.","category":"page"},{"location":"examples/acflow.html","page":"Analytic continuation simulations","title":"Analytic continuation simulations","text":"Next, we have to add a [Solver] section in the act.toml file to setup the control parameters for the MaxEnt analytic continuation solver (which implements the maximum entropy method) in the ACFlow toolkit. The spirit of the maximum entropy entropy is to figure out the optimal A, that minimizes the following functional:","category":"page"},{"location":"examples/acflow.html","page":"Analytic continuation simulations","title":"Analytic continuation simulations","text":"beginequation\nQA = frac12chi^2A - alpha SA\nendequation","category":"page"},{"location":"examples/acflow.html","page":"Analytic continuation simulations","title":"Analytic continuation simulations","text":"Here, chi^2 is the so-called goodness-of-fit functional, which measures the distance between the reconstructed Green's function and the original Green's function. S is the entropic term. Usually the Shannon-Jaynes entropy is used. alpha is a hyperparameter. In this example, we adopt the chi2kink algorithm to determine the optimized alpha parameters. The list of the alpha parameters contains 10 elements. The initial value of alpha is alpha_1 = 10^12, and the ratio between two consecutive alpha parameters (alpha_i  alpha_i+1) is 10. The complete [Solver] section is shown as follows:","category":"page"},{"location":"examples/acflow.html","page":"Analytic continuation simulations","title":"Analytic continuation simulations","text":"[Solver]\nmethod = \"chi2kink\" # Method to optimize the \\alpha parameter\nstype  = \"sj\"       # Typer of the entropic term\nnalph  = 12         # Number of \\alpha parameter\nalpha  = 1e12       # Initial value of \\alpha\nratio  = 10.0       # Ratio between two successive \\alpha parameters\nblur   = -1.0       # Whether we should broaden the kernel","category":"page"},{"location":"examples/acflow.html","page":"Analytic continuation simulations","title":"Analytic continuation simulations","text":"Please execute the following command in the terminal:","category":"page"},{"location":"examples/acflow.html","page":"Analytic continuation simulations","title":"Analytic continuation simulations","text":"$ actest/util/acflow.jl act.toml","category":"page"},{"location":"examples/acflow.html","page":"Analytic continuation simulations","title":"Analytic continuation simulations","text":"It will launch the ACFlow toolkit to perform analytic continuation calculations and generate a lot of output files. In addition to the Aout.data.i file, perhaps the most important file is summary.data. It records the error, status (pass or fail), and duration time for each test. So, we visualize the summary.data file in Figure 1. It is evident that the errors for the analytic continuations of non-diagonal Green's functions [i.e., scenarios (2) and (4)] are slightly larger than those of diagonal Green's functions [i.e., scenarios (1) and (3)]. Furthermore, scenarios (2) and (4) consume much less time to solve the problems. Surprisingly, we found that the pass rates for scenarios (1) and (3) are approximately 80\\%, while those for scenarios (2) and (4) are close to 100\\%. If we further change the computational configurations (such as increasing the size of the dataset, altering the noise level or changing the type of peaks), and then repeat the aforementioned tests, the final conclusions could be similar.","category":"page"},{"location":"examples/acflow.html","page":"Analytic continuation simulations","title":"Analytic continuation simulations","text":"(Image: T_maxent.png)","category":"page"},{"location":"examples/acflow.html","page":"Analytic continuation simulations","title":"Analytic continuation simulations","text":"Figure 1 | Tests of the maximum entropy method as implemented in the ACFlow package. The tests are classified as four categories (scenarios): (1) F_D, (2) F_OD, (3) B_D, and (4) B_OD. Here, F means fermionic systems and B means bosonic systems. D means diagonal Green's functions [A(omega)  0] and OD means off-diagonal Green's functions [A(omega) is non-positive definite]. Each category contains 100 tests. In this figure, the information contained in the summary.data file is visualized. (Left) Box-and-whisker plot for error statistics. The black solid segments denote the median values. (Right) Histogram plot for duration times consumed in the tests.","category":"page"},{"location":"man/script.html#Scripts","page":"Scripts","title":"Scripts","text":"","category":"section"},{"location":"man/script.html","page":"Scripts","title":"Scripts","text":"The ACTest toolkit provides four Julia scripts. They are located in the actest/util directory. Here are brief descriptions for these scripts:","category":"page"},{"location":"man/script.html#acgen.jl","page":"Scripts","title":"acgen.jl","text":"","category":"section"},{"location":"man/script.html","page":"Scripts","title":"Scripts","text":"This is the core script of the ACTest toolkit. It is able to randomly generate any number of spectral functions and corresponding Green's functions according to the user's settings.","category":"page"},{"location":"man/script.html#acstd.jl","page":"Scripts","title":"acstd.jl","text":"","category":"section"},{"location":"man/script.html","page":"Scripts","title":"Scripts","text":"It is similar to \\texttt{acgen.jl}. But its task is to generate the ACT100 dataset, which includes 100 predefined spectral functions and corresponding Green's functions.","category":"page"},{"location":"man/script.html#acflow.jl","page":"Scripts","title":"acflow.jl","text":"","category":"section"},{"location":"man/script.html","page":"Scripts","title":"Scripts","text":"This script provides a bridge between the ACTest toolkit and the ACFlow toolkit. At first, it will parse outputs from the acgen.jl or acstd.jl script to get the synthetic Green's functions. Next, these Green's functions are fed into the ACFlow toolkit, which will perform analytic continuation calculations and return the calculated spectral functions. Finally, acflow.jl script will compare the calculated spectral functions with the true solutions, and produce benchmark reports. This script needs support of the ACFlow toolkit. ","category":"page"},{"location":"man/script.html#acplot.jl","page":"Scripts","title":"acplot.jl","text":"","category":"section"},{"location":"man/script.html","page":"Scripts","title":"Scripts","text":"It is able to read A_textcalc(omega) and A_texttrue(omega), and plot them in the same figure for comparison. It adopts the PDF format to output the figure. This script requires support of the CairoMakie.jl package.","category":"page"},{"location":"man/script.html","page":"Scripts","title":"Scripts","text":"","category":"page"},{"location":"man/script.html","page":"Scripts","title":"Scripts","text":"Please execute the above scripts using the following command:","category":"page"},{"location":"man/script.html","page":"Scripts","title":"Scripts","text":"$ actest/util/script_name act.toml","category":"page"},{"location":"man/script.html","page":"Scripts","title":"Scripts","text":"Here, act.toml is the configuration file. It is a standard TOML file, primarily used for storing user's settings (i.e., control parameters). The technical details of the act.toml file will be introduced in the following text.","category":"page"},{"location":"library/peak.html#Peaks","page":"Peaks","title":"Peaks","text":"","category":"section"},{"location":"library/peak.html","page":"Peaks","title":"Peaks","text":"Declare various peaks, which are used to build the spectral functions.","category":"page"},{"location":"library/peak.html","page":"Peaks","title":"Peaks","text":"Now the ACTest toolkit supports the following five types of peaks:","category":"page"},{"location":"library/peak.html","page":"Peaks","title":"Peaks","text":"Gaussian peak (ptype = \"gauss\")\nLorentzian peak (ptype = \"lorentz\")\ndelta-like peak (ptype = \"delta\")\nRectangle peak (ptype = \"rectangle\")\nRise-And-Decay peak (ptype = \"risedecay\")","category":"page"},{"location":"library/peak.html#Contents","page":"Peaks","title":"Contents","text":"","category":"section"},{"location":"library/peak.html","page":"Peaks","title":"Peaks","text":"Pages = [\"peak.md\"]\nDepth = 2","category":"page"},{"location":"library/peak.html#Index","page":"Peaks","title":"Index","text":"","category":"section"},{"location":"library/peak.html","page":"Peaks","title":"Peaks","text":"Pages = [\"peak.md\"]","category":"page"},{"location":"library/peak.html#Types","page":"Peaks","title":"Types","text":"","category":"section"},{"location":"library/peak.html","page":"Peaks","title":"Peaks","text":"AbstractPeak\nGaussianPeak\nLorentzianPeak\nDeltaPeak\nRectanglePeak\nRiseDecayPeak","category":"page"},{"location":"library/peak.html#ACTest.AbstractPeak","page":"Peaks","title":"ACTest.AbstractPeak","text":"AbstractPeak\n\nAn abstract type representing the peaks in the spectral functions. It is used to build the internal type system.\n\n\n\n\n\n","category":"type"},{"location":"library/peak.html#ACTest.GaussianPeak","page":"Peaks","title":"ACTest.GaussianPeak","text":"GaussianPeak\n\nMutable struct. It represents the gaussian peak.\n\nMembers\n\nA -> Amplitude of the peak.\nΓ -> Broadening of the peak.\nϵ -> Shift of the peak.\n\n\n\n\n\n","category":"type"},{"location":"library/peak.html#ACTest.LorentzianPeak","page":"Peaks","title":"ACTest.LorentzianPeak","text":"LorentzianPeak\n\nMutable struct. It represents the lorentzian peak.\n\nMembers\n\nA -> Amplitude of the peak.\nΓ -> Broadening of the peak.\nϵ -> Shift of the peak.\n\n\n\n\n\n","category":"type"},{"location":"library/peak.html#ACTest.DeltaPeak","page":"Peaks","title":"ACTest.DeltaPeak","text":"DeltaPeak\n\nMutable struct. It represents the δ-like peak. Actually, it is a variation of the GaussianPeak with Γ = 0.02.\n\nMembers\n\nA -> Amplitude of the peak.\nΓ -> Broadening of the peak.\nϵ -> Shift of the peak.\n\n\n\n\n\n","category":"type"},{"location":"library/peak.html#ACTest.RectanglePeak","page":"Peaks","title":"ACTest.RectanglePeak","text":"RectanglePeak\n\nMutable struct. It represents the rectangle peak.\n\nMembers\n\nc -> Center of the peak.\nw -> Width of the peak.\nh -> Height of the peak.\n\n\n\n\n\n","category":"type"},{"location":"library/peak.html#ACTest.RiseDecayPeak","page":"Peaks","title":"ACTest.RiseDecayPeak","text":"RiseDecayPeak\n\nMutable struct. It represents the rise-and-decay peak.\n\nMembers\n\nc -> Center of the peak.\nγ -> Exponential parameter. It is used to control the width of the peak.\nh -> Height of the peak.\n\n\n\n\n\n","category":"type"},{"location":"library/peak.html#Base.*-Functions","page":"Peaks","title":"Base.* Functions","text":"","category":"section"},{"location":"library/peak.html","page":"Peaks","title":"Peaks","text":"Base.show(io::IO, 𝑝::GaussianPeak)\nBase.show(io::IO, 𝑝::LorentzianPeak)\nBase.show(io::IO, 𝑝::DeltaPeak)\nBase.show(io::IO, 𝑝::RectanglePeak)\nBase.show(io::IO, 𝑝::RiseDecayPeak)","category":"page"},{"location":"library/peak.html#Base.show-Tuple{IO, GaussianPeak}","page":"Peaks","title":"Base.show","text":"Base.show(io::IO, 𝑝::GaussianPeak)\n\nWrite a GaussianPeak struct.\n\n\n\n\n\n","category":"method"},{"location":"library/peak.html#Base.show-Tuple{IO, LorentzianPeak}","page":"Peaks","title":"Base.show","text":"Base.show(io::IO, 𝑝::LorentzianPeak)\n\nWrite a LorentzianPeak struct.\n\n\n\n\n\n","category":"method"},{"location":"library/peak.html#Base.show-Tuple{IO, DeltaPeak}","page":"Peaks","title":"Base.show","text":"Base.show(io::IO, 𝑝::DeltaPeak)\n\nWrite a DeltaPeak struct.\n\n\n\n\n\n","category":"method"},{"location":"library/peak.html#Base.show-Tuple{IO, RectanglePeak}","page":"Peaks","title":"Base.show","text":"Base.show(io::IO, 𝑝::RectanglePeak)\n\nWrite a RectanglePeak struct.\n\n\n\n\n\n","category":"method"},{"location":"library/peak.html#Base.show-Tuple{IO, RiseDecayPeak}","page":"Peaks","title":"Base.show","text":"Base.show(io::IO, 𝑝::RiseDecayPeak)\n\nWrite a RiseDecayPeak struct.\n\n\n\n\n\n","category":"method"},{"location":"man/param.html#Parameters","page":"Parameters","title":"Parameters","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"A comprehensive dictionary about parameters.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"In this part, we will provide detailed explanations of the control parameters of the ACTest toolkit. As mentioned before, the act.toml file contains two sections: [Test] and [Solver]. The parameters described here are specific to the [Test] section. They are primarily used for setting generation rules for the spectral functions and Green's functions. However, the parameters within the [Solver] section will be transferred to the ACFlow toolkit for configuring the analytic continuation methods. They will be explained in the documentation of the ACFlow toolkit.","category":"page"},{"location":"man/param.html#Contents","page":"Parameters","title":"Contents","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Pages = [\"param.md\"]\nDepth = 3","category":"page"},{"location":"man/param.html#solver","page":"Parameters","title":"solver","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Specify analytic continuation solver. Possible values includeMaxEnt\nBarRat\nNevanAC\nStochAC\nStochSK\nStochOM\nStochPXThey are the analytic continuation methods supported by the ACFlow toolkit. This parameter is only relevant for the acflow.jl and acplot.jl scripts.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"String.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Examples:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"solver = \"MaxEnt\"","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#ptype","page":"Parameters","title":"ptype","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Specify type of peaks. Possible values includegauss\nlorentz\ndelta\nrectangle\nrisedecayThey are corresponding to the Gaussian, Lorentzian, delta-like, rectangular, and Rise-And-Decay peaks, respectively. This parameter is only relevant for the acgen.jl script.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"String.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Examples:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"ptype = \"gauss\"","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#ktype","page":"Parameters","title":"ktype","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Specify kernel function. Possible values includefermi\nboson\nbsymmThey are corresponding to the fermionic, bosonic, and symmetric bosonic kernels, respectively.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"String.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Examples:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"ktype = \"fermi\"","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#grid","page":"Parameters","title":"grid","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Specify grid for the Green's functions. Possible values includeftime\nbtime\nffreq\nbfreqHere, the characters f and b mean fermionic and bosonic, respectively. The strings time and freq mean imaginary time and Matsubara frequency axes, respectively.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"String.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Examples:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"grid = \"ftime\"","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#mesh","page":"Parameters","title":"mesh","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Specify mesh for the spectral function. Possible values arelinear\ntangent\nlorentz\nhalflorentzThey are corresponding to the linear, tangent, Lorentzian, and half-Lorentzian meshes, respectively.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"String.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Examples:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"mesh = \"linear\"","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#ngrid","page":"Parameters","title":"ngrid","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of imaginary time or Matsubara frequency points for the Green's function. It denotes N_tau or N.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Examples:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"ngrid = 10","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#nmesh","page":"Parameters","title":"nmesh","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Number of mesh points for the spectral function. It is N_omega.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Examples:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"nmesh = 101","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#ntest","page":"Parameters","title":"ntest","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"How many spectral functions and corresponding Green's functions are generated by the ACTest toolkit? It is the size of the testing dataset for analytic continuation methods or codes. ","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Integer.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Examples:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"ntest = 100","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#wmax","page":"Parameters","title":"wmax","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Right boundary of the real frequency mesh (omega_textmax).","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Examples:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"wmax = 8.0","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#wmin","page":"Parameters","title":"wmin","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Left boundary of the real frequency mesh (omega_textmin).","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Examples:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"wmin = -8.0","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#pmax","page":"Parameters","title":"pmax","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Right boundary of features in the spectrum. It is used to restrict the centers of Gaussian and Lorentzian peaks. textttwmin  textttpmin  textttpmax  textttwmax.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Examples:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"pmax = 4.0","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#pmin","page":"Parameters","title":"pmin","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Left boundary of features in the spectrum. It is used to restrict the centers of Gaussian and Lorentzian peaks. textttwmin  textttpmin  textttpmax  textttwmax.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Examples:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"pmin = -4.0","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#beta","page":"Parameters","title":"beta","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Inverse temperature of the system beta (equiv 1T). It is used to define the imaginary time or Matsubara frequency grids for Green's functions.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Examples:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"beta = 40.0","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#noise","page":"Parameters","title":"noise","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"The noise level, i.e., the delta parameter.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Float.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Examples:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"noise = 1e-6","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#offdiag","page":"Parameters","title":"offdiag","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Specify whether the spectral function is positive definite or not. If offdiag is true, it implies that the spectral function is not positive definite and the ACTest toolkit will generate off-diagonal Green's function.  ","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Bool.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Examples:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"offdiag = true","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"man/param.html#lpeak","page":"Parameters","title":"lpeak","text":"","category":"section"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Definition:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"It is an integer array that sets the number of peaks (features) that the synthetic spectral function may contain. For example: lpeak = [1,2,3,4,5], then the ACTest toolkit can generate spectral functions with the number of peaks ranging from 1 to 5. This parameter is only relevant for the acgen.jl script.","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Type:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Array (Integer).","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Examples:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"lpeak = [1,2,3,5]","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"Comment:","category":"page"},{"location":"man/param.html","page":"Parameters","title":"Parameters","text":"This parameter is mandatory.","category":"page"},{"location":"library/outline.html#Outline","page":"Outline","title":"Outline","text":"","category":"section"},{"location":"library/outline.html#Contents","page":"Outline","title":"Contents","text":"","category":"section"},{"location":"library/outline.html","page":"Outline","title":"Outline","text":"Pages = [\"actest.md\",\n         \"global.md\",\n         \"type.md\",\n         \"base.md\",\n         \"peak.md\",\n         \"spectrum.md\",\n         \"dataset.md\",\n         \"grid.md\",\n         \"mesh.md\",\n         \"kernel.md\",\n         \"config.md\",\n         \"inout.md\",\n         \"math.md\",\n         \"util.md\"\n        ]\nDepth = 2","category":"page"},{"location":"library/outline.html#Index","page":"Outline","title":"Index","text":"","category":"section"},{"location":"library/outline.html#Modules","page":"Outline","title":"Modules","text":"","category":"section"},{"location":"library/outline.html","page":"Outline","title":"Outline","text":"Modules = [ACTest]\nOrder = [:module]","category":"page"},{"location":"library/outline.html#Constants","page":"Outline","title":"Constants","text":"","category":"section"},{"location":"library/outline.html","page":"Outline","title":"Outline","text":"Modules = [ACTest]\nOrder = [:constant]","category":"page"},{"location":"library/outline.html#Types","page":"Outline","title":"Types","text":"","category":"section"},{"location":"library/outline.html","page":"Outline","title":"Outline","text":"Modules = [ACTest]\nOrder = [:type]","category":"page"},{"location":"library/outline.html#Macros","page":"Outline","title":"Macros","text":"","category":"section"},{"location":"library/outline.html","page":"Outline","title":"Outline","text":"Modules = [ACTest]\nOrder = [:macro]","category":"page"},{"location":"library/outline.html#Functions","page":"Outline","title":"Functions","text":"","category":"section"},{"location":"library/outline.html","page":"Outline","title":"Outline","text":"Modules = [ACTest]\nOrder = [:function]","category":"page"},{"location":"theory/grid.html#Grids-for-Green's-functions","page":"Grids","title":"Grids for Green's functions","text":"","category":"section"},{"location":"theory/grid.html","page":"Grids","title":"Grids","text":"As mentioned before, Green's functions in quantum many-body physics are usually defined on imaginary time or Matsubara frequency axes. Imaginary time Green's functions G(tau) and Matsubara Green's functions G(iomega_n) are related via Fourier transformation:","category":"page"},{"location":"theory/grid.html","page":"Grids","title":"Grids","text":"beginequation\nG(tau) = frac1beta sum_n e^iomega_n tau G(iomega_n)\nendequation","category":"page"},{"location":"theory/grid.html","page":"Grids","title":"Grids","text":"and","category":"page"},{"location":"theory/grid.html","page":"Grids","title":"Grids","text":"beginequation\nG(iomega_n) = int^beta_0 dtau e^-iomega_n tau G(tau)\nendequation","category":"page"},{"location":"theory/grid.html","page":"Grids","title":"Grids","text":"where beta denotes inverse temperature (beta equiv 1T). The grids for Green's functions are linear. Specifically, tau_i = i betaN_tau, where N_tau denotes number of time slices and i in 0N_tau. omega_n = (2n+1)pibeta for fermions and 2npibeta for bosons, where n in 0 N and N means number of Matsubara frequency points.","category":"page"},{"location":"theory/peak.html#Peaks","page":"Peaks","title":"Peaks","text":"","category":"section"},{"location":"theory/peak.html","page":"Peaks","title":"Peaks","text":"In the ACTest toolkit, the spectral function A(omega) is treated as a superposition of some peaks (i.e., features). That is to say:","category":"page"},{"location":"theory/peak.html","page":"Peaks","title":"Peaks","text":"beginequation\nA(omega) = sum^N_p_i = 1 p_i(omega)\nendequation","category":"page"},{"location":"theory/peak.html","page":"Peaks","title":"Peaks","text":"where N_p is the number of peaks, p(omega) is the peak generation function. Now ACTest supports the following types of peaks:","category":"page"},{"location":"theory/peak.html","page":"Peaks","title":"Peaks","text":"Gaussian peak","category":"page"},{"location":"theory/peak.html","page":"Peaks","title":"Peaks","text":"beginequation\np(omega) = Aexpleft-frac(omega - epsilon)^22Gamma^2right\nendequation","category":"page"},{"location":"theory/peak.html","page":"Peaks","title":"Peaks","text":"Lorentzian peak","category":"page"},{"location":"theory/peak.html","page":"Peaks","title":"Peaks","text":"beginequation\np(omega) = fracApi fracGamma(omega - epsilon)^2 + Gamma^2\nendequation","category":"page"},{"location":"theory/peak.html","page":"Peaks","title":"Peaks","text":"delta-like peak","category":"page"},{"location":"theory/peak.html","page":"Peaks","title":"Peaks","text":"beginequation\np(omega) = Aexpleft-frac(omega - epsilon)^22gamma^2right\ntextwheregamma = 001\nendequation","category":"page"},{"location":"theory/peak.html","page":"Peaks","title":"Peaks","text":"Rectangular peak","category":"page"},{"location":"theory/peak.html","page":"Peaks","title":"Peaks","text":"beginequation\np(omega) =\nbegincases\nh quad textifomega in c-w2c+w2 \n0 quad textelse \nendcases\nendequation","category":"page"},{"location":"theory/peak.html","page":"Peaks","title":"Peaks","text":"Rise-And-Decay peak","category":"page"},{"location":"theory/peak.html","page":"Peaks","title":"Peaks","text":"beginequation\np(omega) = h exp(-omega - c^gamma)\nendequation","category":"page"},{"location":"theory/peak.html","page":"Peaks","title":"Peaks","text":"Here we just use a narrow Gaussian peak to mimic the delta-like peak. In the above equations, mathcalC = AGammaepsilonhcwgamma is a collection for essential parameters. The ACTest toolkit will randomize mathcalC and use it to parameterize the peaks.","category":"page"},{"location":"library/base.html#Core","page":"Core","title":"Core","text":"","category":"section"},{"location":"library/base.html","page":"Core","title":"Core","text":"Provide basic user's interfaces for the ACTest toolkit.","category":"page"},{"location":"library/base.html#Contents","page":"Core","title":"Contents","text":"","category":"section"},{"location":"library/base.html","page":"Core","title":"Core","text":"Pages = [\"base.md\"]\nDepth = 2","category":"page"},{"location":"library/base.html#Index","page":"Core","title":"Index","text":"","category":"section"},{"location":"library/base.html","page":"Core","title":"Core","text":"Pages = [\"base.md\"]","category":"page"},{"location":"library/base.html#Parameters","page":"Core","title":"Parameters","text":"","category":"section"},{"location":"library/base.html","page":"Core","title":"Core","text":"setup_param\nread_param","category":"page"},{"location":"library/base.html#ACTest.setup_param","page":"Core","title":"ACTest.setup_param","text":"setup_param(C::Dict{String,Any}, reset::Bool = true)\n\nSetup the configuration dictionaries via function call. Here C contains parameters for general setup. If reset is true, then the configuration dictionaries will be reset to their default values at first. Later, C will be used to customized the dictionaries further.\n\nArguments\n\nSee above explanations.\n\nReturns\n\nN/A\n\nSee also: read_param.\n\n\n\n\n\n","category":"function"},{"location":"library/base.html#ACTest.read_param","page":"Core","title":"ACTest.read_param","text":"read_param()\n\nSetup the configuration dictionaries via an external file. The valid format of a configuration file is toml.\n\nArguments\n\nN/A\n\nReturns\n\nN/A\n\nSee also: setup_param.\n\n\n\n\n\n","category":"function"},{"location":"library/base.html#Data","page":"Core","title":"Data","text":"","category":"section"},{"location":"library/base.html","page":"Core","title":"Core","text":"make_data_std\nmake_data\nmake_peak\nmake_spectrum\nmake_green","category":"page"},{"location":"library/base.html#ACTest.make_data_std","page":"Core","title":"ACTest.make_data_std","text":"make_data_std()\n\nTry to build a standard dataset (ACT100), which contains 100 typical spectral functions and the corresponding correlation functions. These spectral functions are defined in src/dataset.jl. Please use the script util/acstd.jl to do this job.\n\nArguments\n\nN/A\n\nReturns\n\nN/A\n\n\n\n\n\n","category":"function"},{"location":"library/base.html#ACTest.make_data","page":"Core","title":"ACTest.make_data","text":"make_data()\n\nTry to generate spectral functions and the corresponding Green's functions.\n\nArguments\n\nN/A\n\nReturns\n\nN/A\n\n\n\n\n\n","category":"function"},{"location":"library/base.html#ACTest.make_peak","page":"Core","title":"ACTest.make_peak","text":"make_peak(rng::AbstractRNG)\n\nGenerate peak to build the final spectral function.\n\nArguments\n\nrng -> Random number generator.\n\nReturns\n\n𝑝 -> A Peak struct (subtype of AbstractPeak).\n\nSee also: AbstractPeak.\n\n\n\n\n\n","category":"function"},{"location":"library/base.html#ACTest.make_spectrum","page":"Core","title":"ACTest.make_spectrum","text":"make_spectrum(rng::AbstractRNG, mesh::AbstractMesh)\n\nGenerate a spectral function randomly at given mesh.\n\nArguments\n\nrng -> Random number generator.\nmesh -> Real frequency mesh, ω.\n\nReturns\n\nsf -> A SpectralFunction struct.\n\nSee also: make_data.\n\n\n\n\n\nmake_spectrum(\n    mesh::AbstractMesh,\n    pv::Vector{<:AbstractPeak},\n    sv::Vector{F64}\n)\n\nGenerate a spectral function with given peaks and signs at given mesh.\n\nArguments\n\nmesh -> Real frequency mesh, ω.\npv -> List of peaks.\nsv -> List of signs.\n\nReturns\n\nsf -> A SpectralFunction struct.\n\nSee also: make_data_std.\n\n\n\n\n\n","category":"function"},{"location":"library/base.html#ACTest.make_green","page":"Core","title":"ACTest.make_green","text":"make_green(\n    rng::AbstractRNG,\n    sf::SpectralFunction,\n    kernel::Matrix{F64},\n    grid::AbstractGrid\n)\n\nFor given spectral function A and kernel matrix K, try to generate the corresponding correlation function G (note that G ≡ KA).\n\nArguments\n\nrng -> Random number generator.\nsf -> A SpectralFunction struct, A(ω).\nkernel -> Kernel matrix.\ngrid -> Grid for correlation function.\n\nReturns\n\ngf -> A GreenFunction struct.\n\n\n\n\n\n","category":"function"},{"location":"library/base.html#Grids","page":"Core","title":"Grids","text":"","category":"section"},{"location":"library/base.html","page":"Core","title":"Core","text":"make_grid","category":"page"},{"location":"library/base.html#ACTest.make_grid","page":"Core","title":"ACTest.make_grid","text":"make_grid(_grid = nothing)\n\nTo generate imaginary time grid or Masubara grid for many-body correlator. It will return a sub-type of the AbstractGrid struct.\n\nArguments\n\n_grid -> If it is present, we should use it to setup grid.\n\nReturns\n\ngrid -> Imaginary time or imaginary frequency grid.\n\nSee also: AbstractGrid.\n\n\n\n\n\n","category":"function"},{"location":"library/base.html#Meshes","page":"Core","title":"Meshes","text":"","category":"section"},{"location":"library/base.html","page":"Core","title":"Core","text":"make_mesh","category":"page"},{"location":"library/base.html#ACTest.make_mesh","page":"Core","title":"ACTest.make_mesh","text":"make_mesh(_ktype = nothing, _mesh = nothing)\n\nTry to generate an uniform (linear) or non-uniform (non-linear) mesh for the spectral function in real axis.\n\nArguments\n\n_ktype -> If it is present, we should use it to setup ktype.\n_mesh -> If it is present, we should use it to setup mesh.\n\nReturns\n\nmesh -> Real frequency mesh. It should be a subtype of AbstractMesh.\n\nSee also: LinearMesh, TangentMesh, LorentzMesh.\n\n\n\n\n\n","category":"function"},{"location":"library/base.html#Kernels","page":"Core","title":"Kernels","text":"","category":"section"},{"location":"library/base.html","page":"Core","title":"Core","text":"make_kernel","category":"page"},{"location":"library/base.html#ACTest.make_kernel","page":"Core","title":"ACTest.make_kernel","text":"make_kernel(am::AbstractMesh, ag::AbstractGrid)\n\nTry to generate various kernel functions.\n\nArguments\n\nam -> Real frequency mesh.\nag -> Imaginary axis grid.\n\nReturns\n\nkernel -> Kernel function, a 2D array, (ntime,nmesh) or (nfreq,nmesh).\n\nSee also: AbstractMesh, AbstractGrid.\n\n\n\n\n\n","category":"function"},{"location":"library/base.html#Postprocessing","page":"Core","title":"Postprocessing","text":"","category":"section"},{"location":"library/base.html","page":"Core","title":"Core","text":"reprod","category":"page"},{"location":"library/base.html#ACTest.reprod","page":"Core","title":"ACTest.reprod","text":"reprod(am::AbstractMesh, kernel::Matrix{F64}, A::Vector{F64})\n\nTry to reproduce the input data, which can be compared with the raw data to see whether the analytic continuation is reasonable.\n\nArguments\n\nam -> Real frequency mesh.\nkernel -> The kernel function.\nA -> The calculated spectral function, A(ω).\n\nReturns\n\nG -> Reconstructed correlators, G(τ) or G(iωₙ), Vector{F64}.\n\nSee also: AbstractMesh.\n\n\n\n\n\n","category":"function"},{"location":"examples/plot.html#Visualizations","page":"Visualizations","title":"Visualizations","text":"","category":"section"},{"location":"examples/plot.html","page":"Visualizations","title":"Visualizations","text":"info: Info\nIn the actest/tests directory, there are seven typical test cases. Users can modify them to meet their requirements. This section will use an independent example to demonstrate the basic usage of the ACTest toolkit.","category":"page"},{"location":"examples/plot.html","page":"Visualizations","title":"Visualizations","text":"Finally, we can utilize the acplot.jl script to generate figures for the spectral functions. To achieve that effect, please execute the following command in the terminal:","category":"page"},{"location":"examples/plot.html","page":"Visualizations","title":"Visualizations","text":"$ actest/util/acplot.jl act.toml","category":"page"},{"location":"examples/plot.html","page":"Visualizations","title":"Visualizations","text":"These figures are in standard PDF format. They are used to analyze the differences between the true spectral functions A_texttrue(omega) and the calculated spectral functions A_textcalc(omega). Figures 1 and 2 illustrate the spectral functions of typical fermionic systems and bosonic systems, respectively. As can be seen from the figures, aside from some very sharp peaks, the calculated spectral functions agree quite well with the true ones.","category":"page"},{"location":"examples/plot.html","page":"Visualizations","title":"Visualizations","text":"(Image: T_f.png)","category":"page"},{"location":"examples/plot.html","page":"Visualizations","title":"Visualizations","text":"Figure 1 | Selected analytic continuation results for Matsubara Green's functions (fermionic systems). (Left) Spectra for diagonal Green's function. (Right) Spectra for off-diagonal Green's function. The exact spectra are generated randomly by the ACTest toolkit. The vertical dashed lines denote the Fermi level.","category":"page"},{"location":"examples/plot.html","page":"Visualizations","title":"Visualizations","text":"(Image: T_b.png)","category":"page"},{"location":"examples/plot.html","page":"Visualizations","title":"Visualizations","text":"Figure 2 | Selected analytic continuation results for Matsubara Green's functions (bosonic systems). (Left) Spectra for diagonal Green's function. (Right) Spectra for off-diagonal Green's function. The exact spectra are generated randomly by the ACTest toolkit. The vertical dashed lines denote the Fermi level.","category":"page"},{"location":"intro/motivation.html#Motivation","page":"Motivation","title":"Motivation","text":"","category":"section"},{"location":"intro/motivation.html","page":"Motivation","title":"Motivation","text":"In quantum many-body computations, analytic continuation usually plays a vital role. Its objective is to convert Green's function G from imaginary time (tau) or Matsubara frequency (iomega_n) axis to real time (t) or real frequency (omega) axis, extracting spectral function A(omega) for comparison with experimental data. From a mathematical perspective, G(tau) or G(iomega_n) is related to A(omega) through the well-known Laplace transformation. Given G(tau) or G(iomega_n), analytic continuation calculation is essentially finding the associated A(omega) that satisfies the Laplace transformation. This is a typical inverse problem. Note that the solution, i.e., A(omega), is particularly sensitive to numerical fluctuations or noises in the input data, i.e., G(tau) or G(iomega_n). This poses a severe challenge to the analytic continuation methods.","category":"page"},{"location":"intro/motivation.html","page":"Motivation","title":"Motivation","text":"Over the past few decades, people have developed many analytic continuation methods, including the Pad\\'{e} approximation, maximum entropy method, stochastic analytic continuation, stochastic optimization method, stochastic pole expansion, Nevanlinna analytical continuation, sparse modeling, causal projections, Prony fits, and machine learning-aided methods, to name a few. Unfortunately, nowadays there is no perfect and universal method for solving analytic continuation problems. The existing methods have their own advantages and disadvantages, as well as their scopes of applications. We need a quantitative comparison standard to determine their relative merits. In addition, people have developed several analytic continuation toolkits, such as ACFlow, OmegaMaxent, ana_cont, Nevanlnna.jl, maxent (in ALPSCore), Nevanlinna (in TRIQS), SOM (in TRIQS), Stoch (in ALF), SmoQyDEAC.jl, etc. Are these analytic continuation toolkits reliable? Can their accuracy meet the requirements? These are open questions that need to be addressed.","category":"page"},{"location":"intro/motivation.html","page":"Motivation","title":"Motivation","text":"To answer or solve the aforementioned questions, we would like to introduce an open-source toolkit ACTest in this paper. ACTest can randomly generate a large number of A(omega), along with the corresponding G(tau) or G(iomega_n). It is worth emphasizing that G(tau) or G(iomega_n) should be supplemented with artificial noises to mimic input data from realistic quantum many-body calculations. The synthetic A(omega) and G(tau) [or G(iomega_n)] can be used to benchmark the existing or newly developed analytic continuation methods, examining their computational accuracies and efficiencies. The ACTest toolkit comes with a standard dataset containing 100 spectral functions, known as ACT100. This built-in dataset can be used to assess the merits of different analytic continuation methods in a relatively fair, reproducible, and quantitative manner. People can also employ the ACTest toolkit to create large datasets, which can serve as training and testing datasets for machine learning-aided methods. Currently, the ACTest toolkit has been integrated with the ACFlow toolkit. Thus, it allows direct calls of various methods as implemented in the ACFlow toolkit for analytic continuation calculations.","category":"page"},{"location":"man/feature.html#Main-Features","page":"Main Features","title":"Main Features","text":"","category":"section"},{"location":"man/feature.html","page":"Main Features","title":"Main Features","text":"The major features of the ACTest toolkit are as follows:","category":"page"},{"location":"man/feature.html","page":"Main Features","title":"Main Features","text":"ACTest can randomly generate any number of A(omega), as well as corresponding G(tau) or G(iomega_n).\nACTest employs one or more parameterized Gaussian, Lorentzian, delta-like, rectangular, and Rise-And-Decay peaks to assemble A(omega). A(omega) can be either positive definite for fermionic Green's functions, or non-positive definite for bosonic Green's functions and matrix-valued Green's functions. The frequency grid, i.e., omega, can be either linear or non-linear (such as tangent, Lorentzian, and half-Lorentzian grids).\nACTest supports fermionic, bosonic, and symmetric bosonic kernels to generate Green's functions on either imaginary time or Matsubara frequency axes. It supports artificial noise, and the noise level is adjustable.\nACTest includes a built-in testing dataset, ACT100, which can serve as a relatively fair standard for examining different analytic continuation methods and codes.\nACTest is already interfaced with ACFlow, which is a full-fledged and open-source analytic continuation toolkit. ACTest can access various analytic continuation methods in the ACFlow toolkit, launch them to perform analytic continuation calculations, and provide benchmark reports on their accuracy and efficiency. ACTest also provides a plotting script, that can be used to visualize and compare the true and reconstructed spectral functions.\nACTest is an open-source software developed in Julia language. It is quite easy to be extended to implement new features or support the other analytic continuation codes, such as Nevanlinna.jl and SmoQyDEAC.jl. Furthermore, ACTest offers extensive documentation and examples, making it user-friendly.","category":"page"},{"location":"man/feature.html","page":"Main Features","title":"Main Features","text":"In the following text, we will elaborate on the technical details inside ACTest.","category":"page"},{"location":"library/actest.html#ACTest.jl","page":"ACTest","title":"ACTest.jl","text":"","category":"section"},{"location":"library/actest.html","page":"ACTest","title":"ACTest","text":"Declare the module and public members.","category":"page"},{"location":"library/actest.html#Modules","page":"ACTest","title":"Modules","text":"","category":"section"},{"location":"library/actest.html","page":"ACTest","title":"ACTest","text":"ACTest","category":"page"},{"location":"library/actest.html#ACTest","page":"ACTest","title":"ACTest","text":"ACTest\n\nACTest is an automatical generator for fermionic or bosonic correlation functions. It is used to generate a lot of correlators and corresponding spectral functions. They are then employed to test the newly developed analytic continuation methods or tools.\n\nNow ACTest is used together with the ACFlow toolkit. But it is easily to be interfaced with the other analytic continuation codes.\n\nFor more details about how to obtain, install and use the ACTest toolkit, please visit the following website:\n\nhttps://huangli712.github.io/projects/actest/index.html\n\nAny suggestions, comments, and feedbacks are welcome. Enjoy it!\n\n\n\n\n\n","category":"module"},{"location":"library/actest.html#Initialization","page":"ACTest","title":"Initialization","text":"","category":"section"},{"location":"library/actest.html","page":"ACTest","title":"ACTest","text":"_precompile\nACTest.__init__","category":"page"},{"location":"library/actest.html#ACTest._precompile","page":"ACTest","title":"ACTest._precompile","text":"_precompile()\n\nHere, we would like to precompile the whole ACTest toolkit to reduce the runtime latency and speed up the successive calculations.\n\n\n\n\n\n","category":"function"},{"location":"library/actest.html#ACTest.__init__","page":"ACTest","title":"ACTest.__init__","text":"__init__()\n\nThis function would be executed immediately after the module is loaded at runtime for the first time. It works at the REPL mode only.\n\n\n\n\n\n","category":"function"},{"location":"library/grid.html#Grids","page":"Grids","title":"Grids","text":"","category":"section"},{"location":"library/grid.html","page":"Grids","title":"Grids","text":"Grids on imaginary axis.","category":"page"},{"location":"library/grid.html","page":"Grids","title":"Grids","text":"In the ACTest toolkit, the output correlators are defined on grid, while the spectral functions are defined on mesh. The ACTest toolkit supports both imaginary time and Matsubara frequency grids. Note that for Matsubara frequency grid, the bosonic and fermionic grids are different.","category":"page"},{"location":"library/grid.html#Contents","page":"Grids","title":"Contents","text":"","category":"section"},{"location":"library/grid.html","page":"Grids","title":"Grids","text":"Pages = [\"grid.md\"]\nDepth = 2","category":"page"},{"location":"library/grid.html#Index","page":"Grids","title":"Index","text":"","category":"section"},{"location":"library/grid.html","page":"Grids","title":"Grids","text":"Pages = [\"grid.md\"]","category":"page"},{"location":"library/grid.html#Types","page":"Grids","title":"Types","text":"","category":"section"},{"location":"library/grid.html","page":"Grids","title":"Grids","text":"AbstractGrid\nFermionicImaginaryTimeGrid\nFermionicMatsubaraGrid\nBosonicImaginaryTimeGrid\nBosonicMatsubaraGrid","category":"page"},{"location":"library/grid.html#ACTest.AbstractGrid","page":"Grids","title":"ACTest.AbstractGrid","text":"AbstractGrid\n\nAn abstract type representing the imaginary axis. It is used to build the internal type system.\n\n\n\n\n\n","category":"type"},{"location":"library/grid.html#ACTest.FermionicImaginaryTimeGrid","page":"Grids","title":"ACTest.FermionicImaginaryTimeGrid","text":"FermionicImaginaryTimeGrid\n\nMutable struct. It represents the fermionic imaginary time grid.\n\nMembers\n\nntime -> Number of time slices.\nβ     -> Inverse temperature.\nτ     -> Vector of grid points， τᵢ.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\n","category":"type"},{"location":"library/grid.html#ACTest.FermionicMatsubaraGrid","page":"Grids","title":"ACTest.FermionicMatsubaraGrid","text":"FermionicMatsubaraGrid\n\nMutable struct. It represents the fermionic Matsubara frequency grid.\n\nMembers\n\nnfreq -> Number of Matsubara frequency points.\nβ     -> Inverse temperature.\nω     -> Vector of grid points, iωₙ.\n\nSee also: FermionicImaginaryTimeGrid.\n\n\n\n\n\n","category":"type"},{"location":"library/grid.html#ACTest.BosonicImaginaryTimeGrid","page":"Grids","title":"ACTest.BosonicImaginaryTimeGrid","text":"BosonicImaginaryTimeGrid\n\nMutable struct. It represents the bosonic imaginary time grid.\n\nMembers\n\nntime -> Number of time slices.\nβ     -> Inverse temperature.\nτ     -> Vector of grid points, τᵢ.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\n","category":"type"},{"location":"library/grid.html#ACTest.BosonicMatsubaraGrid","page":"Grids","title":"ACTest.BosonicMatsubaraGrid","text":"BosonicMatsubaraGrid\n\nMutable struct. It represents the bosonic Matsubara frequency grid.\n\nMembers\n\nnfreq -> Number of Matsubara frequency points.\nβ     -> Inverse temperature.\nω     -> Vector of grid points, iωₙ.\n\nSee also: BosonicImaginaryTimeGrid.\n\n\n\n\n\n","category":"type"},{"location":"library/grid.html#Constructors","page":"Grids","title":"Constructors","text":"","category":"section"},{"location":"library/grid.html","page":"Grids","title":"Grids","text":"FermionicImaginaryTimeGrid(ntime::I64, β::F64)\nFermionicMatsubaraGrid(nfreq::I64, β::F64)\nBosonicImaginaryTimeGrid(ntime::I64, β::F64)\nBosonicMatsubaraGrid(nfreq::I64, β::F64)","category":"page"},{"location":"library/grid.html#ACTest.FermionicImaginaryTimeGrid-Tuple{Int64, Float64}","page":"Grids","title":"ACTest.FermionicImaginaryTimeGrid","text":"FermionicImaginaryTimeGrid(ntime::I64, β::F64)\n\nA constructor for the FermionicImaginaryTimeGrid struct, which is defined in src/types.jl.\n\nArguments\n\nntime -> Number of time slices in imaginary axis.\nβ     -> Inverse temperature.\n\nReturns\n\ngrid -> A FermionicImaginaryTimeGrid struct.\n\nSee also: FermionicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#ACTest.FermionicMatsubaraGrid-Tuple{Int64, Float64}","page":"Grids","title":"ACTest.FermionicMatsubaraGrid","text":"FermionicMatsubaraGrid(nfreq::I64, β::F64)\n\nA constructor for the FermionicMatsubaraGrid struct, which is defined in src/types.jl. The Matsubara grid is evaluated as ωₙ = (2n - 1) π / β.\n\nArguments\n\nnfreq -> Number of Matsubara frequencies.\nβ     -> Inverse temperature.\n\nReturns\n\ngrid -> A FermionicMatsubaraGrid struct.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#ACTest.BosonicImaginaryTimeGrid-Tuple{Int64, Float64}","page":"Grids","title":"ACTest.BosonicImaginaryTimeGrid","text":"BosonicImaginaryTimeGrid(ntime::I64, β::F64)\n\nA constructor for the BosonicImaginaryTimeGrid struct, which is defined in src/types.jl.\n\nArguments\n\nntime -> Number of time slices in imaginary axis.\nβ     -> Inverse temperature.\n\nReturns\n\ngrid -> A BosonicImaginaryTimeGrid struct.\n\nSee also: BosonicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#ACTest.BosonicMatsubaraGrid-Tuple{Int64, Float64}","page":"Grids","title":"ACTest.BosonicMatsubaraGrid","text":"BosonicMatsubaraGrid(nfreq::I64, β::F64)\n\nA constructor for the BosonicMatsubaraGrid struct, which is defined in src/types.jl. The Matsubara grid is evaluated as ωₙ = (2n - 2) π / β.\n\nArguments\n\nnfreq -> Number of Matsubara frequencies.\nβ     -> Inverse temperature.\n\nReturns\n\ngrid -> A BosonicMatsubaraGrid struct.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.*-Functions","page":"Grids","title":"Base.* Functions","text":"","category":"section"},{"location":"library/grid.html","page":"Grids","title":"Grids","text":"Base.length(fg::FermionicImaginaryTimeGrid)\nBase.length(fg::FermionicMatsubaraGrid)\nBase.length(bg::BosonicImaginaryTimeGrid)\nBase.length(bg::BosonicMatsubaraGrid)\nBase.iterate(fg::FermionicImaginaryTimeGrid)\nBase.iterate(fg::FermionicMatsubaraGrid)\nBase.iterate(bg::BosonicImaginaryTimeGrid)\nBase.iterate(bg::BosonicMatsubaraGrid)\nBase.iterate(fg::FermionicImaginaryTimeGrid, i::I64)\nBase.iterate(fg::FermionicMatsubaraGrid, i::I64)\nBase.iterate(bg::BosonicImaginaryTimeGrid, i::I64)\nBase.iterate(bg::BosonicMatsubaraGrid, i::I64)\nBase.eachindex(fg::FermionicImaginaryTimeGrid)\nBase.eachindex(fg::FermionicMatsubaraGrid)\nBase.eachindex(bg::BosonicImaginaryTimeGrid)\nBase.eachindex(bg::BosonicMatsubaraGrid)\nBase.firstindex(fg::FermionicImaginaryTimeGrid)\nBase.firstindex(fg::FermionicMatsubaraGrid)\nBase.firstindex(bg::BosonicImaginaryTimeGrid)\nBase.firstindex(bg::BosonicMatsubaraGrid)\nBase.lastindex(fg::FermionicImaginaryTimeGrid)\nBase.lastindex(fg::FermionicMatsubaraGrid)\nBase.lastindex(bg::BosonicImaginaryTimeGrid)\nBase.lastindex(bg::BosonicMatsubaraGrid)\nBase.getindex(fg::FermionicImaginaryTimeGrid, ind::I64)\nBase.getindex(fg::FermionicMatsubaraGrid, ind::I64)\nBase.getindex(bg::BosonicImaginaryTimeGrid, ind::I64)\nBase.getindex(bg::BosonicMatsubaraGrid, ind::I64)\nBase.getindex(fg::FermionicImaginaryTimeGrid, I::UnitRange{I64})\nBase.getindex(fg::FermionicMatsubaraGrid, I::UnitRange{I64})\nBase.getindex(bg::BosonicImaginaryTimeGrid, I::UnitRange{I64})\nBase.getindex(bg::BosonicMatsubaraGrid, I::UnitRange{I64})","category":"page"},{"location":"library/grid.html#Base.length-Tuple{FermionicImaginaryTimeGrid}","page":"Grids","title":"Base.length","text":"Base.length(fg::FermionicImaginaryTimeGrid)\n\nReturn number of grid points in a FermionicImaginaryTimeGrid struct.\n\nSee also: FermionicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.length-Tuple{FermionicMatsubaraGrid}","page":"Grids","title":"Base.length","text":"Base.length(fg::FermionicMatsubaraGrid)\n\nReturn number of grid points in a FermionicMatsubaraGrid struct.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.length-Tuple{BosonicImaginaryTimeGrid}","page":"Grids","title":"Base.length","text":"Base.length(bg::BosonicImaginaryTimeGrid)\n\nReturn number of grid points in a BosonicImaginaryTimeGrid struct.\n\nSee also: BosonicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.length-Tuple{BosonicMatsubaraGrid}","page":"Grids","title":"Base.length","text":"Base.length(bg::BosonicMatsubaraGrid)\n\nReturn number of grid points in a BosonicMatsubaraGrid struct.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{FermionicImaginaryTimeGrid}","page":"Grids","title":"Base.iterate","text":"Base.iterate(fg::FermionicImaginaryTimeGrid)\n\nAdvance the iterator of a FermionicImaginaryTimeGrid struct to obtain the next grid point.\n\nSee also: FermionicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{FermionicMatsubaraGrid}","page":"Grids","title":"Base.iterate","text":"Base.iterate(fg::FermionicMatsubaraGrid)\n\nAdvance the iterator of a FermionicMatsubaraGrid struct to obtain the next grid point.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{BosonicImaginaryTimeGrid}","page":"Grids","title":"Base.iterate","text":"Base.iterate(bg::BosonicImaginaryTimeGrid)\n\nAdvance the iterator of a BosonicImaginaryTimeGrid struct to obtain the next grid point.\n\nSee also: BosonicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{BosonicMatsubaraGrid}","page":"Grids","title":"Base.iterate","text":"Base.iterate(bg::BosonicMatsubaraGrid)\n\nAdvance the iterator of a BosonicMatsubaraGrid struct to obtain the next grid point.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{FermionicImaginaryTimeGrid, Int64}","page":"Grids","title":"Base.iterate","text":"Base.iterate(fg::FermionicImaginaryTimeGrid, i::I64)\n\nThis is the key method that allows a FermionicImaginaryTimeGrid struct to be iterated, yielding a sequences of grid points.\n\nSee also: FermionicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{FermionicMatsubaraGrid, Int64}","page":"Grids","title":"Base.iterate","text":"Base.iterate(fg::FermionicMatsubaraGrid, i::I64)\n\nCreate an iterable object for visiting each index of a FermionicMatsubaraGrid struct.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{BosonicImaginaryTimeGrid, Int64}","page":"Grids","title":"Base.iterate","text":"Base.iterate(bg::BosonicImaginaryTimeGrid, i::I64)\n\nCreate an iterable object for visiting each index of a BosonicImaginaryTimeGrid struct.\n\nSee also: BosonicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.iterate-Tuple{BosonicMatsubaraGrid, Int64}","page":"Grids","title":"Base.iterate","text":"Base.iterate(bg::BosonicMatsubaraGrid, i::I64)\n\nCreate an iterable object for visiting each index of a BosonicMatsubaraGrid struct.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.eachindex-Tuple{FermionicImaginaryTimeGrid}","page":"Grids","title":"Base.eachindex","text":"Base.eachindex(fg::FermionicImaginaryTimeGrid)\n\nCreate an iterable object for visiting each index of a FermionicImaginaryTimeGrid struct.\n\nSee also: FermionicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.eachindex-Tuple{FermionicMatsubaraGrid}","page":"Grids","title":"Base.eachindex","text":"Base.eachindex(fg::FermionicMatsubaraGrid)\n\nCreate an iterable object for visiting each index of a FermionicMatsubaraGrid struct.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.eachindex-Tuple{BosonicImaginaryTimeGrid}","page":"Grids","title":"Base.eachindex","text":"Base.eachindex(bg::BosonicImaginaryTimeGrid)\n\nCreate an iterable object for visiting each index of a BosonicImaginaryTimeGrid struct.\n\nSee also: BosonicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.eachindex-Tuple{BosonicMatsubaraGrid}","page":"Grids","title":"Base.eachindex","text":"Base.eachindex(bg::BosonicMatsubaraGrid)\n\nCreate an iterable object for visiting each index of a BosonicMatsubaraGrid struct.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.firstindex-Tuple{FermionicImaginaryTimeGrid}","page":"Grids","title":"Base.firstindex","text":"Base.firstindex(fg::FermionicImaginaryTimeGrid)\n\nReturn the first index of a FermionicImaginaryTimeGrid struct.\n\nSee also: FermionicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.firstindex-Tuple{FermionicMatsubaraGrid}","page":"Grids","title":"Base.firstindex","text":"Base.firstindex(fg::FermionicMatsubaraGrid)\n\nReturn the first index of a FermionicMatsubaraGrid struct.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.firstindex-Tuple{BosonicImaginaryTimeGrid}","page":"Grids","title":"Base.firstindex","text":"Base.firstindex(bg::BosonicImaginaryTimeGrid)\n\nReturn the first index of a BosonicImaginaryTimeGrid struct.\n\nSee also: BosonicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.firstindex-Tuple{BosonicMatsubaraGrid}","page":"Grids","title":"Base.firstindex","text":"Base.firstindex(bg::BosonicMatsubaraGrid)\n\nReturn the first index of a BosonicMatsubaraGrid struct.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.lastindex-Tuple{FermionicImaginaryTimeGrid}","page":"Grids","title":"Base.lastindex","text":"Base.lastindex(fg::FermionicImaginaryTimeGrid)\n\nReturn the last index of a FermionicImaginaryTimeGrid struct.\n\nSee also: FermionicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.lastindex-Tuple{FermionicMatsubaraGrid}","page":"Grids","title":"Base.lastindex","text":"Base.lastindex(fg::FermionicMatsubaraGrid)\n\nReturn the last index of a FermionicMatsubaraGrid struct.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.lastindex-Tuple{BosonicImaginaryTimeGrid}","page":"Grids","title":"Base.lastindex","text":"Base.lastindex(bg::BosonicImaginaryTimeGrid)\n\nReturn the last index of a BosonicImaginaryTimeGrid struct.\n\nSee also: BosonicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.lastindex-Tuple{BosonicMatsubaraGrid}","page":"Grids","title":"Base.lastindex","text":"Base.lastindex(bg::BosonicMatsubaraGrid)\n\nReturn the last index of a BosonicMatsubaraGrid struct.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{FermionicImaginaryTimeGrid, Int64}","page":"Grids","title":"Base.getindex","text":"Base.getindex(fg::FermionicImaginaryTimeGrid, ind::I64)\n\nRetrieve the value(s) stored at the given key or index within a FermionicImaginaryTimeGrid struct.\n\nSee also: FermionicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{FermionicMatsubaraGrid, Int64}","page":"Grids","title":"Base.getindex","text":"Base.getindex(fg::FermionicMatsubaraGrid, ind::I64)\n\nRetrieve the value(s) stored at the given key or index within a FermionicMatsubaraGrid struct.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{BosonicImaginaryTimeGrid, Int64}","page":"Grids","title":"Base.getindex","text":"Base.getindex(bg::BosonicImaginaryTimeGrid, ind::I64)\n\nRetrieve the value(s) stored at the given key or index within a BosonicImaginaryTimeGrid struct.\n\nSee also: BosonicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{BosonicMatsubaraGrid, Int64}","page":"Grids","title":"Base.getindex","text":"Base.getindex(bg::BosonicMatsubaraGrid, ind::I64)\n\nRetrieve the value(s) stored at the given key or index within a BosonicMatsubaraGrid struct.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{FermionicImaginaryTimeGrid, UnitRange{Int64}}","page":"Grids","title":"Base.getindex","text":"Base.getindex(fg::FermionicImaginaryTimeGrid, I::UnitRange{I64})\n\nReturn a subset of a FermionicImaginaryTimeGrid struct as specified by I.\n\nSee also: FermionicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{FermionicMatsubaraGrid, UnitRange{Int64}}","page":"Grids","title":"Base.getindex","text":"Base.getindex(fg::FermionicMatsubaraGrid, I::UnitRange{I64})\n\nReturn a subset of a FermionicMatsubaraGrid struct as specified by I.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{BosonicImaginaryTimeGrid, UnitRange{Int64}}","page":"Grids","title":"Base.getindex","text":"Base.getindex(bg::BosonicImaginaryTimeGrid, I::UnitRange{I64})\n\nReturn a subset of a BosonicImaginaryTimeGrid struct as specified by I.\n\nSee also: BosonicImaginaryTimeGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Base.getindex-Tuple{BosonicMatsubaraGrid, UnitRange{Int64}}","page":"Grids","title":"Base.getindex","text":"Base.getindex(bg::BosonicMatsubaraGrid, I::UnitRange{I64})\n\nReturn a subset of a BosonicMatsubaraGrid struct as specified by I.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\n","category":"method"},{"location":"library/grid.html#Utilities","page":"Grids","title":"Utilities","text":"","category":"section"},{"location":"library/grid.html","page":"Grids","title":"Grids","text":"rebuild!\nresize!\nreverse!","category":"page"},{"location":"library/grid.html#ACTest.rebuild!","page":"Grids","title":"ACTest.rebuild!","text":"rebuild!(fg::FermionicImaginaryTimeGrid, ntime::I64, β::F64)\n\nRebuild the FermionicImaginaryTimeGrid struct via new ntime and β parameters.\n\nArguments\n\nfg -> A FermionicImaginaryTimeGrid struct.\nntime -> Number of time slices.\nβ -> Inverse temperature.\n\nReturns\n\nN/A\n\nSee also: FermionicImaginaryTimeGrid.\n\n\n\n\n\nrebuild!(fg::FermionicMatsubaraGrid, nfreq::I64, β::F64)\n\nRebuild the FermionicMatsubaraGrid struct via new nfreq and β parameters.\n\nArguments\n\nfg -> A FermionicMatsubaraGrid struct.\nnfreq -> Number of Matsubara frequencies.\nβ -> Inverse temperature.\n\nReturns\n\nN/A\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\nrebuild!(bg::BosonicImaginaryTimeGrid, ntime::I64, β::F64)\n\nRebuild the BosonicImaginaryTimeGrid struct via new ntime and β parameters.\n\nArguments\n\nbg -> A BosonicImaginaryTimeGrid struct.\nntime -> Number of time slices.\nβ -> Inverse temperature.\n\nReturns\n\nN/A\n\nSee also: BosonicImaginaryTimeGrid.\n\n\n\n\n\nrebuild!(bg::BosonicMatsubaraGrid, nfreq::I64, β::F64)\n\nRebuild the BosonicMatsubaraGrid struct via new nfreq and β parameters.\n\nArguments\n\nbg -> A BosonicMatsubaraGrid struct.\nnfreq -> Number of Matsubara frequencies.\nβ -> Inverse temperature.\n\nReturns\n\nN/A\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\n","category":"function"},{"location":"library/grid.html#Base.resize!","page":"Grids","title":"Base.resize!","text":"Base.resize!(fg::FermionicMatsubaraGrid, nfreq::I64)\n\nReduce the size of the fermionic Matsubara grid. Note that nfreq should be smaller than or equal to fg.nfreq. This function is called by the NevanAC solver only.\n\nArguments\n\nfg -> A FermionicMatsubaraGrid struct.\nnfreq -> Number of Matsubara frequencies.\n\nReturns\n\nN/A\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\nBase.resize!(bg::BosonicMatsubaraGrid, nfreq::I64)\n\nReduce the size of the bosonic Matsubara grid. Note that nfreq should be smaller than or equal to bg.nfreq. This function is called by the NevanAC solver only.\n\nArguments\n\nbg -> A BosonicMatsubaraGrid struct.\nnfreq -> Number of Matsubara frequencies.\n\nReturns\n\nN/A\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\n","category":"function"},{"location":"library/grid.html#Base.reverse!","page":"Grids","title":"Base.reverse!","text":"Base.reverse!(fg::FermionicMatsubaraGrid)\n\nReverse the fermionic Matsubara grid. This function is called by the NevanAC solver only.\n\nSee also: FermionicMatsubaraGrid.\n\n\n\n\n\nBase.reverse!(bg::BosonicMatsubaraGrid)\n\nReverse the bosonic Matsubara grid. This function is called by the NevanAC solver only.\n\nSee also: BosonicMatsubaraGrid.\n\n\n\n\n\n","category":"function"},{"location":"man/interface.html#Interface-to-analytic-continuation-toolkits","page":"Interface to ACFlow","title":"Interface to analytic continuation toolkits","text":"","category":"section"},{"location":"man/interface.html","page":"Interface to ACFlow","title":"Interface to ACFlow","text":"The ACTest toolkit is not only capable of generating testing datasets, but also of invoking external programs for analytic continuation calculations. Currently, it is integrated with the ACFlow toolkit via the actest/util/acflow.jl script. ACFlow is an open-source toolkit written in Julia. It supports a variety of highly optimized analytic continuation methods, including the maximum entropy method, barycentric rational function approximation, Nevanlinna analytical continuation, stochastic analytic continuation (both the Beach's algorithm and Sanvik's algorithm are supported), stochastic optimization method, and stochastic pole expansion, etc. The ACTest toolkit is designed in a modular fashion, making it not very difficult to interface with other analytic continuation tools.","category":"page"},{"location":"theory/mesh.html#Meshes-for-spectral-functions","page":"Meshes","title":"Meshes for spectral functions","text":"","category":"section"},{"location":"theory/mesh.html","page":"Meshes","title":"Meshes","text":"The spectral function A(omega) is defined on the real frequency axis. The frequency range for omega is restricted in omega_textmin omega_textmax, where N_omega represents the number of mesh points, omega_textmin and omega_textmax denote the left and right boundaries of the mesh, respectively. Currently, the ACTest toolkit supports four types of meshes: linear, tangent, Lorentzian, and half-Lorentzian meshes. The latter three meshes are non-linear, with the highest grid density near omega = 0. As its name suggests, the half-Lorentzian mesh is only suitable for cases where omega ge 0. Figure 1 illustrates typical examples of the four meshes.","category":"page"},{"location":"theory/mesh.html","page":"Meshes","title":"Meshes","text":"(Image: T_mesh.png)","category":"page"},{"location":"theory/mesh.html","page":"Meshes","title":"Meshes","text":"Figure 1 | The four frequency meshes supported in ACTest: linear, tangent, Lorentzian, and half-Lorentzian meshes. The parameters for these meshes are omega_textmax = -omega_textmin = 20 and N_omega = 101.","category":"page"},{"location":"library/util.html#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"library/util.html","page":"Utilities","title":"Utilities","text":"Provide some utility macros and functions for the ACTest toolkit.","category":"page"},{"location":"library/util.html#Contents","page":"Utilities","title":"Contents","text":"","category":"section"},{"location":"library/util.html","page":"Utilities","title":"Utilities","text":"Pages = [\"util.md\"]\nDepth = 2","category":"page"},{"location":"library/util.html#Index","page":"Utilities","title":"Index","text":"","category":"section"},{"location":"library/util.html","page":"Utilities","title":"Utilities","text":"Pages = [\"util.md\"]","category":"page"},{"location":"library/util.html#Color-Constants","page":"Utilities","title":"Color Constants","text":"","category":"section"},{"location":"library/util.html","page":"Utilities","title":"Utilities","text":"COLORS\nMODES","category":"page"},{"location":"library/util.html#ACTest.COLORS","page":"Utilities","title":"ACTest.COLORS","text":"COLORS\n\nA global dict, which is used to specify the system colors.\n\n\n\n\n\n","category":"constant"},{"location":"library/util.html#ACTest.MODES","page":"Utilities","title":"ACTest.MODES","text":"MODES\n\nA global dict, which is used to specify the mode for output characters.\n\n\n\n\n\n","category":"constant"},{"location":"library/util.html#Macros","page":"Utilities","title":"Macros","text":"","category":"section"},{"location":"library/util.html","page":"Utilities","title":"Utilities","text":"@cswitch\n@time_call\n@pcs","category":"page"},{"location":"library/util.html#ACTest.@cswitch","page":"Utilities","title":"ACTest.@cswitch","text":"@cswitch(constexpr, body)\n\nProvides a C-like switch statement with the falling through behavior. This implementation was borrowed from the following github repository:\n\nhttps://github.com/Gnimuc/CSyntax.jl\n\nExamples\n\nengine = get_d(\"engine\")\n@cswitch engine begin\n    @case \"vasp\"\n        just_do_it()\n        break\n\n    @default\n        sorry()\n        break\nend\n\n\n\n\n\n","category":"macro"},{"location":"library/util.html#ACTest.@time_call","page":"Utilities","title":"ACTest.@time_call","text":"@time_call(ex)\n\nEvaluate a function call (ex), and then print the elapsed time (number of seconds) it took to execute.\n\nThis macro is a variation of the standard @elapsed macro.\n\n\n\n\n\n","category":"macro"},{"location":"library/util.html#ACTest.@pcs","page":"Utilities","title":"ACTest.@pcs","text":"@pcs(x...)\n\nTry to print colorful strings. Here x is a combination of strings and colors. Its format likes string1 color1 string2 color2 (repeat). For the supported colors, please check the global dict COLORS.\n\nExamples\n\njulia> @pcs \"Hello world!\" blue\njulia> @pcs \"Hello \" red \"world!\" green\n\nSee also: COLORS, welcome.\n\n\n\n\n\n","category":"macro"},{"location":"library/util.html#Query-Runtime-Environment","page":"Utilities","title":"Query Runtime Environment","text":"","category":"section"},{"location":"library/util.html","page":"Utilities","title":"Utilities","text":"require\nsetup_args\nquery_args","category":"page"},{"location":"library/util.html#ACTest.require","page":"Utilities","title":"ACTest.require","text":"require()\n\nCheck the version of julia runtime environment. It should be higher than v1.6.x. One of the most important philosophies of the ACTest toolkit is minimizing the dependence on the third-party libraries as far as possible. Note that the ACTest toolkit relys on the TOML package to parse the *.toml file. Only in v1.6.0 and higher versions, julia includes the TOML package in its standard library.\n\nArguments\n\nN/A\n\nReturns\n\nN/A\n\n\n\n\n\n","category":"function"},{"location":"library/util.html#ACTest.setup_args","page":"Utilities","title":"ACTest.setup_args","text":"setup_args(x::Vararg{String})\n\nSetup ARGS manually. This function is used only in REPL environment. We can use this function to update ARGS, so that the query_args() and the other related functions can work correctly.\n\nArguments\n\nx -> Filename of configuration file.\n\nReturns\n\nARGS -> Global variable.\n\nExamples\n\njulia> setup_args(\"act.toml\")\n1-element Array{String,1}:\n \"act.toml\"\n\nSee also: query_args.\n\n\n\n\n\n","category":"function"},{"location":"library/util.html#ACTest.query_args","page":"Utilities","title":"ACTest.query_args","text":"query_args()\n\nCheck whether the configuration file (case.toml) is provided.\n\nArguments\n\nN/A\n\nReturns\n\nx -> ARGS[1], where ARGS is a global variable.\n\nSee also: setup_args.\n\n\n\n\n\n","category":"function"},{"location":"library/util.html#Colorful-Outputs","page":"Utilities","title":"Colorful Outputs","text":"","category":"section"},{"location":"library/util.html","page":"Utilities","title":"Utilities","text":"welcome\noverview\ngoodbye\nsorry\nprompt","category":"page"},{"location":"library/util.html#ACTest.welcome","page":"Utilities","title":"ACTest.welcome","text":"welcome()\n\nPrint out the welcome messages to the screen.\n\nArguments\n\nN/A\n\nReturns\n\nN/A\n\n\n\n\n\n","category":"function"},{"location":"library/util.html#ACTest.overview","page":"Utilities","title":"ACTest.overview","text":"overview()\n\nPrint out the overview of ACTest to the screen.\n\nArguments\n\nN/A\n\nReturns\n\nN/A\n\n\n\n\n\n","category":"function"},{"location":"library/util.html#ACTest.goodbye","page":"Utilities","title":"ACTest.goodbye","text":"goodbye()\n\nPrint the goodbye messages to the screen.\n\nArguments\n\nN/A\n\nReturns\n\nN/A\n\n\n\n\n\n","category":"function"},{"location":"library/util.html#ACTest.sorry","page":"Utilities","title":"ACTest.sorry","text":"sorry()\n\nPrint an error message to the screen.\n\nArguments\n\nN/A\n\nReturns\n\nN/A\n\n\n\n\n\n","category":"function"},{"location":"library/util.html#ACTest.prompt","page":"Utilities","title":"ACTest.prompt","text":"prompt(msg::String)\n\nPrint a stylized ACTest message to the screen.\n\nArguments\n\nmsg -> Message that need to be printed.\n\nReturns\n\nN/A\n\n\n\n\n\n","category":"function"},{"location":"library/util.html#Input/output-Operations","page":"Utilities","title":"Input/output Operations","text":"","category":"section"},{"location":"library/util.html","page":"Utilities","title":"Utilities","text":"line_to_array","category":"page"},{"location":"library/util.html#ACTest.line_to_array","page":"Utilities","title":"ACTest.line_to_array","text":"line_to_array(io::IOStream)\n\nConvert a line (reading from an IOStream) to a string array.\n\nArguments\n\nio -> An IOStream struct.\n\nReturns\n\narr -> An array  of String.\n\n\n\n\n\nline_to_array(str::AbstractString)\n\nConvert a string (AbstractString) to a string array.\n\nArguments\n\nstr -> A String.\n\nReturns\n\nass -> An array of String.\n\nExamples\n\njulia> str = \"Hello World!\"\n\"Hello World!\"\n\njulia> line_to_array(str)\n2-element Vector{SubString{String}}:\n \"Hello\"\n \"World!\"\n\n\n\n\n\n","category":"function"},{"location":"library/util.html#Color-Tools","page":"Utilities","title":"Color Tools","text":"","category":"section"},{"location":"library/util.html","page":"Utilities","title":"Utilities","text":"colorize","category":"page"},{"location":"library/util.html#ACTest.colorize","page":"Utilities","title":"ACTest.colorize","text":"colorize(\n    c::String,\n    s::String;\n    bg::String = \"default\",\n    m::String = \"default\"\n)\n\nReturn some escape sequences, which will be displayed as colorized texts in the terminal.\n\nArguments\n\nc  -> Color names.\ns  -> The string that want to be printed.\nbg -> Background color.\nm  -> Output mode.\n\nReturns\n\nSee above explanations.\n\n\n\n\n\ncolorize(\n    c::Symbol,\n    s::String;\n    bg::String = \"default\",\n    m::String = \"default\"\n)\n\nReturn some escape sequences, which will be displayed as colorized texts in the terminal.\n\nArguments\n\nc  -> Color names.\ns  -> The string that want to be printed.\nbg -> Background color.\nm  -> Output mode.\n\nReturns\n\nSee above explanations.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#Math","page":"Math","title":"Math","text":"","category":"section"},{"location":"library/math.html","page":"Math","title":"Math","text":"Define some essential mathematical functions.","category":"page"},{"location":"library/math.html#Contents","page":"Math","title":"Contents","text":"","category":"section"},{"location":"library/math.html","page":"Math","title":"Math","text":"Pages = [\"math.md\"]\nDepth = 3","category":"page"},{"location":"library/math.html#Index","page":"Math","title":"Index","text":"","category":"section"},{"location":"library/math.html","page":"Math","title":"Math","text":"Pages = [\"math.md\"]","category":"page"},{"location":"library/math.html#Numerical-Integrations","page":"Math","title":"Numerical Integrations","text":"","category":"section"},{"location":"library/math.html","page":"Math","title":"Math","text":"trapz\nsimpson","category":"page"},{"location":"library/math.html#ACTest.trapz","page":"Math","title":"ACTest.trapz","text":"trapz(x::AbstractMesh, y::AbstractVector{T}) where {T<:N64}\n\nPerform numerical integration by using the composite trapezoidal rule.\n\nArguments\n\nx -> Real frequency mesh.\ny -> Function values at real axis.\n\nReturns\n\nℐ -> The final value.\n\nSee also: simpson.\n\n\n\n\n\ntrapz(\n    x::AbstractVector{S},\n    y::AbstractVector{T},\n    linear::Bool = false\n) where {S<:Number, T<:Number}\n\nPerform numerical integration by using the composite trapezoidal rule. Note that it supports arbitrary precision via BigFloat.\n\nArguments\n\nx      -> Real frequency mesh.\ny      -> Function values at real axis.\nlinear -> Whether the given mesh is linear?\n\nReturns\n\nℐ -> The final value.\n\nSee also: simpson.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#ACTest.simpson","page":"Math","title":"ACTest.simpson","text":"simpson(\n    x::AbstractVector{S},\n    y::AbstractVector{T}\n) where {S<:Number, T<:Number}\n\nPerform numerical integration by using the simpson rule. Note that the length of x and y must be odd numbers. And x must be a linear and uniform mesh.\n\nArguments\n\nx -> Real frequency mesh.\ny -> Function values at real axis.\n\nReturns\n\nℐ -> The final value.\n\nSee also: trapz.\n\n\n\n\n\n","category":"function"},{"location":"library/math.html#Einstein-Summation-Convention","page":"Math","title":"Einstein Summation Convention","text":"","category":"section"},{"location":"library/math.html","page":"Math","title":"Math","text":"@einsum","category":"page"},{"location":"library/math.html#ACTest.@einsum","page":"Math","title":"ACTest.@einsum","text":"@einsum(ex)\n\nPerform Einstein summation like operations on Julia Arrays.\n\nExamples\n\nBasic matrix multiplication can be implemented as:\n\n@einsum A[i, j] := B[i, k] * C[k, j]\n\nIf the destination array is preallocated, then use =:\n\nA = ones(5, 6, 7) # Preallocated space\nX = randn(5, 2)\nY = randn(6, 2)\nZ = randn(7, 2)\n\n# Store the result in A, overwriting as necessary:\n@einsum A[i, j, k] = X[i, r] * Y[j, r] * Z[k, r]\n\nIf destination is not preallocated, then use := to automatically create a new array for the result:\n\nX = randn(5, 2)\nY = randn(6, 2)\nZ = randn(7, 2)\n\n# Create new array B with appropriate dimensions:\n@einsum B[i, j, k] := X[i, r] * Y[j, r] * Z[k, r]\n\n\n\n\n\n","category":"macro"},{"location":"theory/noise.html#Artificial-noise","page":"Noise","title":"Artificial noise","text":"","category":"section"},{"location":"theory/noise.html","page":"Noise","title":"Noise","text":"Assuming that we already construct the spectral function A(omega), it is then straightforward to calculate G(tau) or G(iomega_n) via Laplace transformation. At this point, the synthetic Green's function G is exact, containing no numerical noise. We name it G_textexact. However, the Green's functions obtained from quantum many-body calculations are often noisy. This is especially the case in finite-temperature quantum Monte Carlo simulations, where numerical noise is inevitable. To make things worse, when the fermionic sign problem is severe, the noise correspondingly increases. To simulate this scenario, the ACTest toolkit can introduce artificial noise into the synthetic Green's function as follows:","category":"page"},{"location":"theory/noise.html","page":"Noise","title":"Noise","text":"beginequation\nG_textnoisy = G_textexact1 + delta mathcalN_C(01)\nendequation","category":"page"},{"location":"theory/noise.html","page":"Noise","title":"Noise","text":"where mathcalN_C(01) represents complex-valued Gaussian noise with zero mean and unit variance, and the parameter delta is used to control the noise level (0 le delta le 1).","category":"page"},{"location":"intro/ack.html#Acknowledgements","page":"Acknowledgements","title":"Acknowledgements","text":"","category":"section"},{"location":"intro/ack.html","page":"Acknowledgements","title":"Acknowledgements","text":"This project has been supported by the following foundations:","category":"page"},{"location":"intro/ack.html","page":"Acknowledgements","title":"Acknowledgements","text":"CAEP Foundation (under Grant No.CX20210033)\nNational Science Foundation of China (under Grants No.11874329).\nNational Science Foundation of China (under Grants No.11934020).","category":"page"},{"location":"man/install.html#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"man/install.html#Prerequisites","page":"Installation","title":"Prerequisites","text":"","category":"section"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"We chose the Julia language to develop the ACTest toolkit. Julia is an interpreted language. Hence, to run the ACTest toolkit, the latest version of the Julia interpreter must be installed on the target system. Actually, Julia's version number should not be less than 1.6. The core features of the ACTest toolkit rely only on Julia's standard library. However, if one needs to invoke the ACFlow toolkit for analytic continuation calculations, the toolkit must be available in the system. As for how to install and configure the ACFlow toolkit, please refer to the relevant paper. Additionally, if one wants to use the built-in script of ACTest to visualize the calculated results (i.e., the spectral functions), support from the CairoMakie.jl package is necessary. CairoMakie.jl is a 2D plotting program developed in Julia. It can be installed via Julia's package manager:","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"julia> ]\n(@v1.11) pkg> add CairoMakie","category":"page"},{"location":"man/install.html#Main-program","page":"Installation","title":"Main program","text":"","category":"section"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"The official repository of the ACTest toolkit is hosted on github. Its URL is as follows:","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"https://github.com/huangli712/ACTest","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"Since the ACTest toolkit has not yet been registered as a regular Julia package, please type the following commands in Julia's REPL to install it:","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"julia> using Pkg\njulia> Pkg.add(\"https://github.com/huangli712/ACTest\")","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"If this method fails due to an unstable network connection, an offline method should be adopted. First of all, please download the compressed package for the ACTest toolkit from github. Usually it is called actest.tar.gz or actest.zip. Second, please copy it to your favorite directory (such as /home/your_home), and then enter the following command in the terminal to decompress it:","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"$ tar xvfz actest.tar.gz","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"or","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"$ unzip actest.zip","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"Finally, we just assume that the ACTest toolkit is placed in the directory:","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"/home/your_home/actest","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"Now we have to manually insert the following codes at the beginning of all ACTest's scripts:","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"# Add the ACTest package to the Julia load path\npush!(LOAD_PATH, \"/home/your_home/actest/src\")","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"These modifications just ensure that the Julia interpreter can find and import the ACTest toolkit correctly. Now it should work as expected.","category":"page"},{"location":"man/install.html#Documentation","page":"Installation","title":"Documentation","text":"","category":"section"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"The ACTest toolkit ships with detailed documentation, including the user's manual and application programming interface. They are developed with the Markdown language and the Documenter.jl package. So, please make sure that the latest version of the Documenter.jl package is ready (see https://github.com/JuliaDocs/Documenter.jl for more details). If everything is OK, users can generate the documentation by themselves. Please enter the following commands in the terminal:","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"$ pwd\n/home/your_home/actest\n$ cd docs\n$ julia make.jl","category":"page"},{"location":"man/install.html","page":"Installation","title":"Installation","text":"After a few seconds, the documentation is built and saved in the actest/docs/build directory. The entry of the documentation is actest/docs/build/index.html. You can open it with any web browser.","category":"page"},{"location":"library/kernel.html#Kernels","page":"Kernels","title":"Kernels","text":"","category":"section"},{"location":"library/kernel.html","page":"Kernels","title":"Kernels","text":"Build kernel functions.","category":"page"},{"location":"library/kernel.html","page":"Kernels","title":"Kernels","text":"The ACTest toolkit supports twelve types of kernel functions. They are:","category":"page"},{"location":"library/kernel.html","page":"Kernels","title":"Kernels","text":"Fermionic imaginary time kernel (ktype = \"fermi\", grid = \"ftime\")\nFermionic Matsubara kernel (ktype = \"fermi\", grid = \"ffreq\")\nBosonic imaginary time kernel (ktype = \"boson\", grid = \"btime\")\nBosonc Matsubara kernel (ktype = \"boson\", grid = \"bfreq\")\nSymmetric bosonic imaginary time kernel (ktype = \"bsymm\", grid = \"btime\")\nSymmetric bosonic Matsubara kernel (ktype = \"bsymm\", grid = \"bfreq\")","category":"page"},{"location":"library/kernel.html#Contents","page":"Kernels","title":"Contents","text":"","category":"section"},{"location":"library/kernel.html","page":"Kernels","title":"Kernels","text":"Pages = [\"kernel.md\"]\nDepth = 2","category":"page"},{"location":"library/kernel.html#Index","page":"Kernels","title":"Index","text":"","category":"section"},{"location":"library/kernel.html","page":"Kernels","title":"Kernels","text":"Pages = [\"kernel.md\"]","category":"page"},{"location":"library/kernel.html#Making-Kernels","page":"Kernels","title":"Making Kernels","text":"","category":"section"},{"location":"library/kernel.html","page":"Kernels","title":"Kernels","text":"build_kernel\nbuild_kernel_symm","category":"page"},{"location":"library/kernel.html#ACTest.build_kernel","page":"Kernels","title":"ACTest.build_kernel","text":"build_kernel(am::AbstractMesh, fg::FermionicImaginaryTimeGrid)\n\nTry to build fermionic kernel function in imaginary time axis.\n\nArguments\n\nam -> Real frequency mesh.\nfg -> Imaginary time grid.\n\nReturns\n\nkernel -> Kernel function, K(τ,ω).\n\nSee also: AbstractMesh, FermionicImaginaryTimeGrid.\n\n\n\n\n\nbuild_kernel(am::AbstractMesh, fg::FermionicMatsubaraGrid)\n\nTry to build fermionic kernel function in Matsubara frequency axis.\n\nArguments\n\nam -> Real frequency mesh.\nfg -> Matsubara frequency grid.\n\nReturns\n\nkernel -> Kernel function, K(iωₙ,ω).\n\nSee also: AbstractMesh, FermionicMatsubaraGrid.\n\n\n\n\n\nbuild_kernel(am::AbstractMesh, bg::BosonicImaginaryTimeGrid)\n\nTry to build bosonic kernel function in imaginary time axis.\n\nArguments\n\nam -> Real frequency mesh.\nbg -> Imaginary time grid.\n\nReturns\n\nkernel -> Kernel function, K(τ,ω).\n\nSee also: AbstractMesh, BosonicImaginaryTimeGrid.\n\n\n\n\n\nbuild_kernel(am::AbstractMesh, bg::BosonicMatsubaraGrid)\n\nTry to build bosonic kernel function in Matsubara frequency axis.\n\nArguments\n\nam -> Real frequency mesh.\nbg -> Matsubara frequency grid.\n\nReturns\n\nkernel -> Kernel function, K(iωₙ,ω).\n\nSee also: AbstractMesh, BosonicMatsubaraGrid.\n\n\n\n\n\n","category":"function"},{"location":"library/kernel.html#ACTest.build_kernel_symm","page":"Kernels","title":"ACTest.build_kernel_symm","text":"build_kernel_symm(am::AbstractMesh, bg::BosonicImaginaryTimeGrid)\n\nTry to build bosonic kernel function in imaginary time axis (just for correlator of Hermitian operator only).\n\nArguments\n\nam -> Real frequency mesh.\nbg -> Imaginary time grid.\n\nReturns\n\nkernel -> Kernel function, K(τ,ω).\n\nSee also: AbstractMesh, BosonicImaginaryTimeGrid.\n\n\n\n\n\nbuild_kernel_symm(am::AbstractMesh, bg::BosonicMatsubaraGrid)\n\nTry to build bosonic kernel function in Matsubara frequency axis (just for correlator of Hermitian operator only).\n\nArguments\n\nam -> Real frequency mesh.\nbg -> Matsubara frequency grid.\n\nReturns\n\nkernel -> Kernel function, K(iωₙ,ω).\n\nSee also: AbstractMesh, BosonicMatsubaraGrid.\n\n\n\n\n\n","category":"function"},{"location":"man/act100.html#Built-in-testing-dataset","page":"Built-in testing dataset","title":"Built-in testing dataset","text":"","category":"section"},{"location":"man/act100.html","page":"Built-in testing dataset","title":"Built-in testing dataset","text":"The ACTest toolkit operates in two modes. On one hand, ACTest can randomly generate a large number of spectral functions and Green's functions. People can use them to train or examine machine learning models for solving analytic continuation problems. On the other hand, ACTest includes a standard testing dataset. This dataset comprises 100 representative tests, 50 for fermionic systems and 50 for bosonic systems. Hence we name it the ACT100 dataset. In this dataset, the spectral functions are constructed with predefined parameters (it means that all the peaks and features in these spectra are certain), so they are reproducible. Note that users can only change the grids and the noise levels of the synthetic Green's functions. The basic configurations regarding the fermionic subset of the ACT100 dataset are shown in Table 1. As for the bosonic subset, the basic configurations are identical. The only difference is the use of bosonic kernels to generate the Green's functions. Four typical spectral functions in the ACT100 dataset are illustrated in Figure 1.","category":"page"},{"location":"man/act100.html","page":"Built-in testing dataset","title":"Built-in testing dataset","text":"The ACT100 dataset can be utilized to assess the accuracy of various analytic continuation methods. The question is how to measure the accuracy. Supposed that the true spectral function and the calculated spectral function are A_texttrue(omega) and A_textcalc(omega), respectively, their difference can be calculated by the following expression:","category":"page"},{"location":"man/act100.html","page":"Built-in testing dataset","title":"Built-in testing dataset","text":"beginequation\ntextErr(A_texttrueA_textcalc) =\nint^omega_textmax_omega_textmin domega\nLarge A_texttrue(omega) - A_textcalc(omega)Large \n\nint^omega_textmax_omega_textmin domega\nLarge A_texttrue(omega)Large \nendequation","category":"page"},{"location":"man/act100.html","page":"Built-in testing dataset","title":"Built-in testing dataset","text":"It is evident that the smaller the value of Err(A_texttrueA_textcalc), the better. Thus, the accuracy of an analytic continuation method can be evaluated by:","category":"page"},{"location":"man/act100.html","page":"Built-in testing dataset","title":"Built-in testing dataset","text":"beginequation\nf = sum^N_texttest_i = 1\nthetaleft1 - textErrleft(A^i_texttrueA^i_textcalcright)right\nleft1 - textErrleft(A^i_texttrueA^i_textcalcright)right\nendequation","category":"page"},{"location":"man/act100.html","page":"Built-in testing dataset","title":"Built-in testing dataset","text":"Here, N_texttest is the number of tests, i is the index, theta(x) is the Heaviside step function. It is obvious that textmax(f) = N_texttest and textmin(f) = 0.","category":"page"},{"location":"man/act100.html","page":"Built-in testing dataset","title":"Built-in testing dataset","text":"System Spectrum's type Peak's type Number of peaks Number of spectra / tests\nFermionic Continuum spectrum, Gaussian 1 3\n A(omega) ge 0  2 7\n   3 10\nFermionic Discrete spectrum, Gaussian 1 5\n A(omega) ge 0  2 5\n   3 2\n   4 3\n   5 3\n   6 2\nFermionic Continuum spectrum, Rise-And-Decay 1 1\n A(omega) is non-positive definite  2 5\n   3 2\n   4 1\n   5 1","category":"page"},{"location":"man/act100.html","page":"Built-in testing dataset","title":"Built-in testing dataset","text":"Table 1 | Basic configurations about the fermionic subset in the ACT100 dataset. Clearly, the fermionic subset is classified into three parts. Both the first and the second parts are for diagonal Green's functions, where A(omega) is positive. Their spectra are continuum and discrete, respectively. The third part is for off-diagonal Green's functions, where A(omega) is non-positive definite and continuum. The configurations for the bosonic subset are the same. It is also classified into three parts according to positive definiteness of tildeA(omega) [equiv A(omega)omega]. Full parameters for constructing these spectra are defined in actest/src/dataset.jl.","category":"page"},{"location":"man/act100.html","page":"Built-in testing dataset","title":"Built-in testing dataset","text":"(Image: T_dataset.png)","category":"page"},{"location":"man/act100.html","page":"Built-in testing dataset","title":"Built-in testing dataset","text":"Figure 1 | Four representative spectra in the ACT100 dataset. The vertical dashed lines denote the Fermi level. The raw data and figures are generated by the actest/util/acstd.jl and actest/util/acplot.jl scripts, respectively.","category":"page"},{"location":"library/global.html#Constants","page":"Constants","title":"Constants","text":"","category":"section"},{"location":"library/global.html","page":"Constants","title":"Constants","text":"Define some type aliases and string constants for the ACTest toolkit.","category":"page"},{"location":"library/global.html#Contents","page":"Constants","title":"Contents","text":"","category":"section"},{"location":"library/global.html","page":"Constants","title":"Constants","text":"Pages = [\"global.md\"]\nDepth = 2","category":"page"},{"location":"library/global.html#Index","page":"Constants","title":"Index","text":"","category":"section"},{"location":"library/global.html","page":"Constants","title":"Constants","text":"Pages = [\"global.md\"]","category":"page"},{"location":"library/global.html#Numerical-Types","page":"Constants","title":"Numerical Types","text":"","category":"section"},{"location":"library/global.html","page":"Constants","title":"Constants","text":"I32\nI64\nAPI\nF32\nF64\nAPF\nC32\nC64\nAPC\nR32\nR64\nAPR\nN32\nN64\nAPN","category":"page"},{"location":"library/global.html#ACTest.I32","page":"Constants","title":"ACTest.I32","text":"I32\n\nAlias of Integer type (32 bit).\n\nSee also: R32, N32.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACTest.I64","page":"Constants","title":"ACTest.I64","text":"I64\n\nAlias of Integer type (64 bit).\n\nSee also: R64, N64.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACTest.API","page":"Constants","title":"ACTest.API","text":"API\n\nAlias of Integer type (Arbitrary Precision Integer).\n\nSee also: APF, APC.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACTest.F32","page":"Constants","title":"ACTest.F32","text":"F32\n\nAlias of Float type (32 bit).\n\nSee also: R32, N32.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACTest.F64","page":"Constants","title":"ACTest.F64","text":"F64\n\nAlias of Float type (64 bit).\n\nSee also: R64, N64.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACTest.APF","page":"Constants","title":"ACTest.APF","text":"APF\n\nAlias of Float type (Arbitrary Precision Float).\n\nSee also: API, APC.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACTest.C32","page":"Constants","title":"ACTest.C32","text":"C32\n\nAlias of Complex type (32 bit).\n\nSee also: R32, N32.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACTest.C64","page":"Constants","title":"ACTest.C64","text":"C64\n\nAlias of Complex type (64 bit).\n\nSee also: R64, N64.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACTest.APC","page":"Constants","title":"ACTest.APC","text":"APC\n\nAlias of Complex type (Arbitrary Precision Complex).\n\nSee also: API, APF.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACTest.R32","page":"Constants","title":"ACTest.R32","text":"R32\n\nAlias of Integer and Float types (32 bit). Here R means Real.\n\nSee also: N32, N64, APN.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACTest.R64","page":"Constants","title":"ACTest.R64","text":"R64\n\nAlias of Integer and Float types (64 bit). Here R means Real.\n\nSee also: N32, N64, APN.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACTest.APR","page":"Constants","title":"ACTest.APR","text":"APR\n\nAlias of Integer and Float types (Arbitrary Precision). Here R means Real.\n\nSee also: N32, N64, APN.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACTest.N32","page":"Constants","title":"ACTest.N32","text":"N32\n\nAlias of Integer, Float, and Complex types (32 bit). Here N means Number.\n\nSee also: R32, R64, APR.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACTest.N64","page":"Constants","title":"ACTest.N64","text":"N64\n\nAlias of Integer, Float, and Complex types (64 bit). Here N means Number.\n\nSee also: R32, R64, APR.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#ACTest.APN","page":"Constants","title":"ACTest.APN","text":"APN\n\nAlias of Integer, Float, and Complex types (Arbitrary Precision). Here N means Number.\n\nSee also: R32, R64, APR.\n\n\n\n\n\n","category":"type"},{"location":"library/global.html#String-Constants","page":"Constants","title":"String Constants","text":"","category":"section"},{"location":"library/global.html","page":"Constants","title":"Constants","text":"__LIBNAME__\n__VERSION__\n__RELEASE__\n__AUTHORS__","category":"page"},{"location":"library/global.html#ACTest.__LIBNAME__","page":"Constants","title":"ACTest.__LIBNAME__","text":"__LIBNAME__\n\nName of this julia toolkit.\n\nSee also: __VERSION__.\n\n\n\n\n\n","category":"constant"},{"location":"library/global.html#ACTest.__VERSION__","page":"Constants","title":"ACTest.__VERSION__","text":"__VERSION__\n\nVersion of this julia toolkit.\n\nSee also: __RELEASE__.\n\n\n\n\n\n","category":"constant"},{"location":"library/global.html#ACTest.__RELEASE__","page":"Constants","title":"ACTest.__RELEASE__","text":"__RELEASE__\n\nRelease date of this julia toolkit.\n\nSee also: __AUTHORS__.\n\n\n\n\n\n","category":"constant"},{"location":"library/global.html#ACTest.__AUTHORS__","page":"Constants","title":"ACTest.__AUTHORS__","text":"__AUTHORS__\n\nCore authors of this julia toolkit.\n\nSee also: __LIBNAME__.\n\n\n\n\n\n","category":"constant"},{"location":"library/global.html#Utilities","page":"Constants","title":"Utilities","text":"","category":"section"},{"location":"library/global.html","page":"Constants","title":"Constants","text":"authors","category":"page"},{"location":"library/global.html#ACTest.authors","page":"Constants","title":"ACTest.authors","text":"authors()\n\nPrint authors / contributors of the ACTest toolkit.\n\nSee also: __AUTHORS__.\n\n\n\n\n\n","category":"function"},{"location":"man/input.html#Inputs","page":"Inputs","title":"Inputs","text":"","category":"section"},{"location":"man/input.html","page":"Inputs","title":"Inputs","text":"The scripts in the ACTest toolkit require only one input file, which is act.toml. Below is a typical act.toml file with some omissions. In this act.toml, text following the # symbol is considered as a comment. It contains two sections: [Test] and [Solver].","category":"page"},{"location":"man/input.html","page":"Inputs","title":"Inputs","text":"The [Test] section is mandatory, which controls generation of spectral functions and corresponding Green's functions. We would like to explain the relevant control parameters in the following text.","category":"page"},{"location":"man/input.html","page":"Inputs","title":"Inputs","text":"The [Solver] section is optional. Now it is used to configure the analytic continuation methods as implemented in the ACFlow toolkit. Only the acflow.jl script needs to read the [Solver] section. It will transfer these parameters to the ACFlow toolkit to customize the successive analytic continuation calculations. For possible parameters within the [Solver] section, please refer to the documentation of the ACFlow toolkit.","category":"page"},{"location":"man/input.html","page":"Inputs","title":"Inputs","text":"#\n# Test: A01\n#\n# 1. Execute ../../util/acgen.jl act.toml.\n# 2. Change solver = \"MaxEnt\" and modify the [Solver] section accordingly.\n# 3. Execute ../../util/acflow.jl act.toml.\n# 4. Execute ../../util/acplot.jl act.toml.\n#\n\n[Test]\nsolver  = \"MaxEnt\"\n...\n\n[Solver]\nmethod = \"chi2kink\"\n...","category":"page"},{"location":"library/dataset.html#Standard-dataset","page":"Standard dataset","title":"Standard dataset","text":"","category":"section"},{"location":"library/dataset.html","page":"Standard dataset","title":"Standard dataset","text":"Define the standard dataset of spectral functions (namely ACT100).","category":"page"},{"location":"library/dataset.html#Contents","page":"Standard dataset","title":"Contents","text":"","category":"section"},{"location":"library/dataset.html","page":"Standard dataset","title":"Standard dataset","text":"Pages = [\"dataset.md\"]\nDepth = 2","category":"page"},{"location":"library/dataset.html#Index","page":"Standard dataset","title":"Index","text":"","category":"section"},{"location":"library/dataset.html","page":"Standard dataset","title":"Standard dataset","text":"Pages = [\"dataset.md\"]","category":"page"},{"location":"library/dataset.html#Dictionaries","page":"Standard dataset","title":"Dictionaries","text":"","category":"section"},{"location":"library/dataset.html","page":"Standard dataset","title":"Standard dataset","text":"STD_FG\nSTD_FD\nSTD_FRD\nSTD_BG\nSTD_BD\nSTD_BRD","category":"page"},{"location":"library/dataset.html#ACTest.STD_FG","page":"Standard dataset","title":"ACTest.STD_FG","text":"STD_FG\n\nDictionary for standard spectral functions: fermionic + gaussian peaks.\n\n\n\n\n\n","category":"constant"},{"location":"library/dataset.html#ACTest.STD_FD","page":"Standard dataset","title":"ACTest.STD_FD","text":"STD_FD\n\nDictionary for standard spectral functions: fermionic + delta-like peaks.\n\n\n\n\n\n","category":"constant"},{"location":"library/dataset.html#ACTest.STD_FRD","page":"Standard dataset","title":"ACTest.STD_FRD","text":"STD_FRD\n\nDictionary for standard spectral functions: fermionic + rise-and-decay peaks.\n\n\n\n\n\n","category":"constant"},{"location":"library/dataset.html#ACTest.STD_BG","page":"Standard dataset","title":"ACTest.STD_BG","text":"STD_BG\n\nDictionary for standard spectral functions: bosonic + gaussian peaks.\n\n\n\n\n\n","category":"constant"},{"location":"library/dataset.html#ACTest.STD_BD","page":"Standard dataset","title":"ACTest.STD_BD","text":"STD_BD\n\nDictionary for standard spectral functions: bosonic + delta-like peaks.\n\n\n\n\n\n","category":"constant"},{"location":"library/dataset.html#ACTest.STD_BRD","page":"Standard dataset","title":"ACTest.STD_BRD","text":"STD_BRD\n\nDictionary for standard spectral functions: bosonic + rise-and-decay peaks.\n\n\n\n\n\n","category":"constant"},{"location":"library/mesh.html#Meshes","page":"Meshes","title":"Meshes","text":"","category":"section"},{"location":"library/mesh.html","page":"Meshes","title":"Meshes","text":"Meshes on real axis.","category":"page"},{"location":"library/mesh.html","page":"Meshes","title":"Meshes","text":"The spectral functions are always defined on real axis. The ACTest toolkit supports various uniform and non-uniform meshes. In order to build these meshes, we need some additional control parameters, including f_1 and cut. They should be setup by using the parameter pmesh.","category":"page"},{"location":"library/mesh.html#Contents","page":"Meshes","title":"Contents","text":"","category":"section"},{"location":"library/mesh.html","page":"Meshes","title":"Meshes","text":"Pages = [\"mesh.md\"]\nDepth = 2","category":"page"},{"location":"library/mesh.html#Index","page":"Meshes","title":"Index","text":"","category":"section"},{"location":"library/mesh.html","page":"Meshes","title":"Meshes","text":"Pages = [\"mesh.md\"]","category":"page"},{"location":"library/mesh.html#Types","page":"Meshes","title":"Types","text":"","category":"section"},{"location":"library/mesh.html","page":"Meshes","title":"Meshes","text":"AbstractMesh\nLinearMesh\nTangentMesh\nLorentzMesh\nHalfLorentzMesh\nDynamicMesh","category":"page"},{"location":"library/mesh.html#ACTest.AbstractMesh","page":"Meshes","title":"ACTest.AbstractMesh","text":"AbstractMesh\n\nAn abstract type representing the real axis. It is used to build the internal type system.\n\n\n\n\n\n","category":"type"},{"location":"library/mesh.html#ACTest.LinearMesh","page":"Meshes","title":"ACTest.LinearMesh","text":"LinearMesh\n\nMutable struct. A linear and uniform mesh.\n\nMembers\n\nnmesh  -> Number of mesh points.\nwmax   -> Right boundary (maximum value).\nwmin   -> Left boundary (minimum value).\nmesh   -> Mesh itself.\nweight -> Precomputed integration weights (composite trapezoidal rule).\n\nSee also: TangentMesh.\n\n\n\n\n\n","category":"type"},{"location":"library/mesh.html#ACTest.TangentMesh","page":"Meshes","title":"ACTest.TangentMesh","text":"TangentMesh\n\nMutable struct. A non-linear and non-uniform mesh. Note that it should be defined on both negative and positive half-axis.\n\nMembers\n\nnmesh  -> Number of mesh points.\nwmax   -> Right boundary (maximum value).\nwmin   -> Left boundary (minimum value).\nmesh   -> Mesh itself.\nweight -> Precomputed integration weights (composite trapezoidal rule).\n\nSee also: LinearMesh.\n\n\n\n\n\n","category":"type"},{"location":"library/mesh.html#ACTest.LorentzMesh","page":"Meshes","title":"ACTest.LorentzMesh","text":"LorentzMesh\n\nMutable struct. A non-linear and non-uniform mesh. Note that it should be defined on both negative and positive half-axis.\n\nMembers\n\nnmesh  -> Number of mesh points.\nwmax   -> Right boundary (maximum value).\nwmin   -> Left boundary (minimum value).\nmesh   -> Mesh itself.\nweight -> Precomputed integration weights (composite trapezoidal rule).\n\nSee also: HalfLorentzMesh.\n\n\n\n\n\n","category":"type"},{"location":"library/mesh.html#ACTest.HalfLorentzMesh","page":"Meshes","title":"ACTest.HalfLorentzMesh","text":"HalfLorentzMesh\n\nMutable struct. A non-linear and non-uniform mesh. Note that it should be defined on positive half-axis only.\n\nMembers\n\nnmesh  -> Number of mesh points.\nwmax   -> Right boundary (maximum value).\nwmin   -> Left boundary (minimum value). It must be 0.0.\nmesh   -> Mesh itself.\nweight -> Precomputed integration weights (composite trapezoidal rule).\n\nSee also: LorentzMesh.\n\n\n\n\n\n","category":"type"},{"location":"library/mesh.html#ACTest.DynamicMesh","page":"Meshes","title":"ACTest.DynamicMesh","text":"DynamicMesh\n\nMutable struct. A mesh used internally in the util/acplot.jl script. It supports both uniform and non-uniform meshes.\n\nMembers\n\nnmesh  -> Number of mesh points.\nwmax   -> Right boundary (maximum value).\nwmin   -> Left boundary (minimum value).\nmesh   -> Mesh itself.\nweight -> Precomputed integration weights (composite trapezoidal rule).\n\nSee also: LinearMesh.\n\n\n\n\n\n","category":"type"},{"location":"library/mesh.html#Constructors","page":"Meshes","title":"Constructors","text":"","category":"section"},{"location":"library/mesh.html","page":"Meshes","title":"Meshes","text":"LinearMesh(nmesh::I64, wmin::F64, wmax::F64)\nTangentMesh(nmesh::I64, wmin::F64, wmax::F64, 𝑝::F64 = 2.1)\nLorentzMesh(nmesh::I64, wmin::F64, wmax::F64, 𝑝::F64 = 0.01)\nHalfLorentzMesh(nmesh::I64, wmax::F64, 𝑝::F64 = 0.01)\nDynamicMesh(mesh::Vector{F64})","category":"page"},{"location":"library/mesh.html#ACTest.LinearMesh-Tuple{Int64, Float64, Float64}","page":"Meshes","title":"ACTest.LinearMesh","text":"LinearMesh(nmesh::I64, wmin::F64, wmax::F64)\n\nA constructor for the LinearMesh struct, which is announced in src/types.jl.\n\nArguments\n\nnmesh -> Number of mesh points.\nwmin  -> Left boundary of the mesh.\nwmax  -> Right boundary of the mesh.\n\nReturns\n\nlm -> A LinearMesh struct.\n\nSee also: LinearMesh.\n\n\n\n\n\n","category":"method"},{"location":"library/mesh.html#ACTest.TangentMesh-2","page":"Meshes","title":"ACTest.TangentMesh","text":"TangentMesh(nmesh::I64, wmin::F64, wmax::F64, 𝑝::F64 = 2.1)\n\nA constructor for the TangentMesh struct, which is announced in src/types.jl.\n\nArguments\n\nnmesh -> Number of mesh points.\nwmin  -> Left boundary of the mesh.\nwmax  -> Right boundary of the mesh.\n𝑝     -> A customized parameter.\n\nReturns\n\ntm -> A TangentMesh struct.\n\nSee also: TangentMesh.\n\n\n\n\n\n","category":"type"},{"location":"library/mesh.html#ACTest.LorentzMesh-2","page":"Meshes","title":"ACTest.LorentzMesh","text":"LorentzMesh(nmesh::I64, wmin::F64, wmax::F64, 𝑝::F64 = 0.01)\n\nA constructor for the LorentzMesh struct, which is announced in src/types.jl. The algorithm for generating a lorentzian mesh is taken from:\n\nhttps://github.com/CQMP/Maxent.\n\nArguments\n\nnmesh -> Number of mesh points.\nwmin  -> Left boundary of the mesh.\nwmax  -> Right boundary of the mesh.\n𝑝     -> A customized parameter.\n\nReturns\n\nlm -> A LorentzMesh struct.\n\nSee also: LorentzMesh.\n\n\n\n\n\n","category":"type"},{"location":"library/mesh.html#ACTest.HalfLorentzMesh-2","page":"Meshes","title":"ACTest.HalfLorentzMesh","text":"HalfLorentzMesh(nmesh::I64, wmax::F64, 𝑝::F64 = 0.01)\n\nA constructor for the HalfLorentzMesh struct, which is announced in src/types.jl. The algorithm for generating a half-lorentzian mesh is taken from:\n\nhttps://github.com/CQMP/Maxent.\n\nArguments\n\nnmesh -> Number of mesh points.\nwmax  -> Right boundary of the mesh (wmin ≡ 0.0).\n𝑝     -> A customized parameter.\n\nReturns\n\nhm -> A HalfLorentzMesh struct.\n\nSee also: HalfLorentzMesh.\n\n\n\n\n\n","category":"type"},{"location":"library/mesh.html#ACTest.DynamicMesh-Tuple{Vector{Float64}}","page":"Meshes","title":"ACTest.DynamicMesh","text":"DynamicMesh(mesh::Vector{F64})\n\nA constructor for the DynamicMesh struct, which is announced in src/types.jl. This mesh is usually used to describe the real frequency mesh that read from files.\n\nArguments\n\nmesh -> Usually a mesh from file image.data or Aout.data.\n\nReturns\n\ndm -> A DynamicMesh struct.\n\nSee also: DynamicMesh.\n\n\n\n\n\n","category":"method"},{"location":"library/mesh.html#Base.*-Functions","page":"Meshes","title":"Base.* Functions","text":"","category":"section"},{"location":"library/mesh.html","page":"Meshes","title":"Meshes","text":"Base.length(am::AbstractMesh)\nBase.iterate(am::AbstractMesh)\nBase.iterate(am::AbstractMesh, i::I64)\nBase.eachindex(am::AbstractMesh)\nBase.firstindex(am::AbstractMesh)\nBase.lastindex(am::AbstractMesh)\nBase.getindex(am::AbstractMesh, ind::I64)\nBase.getindex(am::AbstractMesh, I::UnitRange{I64})","category":"page"},{"location":"library/mesh.html#Base.length-Tuple{AbstractMesh}","page":"Meshes","title":"Base.length","text":"Base.length(am::AbstractMesh)\n\nReturn number of mesh points in a Mesh-like struct.\n\n\n\n\n\n","category":"method"},{"location":"library/mesh.html#Base.iterate-Tuple{AbstractMesh}","page":"Meshes","title":"Base.iterate","text":"Base.iterate(am::AbstractMesh)\n\nAdvance the iterator of a Mesh-like struct to obtain the next mesh point.\n\n\n\n\n\n","category":"method"},{"location":"library/mesh.html#Base.iterate-Tuple{AbstractMesh, Int64}","page":"Meshes","title":"Base.iterate","text":"Base.iterate(am::AbstractMesh, i::I64)\n\nThis is the key method that allows a Mesh-like struct to be iterated, yielding a sequences of mesh points.\n\n\n\n\n\n","category":"method"},{"location":"library/mesh.html#Base.eachindex-Tuple{AbstractMesh}","page":"Meshes","title":"Base.eachindex","text":"Base.eachindex(am::AbstractMesh)\n\nCreate an iterable object for visiting each index of a Mesh-like struct.\n\n\n\n\n\n","category":"method"},{"location":"library/mesh.html#Base.firstindex-Tuple{AbstractMesh}","page":"Meshes","title":"Base.firstindex","text":"Base.firstindex(am::AbstractMesh)\n\nReturn the first index of a Mesh-like struct.\n\n\n\n\n\n","category":"method"},{"location":"library/mesh.html#Base.lastindex-Tuple{AbstractMesh}","page":"Meshes","title":"Base.lastindex","text":"Base.lastindex(am::AbstractMesh)\n\nReturn the last index of a Mesh-like struct.\n\n\n\n\n\n","category":"method"},{"location":"library/mesh.html#Base.getindex-Tuple{AbstractMesh, Int64}","page":"Meshes","title":"Base.getindex","text":"Base.getindex(am::AbstractMesh, ind::I64)\n\nRetrieve the value(s) stored at the given key or index within a Mesh-like struct.\n\n\n\n\n\n","category":"method"},{"location":"library/mesh.html#Base.getindex-Tuple{AbstractMesh, UnitRange{Int64}}","page":"Meshes","title":"Base.getindex","text":"Base.getindex(am::AbstractMesh, I::UnitRange{I64})\n\nReturn a subset of a Mesh-like struct as specified by I.\n\n\n\n\n\n","category":"method"},{"location":"library/mesh.html#Utilities","page":"Meshes","title":"Utilities","text":"","category":"section"},{"location":"library/mesh.html","page":"Meshes","title":"Meshes","text":"nearest","category":"page"},{"location":"library/mesh.html#ACTest.nearest","page":"Meshes","title":"ACTest.nearest","text":"nearest(am::AbstractMesh, r::F64)\n\nGiven a position r (0.0 ≤ r ≤ 1.0), and return the index of the nearest point in the mesh am.\n\nArguments\n\nSee above explanations.\n\nReturns\n\nSee above explanations.\n\nExamples\n\nam = LinearMesh(1001, -10.0, 10.0)\npos = nearest(am, 0.2) # pos = 201\nprintln(am[pos]) # -6.0\n\nSee also: AbstractMesh.\n\n\n\n\n\n","category":"function"},{"location":"man/output.html#Outputs","page":"Outputs","title":"Outputs","text":"","category":"section"},{"location":"man/output.html","page":"Outputs","title":"Outputs","text":"Both acgen.jl and acstd.jl scripts generate image.data.i and green.data.i files. The image.data.i file stores the exact spectral function, i.e., A_texttrue(omega). The green.data.i file stores the imaginary time Green's function G(tau) or the Matsubara Green's function G(iomega_n). The suffix i in filename denotes index for tests. It starts from 1.","category":"page"},{"location":"man/output.html","page":"Outputs","title":"Outputs","text":"The acflow.jl script will output quite a few files. The most important one is Aout.data.i. For other possible output files, please refer to the documentation of the ACFlow toolkit. The Aout.data.i file stores the calculated spectral function, i.e., A_textcalc(omega). The suffix i in filename also represents index for tests.","category":"page"},{"location":"man/output.html","page":"Outputs","title":"Outputs","text":"The aforementioned files are column-based plain texts. They can be opened by any text editor. Their file formats are summarized in Table 1.","category":"page"},{"location":"man/output.html","page":"Outputs","title":"Outputs","text":"As for the acplot.jl script, it will generate image.i.pdf files, which are image files for A_texttrue(omega) and A_textcalc(omega). Actually, the data from the image.data.i and Aout.data.i files are used to generate the image.i.pdf file.","category":"page"},{"location":"man/output.html","page":"Outputs","title":"Outputs","text":"Filename Column 1 Column 2 Column 3 Column 4 Column 5 Number of lines\nimage.data.i omega A_texttrue(omega) - - - N_omega\ngreen.data.i tau G(tau) textVarG(tau) - - N_tau\ngreen.data.i iomega_n ReG(iomega_n) ImG(iomega_n) Var[ReG(iomega_n)] Var[ImG(iomega_n)] N\nAout.data.i omega A_textcalc(omega) - - - N_omega","category":"page"},{"location":"man/output.html","page":"Outputs","title":"Outputs","text":"Table 1 | File formats for selected files generated by the ACTest toolkit. Here, Var[G] means error bar for G. ReG and ImG mean real and imaginary parts of G, respectively.","category":"page"},{"location":"library/spectrum.html#Spectra","page":"Spectra","title":"Spectra","text":"","category":"section"},{"location":"library/spectrum.html","page":"Spectra","title":"Spectra","text":"Declare structs for spectral functions and Green's functions.","category":"page"},{"location":"library/spectrum.html#Contents","page":"Spectra","title":"Contents","text":"","category":"section"},{"location":"library/spectrum.html","page":"Spectra","title":"Spectra","text":"Pages = [\"spectrum.md\"]\nDepth = 2","category":"page"},{"location":"library/spectrum.html#Index","page":"Spectra","title":"Index","text":"","category":"section"},{"location":"library/spectrum.html","page":"Spectra","title":"Spectra","text":"Pages = [\"spectrum.md\"]","category":"page"},{"location":"library/spectrum.html#Types","page":"Spectra","title":"Types","text":"","category":"section"},{"location":"library/spectrum.html","page":"Spectra","title":"Spectra","text":"AbstractFunction\nSpectralFunction\nGreenFunction","category":"page"},{"location":"library/spectrum.html#ACTest.AbstractFunction","page":"Spectra","title":"ACTest.AbstractFunction","text":"AbstractFunction\n\nAn abstract type representing the general functions. It is used to build the internal type system.\n\n\n\n\n\n","category":"type"},{"location":"library/spectrum.html#ACTest.SpectralFunction","page":"Spectra","title":"ACTest.SpectralFunction","text":"SpectralFunction\n\nMutable struct. It represents the spectral function A(ω).\n\nMembers\n\nmesh -> Real frequency mesh, ω.\nimage -> Spectral function, A(ω).\n\n\n\n\n\n","category":"type"},{"location":"library/spectrum.html#ACTest.GreenFunction","page":"Spectra","title":"ACTest.GreenFunction","text":"GreenFunction\n\nMutable struct. It represents the Green's function G(iωₙ) or G(τ).\n\nMembers\n\ngrid -> Imaginary axis grid, ωₙ or τ.\ngreen -> Green's function, G(iωₙ) or G(τ).\nerror -> Standard deviation of the Green's function, σ.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"library/type.html","page":"Types","title":"Types","text":"Define some fundamental types and structs for the ACTest toolkit.","category":"page"},{"location":"library/type.html#Contents","page":"Types","title":"Contents","text":"","category":"section"},{"location":"library/type.html","page":"Types","title":"Types","text":"Pages = [\"type.md\"]\nDepth = 2","category":"page"},{"location":"library/type.html#Index","page":"Types","title":"Index","text":"","category":"section"},{"location":"library/type.html","page":"Types","title":"Types","text":"Pages = [\"type.md\"]","category":"page"},{"location":"library/type.html#Data-Types","page":"Types","title":"Data Types","text":"","category":"section"},{"location":"library/type.html","page":"Types","title":"Types","text":"DType\nADT","category":"page"},{"location":"library/type.html#ACTest.DType","page":"Types","title":"ACTest.DType","text":"Customized types. It is used to define the following dicts.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#ACTest.ADT","page":"Types","title":"ACTest.ADT","text":"Customized types. It is used to define the following dicts.\n\n\n\n\n\n","category":"type"},{"location":"library/type.html#Dictionaries","page":"Types","title":"Dictionaries","text":"","category":"section"},{"location":"library/type.html","page":"Types","title":"Types","text":"PTEST","category":"page"},{"location":"library/type.html#ACTest.PTEST","page":"Types","title":"ACTest.PTEST","text":"PTEST\n\nDictionary for configuration parameters: general setup.\n\n\n\n\n\n","category":"constant"},{"location":"index.html#ACTest","page":"Home","title":"ACTest","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"A spectral function and correlation function generator in Julia.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"info: Info\nThank you for using ACTest. This documentation will help you to be familiar with and explore the ACTest toolkit. It is just compatible with ACTest v1.0.0-devel.241126.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"note: Note\nAnalytic continuation is an art of optimization. Please check your simulated results carefully.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"warning: Warning\nThe ACTest toolkit is in heavy development. Please use it at your own risk. If you encounter any bugs or troubles, or require new features, please consult me directly: huangli at caep.cn","category":"page"},{"location":"index.html#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"intro/motivation.md\",\n    \"intro/ack.md\",\n    \"intro/cite.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"man/feature.md\",\n    \"man/install.md\",\n    \"man/script.md\",\n    \"man/input.md\",\n    \"man/output.md\",\n    \"man/param.md\",\n    \"man/act100.md\",\n    \"man/interface.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#Theory","page":"Home","title":"Theory","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"theory/grid.md\",\n    \"theory/mesh.md\",\n    \"theory/peak.md\",\n    \"theory/kernel.md\",\n    \"theory/noise.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"examples/generate.md\",\n    \"examples/acflow.md\",\n    \"examples/plot.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#Library","page":"Home","title":"Library","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"library/outline.md\",\n    \"library/actest.md\",\n    \"library/global.md\",\n    \"library/types.md\",\n    \"library/base.md\",\n    \"library/peak.md\",\n    \"library/spectrum.md\",\n    \"library/dataset.md\",\n    \"library/grid.md\",\n    \"library/mesh.md\",\n    \"library/kernel.md\",\n    \"library/config.md\",\n    \"library/inout.md\",\n    \"library/math.md\",\n    \"library/util.md\",\n]\nDepth = 1","category":"page"}]
}

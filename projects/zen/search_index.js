var documenterSearchIndex = {"docs":
[{"location":"intro/fund.html#Fundings","page":"Funding","title":"Fundings","text":"","category":"section"},{"location":"intro/fund.html","page":"Funding","title":"Funding","text":"This package is developed and maintained under the financial supports of the following fundings:","category":"page"},{"location":"intro/fund.html","page":"Funding","title":"Funding","text":"National Natural Science Foundation of China (Grants No. 12274380, 11934020)","category":"page"},{"location":"guide/repl.html#REPL-Mode","page":"REPL Mode","title":"REPL Mode","text":"","category":"section"},{"location":"intro/dft.html#Density-Functional-Theory","page":"Density Functional Theory","title":"Density Functional Theory","text":"","category":"section"},{"location":"guide/qim.html#Quantum-Impurity-Solvers","page":"Quantum Impurity Solvers","title":"Quantum Impurity Solvers","text":"","category":"section"},{"location":"guide/dmft.html#Dynamical-Mean-Field-Theory-Code","page":"Dynamical Mean-Field Theory Code","title":"Dynamical Mean-Field Theory Code","text":"","category":"section"},{"location":"internals/global.html#Global-Constants","page":"Global","title":"Global Constants","text":"","category":"section"},{"location":"internals/global.html","page":"Global","title":"Global","text":"Define some type aliases and string constants for the ZenCore package.","category":"page"},{"location":"internals/global.html","page":"Global","title":"Global","text":"Source: global.jl","category":"page"},{"location":"internals/global.html#Contents","page":"Global","title":"Contents","text":"","category":"section"},{"location":"internals/global.html","page":"Global","title":"Global","text":"Pages = [\"global.md\"]","category":"page"},{"location":"internals/global.html#Index","page":"Global","title":"Index","text":"","category":"section"},{"location":"internals/global.html","page":"Global","title":"Global","text":"Pages = [\"global.md\"]","category":"page"},{"location":"internals/global.html#Constants","page":"Global","title":"Constants","text":"","category":"section"},{"location":"internals/global.html","page":"Global","title":"Global","text":"I32\nI64\nF32\nF64\nC32\nC64\nR32\nR64\nN32\nN64\n__LIBNAME__\n__VERSION__\n__RELEASE__\n__AUTHORS__","category":"page"},{"location":"internals/global.html#ZenCore.I32","page":"Global","title":"ZenCore.I32","text":"I32\n\nAlias of Integer type (32 bit).\n\nSee also: R32, R64, N32, N64.\n\n\n\n\n\n","category":"type"},{"location":"internals/global.html#ZenCore.I64","page":"Global","title":"ZenCore.I64","text":"I64\n\nAlias of Integer type (64 bit).\n\nSee also: R32, R64, N32, N64.\n\n\n\n\n\n","category":"type"},{"location":"internals/global.html#ZenCore.F32","page":"Global","title":"ZenCore.F32","text":"F32\n\nAlias of Float type (32 bit).\n\nSee also: R32, R64, N32, N64.\n\n\n\n\n\n","category":"type"},{"location":"internals/global.html#ZenCore.F64","page":"Global","title":"ZenCore.F64","text":"F64\n\nAlias of Float type (64 bit).\n\nSee also: R32, R64, N32, N64.\n\n\n\n\n\n","category":"type"},{"location":"internals/global.html#ZenCore.C32","page":"Global","title":"ZenCore.C32","text":"C32\n\nAlias of Complex type (32 bit).\n\nSee also: N32, N64.\n\n\n\n\n\n","category":"type"},{"location":"internals/global.html#ZenCore.C64","page":"Global","title":"ZenCore.C64","text":"C64\n\nAlias of Complex type (64 bit).\n\nSee also: N32, N64.\n\n\n\n\n\n","category":"type"},{"location":"internals/global.html#ZenCore.R32","page":"Global","title":"ZenCore.R32","text":"R32\n\nAlias of Integer and Float types (32 bit). Here R means Real.\n\nSee also: N32, N64.\n\n\n\n\n\n","category":"type"},{"location":"internals/global.html#ZenCore.R64","page":"Global","title":"ZenCore.R64","text":"R64\n\nAlias of Integer and Float types (64 bit). Here R means Real.\n\nSee also: N32, N64.\n\n\n\n\n\n","category":"type"},{"location":"internals/global.html#ZenCore.N32","page":"Global","title":"ZenCore.N32","text":"N32\n\nAlias of Integer, Float, and Complex types (32 bit). Here N means Number.\n\nSee also: R32, R64.\n\n\n\n\n\n","category":"type"},{"location":"internals/global.html#ZenCore.N64","page":"Global","title":"ZenCore.N64","text":"N64\n\nAlias of Integer, Float, and Complex types (64 bit). Here N means Number.\n\nSee also: R32, R64.\n\n\n\n\n\n","category":"type"},{"location":"internals/global.html#ZenCore.__LIBNAME__","page":"Global","title":"ZenCore.__LIBNAME__","text":"__LIBNAME__\n\nName of this julia package.\n\nSee also: __VERSION__.\n\n\n\n\n\n","category":"constant"},{"location":"internals/global.html#ZenCore.__VERSION__","page":"Global","title":"ZenCore.__VERSION__","text":"__VERSION__\n\nVersion of this julia package.\n\nSee also: __RELEASE__.\n\n\n\n\n\n","category":"constant"},{"location":"internals/global.html#ZenCore.__RELEASE__","page":"Global","title":"ZenCore.__RELEASE__","text":"__RELEASE__\n\nRelease date of this julia package.\n\nSee also: __AUTHORS__.\n\n\n\n\n\n","category":"constant"},{"location":"internals/global.html#ZenCore.__AUTHORS__","page":"Global","title":"ZenCore.__AUTHORS__","text":"__AUTHORS__\n\nCore authors of this julia package.\n\nSee also: __LIBNAME__.\n\n\n\n\n\n","category":"constant"},{"location":"internals/global.html#Functions","page":"Global","title":"Functions","text":"","category":"section"},{"location":"internals/global.html","page":"Global","title":"Global","text":"authors","category":"page"},{"location":"internals/global.html#ZenCore.authors","page":"Global","title":"ZenCore.authors","text":"authors()\n\nPrint authors / contributors of the ZenCore package.\n\nSee also: __AUTHORS__.\n\n\n\n\n\n","category":"function"},{"location":"start/components.html#Components","page":"Components","title":"Components","text":"","category":"section"},{"location":"start/components.html","page":"Components","title":"Components","text":"Well, the DFT + DMFT calculation is extremely tedious and complicated. It is almost impossible to finish the whole task within a single program. So, just like the other DFT + DMFT codes, such as eDMFT and TRIQS, the Zen computation framework is also composed of a few components. They are listed as follows:","category":"page"},{"location":"start/components.html","page":"Components","title":"Components","text":"Components Type Version\nZenCore Core framework v0.8.4-devel.250326\nZenGui Graphic user interface v1.0.2-devel.250429\nZenTools Auxiliary tools v0.3.0-devel.250428\nZenDocs Documentation v0.2.4-devel.250506\nZenTests Tests and tutorials v0.2.0-devel.250402\nDyson Dynamical mean-field theory codes v0.7.5-devel.250326\nDFermion Dynamical mean-field theory codes v0.0.4-devel.230628\niQIST Quantum impurity solvers v0.8.2-devel.230706\nACFlow Analytic continuation tools v2.1.5-devel.250427\nACGui Analytic continuation tools v1.0.0-devel.250405\nACTest Analytic continuation tools v1.1.4-devel.250429\nFlink Numerical library v1.2.1-devel.250430","category":"page"},{"location":"start/components.html","page":"Components","title":"Components","text":"These components should be updated frequently and individually. More components could be added in the future.","category":"page"},{"location":"intro/sces.html#Strongly-Correlated-Materials","page":"Strongly Correlated Materials","title":"Strongly Correlated Materials","text":"","category":"section"},{"location":"internals/vasp.html#VASP","page":"VASP","title":"VASP","text":"","category":"section"},{"location":"internals/vasp.html","page":"VASP","title":"VASP","text":"Tools for the vasp software package (adaptor). It provide a lot of functions to deal with the vasp-related files.","category":"page"},{"location":"internals/vasp.html","page":"VASP","title":"VASP","text":"Source: vasp.jl","category":"page"},{"location":"internals/vasp.html#Contents","page":"VASP","title":"Contents","text":"","category":"section"},{"location":"internals/vasp.html","page":"VASP","title":"VASP","text":"Pages = [\"vasp.md\"]","category":"page"},{"location":"internals/vasp.html#Index","page":"VASP","title":"Index","text":"","category":"section"},{"location":"internals/vasp.html","page":"VASP","title":"VASP","text":"Pages = [\"vasp.md\"]","category":"page"},{"location":"internals/vasp.html#Functions","page":"VASP","title":"Functions","text":"","category":"section"},{"location":"internals/vasp.html","page":"VASP","title":"VASP","text":"dft_call(::VASPEngine, ::IterInfo)\ndft_stop(::VASPEngine)\ndft_resume(::VASPEngine)\nadaptor_call(::VASPEngine, ::Dict{Symbol,Any})\nvasp_adaptor\nvasp_init\nvasp_exec\nvasp_save\nvasp_back\nvasp_stop\nvaspc_incar\nvaspc_kpoints\nvaspc_gcorr\nvaspc_stopcar\nvaspc_lock\nvaspq_stopcar\nvaspq_lock\nvaspq_files\nvaspio_nband\nvaspio_valence\nvaspio_energy\nvaspio_procar\nvaspio_lattice\nvaspio_kmesh\nvaspio_tetra\nvaspio_eigen\nvaspio_projs\nvaspio_fermi\nvaspio_charge","category":"page"},{"location":"internals/vasp.html#ZenCore.dft_call-Tuple{VASPEngine, IterInfo}","page":"VASP","title":"ZenCore.dft_call","text":"dft_call(::VASPEngine, it::IterInfo)\n\nTry to carry out full DFT calculation with the vasp code. It is only a dispatcher. Similar function is defined in qe.jl as well.\n\nSee also: _engine_.\n\n\n\n\n\n","category":"method"},{"location":"internals/vasp.html#ZenCore.dft_stop-Tuple{VASPEngine}","page":"VASP","title":"ZenCore.dft_stop","text":"dft_stop(::VASPEngine)\n\nTry to terminate DFT calculation and kill running process of the DFT backend. It supports the vasp code. It is only a dispatcher. Similar function is defined in qe.jl as well.\n\nSee also: _engine_.\n\n\n\n\n\n","category":"method"},{"location":"internals/vasp.html#ZenCore.dft_resume-Tuple{VASPEngine}","page":"VASP","title":"ZenCore.dft_resume","text":"dft_resume(::VASPEngine)\n\nTry to wake up the DFT backend and resume the DFT calculation. It only supports the vasp code. It is only a dispatcher. Similar function is defined in qe.jl as well.\n\nSee also: _engine_.\n\n\n\n\n\n","category":"method"},{"location":"internals/vasp.html#ZenCore.adaptor_call-Tuple{VASPEngine, Dict{Symbol, Any}}","page":"VASP","title":"ZenCore.adaptor_call","text":"adaptor_call(::VASPEngine, D::Dict{Symbol,Any})\n\nIt is a dispatcher for the DFT-DMFT adaptor. It calls vasp_adaptor() function to deal with the outputs of the DFT backend (such as vasp) and generate key dataset for the next level adaptor (PLOAdaptor). Note that similar function is also defined in qe.jl.\n\n\n\n\n\n","category":"method"},{"location":"internals/vasp.html#ZenCore.vasp_adaptor","page":"VASP","title":"ZenCore.vasp_adaptor","text":"vasp_adaptor(D::Dict{Symbol,Any})\n\nAdaptor support for vasp code. It will parse the output files of vasp code, extract the Kohn-Sham dataset,  and then fulfill the DFTData dict (i.e D).\n\nThe following vasp's output files must be presented:\n\nPOSCAR\nIBZKPT\nEIGENVAL\nLOCPROJ\nDOSCAR\nOSZICAR\n\nSee also: plo_adaptor, ir_adaptor.\n\n\n\n\n\n","category":"function"},{"location":"internals/vasp.html#ZenCore.vasp_init","page":"VASP","title":"ZenCore.vasp_init","text":"vasp_init(it::IterInfo)\n\nCheck the runtime environment of vasp, prepare necessary input files.\n\nSee also: vasp_exec, vasp_save.\n\n\n\n\n\n","category":"function"},{"location":"internals/vasp.html#ZenCore.vasp_exec","page":"VASP","title":"ZenCore.vasp_exec","text":"vasp_exec(it::IterInfo)\n\nExecute the vasp program, monitor the convergence progress, and output the relevant information. Especially, if it.sc == 2 (self-consistent mode), this function will launch the vasp code, then return immediately.\n\nIn order to execute this function correctly, you have to setup the following environment variables:\n\nVASP_HOME\n\nand make sure the file MPI.toml is available.\n\nSee also: vasp_init, vasp_save.\n\n\n\n\n\n","category":"function"},{"location":"internals/vasp.html#ZenCore.vasp_save","page":"VASP","title":"ZenCore.vasp_save","text":"vasp_save(it::IterInfo)\n\nBackup the output files of vasp if necessary. Furthermore, the DFT fermi level and the DFT band energy in IterInfo struct will also be updated (i.e IterInfo.μ₀ and IterInfo.et.dft).\n\nSee also: vasp_init, vasp_exec.\n\n\n\n\n\n","category":"function"},{"location":"internals/vasp.html#ZenCore.vasp_back","page":"VASP","title":"ZenCore.vasp_back","text":"vasp_back()\n\nReactivate the vasp engine to continue the charge self-consistent DFT + DMFT calculation. It will prepare the file GAMMA, and try to create a lock file (vasp.lock). Then the vasp engine will wake up and continue to work automatically.\n\nSee also: vasp_stop.\n\n\n\n\n\n","category":"function"},{"location":"internals/vasp.html#ZenCore.vasp_stop","page":"VASP","title":"ZenCore.vasp_stop","text":"vasp_stop()\n\nStop the vasp engine by creating a STOPCAR file in the working folder. It will not return until the vasp engine is completely termined.\n\nSee also: vasp_back.\n\n\n\n\n\n","category":"function"},{"location":"internals/vasp.html#ZenCore.vaspc_incar","page":"VASP","title":"ZenCore.vaspc_incar","text":"vaspc_incar(fermi::F64, sc_mode::I64)\n\nGenerate an INCAR file. It will be used only when the DFT engine is vasp.\n\nSee also: vaspc_kpoints.\n\n\n\n\n\n","category":"function"},{"location":"internals/vasp.html#ZenCore.vaspc_kpoints","page":"VASP","title":"ZenCore.vaspc_kpoints","text":"vaspc_kpoints(mp_scheme::Bool = true, n::I64 = 9)\n\nGenerate a valid KPOINTS file for vasp.\n\nSee also: vaspc_incar.\n\n\n\n\n\n","category":"function"},{"location":"internals/vasp.html#ZenCore.vaspc_gcorr","page":"VASP","title":"ZenCore.vaspc_gcorr","text":"vaspc_gcorr(kwin::Array{I64,3}, gcorr::Array{C64,4})\n\nGenerate a valid GAMMA file for vasp. The vasp will need this file when ICHARG = 5.\n\nSee also: write_gcorr, read_gcorr.\n\n\n\n\n\n","category":"function"},{"location":"internals/vasp.html#ZenCore.vaspc_stopcar","page":"VASP","title":"ZenCore.vaspc_stopcar","text":"vaspc_stopcar()\n\nCreate the STOPCAR file in the dft directory to stop the vasp engine. Vasp will stop at the next electronic step, i.e. WAVECAR and CHGCAR might contain non-converged results.\n\n\n\n\n\n","category":"function"},{"location":"internals/vasp.html#ZenCore.vaspc_lock","page":"VASP","title":"ZenCore.vaspc_lock","text":"vaspc_lock(dir::String = \".\")\n\nCreate the vasp.lock file. This file is relevant for ICHARG = 5. The vasp program runs only when the vasp.lock file is present in the current directory. Its default working directory is just dft, but we can specify it via argument dir.\n\nSee also: vaspq_lock.\n\n\n\n\n\n","category":"function"},{"location":"internals/vasp.html#ZenCore.vaspq_stopcar","page":"VASP","title":"ZenCore.vaspq_stopcar","text":"vaspq_stopcar()\n\nReturn whether the STOPCAR file is available. Its working directory might be root or dft.\n\nSee also: vaspc_stopcar.\n\n\n\n\n\n","category":"function"},{"location":"internals/vasp.html#ZenCore.vaspq_lock","page":"VASP","title":"ZenCore.vaspq_lock","text":"vaspq_lock()\n\nReturn whether the vasp.lock file is available. Its working directory might be root or dft.\n\nSee also: vaspc_lock.\n\n\n\n\n\n","category":"function"},{"location":"internals/vasp.html#ZenCore.vaspq_files","page":"VASP","title":"ZenCore.vaspq_files","text":"vaspq_files(f::String)\n\nCheck the essential output files by vasp. Here f means only the directory that contains the desired files.\n\nSee also: adaptor_core.\n\n\n\n\n\nvaspq_files()\n\nCheck the essential output files by vasp in the current directory.\n\nSee also: adaptor_core.\n\n\n\n\n\n","category":"function"},{"location":"internals/vasp.html#ZenCore.vaspio_nband","page":"VASP","title":"ZenCore.vaspio_nband","text":"vaspio_nband(f::String)\n\nReading vasp's POSCAR and POTCAR files, evaluating number of bands. It will be used to create the INCAR file. Here f means only the directory that contains POSCAR and POTCAR.\n\nSee also: vaspc_incar, vaspio_valence, vaspio_lattice.\n\n\n\n\n\nvaspio_nband()\n\nReading vasp's POSCAR and POTCAR files, evaluating number of bands. It will be used to create the INCAR file.\n\nSee also: vaspc_incar, vaspio_valence, vaspio_lattice.\n\n\n\n\n\n","category":"function"},{"location":"internals/vasp.html#ZenCore.vaspio_valence","page":"VASP","title":"ZenCore.vaspio_valence","text":"vaspio_valence(f::String)\n\nReading vasp's POTCAR file, return ZVAL. Here f means only the directory that contains POTCAR. The information about ZVAL will be used to determine NBANDS in the INCAR file.\n\nSee also: vaspc_incar, vaspio_nband.\n\n\n\n\n\nvaspio_valence()\n\nReading vasp's POTCAR file, return ZVAL. The information about ZVAL will be used to determine NBANDS in the INCAR file.\n\nSee also: vaspc_incar, vaspio_nband.\n\n\n\n\n\n","category":"function"},{"location":"internals/vasp.html#ZenCore.vaspio_energy","page":"VASP","title":"ZenCore.vaspio_energy","text":"vaspio_energy(f::String)\n\nReading vasp's OSZICAR file, return DFT total energy, which will be used to determine the total DFT + DMFT energy. Here f means only the directory that contains OSZICAR.\n\n\n\n\n\nvaspio_energy()\n\nReading vasp's OSZICAR file, return DFT total energy, which will be used to determine the total DFT + DMFT energy.\n\n\n\n\n\n","category":"function"},{"location":"internals/vasp.html#ZenCore.vaspio_procar","page":"VASP","title":"ZenCore.vaspio_procar","text":"vaspio_procar(f::String)\n\nReading vasp's PROCAR file, extract orbital weight information. Here f means only the directory that contains PROCAR.\n\nThis function is not invoked directly during the DFT + DMFT iteration. It is designed for users merely. They can use it to judge which orbitals are the most relevant, and then apply the obtained information to customize their case.toml configuration file (specifically, the window parameter in the dft block).\n\nnote: Note\nThis function is only called by tools/analyze.jl or used in REPL.\n\n\n\n\n\nvaspio_procar()\n\nReading vasp's PROCAR file, extract orbital weight information.\n\nThis function is not invoked directly during the DFT + DMFT iteration. It is designed for users merely. They can use it to judge which orbitals are the most relevant, and then apply the obtained information to customize their case.toml configuration file (specifically, the window parameter in the dft block).\n\nnote: Note\nThis function is only called by tools/analyze.jl or used in REPL.\n\n\n\n\n\n","category":"function"},{"location":"internals/vasp.html#ZenCore.vaspio_lattice","page":"VASP","title":"ZenCore.vaspio_lattice","text":"vaspio_lattice(f::String, silent::Bool = true)\n\nReading vasp's POSCAR file, return crystallography information. Here f means only the directory that contains POSCAR.\n\nSee also: Lattice, irio_lattice.\n\n\n\n\n\nvaspio_lattice()\n\nReading vasp's POSCAR file, return crystallography information.\n\nSee also: Lattice, irio_lattice.\n\n\n\n\n\n","category":"function"},{"location":"internals/vasp.html#ZenCore.vaspio_kmesh","page":"VASP","title":"ZenCore.vaspio_kmesh","text":"vaspio_kmesh(f::String)\n\nReading vasp's IBZKPT file, return kmesh and weight. Here f means only the directory that contains IBZKPT.\n\nSee also: vaspio_tetra, irio_kmesh.\n\n\n\n\n\nvaspio_kmesh()\n\nReading vasp's IBZKPT file, return kmesh and weight.\n\nSee also: vaspio_tetra, irio_kmesh.\n\n\n\n\n\n","category":"function"},{"location":"internals/vasp.html#ZenCore.vaspio_tetra","page":"VASP","title":"ZenCore.vaspio_tetra","text":"vaspio_tetra(f::String)\n\nReading vasp's IBZKPT file, return tetrahedra information. Here f means only the directory that contains IBZKPT.\n\nSee also: vaspio_kmesh, irio_tetra.\n\n\n\n\n\nvaspio_tetra()\n\nReading vasp's IBZKPT file, return tetrahedra information.\n\nSee also: vaspio_kmesh, irio_tetra.\n\n\n\n\n\n","category":"function"},{"location":"internals/vasp.html#ZenCore.vaspio_eigen","page":"VASP","title":"ZenCore.vaspio_eigen","text":"vaspio_eigen(f::String)\n\nReading vasp's EIGENVAL file, return energy band information. Here f means only the directory that contains EIGENVAL.\n\nSometimes the EIGENVAL file does not contain any useful data, then we turn to the LOCPROJ file to obtain the energy band information.\n\nSee also: irio_eigen.\n\n\n\n\n\nvaspio_eigen()\n\nReading vasp's EIGENVAL file, return energy band information.\n\nSee also: irio_eigen.\n\n\n\n\n\n","category":"function"},{"location":"internals/vasp.html#ZenCore.vaspio_projs","page":"VASP","title":"ZenCore.vaspio_projs","text":"vaspio_projs(f::String)\n\nReading vasp's LOCPROJ file, return raw projector matrix. Here f means only the directory that contains LOCPROJ.\n\nSee also: irio_projs.\n\n\n\n\n\nvaspio_projs()\n\nReading vasp's LOCPROJ file, return raw projector matrix.\n\nSee also: irio_projs.\n\n\n\n\n\n","category":"function"},{"location":"internals/vasp.html#ZenCore.vaspio_fermi","page":"VASP","title":"ZenCore.vaspio_fermi","text":"vaspio_fermi(f::String, silent::Bool = true)\n\nReading vasp's DOSCAR file, return the fermi level. Here f means only the directory that contains DOSCAR.\n\nSometimes the DOSCAR file does not contain the necessary data. Thus we have to turn to the LOCPROJ file.\n\nSee also: irio_fermi.\n\n\n\n\n\nvaspio_fermi()\n\nReading vasp's DOSCAR file, return the fermi level.\n\nSee also: irio_fermi.\n\n\n\n\n\n","category":"function"},{"location":"internals/vasp.html#ZenCore.vaspio_charge","page":"VASP","title":"ZenCore.vaspio_charge","text":"vaspio_charge(f::String)\n\nReading vasp's CHGCAR file, return the charge density. Here f means only the directory that contains CHGCAR.\n\nSee also: irio_charge.\n\n\n\n\n\nvaspio_charge()\n\nReading vasp's CHGCAR file, return the charge density.\n\nSee also: irio_charge.\n\n\n\n\n\n","category":"function"},{"location":"start/directory.html#Directory-Structure","page":"Directory Structure","title":"Directory Structure","text":"","category":"section"},{"location":"intro/future.html#Future-Plans","page":"Future Plans","title":"Future Plans","text":"","category":"section"},{"location":"intro/future.html","page":"Future Plans","title":"Future Plans","text":"In the near future, the following features will be preferentially added to the Zen package:","category":"page"},{"location":"intro/future.html","page":"Future Plans","title":"Future Plans","text":"New quantum impurity solvers that based on new principles.\nExact double-counting terms.\nCluster dynamical mean-field theory for superconducting systems.\nComponent for the constrained random phase approximation (cRPA). Such that we can perform cRPA + DFT + DMFT calculations to determine the interaction parameters (U and J) self-consistently.\nWe should implement the DFT + DF method to support charge fully self-consistent calculations. In order words, we have to integrate the DFermion package with Zen.\nTo explore the DFT + neqDMFT method. With it, we can investigate the non-equilibrium properties (especially the ultrafast dynamics) of strongly correlated materials.","category":"page"},{"location":"intro/future.html","page":"Future Plans","title":"Future Plans","text":"","category":"page"},{"location":"intro/motivation.html#Motivation","page":"Motivation","title":"Motivation","text":"","category":"section"},{"location":"guide/tips.html#Tips-And-Tricks","page":"Tips And Tricks","title":"Tips And Tricks","text":"","category":"section"},{"location":"guide/script.html#Script-Mode","page":"Script Mode","title":"Script Mode","text":"","category":"section"},{"location":"internals/dmft.html#Dynamical-Mean-Field-Theory","page":"DMFT","title":"Dynamical Mean-Field Theory","text":"","category":"section"},{"location":"internals/dmft.html","page":"DMFT","title":"DMFT","text":"Wrapper for dynamical mean-field theory engine. It also provides some essential tools to deal with (read and write) the fermi level mu, hybridization functions Delta, local impurity levels epsilon_i, and correlation-induced correction for density matrix Gamma.","category":"page"},{"location":"internals/dmft.html","page":"DMFT","title":"DMFT","text":"Source: dmft.jl","category":"page"},{"location":"internals/dmft.html#Contents","page":"DMFT","title":"Contents","text":"","category":"section"},{"location":"internals/dmft.html","page":"DMFT","title":"DMFT","text":"Pages = [\"dmft.md\"]","category":"page"},{"location":"internals/dmft.html#Index","page":"DMFT","title":"Index","text":"","category":"section"},{"location":"internals/dmft.html","page":"DMFT","title":"DMFT","text":"Pages = [\"dmft.md\"]","category":"page"},{"location":"internals/dmft.html#Functions","page":"DMFT","title":"Functions","text":"","category":"section"},{"location":"internals/dmft.html","page":"DMFT","title":"DMFT","text":"dmft_init\ndmft_exec\ndmft_save\nread_fermi\nread_delta\nread_eimpx\nread_gcorr\nwrite_delta\nwrite_eimpx\nwrite_gcorr","category":"page"},{"location":"internals/dmft.html#ZenCore.dmft_init","page":"DMFT","title":"ZenCore.dmft_init","text":"dmft_init(it::IterInfo, task::I64)\n\nInitialize the dynamical mean-field theory engine. Prepare the necessary files, and generate the configuration file. No matter what the value of argument task is, the required input files for the DMFT engine is the same. If task = 1, it means one-shot mode. If task = 2, it denotes charge self-consistent mode.\n\nSee also: dmft_exec, dmft_save.\n\n\n\n\n\n","category":"function"},{"location":"internals/dmft.html#ZenCore.dmft_exec","page":"DMFT","title":"ZenCore.dmft_exec","text":"dmft_exec(it::IterInfo, task::I64)\n\nExecute the dynamical mean-field theory engine.\n\nSee also: dmft_init, dmft_save.\n\n\n\n\n\n","category":"function"},{"location":"internals/dmft.html#ZenCore.dmft_save","page":"DMFT","title":"ZenCore.dmft_save","text":"dmft_save(it::IterInfo, task::I64)\n\nBackup the files outputed by the dynamical mean-field theory engine.\n\nSee also: dmft_init, dmft_exec.\n\n\n\n\n\n","category":"function"},{"location":"internals/dmft.html#ZenCore.read_fermi","page":"DMFT","title":"ZenCore.read_fermi","text":"read_fermi()\n\nParse the dmft?/dmft.fermi file to extract the chemical potential. The lattice occupancy and correction to the DFT band energy will be extracted and returned at the same time.\n\nNote that if lfermi in dmft.in is false, the chemical potential and lattice occupancy will not be calculated by the DMFT engine. On the other hand, if the DMFT engine works on non-self-consistent mode, the correction to DFT band energy will be zero as well.\n\nSee also: dmft_save.\n\n\n\n\n\n","category":"function"},{"location":"internals/dmft.html#ZenCore.read_delta","page":"DMFT","title":"ZenCore.read_delta","text":"read_delta(imp::Impurity)\n\nExtract hybridization functions Δ from impurity.i/dmft.delta file, which is generated by sigma_split(). Then the data will be written into solver.hyb.in file (or someting else) by write_delta(). These data are essential for quantum impurity solvers. The working directory of this function must be equal to impurity.i.\n\nThe frequency mesh is also extracted in this function.\n\nSee also: Impurity, read_eimpx.\n\n\n\n\n\nread_delta(ai::Array{Impurity,1}, fhyb::String = \"dmft1/dmft.delta\")\n\nRead the dmft1/dmft.delta file, extract the hybridization functions Δ and the corresponding frequency mesh ω. The working directory of this function must be the root folder. Usually, this function is called by the mixer_delta() function and the sigma_split() function.\n\nSee also: sigma_split, read_eimpx.\n\n\n\n\n\n","category":"function"},{"location":"internals/dmft.html#ZenCore.read_eimpx","page":"DMFT","title":"ZenCore.read_eimpx","text":"read_eimpx(imp::Impurity)\n\nExtract local impurity levels ε from impurity.i/dmft.eimpx file, which is generated by sigma_split(). Then the data will be written into solver.eimp.in (or something else) by write_eimpx(). These data are essential for quantum impurity solvers. The working directory for this function must be equal to impurity.i.\n\nSee also: Impurity, read_delta.\n\n\n\n\n\nread_eimpx(ai::Array{Impurity,1}, flev::String = \"dmft1/dmft.eimpx\")\n\nRead the dmft1/dmft.eimpx file, extract the local impurity levels εᵢ. The working directory of this function must be the root folder. Usually, this function is called by the mixer_eimpx() function and the sigma_split() function.\n\nSee also: sigma_split, read_delta.\n\n\n\n\n\n","category":"function"},{"location":"internals/dmft.html#ZenCore.read_gcorr","page":"DMFT","title":"ZenCore.read_gcorr","text":"read_gcorr(fgcorr::String = \"dmft2/dmft.gcorr\")\n\nRead the dmft2/dmft.gcorr file. It contains the correlation-induced correction for density matrix. The correction will be fed back to the DFT engine, and then the DFT engine will generate new Kohn-Sham states.\n\nThis function also return the 𝑘-mesh, which is useful for mixing the Γ matrix with the Kerker mixing algorithm.\n\nThe working directory of this function must be the root folder.\n\nSee also: write_gcorr.\n\n\n\n\n\n","category":"function"},{"location":"internals/dmft.html#ZenCore.write_delta","page":"DMFT","title":"ZenCore.write_delta","text":"write_delta(fmesh::Array{F64,1},\n            Delta::Array{C64,5},\n            ai::Array{Impurity,1})\n\nSplit hybridization functions Δ and the corresponding frequency mesh ω into the impurity.i/dmft.delta file, which is important for the chosen quantum impurity solver. The working directory of this function must be the root folder.\n\nThis function is usually called by the sigma_split() function.\n\nSee also: Impurity, read_delta, write_eimpx.\n\n\n\n\n\nwrite_delta(fmesh::Array{F64,1},\n            Delta::Array{C64,5},\n            ai::Array{Impurity,1},\n            fhyb::String)\n\nWrite hybridization functions Δ into the fhyb file. This function is usually called by mixer_delta() function to update the hybridization files stored in dmft1/dmft.delta file. The working directory of this function must be the root folder.\n\nSee also: Impurity, read_delta, write_eimpx.\n\n\n\n\n\n","category":"function"},{"location":"internals/dmft.html#ZenCore.write_eimpx","page":"DMFT","title":"ZenCore.write_eimpx","text":"write_eimpx(Eimpx::Array{C64,4}, ai::Array{Impurity,1})\n\nSplit local impurity levels ε into the impurity.i/dmft.eimpx file, which is important for the chosen quantum impurity solver. The working directory of this function must be the root folder.\n\nThis function is usually called by the sigma_split() function.\n\nSee also: Impurity, read_eimpx, write_delta.\n\n\n\n\n\nwrite_eimpx(Eimpx::Array{C64,4},\n            ai::Array{Impurity,1},\n            flev::String)\n\nWrite local impurity levels ε into the flev file. This function is usually called by mixer_eimpx() function to update the local impurity levels stored in dmft1/dmft.eimpx file. The working directory of this function must be the root folder.\n\nSee also: Impurity, read_eimpx, write_delta.\n\n\n\n\n\n","category":"function"},{"location":"internals/dmft.html#ZenCore.write_gcorr","page":"DMFT","title":"ZenCore.write_gcorr","text":"write_gcorr(kmesh::Array{F64,2},\n            kwin::Array{I64,3},\n            gcorr::Array{C64,4},\n            fgcorr::String)\n\nWrite correction for density matrix Γ into fgcorr file. This function is usually called by mixer_gcorr() function to update the correction for density matrix stored in the dmft2/dmft.gcorr file. The working directory of this function must be the root folder.\n\nSee also: read_gcorr, write_delta, write_eimpx.\n\n\n\n\n\n","category":"function"},{"location":"guide/block_solver.html#PSOLVER-block","page":"Block [solver]","title":"PSOLVER block","text":"","category":"section"},{"location":"guide/block_solver.html#Contents","page":"Block [solver]","title":"Contents","text":"","category":"section"},{"location":"guide/block_solver.html","page":"Block [solver]","title":"Block [solver]","text":"Pages = [\"solver.md\"]","category":"page"},{"location":"guide/block_solver.html#Index","page":"Block [solver]","title":"Index","text":"","category":"section"},{"location":"guide/block_solver.html","page":"Block [solver]","title":"Block [solver]","text":"Pages = [\"solver.md\"]","category":"page"},{"location":"guide/block_solver.html#Parameters","page":"Block [solver]","title":"Parameters","text":"","category":"section"},{"location":"intro/about.html#About-The-Zen-Framework","page":"Summary","title":"About The Zen Framework","text":"","category":"section"},{"location":"intro/about.html","page":"Summary","title":"Summary","text":"Motivation\nDesign Philosophy\nFeatures\nFuture Plans\nCitation\nFunding\nDevelopers\nTechnical Support","category":"page"},{"location":"internals/tetra.html#Analytical-Tetrahedron-Method","page":"Tetra","title":"Analytical Tetrahedron Method","text":"","category":"section"},{"location":"internals/tetra.html","page":"Tetra","title":"Tetra","text":"Implementation of the analytical tetrahedron method.","category":"page"},{"location":"internals/tetra.html","page":"Tetra","title":"Tetra","text":"Source: tetra.jl","category":"page"},{"location":"internals/tetra.html#Contents","page":"Tetra","title":"Contents","text":"","category":"section"},{"location":"internals/tetra.html","page":"Tetra","title":"Tetra","text":"Pages = [\"tetra.md\"]","category":"page"},{"location":"internals/tetra.html#Index","page":"Tetra","title":"Index","text":"","category":"section"},{"location":"internals/tetra.html","page":"Tetra","title":"Tetra","text":"Pages = [\"tetra.md\"]","category":"page"},{"location":"internals/tetra.html#Structs","page":"Tetra","title":"Structs","text":"","category":"section"},{"location":"internals/tetra.html","page":"Tetra","title":"Tetra","text":"TetraWeight","category":"page"},{"location":"internals/tetra.html#ZenCore.TetraWeight","page":"Tetra","title":"ZenCore.TetraWeight","text":"TetraWeight\n\nStruct. Integration weights for analytical tetrahedron algorithm.\n\nMembers\n\ncw -> Blochl corrections for dw.\ndw -> Density of states weights at the four corners of a given tetrahedron.\ntw -> Integration weights at the four corners of a given tetrahedron.\n\n\n\n\n\n","category":"type"},{"location":"internals/tetra.html#Functions","page":"Tetra","title":"Functions","text":"","category":"section"},{"location":"internals/tetra.html","page":"Tetra","title":"Tetra","text":"bzint\ngauss_weight\nfermi_weight\ntetra_weight\ntetra_p_ek1\ntetra_p_ek12\ntetra_p_ek23\ntetra_p_ek34\ntetra_p_ek4","category":"page"},{"location":"internals/tetra.html#ZenCore.bzint","page":"Tetra","title":"ZenCore.bzint","text":"bzint(z::F64, itet::Array{I64,2}, enk::Array{F64,3})\n\nCompute tetrahedron integrated weights for Brillouin zone integration. It is used to calculate (partial) density of states.\n\nSee also: gauss_weight, fermi_weight, tetra_weight.\n\n\n\n\n\n","category":"function"},{"location":"internals/tetra.html#ZenCore.gauss_weight","page":"Tetra","title":"ZenCore.gauss_weight","text":"gauss_weight(z::F64, e::Array{F64,1})\n\nGaussian broadening algorithm for (integrated) density of states and relevant integration weights.\n\nSee also: TetraWeight.\n\n\n\n\n\n","category":"function"},{"location":"internals/tetra.html#ZenCore.fermi_weight","page":"Tetra","title":"ZenCore.fermi_weight","text":"fermi_weight(z::F64, e::Array{F64,1})\n\nFermi-Dirac broadening algorithm for (integrated) density of states and relevant integration weights.\n\nSee also: TetraWeight.\n\n\n\n\n\n","category":"function"},{"location":"internals/tetra.html#ZenCore.tetra_weight","page":"Tetra","title":"ZenCore.tetra_weight","text":"tetra_weight(z::F64, e::Array{F64,1})\n\nPeter E. Blochl algorithm for (integrated) density of states and relevant integration weights. Blochl corrections are taken into considersions as well. See Phys. Rev. B, 49, 16223 (1994) for more details.\n\nSee also: TetraWeight.\n\n\n\n\n\n","category":"function"},{"location":"internals/tetra.html#ZenCore.tetra_p_ek1","page":"Tetra","title":"ZenCore.tetra_p_ek1","text":"tetra_p_ek1()\n\nBlochl algorithm, case 1, for fully unoccupied tetrahedron.\n\nSee also: tetra_weight.\n\n\n\n\n\n","category":"function"},{"location":"internals/tetra.html#ZenCore.tetra_p_ek12","page":"Tetra","title":"ZenCore.tetra_p_ek12","text":"tetra_p_ek12(z::F64, e::Array{F64,1})\n\nBlochl algorithm, case 2, for partially occupied tetrahedron.\n\nSee also: tetra_weight.\n\n\n\n\n\n","category":"function"},{"location":"internals/tetra.html#ZenCore.tetra_p_ek23","page":"Tetra","title":"ZenCore.tetra_p_ek23","text":"tetra_p_ek23(z::F64, e::Array{F64,1})\n\nBlochl algorithm, case 3, for partially occupied tetrahedron.\n\nSee also: tetra_weight.\n\n\n\n\n\n","category":"function"},{"location":"internals/tetra.html#ZenCore.tetra_p_ek34","page":"Tetra","title":"ZenCore.tetra_p_ek34","text":"tetra_p_ek34(z::F64, e::Array{F64,1})\n\nBlochl algorithm, case 4, for partially occupied tetrahedron.\n\nSee also: tetra_weight.\n\n\n\n\n\n","category":"function"},{"location":"internals/tetra.html#ZenCore.tetra_p_ek4","page":"Tetra","title":"ZenCore.tetra_p_ek4","text":"tetra_p_ek4()\n\nBlochl algorithm, case 5, for fully occupied tetrahedron.\n\nSee also: tetra_weight.\n\n\n\n\n\n","category":"function"},{"location":"internals/qe.html#Quantum-ESPRESSO","page":"QE","title":"Quantum ESPRESSO","text":"","category":"section"},{"location":"internals/qe.html","page":"QE","title":"QE","text":"Tools for the quantum espresso software package (adaptor). It provide a lot of functions to deal with the qe-related files.","category":"page"},{"location":"internals/qe.html","page":"QE","title":"QE","text":"Source: qe.jl","category":"page"},{"location":"internals/qe.html#Contents","page":"QE","title":"Contents","text":"","category":"section"},{"location":"internals/qe.html","page":"QE","title":"QE","text":"Pages = [\"qe.md\"]","category":"page"},{"location":"internals/qe.html#Index","page":"QE","title":"Index","text":"","category":"section"},{"location":"internals/qe.html","page":"QE","title":"QE","text":"Pages = [\"qe.md\"]","category":"page"},{"location":"internals/qe.html#Functions","page":"QE","title":"Functions","text":"","category":"section"},{"location":"internals/qe.html","page":"QE","title":"QE","text":"dft_call\ndft_stop\ndft_resume\nadaptor_call\nqe_adaptor\nqe_to_wan\nqe_to_plo\nqe_init\nqe_exec\nqe_save\nqec_input\nqeq_files\nqeio_energy\nqeio_lattice\nqeio_kmesh\nqeio_eigen\nqeio_fermi\nqeio_band\nReciprocalPoint\nMonkhorstPackGrid\nAtomicSpecies\nAtomicPosition\nQEInputEntry\nQENamelist\nQECard\nKPointsCard\nAtomicSpeciesCard\nAtomicPositionsCard\nAutoKmeshCard\nGammaPointCard\nSpecialPointsCard\nhaskey\ngetindex\nsetindex!\ndelete!\ntryparse\nparse\nwrite","category":"page"},{"location":"internals/qe.html#ZenCore.dft_call","page":"QE","title":"ZenCore.dft_call","text":"dft_call(::VASPEngine, it::IterInfo)\n\nTry to carry out full DFT calculation with the vasp code. It is only a dispatcher. Similar function is defined in qe.jl as well.\n\nSee also: _engine_.\n\n\n\n\n\ndft_call(::QEEngine, it::IterInfo)\n\nTry to carry out full DFT calculation with the qe code. It is only a dispatcher. Similar function is defined in vasp.jl as well.\n\nSee also: _engine_.\n\n\n\n\n\n","category":"function"},{"location":"internals/qe.html#ZenCore.dft_stop","page":"QE","title":"ZenCore.dft_stop","text":"dft_stop(::VASPEngine)\n\nTry to terminate DFT calculation and kill running process of the DFT backend. It supports the vasp code. It is only a dispatcher. Similar function is defined in qe.jl as well.\n\nSee also: _engine_.\n\n\n\n\n\ndft_stop(::QEEngine)\n\nTry to terminate DFT calculation and kill running process of the DFT backend. It supports the qe code. It is only a dispatcher. Similar function is defined in vasp.jl as well.\n\nSee also: _engine_.\n\n\n\n\n\n","category":"function"},{"location":"internals/qe.html#ZenCore.dft_resume","page":"QE","title":"ZenCore.dft_resume","text":"dft_resume(::VASPEngine)\n\nTry to wake up the DFT backend and resume the DFT calculation. It only supports the vasp code. It is only a dispatcher. Similar function is defined in qe.jl as well.\n\nSee also: _engine_.\n\n\n\n\n\ndft_resume(::QEEngine)\n\nTry to wake up the DFT backend and resume the DFT calculation. It only supports the qe code. It is only a dispatcher. Similar function is defined in vasp.jl as well.\n\nSee also: _engine_.\n\n\n\n\n\n","category":"function"},{"location":"internals/qe.html#ZenCore.adaptor_call","page":"QE","title":"ZenCore.adaptor_call","text":"adaptor_call(::VASPEngine, D::Dict{Symbol,Any})\n\nIt is a dispatcher for the DFT-DMFT adaptor. It calls vasp_adaptor() function to deal with the outputs of the DFT backend (such as vasp) and generate key dataset for the next level adaptor (PLOAdaptor). Note that similar function is also defined in qe.jl.\n\n\n\n\n\nadaptor_call(::QEEngine, D::Dict{Symbol,Any})\n\nIt is a dispatcher for the DFT-DMFT adaptor. It calls qe_adaptor() function to deal with the outputs of the DFT backend (such as qe) and generate key dataset for the next level adaptor (WANNIERAdaptor). Note that similar function is also defined in vasp.jl.\n\nSee also: qe_adaptor.\n\n\n\n\n\nadaptor_call(::PLOAdaptor,\n             D::Dict{Symbol,Any},\n             ai::Array{Impurity,1})\n\nIt is a dispatcher for the DFT-DMFT adaptor. It calls plo_adaptor() function to deal with the outputs of the DFT backend (such as vasp) and generate key dataset for the IR adaptor. Note that similar functions are also defined in vasp.jl, qe.jl, and wannier.jl.\n\nSee also: plo_adaptor.\n\n\n\n\n\nadaptor_call(::WANNIERAdaptor,\n             D::Dict{Symbol,Any},\n             ai::Array{Impurity,1})\n\nIt is a dispatcher for the DFT-DMFT adaptor. It calls wannier_adaptor() function to deal with the outputs of wannier90 code and generate key dataset for the IR adaptor. Note that similar functions are also defined in vasp.jl, qe.jl, and plo.jl.\n\nSee also: wannier_adaptor.\n\n\n\n\n\n","category":"function"},{"location":"internals/qe.html#ZenCore.qe_adaptor","page":"QE","title":"ZenCore.qe_adaptor","text":"qe_adaptor(D::Dict{Symbol,Any})\n\nAdaptor support for the quantum espresso (pwscf code). It will parse the output files of the quantum espresso code, extract the Kohn-Sham dataset, and then fulfill the DFTData dict (i.e D).\n\nThe following output files of the quantum espresso code are needed:\n\nscf.out\nnscf.out\n\nNote in the input file of the quantum espresso code, the verbosity parameter must be set to 'high'.\n\nSee also: wannier_adaptor, ir_adaptor.\n\n\n\n\n\n","category":"function"},{"location":"internals/qe.html#ZenCore.qe_to_wan","page":"QE","title":"ZenCore.qe_to_wan","text":"qe_to_wan(D::Dict{Symbol,Any})\n\nTry to call the wannier90 and pw2wannier90 codes to generate the maximally-localized wannier functions. the DFTData dict (i.e D) will not be modified.\n\nSee also: wannier_adaptor.\n\n\n\n\n\n","category":"function"},{"location":"internals/qe.html#ZenCore.qe_to_plo","page":"QE","title":"ZenCore.qe_to_plo","text":"qe_to_plo(D::Dict{Symbol,Any})\n\nPostprocess outputs of the quantum espresso (pwscf code), call the wannier90 and pw2wannier90 codes to generate the projected local orbitals (which are not maximally-localized wannier functions). The key data are fed into the DFTData dict (i.e D).\n\nMost of the functions used in the qe_to_plo() function are implemented in another file (wannier.jl).\n\nSee also: plo_adaptor, qe_adaptor.\n\n\n\n\n\n","category":"function"},{"location":"internals/qe.html#ZenCore.qe_init","page":"QE","title":"ZenCore.qe_init","text":"qe_init(it::IterInfo)\n\nCheck the runtime environment of quantum espresso (pwscf), prepare necessary input files.\n\nSee also: qe_exec, qe_save.\n\n\n\n\n\n","category":"function"},{"location":"internals/qe.html#ZenCore.qe_exec","page":"QE","title":"ZenCore.qe_exec","text":"qe_exec(it::IterInfo, scf::Bool = true)\n\nExecute the quantum espresso (pwscf) program, monitor the convergence progress, and output the relevant information. The argument scf controls which input file should be used. If scf == true, then the input file is case.scf, or else it is case.nscf.\n\nIn order to execute this function correctly, you have to setup the following environment variables:\n\nQE_HOME\n\nand make sure the file MPI.toml is available.\n\nSee also: qe_init, qe_save.\n\n\n\n\n\n","category":"function"},{"location":"internals/qe.html#ZenCore.qe_save","page":"QE","title":"ZenCore.qe_save","text":"qe_save(it::IterInfo)\n\nBackup the output files of quantum espresso (pwscf) if necessary. Furthermore, the DFT fermi level in IterInfo struct is also updated (i.e. IterInfo.μ₀).\n\nSee also: qe_init, qe_exec.\n\n\n\n\n\n","category":"function"},{"location":"internals/qe.html#ZenCore.qec_input","page":"QE","title":"ZenCore.qec_input","text":"qec_input(it::IterInfo)\n\nIt will parse the QE.INP file at first.  The QE.INP is a standard, but mini input file for quantum espresso (pwscf). It only includes three namelists (namely control, system, and electrons) and three cards (namely ATOMIC_SPECIES, ATOMIC_POSITIONS, and K_POINTS). If you want to support more input entries, please make your own modifications here.\n\nThen this function will try to customize these namelists and cards according to the setup in case.toml.\n\nAt last, it will try to generate the input files for quantum espresso (pwscf). They are case.scf and case.nscf. As shown by their names, one file is for the self-consistent calculation, while another one is for the non-self-consistent calculation.\n\nThe return values of this function are namelist (control) and card (ATOMIC_SPECIES), which will be used to check the pseudopotentials within the qe_init() function.\n\nSee also: QENamelist, QECard.\n\n\n\n\n\n","category":"function"},{"location":"internals/qe.html#ZenCore.qeq_files","page":"QE","title":"ZenCore.qeq_files","text":"qeq_files(f::String)\n\nCheck the essential output files by quantum espresso (pwscf). Here f means only the directory that contains the desired files.\n\nSee also: adaptor_core.\n\n\n\n\n\nqeq_files()\n\nCheck the essential output files by quantum espresso (pwscf) in the current directory.\n\nSee also: adaptor_core.\n\n\n\n\n\n","category":"function"},{"location":"internals/qe.html#ZenCore.qeio_energy","page":"QE","title":"ZenCore.qeio_energy","text":"qeio_energy(f::String)\n\nReading quantum espresso's scf.out file, return DFT total energy, which will be used to determine the DFT + DMFT energy. Here f means only the directory that contains scf.out.\n\n\n\n\n\nqeio_energy()\n\nReading quantum espresso's scf.out file, return DFT total energy, which will be used to determine the DFT + DMFT energy.\n\n\n\n\n\n","category":"function"},{"location":"internals/qe.html#ZenCore.qeio_lattice","page":"QE","title":"ZenCore.qeio_lattice","text":"qeio_lattice(f::String, silent::Bool = true)\n\nReading quantum espresso's scf.out file, return crystallography information. Here f means only the directory that contains scf.out.\n\nSee also: Lattice, irio_lattice.\n\n\n\n\n\nqeio_lattice()\n\nReading quantum espresso's scf.out file, return crystallography information.\n\nSee also: Lattice, irio_lattice.\n\n\n\n\n\n","category":"function"},{"location":"internals/qe.html#ZenCore.qeio_kmesh","page":"QE","title":"ZenCore.qeio_kmesh","text":"qeio_kmesh(f::String)\n\nReading quantum espresso's nscf.out file, return kmesh and weight. Here f means only the directory that contains nscf.out.\n\nNote in scf.out, the 𝑘-mesh is not uniform. So we have to read k-mesh from the nscf.out. In addition, the verbosity parameter must be set to 'high' in the input file.\n\nSee also: irio_kmesh.\n\n\n\n\n\nqeio_kmesh()\n\nReading quantum espresso's nscf.out file, return kmesh and weight.\n\nSee also: irio_kmesh.\n\n\n\n\n\n","category":"function"},{"location":"internals/qe.html#ZenCore.qeio_eigen","page":"QE","title":"ZenCore.qeio_eigen","text":"qeio_eigen(f::String)\n\nReading quantum espresso's nscf.out file, return energy band structure information. Here f means only the directory that contains nscf.out.\n\nNote that in scf.out, the eigenvalues may be not defined on the uniform 𝑘-mesh. So we have to read eigenvalues from the nscf.out file.\n\nNote that the eigenvalues read from nscf.out is somewhat coarse. They should be updated by the values read from case.eig.\n\nSee also: irio_eigen.\n\n\n\n\n\nqeio_eigen()\n\nReading quantum espresso's nscf.out file, return energy band structure information.\n\nSee also: irio_eigen.\n\n\n\n\n\n","category":"function"},{"location":"internals/qe.html#ZenCore.qeio_fermi","page":"QE","title":"ZenCore.qeio_fermi","text":"qeio_fermi(f::String, silent::Bool = true)\n\nReading quantum espresso's nscf.out file, return the fermi level. Here f means only the directory that contains scf.out.\n\nSee also: irio_fermi.\n\n\n\n\n\nqeio_fermi()\n\nReading quantum espresso's scf.out file, return the fermi level.\n\nSee also: irio_fermi.\n\n\n\n\n\n","category":"function"},{"location":"internals/qe.html#ZenCore.qeio_band","page":"QE","title":"ZenCore.qeio_band","text":"qeio_band(f::String)\n\nReading quantum espresso's bands.out file, return energy band structure information. Here f means only the directory that contains bands.out.\n\nIn order to generate the bands.out file, please change the calculation mode of quantum espresso to bands, and redirect the standard output to the bands.out file.\n\nNote that the difference between qeio_band() and qeio_eigen() is that the former does not return the occupy matrix. This function should not be called in the DFT + DMFT iterations.\n\n\n\n\n\nqeio_band()\n\nReading quantum espresso's bands.out file, return energy band structure information.\n\n\n\n\n\n","category":"function"},{"location":"internals/qe.html#ZenCore.ReciprocalPoint","page":"QE","title":"ZenCore.ReciprocalPoint","text":"ReciprocalPoint\n\nRepresent a special point of the 3D Brillouin zone. Each of them has a weight w.\n\nMembers\n\ncoord  -> Coordinates, i.e., k_x, k_y, and k_z.\nweight -> Weight for the k-point.\n\nSee also: MonkhorstPackGrid.\n\n\n\n\n\n","category":"type"},{"location":"internals/qe.html#ZenCore.MonkhorstPackGrid","page":"QE","title":"ZenCore.MonkhorstPackGrid","text":"MonkhorstPackGrid\n\nRepresent the Monkhorst-Pack grid.\n\nMembers\n\nmesh  -> A length-three vector specifying the k-point grid          (nk_1  nk_2  nk_3) as in Monkhorst-Pack grids.\nshift -> A length-three vector specifying whether the grid is displaced          by half a grid step in the corresponding directions.\n\nSee also: ReciprocalPoint.\n\n\n\n\n\n","category":"type"},{"location":"internals/qe.html#ZenCore.AtomicSpecies","page":"QE","title":"ZenCore.AtomicSpecies","text":"AtomicSpecies\n\nRepresent each line of the ATOMIC_SPECIES card in the input file of quantum espresso (pwscf).\n\nMembers\n\natom -> Label of the atom. Maximum total length cannot exceed         3 characters.\nmass -> Mass of the atomic species in atomic unit. Used only when         performing molecular dynamics (MD) run or structural         optimization runs using damped MD.\nupf  -> File containing pseudopotential for this species.\n\nExamples\n\njulia> AtomicSpecies(\"C1\", 12, \"C.pbe-n-kjpaw_psl.1.0.0.UPF\")\nAtomicSpecies(\"C1\", 12.0, \"C.pbe-n-kjpaw_psl.1.0.0.UPF\")\n\nSee also: AtomicSpeciesCard.\n\n\n\n\n\n","category":"type"},{"location":"internals/qe.html#ZenCore.AtomicPosition","page":"QE","title":"ZenCore.AtomicPosition","text":"AtomicPosition\n\nRepresent each line of the ATOMIC_POSITIONS card in the input file of quantum espresso (pwscf).\n\nMembers\n\natom   -> Label of the atom as specified in AtomicSpecies. It           accepts at most 3 characters.\npos    -> Atomic positions. A three-element vector of floats.\nifpos -> Component i of the force for this atom is multiplied           by `ifpos(i), which must be either0or1`.  Used           to keep selected atoms and/or selected components fixed           in MD dynamics or structural optimization run.\n\nExamples\n\njulia> AtomicPosition('O', [0, 0, 0])\nAtomicPosition(\"O\", [0.0, 0.0, 0.0], Bool[1, 1, 1])\n\nSee also: AtomicPositionsCard.\n\n\n\n\n\n","category":"type"},{"location":"internals/qe.html#ZenCore.QEInputEntry","page":"QE","title":"ZenCore.QEInputEntry","text":"QEInputEntry\n\nAn abstract type representing an input component of quantum espresso (pwscf). Note that all other input types (such as QENamelist and QECard) should subtype QEInputEntry.  It is used to build a internal type system.\n\nSee also: QECard, QENamelist.\n\n\n\n\n\n","category":"type"},{"location":"internals/qe.html#ZenCore.QENamelist","page":"QE","title":"ZenCore.QENamelist","text":"QENamelist\n\nRepresent a namelist in the input file of quantum espresso (pwscf), a basic Fortran data structure.\n\nMembers\n\nname -> Name of the namelist. It should be control, system, or         electrons. If you want to support more namelists, please         make your own modifications.\ndata -> A dict containing pairs of key and value.\n\nSee also: QECard.\n\n\n\n\n\n","category":"type"},{"location":"internals/qe.html#ZenCore.QECard","page":"QE","title":"ZenCore.QECard","text":"QECard\n\nIt represents abstract cards in the input file of quantum espresso (pwscf).  It is used to build the internal type system. The input file of quantum espresso (pwscf) consists of various cards and namelists, represented by QECard and QENamelist, respectively.\n\nSee also: QENamelist.\n\n\n\n\n\n","category":"type"},{"location":"internals/qe.html#ZenCore.KPointsCard","page":"QE","title":"ZenCore.KPointsCard","text":"KPointsCard\n\nRepresent an abstract card (K-POINTS) in the input file of quantum espresso (pwscf).\n\n\n\n\n\n","category":"type"},{"location":"internals/qe.html#ZenCore.AtomicSpeciesCard","page":"QE","title":"ZenCore.AtomicSpeciesCard","text":"AtomicSpeciesCard\n\nRepresent the ATOMIC_SPECIES card in the input file of quantum espresso (pwscf).\n\nMembers\n\ndata -> A vector containing AtomicSpecies.\n\nSee also: AtomicSpecies.\n\n\n\n\n\n","category":"type"},{"location":"internals/qe.html#ZenCore.AtomicPositionsCard","page":"QE","title":"ZenCore.AtomicPositionsCard","text":"AtomicPositionsCard\n\nRepresent the ATOMIC_POSITIONS card in the input file of quantum espresso (pwscf).\n\nMembers\n\ndata   -> A vector containing AtomicPositions.\noption -> The scheme about how to define atomic positions.\n\nSee also: AtomicPosition.\n\n\n\n\n\n","category":"type"},{"location":"internals/qe.html#ZenCore.AutoKmeshCard","page":"QE","title":"ZenCore.AutoKmeshCard","text":"AutoKmeshCard\n\nRepresent the K_POINTS card in the input file of quantum espresso (pwscf) (be compatible with the automatic mode only).\n\nSee also: KPointsCard.\n\n\n\n\n\n","category":"type"},{"location":"internals/qe.html#ZenCore.GammaPointCard","page":"QE","title":"ZenCore.GammaPointCard","text":"GammaPointCard\n\nRepresent the K_POINTS card in the input file of quantum espresso (pwscf) (be compatible with the gamma mode).\n\nSee also: KPointsCard.\n\n\n\n\n\n","category":"type"},{"location":"internals/qe.html#ZenCore.SpecialPointsCard","page":"QE","title":"ZenCore.SpecialPointsCard","text":"SpecialPointsCard\n\nRepresent the K_POINTS card in the input file of quantum espresso (pwscf) (be compatible with the tpiba or crystal mode).\n\nMembers\n\ndata   -> A vector containing ReciprocalPoints.\noption -> The way about how to define k-mesh.\n\nSee also: KPointsCard.\n\n\n\n\n\n","category":"type"},{"location":"internals/qe.html#Base.haskey","page":"QE","title":"Base.haskey","text":"Base.haskey(qnl::QENamelist, key::AbstractString)\n\nExamine the existence of an entry (specified by key) in the namelist object (qnl).\n\nSee also: QENamelist.\n\n\n\n\n\n","category":"function"},{"location":"internals/qe.html#Base.getindex","page":"QE","title":"Base.getindex","text":"Base.getindex(qnl::QENamelist, key::AbstractString)\n\nReturn an entry (specified by key) in the namelist object (qnl).\n\nSee also: QENamelist.\n\n\n\n\n\n","category":"function"},{"location":"internals/qe.html#Base.setindex!","page":"QE","title":"Base.setindex!","text":"Base.setindex!(qnl::QENamelist, value, key::AbstractString)\n\nModify an entry (specified by key) in the namelist object (qnl).\n\nSee also: QENamelist.\n\n\n\n\n\n","category":"function"},{"location":"internals/qe.html#Base.delete!","page":"QE","title":"Base.delete!","text":"Base.delete!(qnl::QENamelist, key::AbstractString)\n\nRemove an entry (specified by key) in the namelist object (qnl).\n\nSee also: QENamelist.\n\n\n\n\n\n","category":"function"},{"location":"internals/qe.html#Base.tryparse","page":"QE","title":"Base.tryparse","text":"Base.tryparse(::Type{AtomicSpeciesCard}, str::AbstractString)\n\nTry to parse the AtomicSpeciesCard object.\n\nSee also: AtomicSpeciesCard.\n\n\n\n\n\nBase.tryparse(::Type{AtomicPositionsCard}, str::AbstractString)\n\nTry to parse the AtomicPositionsCard object.\n\nSee also: AtomicPositionsCard.\n\n\n\n\n\nBase.tryparse(::Type{KPointsCard}, str::AbstractString)\n\nTry to parse the KPointsCard object.\n\nSee also: KPointsCard.\n\n\n\n\n\nBase.tryparse(::Type{AutoKmeshCard}, str::AbstractString)\n\nTry to parse the AutoKmeshCard object.\n\nSee also: AutoKmeshCard.\n\n\n\n\n\nBase.tryparse(::Type{GammaPointCard}, str::AbstractString)\n\nTry to parse the GammaPointCard object.\n\nSee also: GammaPointCard.\n\n\n\n\n\nBase.tryparse(::Type{SpecialPointsCard}, str::AbstractString)\n\nTry to parse the SpecialPointsCard object.\n\nSee also: SpecialPointsCard.\n\n\n\n\n\n","category":"function"},{"location":"internals/qe.html#Base.parse","page":"QE","title":"Base.parse","text":"Base.parse(::Type{QENamelist}, strs::Vector{String}, name::String)\n\nParse the QENamelist object. The name of the namelist is specified by argument name.\n\nSee also: QENamelist.\n\n\n\n\n\nBase.parse(::Type{T}, str::AbstractString)\n\nParse the QECard object. Now we support the following cards:\n\nATOMIC_SPECIES (AtomicSpeciesCard)\nATOMIC_POSITIONS (AtomicPositionsCard)\nK_POINTS (AutoKmeshCard, GammaPointCard, SpecialPointsCard)\n\nSee also: QECard.\n\n\n\n\n\n","category":"function"},{"location":"internals/qe.html#Base.write","page":"QE","title":"Base.write","text":"Base.write(io::IO, x::QENamelist)\n\nWrite the QENamelist object to IOStream.\n\nSee also: QENamelist.\n\n\n\n\n\nBase.write(io::IO, x::AtomicSpeciesCard)\n\nWrite the AtomicSpeciesCard object to IOStream.\n\nSee also: AtomicSpeciesCard.\n\n\n\n\n\nBase.write(io::IO, x::AtomicPositionsCard)\n\nWrite the AtomicPositionsCard object to IOStream.\n\nSee also: AtomicPositionsCard.\n\n\n\n\n\nBase.write(io::IO, x::AutoKmeshCard)\n\nWrite the AutoKmeshCard object to IOStream.\n\nSee also: AutoKmeshCard.\n\n\n\n\n\nBase.write(io::IO, x::GammaPointCard)\n\nWrite the GammaPointCard object to IOStream.\n\nSee also: GammaPointCard.\n\n\n\n\n\nBase.write(io::IO, x::SpecialPointsCard)\n\nWrite the SpecialPointsCard object to IOStream.\n\nSee also: SpecialPointsCard.\n\n\n\n\n\n","category":"function"},{"location":"guide/block_case.html#PCASE-block","page":"Block [case]","title":"PCASE block","text":"","category":"section"},{"location":"guide/block_case.html#Contents","page":"Block [case]","title":"Contents","text":"","category":"section"},{"location":"guide/block_case.html","page":"Block [case]","title":"Block [case]","text":"Pages = [\"case.md\"]","category":"page"},{"location":"guide/block_case.html#Index","page":"Block [case]","title":"Index","text":"","category":"section"},{"location":"guide/block_case.html","page":"Block [case]","title":"Block [case]","text":"Pages = [\"case.md\"]","category":"page"},{"location":"guide/block_case.html#Parameters","page":"Block [case]","title":"Parameters","text":"","category":"section"},{"location":"guide/block_case.html#case","page":"Block [case]","title":"case","text":"","category":"section"},{"location":"guide/block_case.html","page":"Block [case]","title":"Block [case]","text":"","category":"page"},{"location":"guide/block_case.html","page":"Block [case]","title":"Block [case]","text":"Name: case","category":"page"},{"location":"guide/block_case.html","page":"Block [case]","title":"Block [case]","text":"Type: String","category":"page"},{"location":"guide/block_case.html","page":"Block [case]","title":"Block [case]","text":"Details: Short name of the system that you would like to study with Zen. Note that underscores and blank spaces are not permitted. ","category":"page"},{"location":"guide/block_case.html","page":"Block [case]","title":"Block [case]","text":"Syntax: ","category":"page"},{"location":"guide/block_case.html","page":"Block [case]","title":"Block [case]","text":"case = \"seedname\"","category":"page"},{"location":"guide/block_case.html","page":"Block [case]","title":"Block [case]","text":"Examples:","category":"page"},{"location":"guide/block_case.html","page":"Block [case]","title":"Block [case]","text":"case = \"SrVO3\"\ncase = \"NiO\"\ncase = \"Ce115\"","category":"page"},{"location":"intro/codes.html#The-DFT-DMFT-Codes","page":"The DFT + DMFT Codes","title":"The DFT + DMFT Codes","text":"","category":"section"},{"location":"intro/codes.html","page":"The DFT + DMFT Codes","title":"The DFT + DMFT Codes","text":"Now there are some DFT + DMFT codes available in the internet. Most of them are open source softwares. They are listed as follows:","category":"page"},{"location":"intro/codes.html","page":"The DFT + DMFT Codes","title":"The DFT + DMFT Codes","text":"eDMFT\nAbinit\nTRIQS\nsolid_dmft\nw2dynamics\ncomsuite\nDCore\nDMFTpack\nRSPt\nQuestaal\nAmulet\nABACUS\nCASTEP","category":"page"},{"location":"intro/codes.html","page":"The DFT + DMFT Codes","title":"The DFT + DMFT Codes","text":"todo: Todo\nThe above list might be incomplete. If your codes/software are missed, please let me know (huangli at caep.cn). I will fix it immediately.","category":"page"},{"location":"guide/block_dft.html#PDFT-block","page":"Block [dft]","title":"PDFT block","text":"","category":"section"},{"location":"guide/block_dft.html#Contents","page":"Block [dft]","title":"Contents","text":"","category":"section"},{"location":"guide/block_dft.html","page":"Block [dft]","title":"Block [dft]","text":"Pages = [\"dft.md\"]","category":"page"},{"location":"guide/block_dft.html#Index","page":"Block [dft]","title":"Index","text":"","category":"section"},{"location":"guide/block_dft.html","page":"Block [dft]","title":"Block [dft]","text":"Pages = [\"dft.md\"]","category":"page"},{"location":"guide/block_dft.html#Parameters","page":"Block [dft]","title":"Parameters","text":"","category":"section"},{"location":"guide/gui.html#Graphic-User-Interface","page":"Graphic User Interface","title":"Graphic User Interface","text":"","category":"section"},{"location":"internals/plo.html#Projected-Local-Orbitals","page":"PLO","title":"Projected Local Orbitals","text":"","category":"section"},{"location":"internals/plo.html","page":"PLO","title":"PLO","text":"Tools for the projection on localized orbitals scheme (adaptor).","category":"page"},{"location":"internals/plo.html","page":"PLO","title":"PLO","text":"Source: plo.jl","category":"page"},{"location":"internals/plo.html#Contents","page":"PLO","title":"Contents","text":"","category":"section"},{"location":"internals/plo.html","page":"PLO","title":"PLO","text":"Pages = [\"plo.md\"]","category":"page"},{"location":"internals/plo.html#Index","page":"PLO","title":"Index","text":"","category":"section"},{"location":"internals/plo.html","page":"PLO","title":"PLO","text":"Pages = [\"plo.md\"]","category":"page"},{"location":"internals/plo.html#Functions","page":"PLO","title":"Functions","text":"","category":"section"},{"location":"internals/plo.html","page":"PLO","title":"PLO","text":"plo_adaptor\nplo_check\nplo_map\nplo_fermi\nplo_group\nplo_window\nplo_rotate\nplo_filter\nplo_orthog\nget_win1\nget_win2\nget_win3\ntry_blk1\ntry_blk2\ntry_diag\ncalc_ovlp\ncalc_dm\ncalc_level\ncalc_hamk\ncalc_dos\nview_ovlp\nview_dm\nview_level\nview_hamk\nview_dos","category":"page"},{"location":"internals/plo.html#ZenCore.plo_adaptor","page":"PLO","title":"ZenCore.plo_adaptor","text":"plo_adaptor(D::Dict{Symbol,Any}, ai::Array{Impurity,1})\n\nAdaptor support. It will preprocess the raw projector matrix. The dict D contains all of the necessary Kohn-Sham data, which will be modified in this function.\n\nIf it is in the REPL mode and the file case.test is present in the current directory, this function will try to calculate some physical observables, such as the density matrix, overlap matrix, partial density of states, and local hamiltonian, which will be written to external files or terminal for further reference.\n\nSee also: vasp_adaptor, ir_adaptor.\n\n\n\n\n\n","category":"function"},{"location":"internals/plo.html#ZenCore.plo_check","page":"PLO","title":"ZenCore.plo_check","text":"plo_check(D::Dict{Symbol,Any})\n\nGenerate some key physical quantities by using the projectors and the Kohn-Sham band structures. It is used for debug only.\n\n\n\n\n\n","category":"function"},{"location":"internals/plo.html#ZenCore.plo_map","page":"PLO","title":"ZenCore.plo_map","text":"plo_map(PG::Array{PrGroup,1}, ai::Array{Impurity,1})\n\nCreate connections / mappings between projectors (or band windows) and quantum impurity problems. Return a Mapping struct.\n\nSee also: PrGroup, PrWindow, Mapping.\n\n\n\n\n\n","category":"function"},{"location":"internals/plo.html#ZenCore.plo_fermi","page":"PLO","title":"ZenCore.plo_fermi","text":"plo_fermi(enk::Array{F64,3}, fermi::F64)\n\nCalibrate the band structure to enforce the fermi level to be zero.\n\nSee also: vaspio_fermi, irio_fermi.\n\n\n\n\n\n","category":"function"},{"location":"internals/plo.html#ZenCore.plo_group","page":"PLO","title":"ZenCore.plo_group","text":"plo_group(MAP::Mapping, PG::Array{PrGroup,1})\n\nUse the information contained in the Mapping struct to further complete the PrGroup struct.\n\nSee also: PIMP, Mapping, PrGroup.\n\n\n\n\n\n","category":"function"},{"location":"internals/plo.html#ZenCore.plo_window","page":"PLO","title":"ZenCore.plo_window","text":"plo_window(PG::Array{PrGroup,1}, enk::Array{F64,3})\n\nCalibrate the band window to filter the Kohn-Sham eigenvalues.\n\nSee also: PrWindow, get_win1, get_win2.\n\n\n\n\n\n","category":"function"},{"location":"internals/plo.html#ZenCore.plo_rotate","page":"PLO","title":"ZenCore.plo_rotate","text":"plo_rotate(PG::Array{PrGroup,1}, chipsi::Array{C64,4})\n\nPerform global rotations or transformations for the projectors. In this function, the projectors will be classified into different groups, and then they will be rotated group by group.\n\nSee also: PrGroup, plo_filter, plo_orthog.\n\n\n\n\n\n","category":"function"},{"location":"internals/plo.html#ZenCore.plo_filter","page":"PLO","title":"ZenCore.plo_filter","text":"plo_filter(PW::Array{PrWindow,1}, chipsi::Array{Array{C64,4},1}}\n\nFilter the projector matrix according to band window.\n\nSee also: PrWindow, plo_rotate, plo_orthog.\n\n\n\n\n\n","category":"function"},{"location":"internals/plo.html#ZenCore.plo_orthog","page":"PLO","title":"ZenCore.plo_orthog","text":"plo_orthog(PW::Array{PrWindow,1}, chipsi::Array{Array{C64,4},1})\n\nOrthogonalize and normalize the projectors.\n\nSee also: PrWindow, plo_rotate, plo_filter.\n\n\n\n\n\n","category":"function"},{"location":"internals/plo.html#ZenCore.get_win1","page":"PLO","title":"ZenCore.get_win1","text":"get_win1(enk::Array{F64,3}, bwin::Tuple{I64,I64})\n\nReturn momentum- and spin-dependent band window (case 1). The users provide only the band indices for the window.\n\nSee also: plo_window.\n\n\n\n\n\n","category":"function"},{"location":"internals/plo.html#ZenCore.get_win2","page":"PLO","title":"ZenCore.get_win2","text":"get_win2(enk::Array{F64,3}, bwin::Tuple{F64,F64})\n\nReturn momentum- and spin-dependent band window (case 2). The users provide only the maximum and minimum energies for the window.\n\nSee also: plo_window.\n\n\n\n\n\n","category":"function"},{"location":"internals/plo.html#ZenCore.get_win3","page":"PLO","title":"ZenCore.get_win3","text":"get_win3(chipsi::Array{C64,4})\n\nReturn momentum- and spin-dependent band window (case 3). This function implement a smart algorithm to determine the band window. It does not need any external parameters. This algorithm is quite simple. First, it uses the projection matrix (chipsi) to calculate the 𝑘- and σ-dependent projectibility. Then it calculates the effective projectibility by using 𝑘-summation. Next, it filters the projectibility to figure out which bands have large contributions. At last, the band window is composed of these selected bands. Note that the obtained band window is actually momentum- and spin-independent.\n\nSee also: plo_window.\n\n\n\n\n\n","category":"function"},{"location":"internals/plo.html#ZenCore.try_blk1","page":"PLO","title":"ZenCore.try_blk1","text":"try_blk1(PW::Array{PrWindow,1}, chipsi::Array{Array{C64,4},1})\n\nTry to orthogonalize and normalize the projectors as a whole.\n\nSee also: PrWindow, try_blk2, plo_orthog.\n\n\n\n\n\n","category":"function"},{"location":"internals/plo.html#ZenCore.try_blk2","page":"PLO","title":"ZenCore.try_blk2","text":"try_blk2(PW::Array{PrWindow,1}, chipsi::Array{Array{C64,4},1})\n\nTry to orthogonalize the projectors group by group.\n\nSee also: PrWindow, try_blk1, plo_orthog.\n\n\n\n\n\n","category":"function"},{"location":"internals/plo.html#ZenCore.try_diag","page":"PLO","title":"ZenCore.try_diag","text":"try_diag(M::AbstractArray{C64,2})\n\nOrthogonalize the given matrix.\n\nSee also: try_blk1, try_blk2.\n\n\n\n\n\n","category":"function"},{"location":"internals/plo.html#ZenCore.calc_ovlp","page":"PLO","title":"ZenCore.calc_ovlp","text":"calc_ovlp(chipsi::Array{C64,4}, weight::Array{F64,1})\n\nCalculate the overlap matrix out of projectors. For raw projectors only.\n\nSee also: view_ovlp.\n\n\n\n\n\ncalc_ovlp(PW::Array{PrWindow,1},\n          chipsi::Array{Array{C64,4},1},\n          weight::Array{F64,1})\n\nCalculate the overlap matrix out of projectors. For normalized projectors only.\n\nSee also: view_ovlp.\n\n\n\n\n\n","category":"function"},{"location":"internals/plo.html#ZenCore.calc_dm","page":"PLO","title":"ZenCore.calc_dm","text":"calc_dm(chipsi::Array{C64,4},\n        weight::Array{F64,1},\n        occupy::Array{F64,3})\n\nCalculate the density matrix out of projectors. For raw projectors only.\n\nSee also: view_dm.\n\n\n\n\n\ncalc_dm(PW::Array{PrWindow,1},\n        chipsi::Array{Array{C64,4},1},\n        weight::Array{F64,1},\n        occupy::Array{F64,3})\n\nCalculate the density matrix out of projectors. For normalized projectors only.\n\nSee also: view_dm.\n\n\n\n\n\n","category":"function"},{"location":"internals/plo.html#ZenCore.calc_level","page":"PLO","title":"ZenCore.calc_level","text":"calc_level(chipsi::Array{C64,4},\n           weight::Array{F64,1},\n           enk::Array{F64,3})\n\nTry to build the effective band level in local basis. For raw projectors only.\n\nSee also: view_level.\n\n\n\n\n\ncalc_level(PW::Array{PrWindow,1},\n           chipsi::Array{Array{C64,4},1},\n           weight::Array{F64,1},\n           enk::Array{F64,3})\n\nTry to build the effective band level in local basis. For normalized projectors only.\n\nSee also: view_level.\n\n\n\n\n\n","category":"function"},{"location":"internals/plo.html#ZenCore.calc_hamk","page":"PLO","title":"ZenCore.calc_hamk","text":"calc_hamk(chipsi::Array{C64,4}, enk::Array{F64,3})\n\nTry to build the hamiltonian matrix in local basis (momentum-dependent). For raw projectors only.\n\nSee also: view_hamk.\n\n\n\n\n\ncalc_hamk(PW::Array{PrWindow,1},\n          chipsi::Array{Array{C64,4},1},\n          enk::Array{F64,3})\n\nTry to build the hamiltonian matrix in local basis (momentum-dependent). For normalized projectors only.\n\nSee also: view_hamk.\n\n\n\n\n\n","category":"function"},{"location":"internals/plo.html#ZenCore.calc_dos","page":"PLO","title":"ZenCore.calc_dos","text":"calc_dos(PW::Array{PrWindow,1},\n         chipsi::Array{Array{C64,4},1},\n         itet::Array{I64,2},\n         enk::Array{F64,3})\n\nTry to calculate the partial density of states using the analytical tetrahedron method.\n\nSee also: view_dos.\n\n\n\n\n\n","category":"function"},{"location":"internals/plo.html#ZenCore.view_ovlp","page":"PLO","title":"ZenCore.view_ovlp","text":"view_ovlp(ovlp::Array{F64,3})\n\nOutput the overlap matrix to ovlp.raw. For raw projectors only.\n\nSee also: calc_ovlp.\n\n\n\n\n\nview_ovlp(PG::Array{PrGroup,1}, ovlp::Array{Array{F64,3},1})\n\nOutput the overlap matrix to ovlp.nor. For normalized projectors only.\n\nSee also: calc_ovlp.\n\n\n\n\n\n","category":"function"},{"location":"internals/plo.html#ZenCore.view_dm","page":"PLO","title":"ZenCore.view_dm","text":"view_dm(dm::Array{F64,3})\n\nOutput the density matrix to dm.raw. For raw projectors only.\n\nSee also: calc_dm.\n\n\n\n\n\nview_dm(PG::Array{PrGroup,1}, dm::Array{Array{F64,3},1})\n\nOutput the density matrix to dm.nor. For normalized projectors only.\n\nSee also: calc_dm.\n\n\n\n\n\n","category":"function"},{"location":"internals/plo.html#ZenCore.view_level","page":"PLO","title":"ZenCore.view_level","text":"view_level(level::Array{C64,3})\n\nOutput the effective atomic level to level.raw. For raw projectors only.\n\nSee also: calc_level.\n\n\n\n\n\nview_level(PG::Array{PrGroup,1}, level::Array{Array{C64,3},1})\n\nOutput the effective atomic level to level.nor. For normalized projectors only.\n\nSee also: calc_level.\n\n\n\n\n\n","category":"function"},{"location":"internals/plo.html#ZenCore.view_hamk","page":"PLO","title":"ZenCore.view_hamk","text":"view_hamk(hamk::Array{C64,4})\n\nOutput the hamiltonian matrix in local basis to hamk.raw. For raw projectors only.\n\nSee also: calc_hamk.\n\n\n\n\n\nview_hamk(hamk::Array{Array{C64,4},1})\n\nOutput the hamiltonian matrix in local basis to hamk.nor.i. For normalized projectors only.\n\nSee also: calc_hamk.\n\n\n\n\n\n","category":"function"},{"location":"internals/plo.html#ZenCore.view_dos","page":"PLO","title":"ZenCore.view_dos","text":"view_dos(mesh::Array{Array{F64,1},1}, dos::Array{Array{F64,3},1})\n\nOutput the density of states to dos.nor. For normalized projectors only.\n\nSee also: calc_dos.\n\n\n\n\n\n","category":"function"},{"location":"intro/methods.html#Theoretical-Methods","page":"Summary","title":"Theoretical Methods","text":"","category":"section"},{"location":"tutor/MnO.html#MnO:-Mott-Insulator","page":"MnO: Mott Insulator","title":"MnO: Mott Insulator","text":"","category":"section"},{"location":"internals/base.html#Base","page":"Base","title":"Base","text":"","category":"section"},{"location":"internals/base.html","page":"Base","title":"Base","text":"To provide the core functions to control the DFT engine, DMFT engine, quantum impurity solvers, Kohn-Sham adaptor, self-energy engine, and mixer engine. The DFT + DMFT iteration (one-shot mode or charge fully self-consistent mode) is also implemented in this file. This file also includes some functions to watch and manipulate the IterInfo struct.","category":"page"},{"location":"internals/base.html","page":"Base","title":"Base","text":"Source: base.jl","category":"page"},{"location":"internals/base.html#Contents","page":"Base","title":"Contents","text":"","category":"section"},{"location":"internals/base.html","page":"Base","title":"Base","text":"Pages = [\"base.md\"]","category":"page"},{"location":"internals/base.html#Index","page":"Base","title":"Index","text":"","category":"section"},{"location":"internals/base.html","page":"Base","title":"Base","text":"Pages = [\"base.md\"]","category":"page"},{"location":"internals/base.html#Functions","page":"Base","title":"Functions","text":"","category":"section"},{"location":"internals/base.html","page":"Base","title":"Base","text":"ready\ngo\nfinal\nrefresh\ncycle1\ncycle2\ntry_dft\ntry_dmft\ntry_solver\ntry_adaptor\ntry_sigma\ntry_mixer\nmonitor\nsuspend\nsuicide\ndft_core\ndmft_core\nsolver_core\nadaptor_core\nsigma_core\nmixer_core\nenergy_core\nbuild_trees\nclear_trees\nincr_it\nzero_it\nprev_it\ncntr_it\nshow_it\nconv_it","category":"page"},{"location":"internals/base.html#ZenCore.ready","page":"Base","title":"ZenCore.ready","text":"ready(mkdir::Bool = true)\n\nExamine whether all the conditions (including input files and working directories) for DFT + DMFT calculations are ready.\n\nSee also: go.\n\n\n\n\n\n","category":"function"},{"location":"internals/base.html#ZenCore.go","page":"Base","title":"ZenCore.go","text":"go()\n\nDispatcher for DFT + DMFT calculations. Note that it can not call the try_dft()-try_mixer() series functions. These functions are designed only for testing purpose.\n\nSee also: ready.\n\n\n\n\n\n","category":"function"},{"location":"internals/base.html#ZenCore.final","page":"Base","title":"ZenCore.final","text":"final()\n\nFinalize the DFT + DMFT calculations.\n\nSee also: go.\n\n\n\n\n\n","category":"function"},{"location":"internals/base.html#ZenCore.refresh","page":"Base","title":"ZenCore.refresh","text":"refresh(ai::Array{Impurity,1})\n\nUpdate the configuration parameters dynamically during the DFT + DMFT iterations.\n\nSee also: renew, FixImpurity.\n\n\n\n\n\n","category":"function"},{"location":"internals/base.html#ZenCore.cycle1","page":"Base","title":"ZenCore.cycle1","text":"cycle1()\n\nPerform one-shot DFT + DMFT calculations. In other words, the charge density won't be fed back to the DFT engine. The self-consistency is only achieved at the DMFT level.\n\nSee also: cycle2, go.\n\n\n\n\n\n","category":"function"},{"location":"internals/base.html#ZenCore.cycle2","page":"Base","title":"ZenCore.cycle2","text":"cycle2()\n\nPerform fully self-consistent DFT + DMFT calculations. The self-consistency is achieved at both DFT and DMFT levels. So far this function only supports the vasp + plo mode.\n\nSee also: cycle1, go.\n\n\n\n\n\n","category":"function"},{"location":"internals/base.html#ZenCore.try_dft","page":"Base","title":"ZenCore.try_dft","text":"try_dft()\n\nPerform DFT calculations only. If there are something wrong, then you have chance to adjust the DFT input files manually (for example, you can modify vaspc_incar() in vasp.jl by yourself).\n\nSee also: cycle1, cycle2.\n\n\n\n\n\n","category":"function"},{"location":"internals/base.html#ZenCore.try_dmft","page":"Base","title":"ZenCore.try_dmft","text":"try_dmft(task::I64)\n\nPerform DMFT calculations only. The users can execute it in the REPL mode to see whether the DMFT engine works properly. If task = 1, it means to generate a new hybridization function for quantum impurity solver. On the other hand, it task = 2, it means to generate a DMFT correction for the density matrix, which will be used by the DFT engine.\n\nSee also: cycle1, cycle2.\n\n\n\n\n\n","category":"function"},{"location":"internals/base.html#ZenCore.try_solver","page":"Base","title":"ZenCore.try_solver","text":"try_solver()\n\nPerform calculations using quantum impurity solvers only. The users can execute it in the REPL mode to see whether the quantum impurity solvers work properly.\n\nSee also: cycle1, cycle2.\n\n\n\n\n\n","category":"function"},{"location":"internals/base.html#ZenCore.try_adaptor","page":"Base","title":"ZenCore.try_adaptor","text":"try_adaptor()\n\nPerform calculations using Kohn-Sham adaptor only. The users can execute it in the REPL mode to see whether the Kohn-Sham adaptor works properly.\n\nSee also: cycle1, cycle2.\n\n\n\n\n\n","category":"function"},{"location":"internals/base.html#ZenCore.try_sigma","page":"Base","title":"ZenCore.try_sigma","text":"try_sigma(task::String = \"reset\")\n\nPerform calculations using self-energy engine only. The users can execute it in the REPL mode to see whether the self-energy engine works properly. The argument task can be reset, dcount, gather, and split.\n\nSee also: cycle1, cycle2.\n\n\n\n\n\n","category":"function"},{"location":"internals/base.html#ZenCore.try_mixer","page":"Base","title":"ZenCore.try_mixer","text":"try_mixer(task::String = \"Σ\")\n\nPerform calculations using mixer engine only. The users can execute it in the REPL mode to see whether the mixer engine works properly. The argument task can be Σ, Δ, E, and Γ.\n\nIn order to run this function correctly, users should try to modify the predefined parameters in step C01.\n\nSee also: cycle1, cycle2.\n\n\n\n\n\n","category":"function"},{"location":"internals/base.html#ZenCore.monitor","page":"Base","title":"ZenCore.monitor","text":"monitor(force_exit::Bool = false)\n\nDetermine whether we need to terminate the Zen code.\n\nSee also: query_stop.\n\n\n\n\n\n","category":"function"},{"location":"internals/base.html#ZenCore.suspend","page":"Base","title":"ZenCore.suspend","text":"suspend(second::I64 = 1)\n\nSuspend the current process to wait the DFT engine. This function is useful for charge fully self-consistent DFT + DMFT calculations.\n\nNow this function only supports the vasp code. We have to improve it to support more DFT engines.\n\nSee also: dft_core.\n\n\n\n\n\n","category":"function"},{"location":"internals/base.html#ZenCore.suicide","page":"Base","title":"ZenCore.suicide","text":"suicide(it::IterInfo)\n\nKill the DFT engine abnormally. Now it supports the vasp code only.\n\nSee also: dft_core.\n\n\n\n\n\n","category":"function"},{"location":"internals/base.html#ZenCore.dft_core","page":"Base","title":"ZenCore.dft_core","text":"dft_core(it::IterInfo, lr::Logger, sc::Bool = false)\n\nSimple driver for DFT engine. It performs three tasks: (1) Examine the runtime environment for the DFT engine. (2) Launch the DFT engine. (3) Backup the output files by DFT engine for next iterations.\n\nIf sc = true, this function will read in the correction for density matrix, and then feed it back to the DFT engine to continue the DFT + DMFT calculations.\n\nNow only the vasp and quantum espresso codes are supported. If you want to support more DFT engines, this function must be adapted.\n\nSee also: adaptor_core, dmft_core, solver_core.\n\n\n\n\n\n","category":"function"},{"location":"internals/base.html#ZenCore.dmft_core","page":"Base","title":"ZenCore.dmft_core","text":"dmft_core(it::IterInfo, lr::Logger, task::I64)\n\nSimple driver for DMFT engine. It performs three tasks: (1) Examine the runtime environment for the DMFT engine. (2) Launch the DMFT engine. (3) Backup the output files by DMFT engine for next iterations.\n\nThe argument task is used to specify running mode of the DMFT code. Its value can be 1 or 2.\n\nSee also: adaptor_core, dft_core, solver_core.\n\n\n\n\n\n","category":"function"},{"location":"internals/base.html#ZenCore.solver_core","page":"Base","title":"ZenCore.solver_core","text":"solver_core(it::IterInfo,\n            lr::Logger,\n            ai::Array{Impurity,1},\n            force::Bool = false)\n\nSimple driver for quantum impurity solvers. It performs three tasks: (1) Examine the runtime environment for quantum impurity solver. (2) Launch the quantum impurity solver. (3) Backup output files by quantum impurity solver for next iterations.\n\nIf force = true, then we will try to solve all of the quantum impurity problems explicitly, irrespective of their equivalences.\n\nNow only the ct_hyb1, ct_hyb2, hub1, and norg quantum impurity solvers are supported. If you want to support the other quantum impurity solvers, this function must be adapted.\n\nSee also: adaptor_core, dft_core, dmft_core.\n\n\n\n\n\n","category":"function"},{"location":"internals/base.html#ZenCore.adaptor_core","page":"Base","title":"ZenCore.adaptor_core","text":"adaptor_core(it::IterInfo, lr::Logger, ai::Array{Impurity,1})\n\nSimple driver for the adaptor. It performs three tasks: (1) Initialize the adaptor, to check whether the essential files exist. (2) Parse the Kohn-Sham data output by the DFT engine, try to preprocess them, and then transform them into IR format. (3) Backup the files by adaptor.\n\nFor the first task, both the vasp and qe adaptors are supported. While for the second task, both the plo and wannier adaptors are supported. If you want to support more adaptors, please adapt this function by yourself.\n\nSee also: dft_core, dmft_core, solver_core.\n\n\n\n\n\n","category":"function"},{"location":"internals/base.html#ZenCore.sigma_core","page":"Base","title":"ZenCore.sigma_core","text":"sigma_core(it::IterInfo,\n           lr::Logger,\n           ai::Array{Impurity,1},\n           task::String = \"reset\")\n\nSimple driver for functions for processing the self-energy functions Σ and hybridization functions Δ (and local impurity levels ϵ).\n\nNow it supports four tasks: reset, dcount, split, gather. It won't change the current directory.\n\nSee also: mixer_core.\n\n\n\n\n\n","category":"function"},{"location":"internals/base.html#ZenCore.mixer_core","page":"Base","title":"ZenCore.mixer_core","text":"mixer_core(it::IterInfo,\n           lr::Logger,\n           ai::Array{Impurity,1},\n           task::String = \"Σ\")\n\nSimple driver for the mixer. It will try to mix the self-energy functions Σ (or hybridization functions Δ, local impurity levels ϵ, density matrix Γ) and generate a new one.\n\nNow it supports four tasks: Σ, Δ, E, Γ. It won't change the current directory.\n\nSee also: sigma_core.\n\n\n\n\n\n","category":"function"},{"location":"internals/base.html#ZenCore.energy_core","page":"Base","title":"ZenCore.energy_core","text":"energy_core(it::IterInfo)\n\nSimple driver for treating the total DFT + DMFT energy. It will print the decomposition of total energy, and try to calculate the energy difference between two successive DFT + DMFT iterations.\n\nSee also: Energy, IterInfo.\n\n\n\n\n\n","category":"function"},{"location":"internals/base.html#ZenCore.build_trees","page":"Base","title":"ZenCore.build_trees","text":"build_trees()\n\nPrepare the working directories at advance.\n\nSee also: clear_trees.\n\n\n\n\n\n","category":"function"},{"location":"internals/base.html#ZenCore.clear_trees","page":"Base","title":"ZenCore.clear_trees","text":"clear_trees()\n\nRemove the working directories finally.\n\nSee also: build_trees.\n\n\n\n\n\n","category":"function"},{"location":"internals/base.html#ZenCore.incr_it","page":"Base","title":"ZenCore.incr_it","text":"incr_it(it::IterInfo)\n\nModify the internal counters in IterInfo struct. This function is used in the one-shot DFT + DMFT calculations only.\n\nSee also: IterInfo, zero_it.\n\n\n\n\n\nincr_it(it::IterInfo, c::I64, v::I64)\n\nModify the internal counters in IterInfo struct. This function is used in the fully charge self-consistent DFT + DMFT calculations only. The argument c denotes the counter it.I, and v is the value.\n\nSee also: IterInfo, zero_it.\n\n\n\n\n\n","category":"function"},{"location":"internals/base.html#ZenCore.zero_it","page":"Base","title":"ZenCore.zero_it","text":"zero_it(it::IterInfo)\n\nReset some (not all) counters in the IterInfo struct.\n\nSee also: IterInfo, incr_it.\n\n\n\n\n\n","category":"function"},{"location":"internals/base.html#ZenCore.prev_it","page":"Base","title":"ZenCore.prev_it","text":"prev_it(it::IterInfo)\n\nReturn the iteration information for previous DFT + DMFT step. This function is suitable for one-shot calculation mode.\n\nSee also: mixer_core, incr_it.\n\n\n\n\n\nprev_it(it::IterInfo, c::I64)\n\nReturn the iteration information for previous DFT + DMFT step. This function is suitable for fully self-consistent calculation mode. Here the argument c denotes the counter it.I\n\nSee also: mixer_core, incr_it.\n\n\n\n\n\n","category":"function"},{"location":"internals/base.html#ZenCore.cntr_it","page":"Base","title":"ZenCore.cntr_it","text":"cntr_it(it::IterInfo)\n\nReturn the counters in the IterInfo struct as a format string.\n\nSee also: IterInfo\n\n\n\n\n\n","category":"function"},{"location":"internals/base.html#ZenCore.show_it","page":"Base","title":"ZenCore.show_it","text":"show_it(it::IterInfo, lr::Logger)\n\nTry to record the iteration information in the case.cycle file.\n\nSee also: IterInfo, Logger.\n\n\n\n\n\nshow_it(mode::String, iter::I64, max_iter::I64)\n\nTry to record the iteration information in the terminal.\n\n\n\n\n\n","category":"function"},{"location":"internals/base.html#ZenCore.conv_it","page":"Base","title":"ZenCore.conv_it","text":"conv_it(it::IterInfo)\n\nCheck whether the convergence flags are achieved.\n\nSee also: IterInfo.\n\n\n\n\n\n","category":"function"},{"location":"tutor/FeSe.html#FeSe:-Unconventional-Superconuctor","page":"FeSe: Unconventional Superconuctor","title":"FeSe: Unconventional Superconuctor","text":"","category":"section"},{"location":"guide/core.html#Core-Components","page":"Summary","title":"Core Components","text":"","category":"section"},{"location":"tutor/outline.html#Outline","page":"Outline","title":"Outline","text":"","category":"section"},{"location":"tutor/outline.html","page":"Outline","title":"Outline","text":"SrVO_3: Strongly Correlated Metal\nFeSe: Unconventional Superconuctor\nMnO: Mott Insulator\nCe: f-Electron Metal","category":"page"},{"location":"guide/parameters.html#Input-Parameters","page":"Summary","title":"Input Parameters","text":"","category":"section"},{"location":"internals/summary.html#Inside-The-ZenCore-Library","page":"Summary","title":"Inside The ZenCore Library","text":"","category":"section"},{"location":"guide/auxiliary.html#Auxiliary-Components","page":"Summary","title":"Auxiliary Components","text":"","category":"section"},{"location":"guide/output.html#Output-Files","page":"Summary","title":"Output Files","text":"","category":"section"},{"location":"start/obtain.html#Get-The-Code","page":"Get The Code","title":"Get The Code","text":"","category":"section"},{"location":"start/obtain.html","page":"Get The Code","title":"Get The Code","text":"The Zen computation framework is an open source software. All the source codes are hosted in the Github. So, the newest version of Zen can be downloaded from the following URL:","category":"page"},{"location":"start/obtain.html","page":"Get The Code","title":"Get The Code","text":"https://github.com/huangli712/Zen","category":"page"},{"location":"start/outline.html#Outline","page":"Outline","title":"Outline","text":"","category":"section"},{"location":"start/outline.html","page":"Outline","title":"Outline","text":"Components\nGet The Code\nUncompress\nDirectory Structure\nCompile\nInstall\nConfigure\nThe First Run\nUpgrade","category":"page"},{"location":"internals/outline.html#Outline","page":"Outline","title":"Outline","text":"","category":"section"},{"location":"internals/sigma.html#Self-Energy-Functions","page":"Sigma","title":"Self-Energy Functions","text":"","category":"section"},{"location":"internals/sigma.html","page":"Sigma","title":"Sigma","text":"Tools for treating the self-energy functions Sigma, double counting terms Sigma_textdc. Note that the function sigma_split() is designed for the hybridization functions Delta and local impurity levels epsilon_i, instead of the self-energy functions.","category":"page"},{"location":"internals/sigma.html","page":"Sigma","title":"Sigma","text":"Source: sigma.jl","category":"page"},{"location":"internals/sigma.html#Contents","page":"Sigma","title":"Contents","text":"","category":"section"},{"location":"internals/sigma.html","page":"Sigma","title":"Sigma","text":"Pages = [\"sigma.md\"]","category":"page"},{"location":"internals/sigma.html#Index","page":"Sigma","title":"Index","text":"","category":"section"},{"location":"internals/sigma.html","page":"Sigma","title":"Sigma","text":"Pages = [\"sigma.md\"]","category":"page"},{"location":"internals/sigma.html#Functions","page":"Sigma","title":"Functions","text":"","category":"section"},{"location":"internals/sigma.html","page":"Sigma","title":"Sigma","text":"sigma_call\nsigma_reset\nsigma_dcount\nsigma_split\nsigma_gather\ncal_dc_fll\ncal_dc_amf\ncal_dc_held\ncal_dc_exact\nread_sigma\nread_sigdc\nwrite_sigma\nwrite_sigdc","category":"page"},{"location":"internals/sigma.html#ZenCore.sigma_call","page":"Sigma","title":"ZenCore.sigma_call","text":"sigma_call(::NULLMode, it::IterInfo, ai::Array{Impurity,1})\nsigma_call(::RESETMode, it::IterInfo, ai::Array{Impurity,1})\nsigma_call(::DCOUNTMode, it::IterInfo, ai::Array{Impurity,1})\nsigma_call(::SPLITMode, it::IterInfo, ai::Array{Impurity,1})\nsigma_call(::GATHERMode, it::IterInfo, ai::Array{Impurity,1})\n\nTry to apply various operations on the self-energy functions Σ and the hybridization functions Δ (or impurity levels ϵ).\n\nSee also: _mode_.\n\n\n\n\n\n","category":"function"},{"location":"internals/sigma.html#ZenCore.sigma_reset","page":"Sigma","title":"ZenCore.sigma_reset","text":"sigma_reset(ai::Array{Impurity,1}, with_init_dc::Bool = true)\n\nCreate initial self-energy functions and write them to sigma.bare. The sigma.bare file is key input for the dynamical mean-field theory engine. The word bare means that the double counting term has not been removed from the self-energy functions. Now this function only supports Matsubara self-energy functions Σ(𝑖ωₙ).\n\nIf with_init_dc = true, then the real parts of self-energy functions are initialized by the double counting terms within the fully localized limited scheme. If with_init_dc = false, then the self-energy functions are set to be complex zero.\n\nSee also: sigma_dcount.\n\n\n\n\n\n","category":"function"},{"location":"internals/sigma.html#ZenCore.sigma_dcount","page":"Sigma","title":"ZenCore.sigma_dcount","text":"sigma_dcount(it::IterInfo,\n             ai::Array{Impurity,1},\n             reset_dc::Bool = false)\n\nCalculate double counting terms for local self-energy functions and write them to sigma.dc, which is an essential input for the dynamical mean-field theory engine.\n\nIf reset_dc = true, it will reset the double counting terms to zero. This is particularly useful for the first DFT + DMFT iteration. However, if reset_dc = false, it will retain the double counting terms.\n\nThe field it.dc will be updated in this function as well.\n\nSee also: sigma_reset.\n\n\n\n\n\n","category":"function"},{"location":"internals/sigma.html#ZenCore.sigma_split","page":"Sigma","title":"ZenCore.sigma_split","text":"sigma_split(ai::Array{Impurity,1})\n\nSplit the hybridization functions Δ (and local impurity levels ϵ) and then distribute them into the impurity.i folder.\n\nSee also: sigma_gather.\n\n\n\n\n\n","category":"function"},{"location":"internals/sigma.html#ZenCore.sigma_gather","page":"Sigma","title":"ZenCore.sigma_gather","text":"sigma_gather(it::IterInfo, ai::Array{Impurity,1})\n\nGather the self-energy functions Σ (or similar local functions) from the all the impurity.i folders and then combine them into a single sigma.bare file.\n\nSee also: sigma_split.\n\n\n\n\n\n","category":"function"},{"location":"internals/sigma.html#ZenCore.cal_dc_fll","page":"Sigma","title":"ZenCore.cal_dc_fll","text":"cal_dc_fll(U::F64, J::F64, N::F64)\n\nEvaluate the double counting term by the fully localized limit scheme. This function is for the spin-unpolarized case.\n\nSee also: cal_dc_amf, cal_dc_exact.\n\n\n\n\n\ncal_dc_fll(U::F64, J::F64, Nup::F64, Ndn::F64)\n\nEvaluate the double counting term by the fully localized limit scheme. This function is for the spin-polarized case.\n\nSee also: cal_dc_amf, cal_dc_exact.\n\n\n\n\n\n","category":"function"},{"location":"internals/sigma.html#ZenCore.cal_dc_amf","page":"Sigma","title":"ZenCore.cal_dc_amf","text":"cal_dc_amf(U::F64, J::F64, N::F64, M::I64)\n\nEvaluate the double counting term by the around mean-field scheme. This function is for the spin-unpolarized case.\n\nSee also: cal_dc_fll, cal_dc_exact.\n\n\n\n\n\ncal_dc_amf(U::F64, J::F64, Nup::F64, Ndn::F64, M::I64)\n\nEvaluate the double counting term by the around mean-field scheme. This function is for the spin-polarized case.\n\nSee also: cal_dc_fll, cal_dc_exact.\n\n\n\n\n\n","category":"function"},{"location":"internals/sigma.html#ZenCore.cal_dc_held","page":"Sigma","title":"ZenCore.cal_dc_held","text":"cal_dc_held(U::F64, J::F64, N::F64, M::I64)\n\nEvaluate the double counting term by the K. Held scheme.\n\nSee also: cal_dc_fll, cal_dc_amf, cal_dc_exact.\n\n\n\n\n\n","category":"function"},{"location":"internals/sigma.html#ZenCore.cal_dc_exact","page":"Sigma","title":"ZenCore.cal_dc_exact","text":"cal_dc_exact(U::F64, J::F64, N::F64)\n\nEvaluate the double counting term by the exact scheme.\n\nSee also: cal_dc_fll, cal_dc_amf.\n\n\n\n\n\n","category":"function"},{"location":"internals/sigma.html#ZenCore.read_sigma","page":"Sigma","title":"ZenCore.read_sigma","text":"read_sigma(ai::Array{Impurity,1},\n           fsig::String = \"dmft1/sigma.bare\")\n\nRead the self-energy functions from the dmft1/sigma.bare file. The working directory of this function must be the root folder.\n\nThis function is usually called by mixer_sigma() function.\n\nSee also: read_sigdc.\n\n\n\n\n\n","category":"function"},{"location":"internals/sigma.html#ZenCore.read_sigdc","page":"Sigma","title":"ZenCore.read_sigdc","text":"read_sigdc(ai::Array{Impurity,1},\n           fsig::String = \"dmft1/sigma.dc\")\n\nRead the double counting terms from the dmft1/sigma.dc file. The working directory of this function must be the root folder.\n\nSee also: read_sigma.\n\n\n\n\n\n","category":"function"},{"location":"internals/sigma.html#ZenCore.write_sigma","page":"Sigma","title":"ZenCore.write_sigma","text":"write_sigma(fmesh::Array{F64,1},\n            SA::Array{Array{C64,4},1},\n            ai::Array{Impurity,1})\n\nWrite the self-energy functions and the corresponding frequency mesh into the dmft1/sigma.bare file, which is key input for the dynamical mean- field theory engine. The working directory of this function must be the root folder.\n\nSee also: write_sigdc.\n\n\n\n\n\n","category":"function"},{"location":"internals/sigma.html#ZenCore.write_sigdc","page":"Sigma","title":"ZenCore.write_sigdc","text":"write_sigdc(DCA::Array{Array{F64,3},1}, ai::Array{Impurity,1})\n\nWrite the double counting terms into the dmft1/sigma.dc file, which is the key input for the dynamical mean-field theory engine. The working directory of this function must be the root folder.\n\nSee also: write_sigma.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Zen","page":"Home","title":"Zen","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"A modern DFT + DMFT computation framework","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"info: Info\nThank you for using Zen. This documentation will help you to be familiar with and explore the Zen software package. It is just compatible with Zen v0.5.0-devel.250402.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"warning: Warning\nThe Zen software package is in heavy development. Please use it at your own risk. If you encounter any bugs or troubles, or require new features, please consult me directly: huangli at caep.cn","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"todo: Todo\nThis documentation is under heavy developement. So many pages could be empty.","category":"page"},{"location":"index.html#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"intro/outline.md\",\n    \"intro/sces.md\",\n    \"intro/methods.md\",\n    \"intro/about.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"start/outline.md\",\n    \"start/components.md\",\n    \"start/obtain.md\",\n    \"start/uncompress.md\",\n    \"start/directory.md\",\n    \"start/compile.md\",\n    \"start/install.md\",\n    \"start/configure.md\",\n    \"start/run.md\",\n    \"start/upgrade.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#Tutorials","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"tutor/outline.md\",\n    \"tutor/SrVO3.md\",\n    \"tutor/FeSe.md\",\n    \"tutor/MnO.md\",\n    \"tutor/Ce.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#Guide","page":"Home","title":"Guide","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"guide/outline.md\",\n    \"guide/modes.md\",\n    \"guide/recipes.md\",\n    \"guide/input.md\",\n    \"guide/output.md\",\n    \"guide/parameters.md\",\n    \"guide/core.md\",\n    \"guide/auxiliary.md\",\n    \"guide/tips.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#Internals","page":"Home","title":"Internals","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"internals/outline.md\",\n    \"internals/arch.md\",\n    \"internals/summary.md\",\n]\nDepth = 1","category":"page"},{"location":"internals/types.html#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"internals/types.html","page":"Types","title":"Types","text":"Define some dicts and structs, which are used to store the config parameters or represent some essential data structures.","category":"page"},{"location":"internals/types.html","page":"Types","title":"Types","text":"Source: types.jl","category":"page"},{"location":"internals/types.html#Contents","page":"Types","title":"Contents","text":"","category":"section"},{"location":"internals/types.html","page":"Types","title":"Types","text":"Pages = [\"types.md\"]","category":"page"},{"location":"internals/types.html#Index","page":"Types","title":"Index","text":"","category":"section"},{"location":"internals/types.html","page":"Types","title":"Types","text":"Pages = [\"types.md\"]","category":"page"},{"location":"internals/types.html#Customized-Types","page":"Types","title":"Customized Types","text":"","category":"section"},{"location":"internals/types.html","page":"Types","title":"Types","text":"ADT\nDType","category":"page"},{"location":"internals/types.html#ZenCore.ADT","page":"Types","title":"ZenCore.ADT","text":"Customized types. It is used to define the following dicts.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore.DType","page":"Types","title":"ZenCore.DType","text":"Customized types. It is used to define the following dicts.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#Global-Dicts","page":"Types","title":"Global Dicts","text":"","category":"section"},{"location":"internals/types.html","page":"Types","title":"Types","text":"PCASE\nPDFT\nPDMFT\nPIMP\nPSOLVER","category":"page"},{"location":"internals/types.html#ZenCore.PCASE","page":"Types","title":"ZenCore.PCASE","text":"PCASE\n\nDictionary for configuration parameters: case summary.\n\nSee also: PDFT, PDMFT, PIMP, PSOLVER.\n\n\n\n\n\n","category":"constant"},{"location":"internals/types.html#ZenCore.PDFT","page":"Types","title":"ZenCore.PDFT","text":"PDFT\n\nDictionary for configuration parameters: density functional theory calculations. Its entries can not be updated once they are initialized.\n\nSee also: PCASE, PDMFT, PIMP, PSOLVER.\n\n\n\n\n\n","category":"constant"},{"location":"internals/types.html#ZenCore.PDMFT","page":"Types","title":"ZenCore.PDMFT","text":"PDMFT\n\nDictionary for configuration parameters: dynamical mean-field theory calculations. Be careful, its entries (such as dcount, mixer, mc, cc, ec, sc, and lfermi) can be updated during the iteration.\n\nSee also: PCASE, PDFT, PIMP, PSOLVER.\n\n\n\n\n\n","category":"constant"},{"location":"internals/types.html#ZenCore.PIMP","page":"Types","title":"ZenCore.PIMP","text":"PIMP\n\nDictionary for configuration parameters: quantum impurity problems. Be careful, its entries (such as ising, occup, upara, jpara, and lpara) can be updated during the iteration.\n\nSee also: PCASE, PDFT, PDMFT, PSOLVER.\n\n\n\n\n\n","category":"constant"},{"location":"internals/types.html#ZenCore.PSOLVER","page":"Types","title":"ZenCore.PSOLVER","text":"PSOLVER\n\nDictionary for configuration parameters: quantum impurity solvers. Be careful, its entry (only params) can be updated during the iteration.\n\nSee also: PCASE, PDFT, PDMFT, PIMP.\n\n\n\n\n\n","category":"constant"},{"location":"internals/types.html#Customized-Structs:-DFT-Engine","page":"Types","title":"Customized Structs: DFT Engine","text":"","category":"section"},{"location":"internals/types.html","page":"Types","title":"Types","text":"AbstractEngine\nNULLEngine\nVASPEngine\nQEEngine\nWANNIEREngine\n_engine_\nnameof(::NULLEngine)","category":"page"},{"location":"internals/types.html#ZenCore.AbstractEngine","page":"Types","title":"ZenCore.AbstractEngine","text":"AbstractEngine\n\nAn abstract type representing the DFT engine. It is used to build the internal type system.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore.NULLEngine","page":"Types","title":"ZenCore.NULLEngine","text":"NULLEngine\n\nIt represents a null DFT engine. It is the default engine and will be replaced by the realistic engine.\n\nSee also: _engine_.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore.VASPEngine","page":"Types","title":"ZenCore.VASPEngine","text":"VASPEngine\n\nIt represents a vasp engine, which is used to perform DFT calculations.\n\nSee also: QEEngine.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore.QEEngine","page":"Types","title":"ZenCore.QEEngine","text":"QEEngine\n\nIt represents a quantum espresso (actually the PWSCF code) engine, which is used to perform DFT calculations.\n\nSee also: VASPEngine.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore.WANNIEREngine","page":"Types","title":"ZenCore.WANNIEREngine","text":"WANNIEREngine\n\nIt represents a wannier90 engine, which is used to generate the maximally localized wannier functions.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore._engine_","page":"Types","title":"ZenCore._engine_","text":"Set up the default density functional theory calculation engine.\n\n\n\n\n\n","category":"constant"},{"location":"internals/types.html#Base.nameof-Tuple{NULLEngine}","page":"Types","title":"Base.nameof","text":"Get name of density functional theory calculation engine.\n\n\n\n\n\n","category":"method"},{"location":"internals/types.html#Customized-Structs:-Quantum-Impurity-Solver","page":"Types","title":"Customized Structs: Quantum Impurity Solver","text":"","category":"section"},{"location":"internals/types.html","page":"Types","title":"Types","text":"AbstractSolver\nNULLSolver\nCTHYB₁Solver\nCTHYB₂Solver\nHIASolver\nNORGSolver\nATOMSolver\n_solver_\nnameof(::NULLSolver)","category":"page"},{"location":"internals/types.html#ZenCore.AbstractSolver","page":"Types","title":"ZenCore.AbstractSolver","text":"AbstractSolver\n\nAn abstract type representing the quantum impurity solver. It is used to build the internal type system.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore.NULLSolver","page":"Types","title":"ZenCore.NULLSolver","text":"NULLSolver\n\nIt represents a null quantum impurity solver. It is the default solver and will be replaced by the realistic solver.\n\nSee also: _solver_.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore.CTHYB₁Solver","page":"Types","title":"ZenCore.CTHYB₁Solver","text":"CTHYB₁Solver\n\nIt represents a quantum impurity solver based on the CTHYB₁ algorithm.\n\nSee also: CTHYB₂Solver.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore.CTHYB₂Solver","page":"Types","title":"ZenCore.CTHYB₂Solver","text":"CTHYB₂Solver\n\nIt represents a quantum impurity solver based on the CTHYB₂ algorithm.\n\nSee also: CTHYB₁Solver.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore.HIASolver","page":"Types","title":"ZenCore.HIASolver","text":"HIASolver\n\nIt represents a quantum impurity solver based on the HIA algorithm.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore.NORGSolver","page":"Types","title":"ZenCore.NORGSolver","text":"NORGSolver\n\nIt represents a quantum impurity solver based on the NORG algorithm.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore.ATOMSolver","page":"Types","title":"ZenCore.ATOMSolver","text":"ATOMSolver\n\nIt represents a solver for atomic eigenvalue problems.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore._solver_","page":"Types","title":"ZenCore._solver_","text":"Set up the default quantum impurity solver.\n\n\n\n\n\n","category":"constant"},{"location":"internals/types.html#Base.nameof-Tuple{NULLSolver}","page":"Types","title":"Base.nameof","text":"Get name of quantum impurity solver.\n\n\n\n\n\n","category":"method"},{"location":"internals/types.html#Customized-Structs:-Adaptor","page":"Types","title":"Customized Structs: Adaptor","text":"","category":"section"},{"location":"internals/types.html","page":"Types","title":"Types","text":"AbstractAdaptor\nNULLAdaptor\nPLOAdaptor\nWANNIERAdaptor\n_adaptor_\nnameof(::NULLAdaptor)","category":"page"},{"location":"internals/types.html#ZenCore.AbstractAdaptor","page":"Types","title":"ZenCore.AbstractAdaptor","text":"AbstractAdaptor\n\nAn abstract type representing the DFT-DMFT adaptor. It is used to build the internal type system.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore.NULLAdaptor","page":"Types","title":"ZenCore.NULLAdaptor","text":"NULLAdaptor\n\nIt represents a null DFT-DMFT adaptor. It is the default adaptor and will be replaced by the realistic adaptor.\n\nSee also: _adaptor_.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore.PLOAdaptor","page":"Types","title":"ZenCore.PLOAdaptor","text":"PLOAdaptor\n\nIt represents a DFT-DMFT adaptor based on the projected local orbitals.\n\nSee also: WANNIERAdaptor.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore.WANNIERAdaptor","page":"Types","title":"ZenCore.WANNIERAdaptor","text":"PLOAdaptor\n\nIt represents a DFT-DMFT adaptor based on the maximally localized wannier functions.\n\nSee also: PLOAdaptor.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore._adaptor_","page":"Types","title":"ZenCore._adaptor_","text":"Set up the default DFT-DMFT adaptor.\n\n\n\n\n\n","category":"constant"},{"location":"internals/types.html#Base.nameof-Tuple{NULLAdaptor}","page":"Types","title":"Base.nameof","text":"Get name of DFT-DMFT adaptor.\n\n\n\n\n\n","category":"method"},{"location":"internals/types.html#Customized-Structs:-Sigma-Engine","page":"Types","title":"Customized Structs: Sigma Engine","text":"","category":"section"},{"location":"internals/types.html","page":"Types","title":"Types","text":"AbstractMode\nNULLMode\nRESETMode\nDCOUNTMode\nSPLITMode\nGATHERMode\n_mode_\nnameof(::NULLMode)","category":"page"},{"location":"internals/types.html#ZenCore.AbstractMode","page":"Types","title":"ZenCore.AbstractMode","text":"AbstractMode\n\nAn abstract type representing various operations on the self-energy functions. It is used to build the internal type system.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore.NULLMode","page":"Types","title":"ZenCore.NULLMode","text":"NULLMode\n\nIt represents a null operation. It is the default operation and will be replaced by the realistic operation.\n\nSee also: _mode_.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore.RESETMode","page":"Types","title":"ZenCore.RESETMode","text":"RESETMode\n\nIt represents a reset operation for resetting the self-energy functions.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore.DCOUNTMode","page":"Types","title":"ZenCore.DCOUNTMode","text":"DCOUNTMode\n\nIt represents a dcount operation for creating the double counting terms.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore.SPLITMode","page":"Types","title":"ZenCore.SPLITMode","text":"SPLITMode\n\nIt represents a split operation for splitting the hybridization functions.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore.GATHERMode","page":"Types","title":"ZenCore.GATHERMode","text":"GATHERMode\n\nIt represents a gather operation for gathering the self-energy functions.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore._mode_","page":"Types","title":"ZenCore._mode_","text":"Set up the default operation.\n\n\n\n\n\n","category":"constant"},{"location":"internals/types.html#Base.nameof-Tuple{NULLMode}","page":"Types","title":"Base.nameof","text":"Get name of operation.\n\n\n\n\n\n","category":"method"},{"location":"internals/types.html#Customized-Structs:-Mixer-Engine","page":"Types","title":"Customized Structs: Mixer Engine","text":"","category":"section"},{"location":"internals/types.html","page":"Types","title":"Types","text":"AbstractMixer\nNULLMixer\nΣMixer\nΔMixer\nEMixer\nΓMixer\n_mixer_\nnameof(::NULLMixer)","category":"page"},{"location":"internals/types.html#ZenCore.AbstractMixer","page":"Types","title":"ZenCore.AbstractMixer","text":"AbstractMixer\n\nAn abstract type representing various mixers for self-energy functions Σ, hybridization function Δ, effective impurity level ϵ, and density matrix Γ. It is used to build the internal type system.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore.NULLMixer","page":"Types","title":"ZenCore.NULLMixer","text":"NULLMixer\n\nIt represents a null mixer. It is the default mixer and will be replaced by the realistic mixer.\n\nSee also: _mixer_.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore.ΣMixer","page":"Types","title":"ZenCore.ΣMixer","text":"ΣMixer\n\nIt represents a mixer for self-energy function Σ.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore.ΔMixer","page":"Types","title":"ZenCore.ΔMixer","text":"ΔMixer\n\nIt represents a mixer for hybridization function Δ.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore.EMixer","page":"Types","title":"ZenCore.EMixer","text":"EMixer\n\nIt represents a mixer for effective impurity level ϵ.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore.ΓMixer","page":"Types","title":"ZenCore.ΓMixer","text":"ΓMixer\n\nIt represents a mixer for density matrix Γ.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore._mixer_","page":"Types","title":"ZenCore._mixer_","text":"Set up the default mixer.\n\n\n\n\n\n","category":"constant"},{"location":"internals/types.html#Base.nameof-Tuple{NULLMixer}","page":"Types","title":"Base.nameof","text":"Get name of mixer.\n\n\n\n\n\n","category":"method"},{"location":"internals/types.html#Structs","page":"Types","title":"Structs","text":"","category":"section"},{"location":"internals/types.html","page":"Types","title":"Types","text":"Logger\nEnergy\nIterInfo\nLattice\nMapping\nImpurity\nPrTrait\nPrGroup\nPrWindow","category":"page"},{"location":"internals/types.html#ZenCore.Logger","page":"Types","title":"ZenCore.Logger","text":"Logger\n\nMutable struct. Store the IOStreams for case.log and case.cycle files.\n\nMembers\n\nlog   -> IOStream for case.log file.\ncycle -> IOStream for case.cycle file.\n\nSee also: IterInfo.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore.Energy","page":"Types","title":"ZenCore.Energy","text":"Energy\n\nMutable struct. Store decomposition of the total DFT + DMFT energy.\n\nMembers\n\ndft  -> DFT band energy.\ndmft -> DMFT interaction energy Tr(ΣG).\ncorr -> DMFT Correction to the DFT band energy.\ndc   -> Energy contributed by the double counting term.\n\nSee also: IterInfo.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore.IterInfo","page":"Types","title":"ZenCore.IterInfo","text":"IterInfo\n\nMutable struct. Record the DFT + DMFT iteration information.\n\nMembers\n\nI₁ -> Number of cycles between dmft1 and quantum impurity solver.\nI₂ -> Number of cycles between dmft2 and DFT engine.\nI₃ -> Number of DFT + DMFT iterations.\nI₄ -> Counter for all the internal cycles.\nM₁ -> Maximum allowed number of cycles (between dmft1 and solver).\nM₂ -> Maximum allowed number of cycles (between dmft2 and DFT).\nM₃ -> Maximum allowed number of DFT + DMFT iterations.\nsc -> Self-consistent mode.\nμ₀ -> Fermi level obtained by DFT engine.\nμ₁ -> Fermi level obtained by DMFT engine (dmft1).\nμ₂ -> Fermi level obtained by DMFT engine (dmft2).\ndc -> Double counting terms.\nn₁ -> Number of lattice occupancy obtained by DMFT engine (dmft1).\nn₂ -> Number of lattice occupancy obtained by DMFT engine (dmft2).\nnf -> Number of impurity occupancy obtained by quantum impurity solver.\net -> Total DFT + DMFT energy (for current iteration).\nep -> Total DFT + DMFT energy (for previous iteration).\ncc -> Convergence flag for charge density.\nce -> Convergence flag for total energy.\ncs -> Convergence flag for self-energy functions.\n\nSee also: Logger.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore.Lattice","page":"Types","title":"ZenCore.Lattice","text":"Lattice\n\nMutable struct. Contain the crystallography information. This struct is designed for the POSCAR file used by the vasp code.\n\nMembers\n\n_case -> The name of system.\nscale -> Universal scaling factor (lattice constant), which is used to          scale all lattice vectors and all atomic coordinates.\nlvect -> Three lattice vectors defining the unit cell of the system. Its          shape must be (3, 3).\nnsort -> Number of sorts of atoms.\nnatom -> Number of atoms.\nsorts -> Sorts of atoms. Its shape must be (nsort, 2).\natoms -> Lists of atoms. Its shape must be (natom).\ncoord -> Atomic positions are provided in cartesian coordinates or in          direct coordinates (respectively fractional coordinates). Its          shape must be (natom, 3).\n\nSee also: vaspio_lattice.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore.Mapping","page":"Types","title":"ZenCore.Mapping","text":"Mapping\n\nMutable struct. It denotes a mapping between quantum impurity problems and groups of projectors (or windows of Kohn-Sham states).\n\nMembers\n\ni_grp -> Mapping from quntum impurity problems to groups of projectors.\ni_wnd -> Mapping from quantum impurity problems to windows of Kohn-Sham states.\ng_imp -> Mapping from groups of projectors to quantum impurity problems.\nw_imp -> Mapping from windows of Kohn-Sham states to quantum impurity problems.\n\nSee also: Impurity, PrGroup, PrWindow.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore.Impurity","page":"Types","title":"ZenCore.Impurity","text":"Impurity\n\nMutable struct. It includes key information of quantum impurity problems.\n\nMembers\n\nindex -> Index of the quantum impurity problem.\natoms -> Chemical symbol of impurity atom.\nsites -> Index of impurity atom.\nequiv -> Equivalence of quantum impurity problem.\nshell -> Angular momentum of correlated orbitals.\nising -> Interaction type of correlated orbitals.\noccup -> Impurity occupancy 𝑛.\nnup   -> Impurity occupancy 𝑛↑ (spin up).\nndown -> Impurity occupancy 𝑛↓ (spin down).\nupara -> Coulomb interaction parameter.\njpara -> Hund's coupling parameter.\nlpara -> Spin-orbit coupling parameter.\nbeta  -> Inverse temperature.\nnband -> Number of correlated orbitals (spin is not included).\n\nSee also: Mapping, PrGroup, PrWindow.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore.PrTrait","page":"Types","title":"ZenCore.PrTrait","text":"PrTrait\n\nMutable struct. It defines a local orbital projection (a projector).\n\nMembers\n\nsite -> Site in which the projector is defined.\nl    -> Quantum number 𝑙.\nm    -> Quantum number 𝑚.\ndesc -> Projector's specification.\n\nSee also: PrGroup, PrWindow.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore.PrGroup","page":"Types","title":"ZenCore.PrGroup","text":"PrGroup\n\nMutable struct. It defines a group of projectors. There are quite a lot of local projectors. We always gather, reorganize, and split them into various groups according to their labels (such as site and 𝑙). Each group is connected with a quantum impurity problem.\n\nMembers\n\nsite   -> Site in which the projectors are defined. In principle, the           projectors included in the same group should be defined at           the same site (or equivalently atom).\nl      -> Quantum number 𝑙. In principle, the projectors included in           the same group should have the same quantum number 𝑙 (but           with different 𝑚).\ncorr   -> Test if the projectors in this group are correlated.\nshell  -> Type of correlated orbitals. It is infered from quantum number 𝑙.\nPr     -> Array. It contains the indices of projectors.\nTr     -> Array. It contains the transformation matrix. This parameter           could be useful to select certain subset of orbitals or perform           a simple global rotation.\n\nSee also: PrTrait, PrWindow, Mapping, Impurity.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#ZenCore.PrWindow","page":"Types","title":"ZenCore.PrWindow","text":"PrWindow\n\nMutable struct. It defines a window for the Kohn-Sham states (DFT bands). Each window is connected with a quantum impurity problem.\n\nMembers\n\nbmin -> Minimum band index.\nbmax -> Maximum band index.\nnbnd -> Maximum number of bands in the current window (≡ bmax - bmin + 1).\nkwin -> Momentum-dependent and spin-dependent band window.\nbwin -> Tuple. It is the band window or energy window, which is used         to filter the Kohn-Sham states (i.e DFT bands). The mesh for         calculating density of states is also deduced from bwin.\n\nSee also: PrTrait, PrGroup, Mapping, Impurity.\n\n\n\n\n\n","category":"type"},{"location":"internals/types.html#Constructors","page":"Types","title":"Constructors","text":"","category":"section"},{"location":"internals/types.html","page":"Types","title":"Types","text":"Logger()\nEnergy()\nIterInfo()\nLattice(::String, ::F64, ::I64, ::I64)\nMapping(::I64, ::I64, ::I64)\nImpurity(::I64, ::String, ::I64, ::I64, ::String, ::String, ::F64, ::F64, ::F64, ::F64, ::F64)\nPrTrait(::I64, ::String)\nPrGroup(::I64, ::I64)\nPrWindow(::Array{I64,3}, ::Tuple{R64,R64})","category":"page"},{"location":"internals/types.html#ZenCore.Logger-Tuple{}","page":"Types","title":"ZenCore.Logger","text":"Logger(case::String = \"case\")\n\nOuter constructor for Logger struct.\n\n\n\n\n\n","category":"method"},{"location":"internals/types.html#ZenCore.Energy-Tuple{}","page":"Types","title":"ZenCore.Energy","text":"Energy()\n\nOuter constructor for Energy struct.\n\n\n\n\n\n","category":"method"},{"location":"internals/types.html#ZenCore.IterInfo-Tuple{}","page":"Types","title":"ZenCore.IterInfo","text":"IterInfo()\n\nOuter constructor for IterInfo struct.\n\n\n\n\n\n","category":"method"},{"location":"internals/types.html#ZenCore.Lattice-Tuple{String, Float64, Int64, Int64}","page":"Types","title":"ZenCore.Lattice","text":"Lattice(_case::String, scale::F64, nsort::I64, natom::I64)\n\nOuter constructor for Lattice struct.\n\n\n\n\n\n","category":"method"},{"location":"internals/types.html#ZenCore.Mapping-Tuple{Int64, Int64, Int64}","page":"Types","title":"ZenCore.Mapping","text":"Mapping(nsite::I64, ngrp::I64, nwnd::I64)\n\nOuter constructor for Mapping struct.\n\n\n\n\n\n","category":"method"},{"location":"internals/types.html#ZenCore.Impurity-Tuple{Int64, String, Int64, Int64, String, String, Vararg{Float64, 5}}","page":"Types","title":"ZenCore.Impurity","text":"Impurity(index::I64, atoms::String, sites::I64,\n         equiv::I64, shell::String, ising::String,\n         occup::F64, upara::F64, jpara::F64, lpara::F64,\n         beta::F64)\n\nOuter constructor for Impurity struct.\n\n\n\n\n\n","category":"method"},{"location":"internals/types.html#ZenCore.PrTrait-Tuple{Int64, String}","page":"Types","title":"ZenCore.PrTrait","text":"PrTrait(site::I64, desc::String)\n\nOuter constructor for PrTrait struct.\n\n\n\n\n\n","category":"method"},{"location":"internals/types.html#ZenCore.PrGroup-Tuple{Int64, Int64}","page":"Types","title":"ZenCore.PrGroup","text":"PrGroup(site::I64, l::I64)\n\nOuter constructor for PrGroup struct.\n\n\n\n\n\n","category":"method"},{"location":"internals/types.html#ZenCore.PrWindow-Tuple{Array{Int64, 3}, Tuple{Union{Float64, Int64}, Union{Float64, Int64}}}","page":"Types","title":"ZenCore.PrWindow","text":"PrWindow(kwin::Array{I64,3}, bwin::Tuple{R64,R64})\n\nOuter constructor for PrWindow struct.\n\n\n\n\n\n","category":"method"},{"location":"internals/types.html#Operators","page":"Types","title":"Operators","text":"","category":"section"},{"location":"internals/types.html","page":"Types","title":"Types","text":"==","category":"page"},{"location":"internals/types.html#Base.:==","page":"Types","title":"Base.:==","text":"==(PT₁::PrTrait, PT₂::PrTrait)\n\nCompare two PrTrait objects.\n\nSee also: PrTrait.\n\n\n\n\n\n==(PG₁::PrGroup, PG₂::PrGroup)\n\nCompare two PrGroup objects.\n\nSee also: PrGroup.\n\n\n\n\n\n==(PW₁::PrWindow, PW₂::PrWindow)\n\nCompare two PrWindow objects.\n\nSee also: PrWindow.\n\n\n\n\n\n","category":"function"},{"location":"internals/types.html#Traits","page":"Types","title":"Traits","text":"","category":"section"},{"location":"internals/types.html","page":"Types","title":"Types","text":"show(io::IO, logger::Logger)\nshow(io::IO, ene::Energy)\nshow(io::IO, it::IterInfo)\nshow(io::IO, latt::Lattice)\nshow(io::IO, map::Mapping)\nshow(io::IO, imp::Impurity)\nshow(io::IO, PT::PrTrait)\nshow(io::IO, PG::PrGroup)\nshow(io::IO, PW::PrWindow)\ngetproperty(et::Energy, sym::Symbol)","category":"page"},{"location":"internals/types.html#Base.show-Tuple{IO, Logger}","page":"Types","title":"Base.show","text":"Base.show(io::IO, it::IterInfo)\n\nBase.show() function for Logger struct.\n\nSee also: Logger.\n\n\n\n\n\n","category":"method"},{"location":"internals/types.html#Base.show-Tuple{IO, Energy}","page":"Types","title":"Base.show","text":"Base.show(io::IO, ene::Energy)\n\nBase.show() function for Energy struct. Note that total is not a real field of the Energy struct.\n\nSee also: Energy.\n\n\n\n\n\n","category":"method"},{"location":"internals/types.html#Base.show-Tuple{IO, IterInfo}","page":"Types","title":"Base.show","text":"Base.show(io::IO, it::IterInfo)\n\nBase.show() function for IterInfo struct.\n\nSee also: IterInfo.\n\n\n\n\n\n","category":"method"},{"location":"internals/types.html#Base.show-Tuple{IO, Lattice}","page":"Types","title":"Base.show","text":"Base.show(io::IO, latt::Lattice)\n\nBase.show() function for Lattice struct.\n\nSee also: Lattice.\n\n\n\n\n\n","category":"method"},{"location":"internals/types.html#Base.show-Tuple{IO, Mapping}","page":"Types","title":"Base.show","text":"Base.show(io::IO, map::Mapping)\n\nBase.show() function for Mapping struct.\n\nSee also: Mapping.\n\n\n\n\n\n","category":"method"},{"location":"internals/types.html#Base.show-Tuple{IO, Impurity}","page":"Types","title":"Base.show","text":"Base.show(io::IO, imp::Impurity)\n\nBase.show() function for Impurity struct.\n\nSee also: Impurity.\n\n\n\n\n\n","category":"method"},{"location":"internals/types.html#Base.show-Tuple{IO, PrTrait}","page":"Types","title":"Base.show","text":"Base.show(io::IO, PT::PrTrait)\n\nBase.show() function for PrTrait struct.\n\nSee also: PrTrait.\n\n\n\n\n\n","category":"method"},{"location":"internals/types.html#Base.show-Tuple{IO, PrGroup}","page":"Types","title":"Base.show","text":"Base.show(io::IO, PG::PrGroup)\n\nBase.show() function for PrGroup struct.\n\nSee also: PrGroup.\n\n\n\n\n\n","category":"method"},{"location":"internals/types.html#Base.show-Tuple{IO, PrWindow}","page":"Types","title":"Base.show","text":"Base.show(io::IO, PW::PrWindow)\n\nBase.show() function for PrWindow struct.\n\nSee also: PrWindow.\n\n\n\n\n\n","category":"method"},{"location":"internals/types.html#Base.getproperty-Tuple{Energy, Symbol}","page":"Types","title":"Base.getproperty","text":"Base.getproperty(et::Energy, sym::Symbol)\n\nImplement the calculation of total DFT + DMFT energy. The Energy struct does not really contains the total field. This function will implement et.total by overriding the Base.getproperty() function.\n\nSee also: Energy.\n\n\n\n\n\n","category":"method"},{"location":"intro/dft_dmft.html#The-DFT-DMFT-Method","page":"The DFT + DMFT Method","title":"The DFT + DMFT Method","text":"","category":"section"},{"location":"start/configure.html#Configure","page":"Configure","title":"Configure","text":"","category":"section"},{"location":"tutor/Ce.html#Ce:-f-Electron-Metal","page":"Ce: f-Electron Metal","title":"Ce: f-Electron Metal","text":"","category":"section"},{"location":"tutor/SrVO3.html#SrVO_{3}:-Strongly-Correlated-Metal","page":"SrVO_3: Strongly Correlated Metal","title":"SrVO_3: Strongly Correlated Metal","text":"","category":"section"},{"location":"guide/apawlib.html#Projector-Augmented-Wave-Datasets","page":"Projector Augmented Wave Datasets","title":"Projector Augmented Wave Datasets","text":"","category":"section"},{"location":"internals/mixing.html#Mixing","page":"Mixing","title":"Mixing","text":"","category":"section"},{"location":"internals/mixing.html","page":"Mixing","title":"Mixing","text":"Tools for mixing the self-energy functions Sigma, hybridization functions Delta, and local impurity levels epsilon_i. They adopted the linear mixing algorithm. We also implement the so-called Kerker algorithm to mix the correlation-induced correction for density matrix Gamma.","category":"page"},{"location":"internals/mixing.html","page":"Mixing","title":"Mixing","text":"Source: mixer.jl","category":"page"},{"location":"internals/mixing.html#Contents","page":"Mixing","title":"Contents","text":"","category":"section"},{"location":"internals/mixing.html","page":"Mixing","title":"Mixing","text":"Pages = [\"mixer.md\"]","category":"page"},{"location":"internals/mixing.html#Index","page":"Mixing","title":"Index","text":"","category":"section"},{"location":"internals/mixing.html","page":"Mixing","title":"Mixing","text":"Pages = [\"mixer.md\"]","category":"page"},{"location":"internals/mixing.html#Functions","page":"Mixing","title":"Functions","text":"","category":"section"},{"location":"internals/mixing.html","page":"Mixing","title":"Mixing","text":"mixer_call\nmixer_sigma\nmixer_delta\nmixer_eimpx\nmixer_gcorr\namix\ndistance","category":"page"},{"location":"internals/mixing.html#ZenCore.mixer_call","page":"Mixing","title":"ZenCore.mixer_call","text":"mixer_call(::NULLMixer, it::IterInfo, ai::Array{Impurity,1})\nmixer_call(::ΣMixer, it::IterInfo, ai::Array{Impurity,1})\nmixer_call(::ΔMixer, it::IterInfo, ai::Array{Impurity,1})\nmixer_call(::EMixer, it::IterInfo, ai::Array{Impurity,1})\nmixer_call(::ΓMixer, it::IterInfo, ai::Array{Impurity,1})\n\nTry to mix various functions during the iterations, including self-energy functions Σ, hybridization functions Δ, effective impurity levels E, and correction for density matrix Γ. It acts as a dispatcher.\n\nSee also: _mixer_.\n\n\n\n\n\n","category":"function"},{"location":"internals/mixing.html#ZenCore.mixer_sigma","page":"Mixing","title":"ZenCore.mixer_sigma","text":"mixer_sigma(it::IterInfo, ai::Array{Impurity,1})\n\nTry to mix the self-energy functions Σ and then use the mixed values to update the dmft1/sigma.bare file.\n\nSee also: mixer_core, amix, distance.\n\n\n\n\n\n","category":"function"},{"location":"internals/mixing.html#ZenCore.mixer_delta","page":"Mixing","title":"ZenCore.mixer_delta","text":"mixer_delta(it::IterInfo, ai::Array{Impurity,1})\n\nTry to mix the hybridization functions Δ and then use the mixed values to update the dmft1/dmft.delta file.\n\nSee also: mixer_core, amix.\n\n\n\n\n\n","category":"function"},{"location":"internals/mixing.html#ZenCore.mixer_eimpx","page":"Mixing","title":"ZenCore.mixer_eimpx","text":"mixer_eimpx(it::IterInfo, ai::Array{Impurity,1})\n\nTry to mix the local impurity levels εᵢ and then use the mixed value to update the dmft1/dmft.eimpx file.\n\nSee also: mixer_core, amix.\n\n\n\n\n\n","category":"function"},{"location":"internals/mixing.html#ZenCore.mixer_gcorr","page":"Mixing","title":"ZenCore.mixer_gcorr","text":"mixer_gcorr(it::IterInfo)\n\nTry to mix the correction for density matrix Γ and then use the mixed value to update the dmft2/dmft.gcorr file. Here we use the Kerker algorithm, instead of the linear mixing algorithm.\n\nSee also: mixer_core, distance.\n\n\n\n\n\n","category":"function"},{"location":"internals/mixing.html#ZenCore.amix","page":"Mixing","title":"ZenCore.amix","text":"amix(it::IterInfo)\n\nReturn the mixing factor for mixer component. It should depend on the current iteration number, instead of being a constant.\n\nSee also: IterInfo.\n\n\n\n\n\n","category":"function"},{"location":"internals/mixing.html#ZenCore.distance","page":"Mixing","title":"ZenCore.distance","text":"distance(SA::Vector{Array{C64,4}}, SB::Vector{Array{C64,4}})\n\nCalculate the difference between two multi-dimensional arrays. Usually We apply this function to calculate the difference between two self-energy functions.\n\nSee also: mixer_sigma.\n\n\n\n\n\ndistance(GA::Array{C64,4}, GB::Array{C64,4})\n\nCalculate the difference between two multi-dimensional arrays. Usually We apply this function to calculate the difference between two corrections for density matrix.\n\nSee also: mixer_gcorr.\n\n\n\n\n\n","category":"function"},{"location":"start/run.html#The-First-Run","page":"The First Run","title":"The First Run","text":"","category":"section"},{"location":"start/upgrade.html#Upgrade","page":"Upgrade","title":"Upgrade","text":"","category":"section"},{"location":"internals/zencore.html#ZenCore","page":"ZenCore","title":"ZenCore","text":"","category":"section"},{"location":"internals/zencore.html","page":"ZenCore","title":"ZenCore","text":"Declare the module and public members.","category":"page"},{"location":"internals/zencore.html","page":"ZenCore","title":"ZenCore","text":"Source: ZenCore.jl","category":"page"},{"location":"internals/zencore.html#Contents","page":"ZenCore","title":"Contents","text":"","category":"section"},{"location":"internals/zencore.html","page":"ZenCore","title":"ZenCore","text":"Pages = [\"zencore.md\"]","category":"page"},{"location":"internals/zencore.html#Index","page":"ZenCore","title":"Index","text":"","category":"section"},{"location":"internals/zencore.html","page":"ZenCore","title":"ZenCore","text":"Pages = [\"zencore.md\"]","category":"page"},{"location":"internals/zencore.html#Modules","page":"ZenCore","title":"Modules","text":"","category":"section"},{"location":"internals/zencore.html","page":"ZenCore","title":"ZenCore","text":"ZenCore","category":"page"},{"location":"internals/zencore.html#ZenCore","page":"ZenCore","title":"ZenCore","text":"Zen and ZenCore\n\nZen is a modern DFT + DMFT computation framework. It can be used to study the correlated electronic structures of a wide range of strongly correlated materials. Now this framework is under heavy development. PLEASE USE IT AT YOUR OWN RISK.\n\nZen supports the following DFT backends:\n\nVASP\nQUANTUM ESPRESSO (Actually only the PWSCF code)\n\nZen supports the following schemes for defining local orbitals:\n\nPLO\nWANNIER (Need support from the wannier90 code)\n\nZen supports the following quantum impurity solvers:\n\nCTHYB\nHIA (Unavailable)\nNORG (Experimental)\n\nZen consists of several components, including:\n\nZenCore (Core library)\nZenApps (Major applications)\nZenTools (Auxiliary tools and plugins)\nDyson (A density functional theory + dynamical mean-field theory engine)\niQIST (An interacting quantum impurity solver toolkit)\nFlink (A reusable fortran numerical library)\nACFlow (A modern toolkit for analytical continuation problems)\n\nZenCore implements the core library of the Zen DFT + DMFT computation framework. It connects various components of Zen, and drive them to work together. It provides an easy-to-use, flexible, efficient, and robust user interface (UI) and application programming interface (API).\n\nFor more details about how to obtain, install and use the Zen framework and the ZenCore library, please visit the following website:\n\nhttps://huangli712.github.io/projects/zen/index.html\n\nAny suggestions, comments, and feedbacks are welcome. Enjoy it!\n\n\n\n\n\n","category":"module"},{"location":"internals/zencore.html#Functions","page":"ZenCore","title":"Functions","text":"","category":"section"},{"location":"internals/zencore.html","page":"ZenCore","title":"ZenCore","text":"_precompile\nZenCore.__init__","category":"page"},{"location":"internals/zencore.html#ZenCore._precompile","page":"ZenCore","title":"ZenCore._precompile","text":"_precompile()\n\nHere, we would like to precompile the whole ZenCore package to reduce the runtime latency and speed up the successive calculations.\n\n\n\n\n\n","category":"function"},{"location":"internals/zencore.html#ZenCore.__init__","page":"ZenCore","title":"ZenCore.__init__","text":"__init__()\n\nThis function would be executed immediately after the module is loaded at runtime for the first time. It works at the REPL mode only.\n\n\n\n\n\n","category":"function"},{"location":"start/install.html#Install","page":"Install","title":"Install","text":"","category":"section"},{"location":"intro/support.html#Technical-Support","page":"Technical Support","title":"Technical Support","text":"","category":"section"},{"location":"intro/support.html","page":"Technical Support","title":"Technical Support","text":"If you meet troubles or bugs when using the Zen computation framework, or request new features, please consult the developer team:","category":"page"},{"location":"intro/support.html","page":"Technical Support","title":"Technical Support","text":"info: Info\nLi HuangInstitute: Institute of Materials, China Academy of Engineering PhysicsAddress: Sichuan, Jiangyou 621907, PRCEmail: huangli at caep.cn","category":"page"},{"location":"guide/tools.html#Auxiliary-Tools","page":"Auxiliary Tools","title":"Auxiliary Tools","text":"","category":"section"},{"location":"guide/input.html#Input-Files","page":"Summary","title":"Input Files","text":"","category":"section"},{"location":"internals/arch.html#Software-Architecture","page":"Software Architecture","title":"Software Architecture","text":"","category":"section"},{"location":"internals/ir.html#Intermediate-Representation","page":"IR","title":"Intermediate Representation","text":"","category":"section"},{"location":"internals/ir.html","page":"IR","title":"IR","text":"Tools for the intermediate representation format (adaptor).","category":"page"},{"location":"internals/ir.html","page":"IR","title":"IR","text":"Source: ir.jl","category":"page"},{"location":"internals/ir.html#Contents","page":"IR","title":"Contents","text":"","category":"section"},{"location":"internals/ir.html","page":"IR","title":"IR","text":"Pages = [\"ir.md\"]","category":"page"},{"location":"internals/ir.html#Index","page":"IR","title":"Index","text":"","category":"section"},{"location":"internals/ir.html","page":"IR","title":"IR","text":"Pages = [\"ir.md\"]","category":"page"},{"location":"internals/ir.html#Functions","page":"IR","title":"Functions","text":"","category":"section"},{"location":"internals/ir.html","page":"IR","title":"IR","text":"ir_adaptor\nir_read\nir_save\nirio_params\nirio_maps\nirio_groups\nirio_windows\nirio_lattice\nirio_kmesh\nirio_tetra\nirio_eigen\nirio_projs\nirio_fermi\nirio_charge\nirio_rawcp","category":"page"},{"location":"internals/ir.html#ZenCore.ir_adaptor","page":"IR","title":"ZenCore.ir_adaptor","text":"ir_adaptor(D::Dict{Symbol,Any})\n\nWrite the Kohn-Sham dataset to specified files using the IR format. Note that the Kohn-Sham dataset are encapsulated in the D dict.\n\nSee also: plo_adaptor, wannier_adaptor.\n\n\n\n\n\n","category":"function"},{"location":"internals/ir.html#ZenCore.ir_read","page":"IR","title":"ZenCore.ir_read","text":"ir_read(f::String)\n\nRead and parse maps.ir, groups.ir, windows.ir, lattice.ir, kmesh.ir, eigen.ir, projs.ir, fermi.ir, and rawcp.ir. The data are encapsulated in a dictionary. Here f means the directory where the files as mentioned above are available.\n\nSee also: ir_adaptor.\n\n\n\n\n\n","category":"function"},{"location":"internals/ir.html#ZenCore.ir_save","page":"IR","title":"ZenCore.ir_save","text":"ir_save(it::IterInfo)\n\nBackup the files outputed by the adaptor.\n\nSee also: ir_adaptor.\n\n\n\n\n\n","category":"function"},{"location":"internals/ir.html#ZenCore.irio_params","page":"IR","title":"ZenCore.irio_params","text":"irio_params(f::String, D::Dict{Symbol,Any})\n\nWrite the key parameters extracted from the Kohn-Sham dataset. Here f means only the directory that we want to use.\n\nSee also: PrGroup, PrWindow.\n\n\n\n\n\n","category":"function"},{"location":"internals/ir.html#ZenCore.irio_maps","page":"IR","title":"ZenCore.irio_maps","text":"irio_maps(f::String, MAP::Mapping)\n\nWrite the information contained in Mapping struct. Here f means only the directory that we want to use.\n\nSee also: Mapping.\n\n\n\n\n\nirio_maps(f::String)\n\nExtract the Mapping struct from maps.ir. Here f means the directory that this file exists.\n\nSee also: Mapping.\n\n\n\n\n\n","category":"function"},{"location":"internals/ir.html#ZenCore.irio_groups","page":"IR","title":"ZenCore.irio_groups","text":"irio_groups(f::String, PG::Array{PrGroup,1})\n\nWrite the information contained in PrGroup struct. Here f means only the directory that we want to use.\n\nSee also: PrGroup.\n\n\n\n\n\nirio_groups(f::String)\n\nExtract the PrGroup struct from groups.ir. Here f means the directory that this file exists. Be careful, the returned PrGroup is not completely the same with the true one. For example, its Pr and Tr fields are not correct. But it doesn't matter.\n\nSee also: PrGroup.\n\n\n\n\n\n","category":"function"},{"location":"internals/ir.html#ZenCore.irio_windows","page":"IR","title":"ZenCore.irio_windows","text":"irio_windows(f::String, PW::Array{PrWindow,1})\n\nWrite the information contained in PrWindow struct. Here f means only the directory that we want to use.\n\nSee also: PrWindow.\n\n\n\n\n\nirio_windows(f::String)\n\nExtract the PrWindow struct from windows.ir. Here f means the directory that this file exists.\n\nSee also: PrWindow.\n\n\n\n\n\n","category":"function"},{"location":"internals/ir.html#ZenCore.irio_lattice","page":"IR","title":"ZenCore.irio_lattice","text":"irio_lattice(f::String, latt::Lattice)\n\nWrite the lattice information to lattice.ir using the IR format. Here f means only the directory that we want to use.\n\nSee also: vaspio_lattice, qeio_lattice.\n\n\n\n\n\nirio_lattice(f::String)\n\nExtract the lattice information from lattice.ir. Here f means the directory that this file exists.\n\nSee also: Lattice.\n\n\n\n\n\n","category":"function"},{"location":"internals/ir.html#ZenCore.irio_kmesh","page":"IR","title":"ZenCore.irio_kmesh","text":"irio_kmesh(f::String, kmesh::Array{F64,2}, weight::Array{F64,1})\n\nWrite the kmesh and weight information to kmesh.ir using the IR format. Here f means only the directory that we want to use.\n\nSee also: vaspio_kmesh.\n\n\n\n\n\nirio_kmesh(f::String)\n\nExtract the kmesh and weight information from kmesh.ir. Here f means the directory that this file exists.\n\n\n\n\n\n","category":"function"},{"location":"internals/ir.html#ZenCore.irio_tetra","page":"IR","title":"ZenCore.irio_tetra","text":"irio_tetra(f::String, volt::F64, itet::Array{I64,2})\n\nWrite the tetrahedra information to tetra.ir using the IR format. Here f means only the directory that we want to use.\n\nSee also: vaspio_tetra.\n\n\n\n\n\nirio_tetra(f::String)\n\nExtract the tetrahedra information from tetra.ir. Here f means the directory that this file exists.\n\n\n\n\n\n","category":"function"},{"location":"internals/ir.html#ZenCore.irio_eigen","page":"IR","title":"ZenCore.irio_eigen","text":"irio_eigen(f::String, enk::Array{F64,3}, occupy::Array{F64,3})\n\nWrite the eigenvalues to eigen.ir using the IR format. Here f means only the directory that we want to use.\n\nSee also: vaspio_eigen, qeio_eigen.\n\n\n\n\n\nirio_eigen(f::String)\n\nExtract the eigenvalues from eigen.ir. Here f means the directory that this file exists.\n\n\n\n\n\n","category":"function"},{"location":"internals/ir.html#ZenCore.irio_projs","page":"IR","title":"ZenCore.irio_projs","text":"irio_projs(f::String, chipsi::Array{Array{C64,4},1})\n\nWrite the projectors to projs.ir using the IR format. Here f means only the directory that we want to use.\n\nThe projectors have been processed to fulfill the requirement of the DMFT engine.\n\nSee also: vaspio_projs.\n\n\n\n\n\nirio_projs(f::String)\n\nExtract the normalized projectors from projs.ir. Here f means the directory that this file exists.\n\n\n\n\n\n","category":"function"},{"location":"internals/ir.html#ZenCore.irio_fermi","page":"IR","title":"ZenCore.irio_fermi","text":"irio_fermi(f::String, fermi::F64)\n\nWrite the fermi level to fermi.ir using the IR format. Here f means only the directory that we want to use.\n\nSee also: vaspio_fermi, qeio_fermi.\n\n\n\n\n\nirio_fermi(f::String)\n\nExtract the fermi level from fermi.ir. Here f means the directory that this file exists.\n\n\n\n\n\n","category":"function"},{"location":"internals/ir.html#ZenCore.irio_charge","page":"IR","title":"ZenCore.irio_charge","text":"irio_charge(f::String)\n\nWrite the charge density to charge.ir using the IR format. Here f means only the directory that we want to use.\n\nSee also: vaspio_charge.\n\n\n\n\n\n","category":"function"},{"location":"internals/ir.html#ZenCore.irio_rawcp","page":"IR","title":"ZenCore.irio_rawcp","text":"irio_rawcp(f::String, chipsi::Array{C64,4})\n\nWrite the projectors to rawcp.ir using the IR format. Here f means only the directory that we want to use.\n\nThe projectors are original data. They have not been modified.\n\nSee also: irio_projs.\n\n\n\n\n\nirio_rawcp(f::String)\n\nExtract the raw projectors from rawcp.ir. Here f means the directory that this file exists.\n\n\n\n\n\n","category":"function"},{"location":"intro/features.html#Features","page":"Features","title":"Features","text":"","category":"section"},{"location":"guide/recipes.html#Detailed-Recipes","page":"Summary","title":"Detailed Recipes","text":"","category":"section"},{"location":"intro/dmft.html#Dynamical-Mean-Field-Theory","page":"Dynamical Mean-Field Theory","title":"Dynamical Mean-Field Theory","text":"","category":"section"},{"location":"internals/util.html#Utility","page":"Util","title":"Utility","text":"","category":"section"},{"location":"internals/util.html","page":"Util","title":"Util","text":"To provide some useful utility macros and functions. They can be used to colorize the output strings, query the environments, and parse the input strings, etc.","category":"page"},{"location":"internals/util.html","page":"Util","title":"Util","text":"Source: util.jl","category":"page"},{"location":"internals/util.html#Contents","page":"Util","title":"Contents","text":"","category":"section"},{"location":"internals/util.html","page":"Util","title":"Util","text":"Pages = [\"util.md\"]","category":"page"},{"location":"internals/util.html#Index","page":"Util","title":"Index","text":"","category":"section"},{"location":"internals/util.html","page":"Util","title":"Util","text":"Pages = [\"util.md\"]","category":"page"},{"location":"internals/util.html#Macros","page":"Util","title":"Macros","text":"","category":"section"},{"location":"internals/util.html","page":"Util","title":"Util","text":"@cswitch\n@time_call\n@pcs","category":"page"},{"location":"internals/util.html#ZenCore.@cswitch","page":"Util","title":"ZenCore.@cswitch","text":"@cswitch(constexpr, body)\n\nProvides a C-like switch statement with the falling through behavior. This implementation was borrowed from the following github repository:\n\nhttps://github.com/Gnimuc/CSyntax.jl\n\nExamples\n\nengine = get_d(\"engine\")\n@cswitch engine begin\n    @case \"vasp\"\n        just_do_it()\n        break\n\n    @default\n        sorry()\n        break\nend\n\n\n\n\n\n","category":"macro"},{"location":"internals/util.html#ZenCore.@time_call","page":"Util","title":"ZenCore.@time_call","text":"@time_call(ex)\n\nEvaluate a function call (ex), and then print the elapsed time (number of seconds) it took to execute.\n\nThis macro is a variation of the standard @elapsed macro.\n\n\n\n\n\n","category":"macro"},{"location":"internals/util.html#ZenCore.@pcs","page":"Util","title":"ZenCore.@pcs","text":"@pcs(x...)\n\nTry to print colorful strings. Here x is a combination of strings and colors. Its format likes string1 color1 string2 color2 (repeat). For the supported colors, please check the global dict COLORS.\n\nExamples\n\njulia> @pcs \"Hello world!\" blue\njulia> @pcs \"Hello \" red \"world!\" green\n\nSee also: COLORS, welcome.\n\n\n\n\n\n","category":"macro"},{"location":"internals/util.html#Global-dicts","page":"Util","title":"Global dicts","text":"","category":"section"},{"location":"internals/util.html","page":"Util","title":"Util","text":"COLORS\nMODES","category":"page"},{"location":"internals/util.html#ZenCore.COLORS","page":"Util","title":"ZenCore.COLORS","text":"COLORS\n\nA global dict, which is used to specify the system colors.\n\n\n\n\n\n","category":"constant"},{"location":"internals/util.html#ZenCore.MODES","page":"Util","title":"ZenCore.MODES","text":"MODES\n\nA global dict, which is used to specify the mode for output characters.\n\n\n\n\n\n","category":"constant"},{"location":"internals/util.html#Functions","page":"Util","title":"Functions","text":"","category":"section"},{"location":"internals/util.html","page":"Util","title":"Util","text":"require\nsetup_args\nquery_args\nquery_case\nquery_inps\nquery_stop\nquery_test\nquery_home\nquery_core\nquery_dft\nquery_dmft\nquery_solver\nis_vasp\nis_qe\nis_plo\nis_wannier\nwelcome\noverview\ngoodbye\nsorry\nprompt\nline_to_array\nline_to_cmplx\nerf\nsubscript\nstr_to_struct\ncolorize","category":"page"},{"location":"internals/util.html#ZenCore.require","page":"Util","title":"ZenCore.require","text":"require()\n\nCheck the version of julia runtime environment. It should be higher than v1.6.x. One of the most important philosophies of the ZenCore package is minimizing the dependence on the third-party libraries as far as possible. Note that the ZenCore package relys on the TOML package to parse the *.toml file. Only in v1.6.0 and higher versions, julia includes the TOML package in its standard library.\n\n\n\n\n\n","category":"function"},{"location":"internals/util.html#ZenCore.setup_args","page":"Util","title":"ZenCore.setup_args","text":"setup_args(x::Vararg{String})\n\nSetup ARGS manually. This function is used only in REPL environment. We can use this function to update ARGS, so that the query_args() and the other related functions can work correctly.\n\nExamples\n\njulia> setup_args(\"SrVO3.toml\")\n1-element Array{String,1}:\n \"SrVO3.toml\"\n\nSee also: query_args.\n\n\n\n\n\n","category":"function"},{"location":"internals/util.html#ZenCore.query_args","page":"Util","title":"ZenCore.query_args","text":"query_args()\n\nCheck whether the configuration file (case.toml) is provided.\n\nSee also: setup_args.\n\n\n\n\n\n","category":"function"},{"location":"internals/util.html#ZenCore.query_case","page":"Util","title":"ZenCore.query_case","text":"query_case()\n\nReturn case, in other words, the job's name.\n\nSee also: query_stop.\n\n\n\n\n\n","category":"function"},{"location":"internals/util.html#ZenCore.query_inps","page":"Util","title":"ZenCore.query_inps","text":"query_inps(::NULLEngine)\nquery_inps(::VASPEngine)\nquery_inps(::QEEngine)\nquery_inps(::WANNIEREngine)\n\nCheck whether the essential input files exist. It acts as a dispatcher. This function is designed for the DFT engine only. The input files for the DMFT engine, quantum impurity solver, and Kohn-Sham adaptor will be generated automatically by default. The ZenCore package will take care of them. Do not worry about that.\n\nSee also: query_case.\n\n\n\n\n\n","category":"function"},{"location":"internals/util.html#ZenCore.query_stop","page":"Util","title":"ZenCore.query_stop","text":"query_stop()\n\nQuery whether the case.stop file exists.\n\nSee also: query_case.\n\n\n\n\n\n","category":"function"},{"location":"internals/util.html#ZenCore.query_test","page":"Util","title":"ZenCore.query_test","text":"query_test()\n\nQuery whether the case.test file exists.\n\nSee also: query_case.\n\n\n\n\n\n","category":"function"},{"location":"internals/util.html#ZenCore.query_home","page":"Util","title":"ZenCore.query_home","text":"query_home()\n\nQuery the home directory of Zen. Actually, the ZEN_HOME means the directory that the Zen Framework is installed.\n\nSee also: query_core.\n\n\n\n\n\n","category":"function"},{"location":"internals/util.html#ZenCore.query_core","page":"Util","title":"ZenCore.query_core","text":"query_core()\n\nQuery the src/core directory of Zen. Actually, the ZEN_CORE denotes the directory that contains the ZenCore.jl file. Be careful, ZEN_CORE must be included in LOAD_PATH.\n\nSee also: query_home.\n\n\n\n\n\n","category":"function"},{"location":"internals/util.html#ZenCore.query_dft","page":"Util","title":"ZenCore.query_dft","text":"query_dft(ae::AbstractEngine)\n\nQuery the home directory of the chosen DFT backend. It supports vasp, quantum espresso, and wannier90 by now.\n\nSee also: query_dmft, query_solver.\n\n\n\n\n\n","category":"function"},{"location":"internals/util.html#ZenCore.query_dmft","page":"Util","title":"ZenCore.query_dmft","text":"query_dmft()\n\nQuery the home directory of the DMFT engine.\n\nSee also: query_dft, query_solver.\n\n\n\n\n\n","category":"function"},{"location":"internals/util.html#ZenCore.query_solver","page":"Util","title":"ZenCore.query_solver","text":"query_solver(as::AbstractSolver)\n\nQuery the home directories of various quantum impurity solvers. Now it supports CTHYB₁, CTHYB₂, HIA, and NORG.\n\nSee also: query_dft, query_dmft.\n\n\n\n\n\n","category":"function"},{"location":"internals/util.html#ZenCore.is_vasp","page":"Util","title":"ZenCore.is_vasp","text":"is_vasp()\n\nTest whether the DFT backend is the vasp code.\n\nSee also: is_qe.\n\n\n\n\n\n","category":"function"},{"location":"internals/util.html#ZenCore.is_qe","page":"Util","title":"ZenCore.is_qe","text":"is_qe()\n\nTest whether the DFT backend is the quantum espresso (pwscf) code.\n\nSee also: is_vasp.\n\n\n\n\n\n","category":"function"},{"location":"internals/util.html#ZenCore.is_plo","page":"Util","title":"ZenCore.is_plo","text":"is_plo()\n\nTest whether the projector is the projected local orbitals.\n\nSee also: is_wannier.\n\n\n\n\n\n","category":"function"},{"location":"internals/util.html#ZenCore.is_wannier","page":"Util","title":"ZenCore.is_wannier","text":"is_wannier()\n\nTest whether the projector is the wannier functions.\n\nSee also: is_plo.\n\n\n\n\n\n","category":"function"},{"location":"internals/util.html#ZenCore.welcome","page":"Util","title":"ZenCore.welcome","text":"welcome()\n\nPrint out the welcome messages to the screen.\n\n\n\n\n\n","category":"function"},{"location":"internals/util.html#ZenCore.overview","page":"Util","title":"ZenCore.overview","text":"overview()\n\nPrint out the overview of Zen to the screen.\n\n\n\n\n\n","category":"function"},{"location":"internals/util.html#ZenCore.goodbye","page":"Util","title":"ZenCore.goodbye","text":"goodbye()\n\nPrint the goodbye messages to the screen.\n\n\n\n\n\n","category":"function"},{"location":"internals/util.html#ZenCore.sorry","page":"Util","title":"ZenCore.sorry","text":"sorry()\n\nPrint an error message to the screen.\n\n\n\n\n\n","category":"function"},{"location":"internals/util.html#ZenCore.prompt","page":"Util","title":"ZenCore.prompt","text":"prompt(msg::String)\n\nPrint a stylized Zen message to the screen.\n\n\n\n\n\nprompt(msg1::String, msg2::String)\n\nPrint a stylized Zen message to the screen.\n\n\n\n\n\nprompt(io::IOStream, msg::String)\n\nPrint a stylized Zen message to the given IOStream. This function is used to log the key events during DFT + DMFT iterations.\n\n\n\n\n\n","category":"function"},{"location":"internals/util.html#ZenCore.line_to_array","page":"Util","title":"ZenCore.line_to_array","text":"line_to_array(io::IOStream)\n\nConvert a line (reading from an IOStream) to a string array.\n\n\n\n\n\nline_to_array(str::AbstractString)\n\nConvert a string (AbstractString) to a string array.\n\n\n\n\n\n","category":"function"},{"location":"internals/util.html#ZenCore.line_to_cmplx","page":"Util","title":"ZenCore.line_to_cmplx","text":"line_to_cmplx(io::IOStream)\n\nConvert a line (reading from an IOStream) to a cmplx number. It is used to parse the LOCPROJ file only.\n\nSee also: vaspio_projs.\n\n\n\n\n\n","category":"function"},{"location":"internals/util.html#ZenCore.erf","page":"Util","title":"ZenCore.erf","text":"erf(x::F64)\n\nCalculate the Gauss error function.\n\nSee also: gauss_weight.\n\n\n\n\n\n","category":"function"},{"location":"internals/util.html#ZenCore.subscript","page":"Util","title":"ZenCore.subscript","text":"subscript(num::I64)\n\nConvert a number (it must be in [0,9]) to subscript.\n\n\n\n\n\n","category":"function"},{"location":"internals/util.html#ZenCore.str_to_struct","page":"Util","title":"ZenCore.str_to_struct","text":"str_to_struct(str::AbstractString, postfix::AbstractString)\n\nConvert a string (str) to an instance of struct. Here postfix could be Engine, Solver, Adaptor, Mode, and Mixer.\n\nExamples\n\njulia> str_to_struct(\"vasp\", \"Engine\")\nZenCore.VASPEngine()\n\njulia> str_to_struct(\"hia\", \"Solver\")\nZenCore.HIASolver()\n\n\n\n\n\n","category":"function"},{"location":"internals/util.html#ZenCore.colorize","page":"Util","title":"ZenCore.colorize","text":"colorize(c::String, s::String; bg::String = \"default\", m::String=\"default\")\n\nReturn some escape sequences, which will be displayed as colorized texts in the terminal.\n\n\n\n\n\ncolorize(c::String, s::String; bg::String = \"default\", m::String=\"default\")\n\nReturn some escape sequences, which will be displayed as colorized texts in the terminal.\n\n\n\n\n\n","category":"function"},{"location":"guide/wannier.html#Wannier-Function-Code","page":"Wannier Function Code","title":"Wannier Function Code","text":"","category":"section"},{"location":"start/compile.html#Compile","page":"Compile","title":"Compile","text":"","category":"section"},{"location":"guide/modes.html#Running-Modes","page":"Summary","title":"Running Modes","text":"","category":"section"},{"location":"internals/config.html#Configuration","page":"Config","title":"Configuration","text":"","category":"section"},{"location":"internals/config.html","page":"Config","title":"Config","text":"To extract, parse, verify, and print the configuration parameters. They are stored in external files (case.toml) or dictionaries.","category":"page"},{"location":"internals/config.html","page":"Config","title":"Config","text":"Source: config.jl","category":"page"},{"location":"internals/config.html#Contents","page":"Config","title":"Contents","text":"","category":"section"},{"location":"internals/config.html","page":"Config","title":"Config","text":"Pages = [\"config.md\"]","category":"page"},{"location":"internals/config.html#Index","page":"Config","title":"Index","text":"","category":"section"},{"location":"internals/config.html","page":"Config","title":"Config","text":"Pages = [\"config.md\"]","category":"page"},{"location":"internals/config.html#Functions","page":"Config","title":"Functions","text":"","category":"section"},{"location":"internals/config.html","page":"Config","title":"Config","text":"setup\nrenew\ninp_toml\nfil_dict\nrev_dict\nchk_dict\nexhibit\n_v\ncat_c\ncat_d\ncat_m\ncat_i\ncat_s\nget_c\nget_d\nget_m\nget_i\nget_s\nstr_c\nstr_d\nstr_m\nstr_i\nstr_s","category":"page"},{"location":"internals/config.html#ZenCore.setup","page":"Config","title":"ZenCore.setup","text":"setup()\n\nRead parameters from configuration file, and then setup the related dicts.\n\nSee also: inp_toml, fil_dict, chk_dict.\n\n\n\n\n\n","category":"function"},{"location":"internals/config.html#ZenCore.renew","page":"Config","title":"ZenCore.renew","text":"renew()\n\nRead parameters from configuration file, and then renew the related dicts. Noted that only parts of the parameters in the dicts are updated.\n\nSee also: inp_toml, rev_dict, chk_dict.\n\n\n\n\n\n","category":"function"},{"location":"internals/config.html#ZenCore.inp_toml","page":"Config","title":"ZenCore.inp_toml","text":"inp_toml(f::String, key::String, necessary::Bool)\n\nParse the configuration file (in toml format). It reads only parts of the configuration file, which depends on the value of key.\n\nSee also: setup.\n\n\n\n\n\ninp_toml(f::String, necessary::Bool)\n\nParse the configuration file (in toml format). It reads the whole file.\n\nSee also: setup.\n\n\n\n\n\n","category":"function"},{"location":"internals/config.html#ZenCore.fil_dict","page":"Config","title":"ZenCore.fil_dict","text":"fil_dict(cfg::Dict{String,Any})\n\nTransfer configurations from dict cfg to internal dicts (including PCASE, PDFT, PDMFT, PIMP, and PSOLVER).\n\nSee also: chk_dict.\n\n\n\n\n\n","category":"function"},{"location":"internals/config.html#ZenCore.rev_dict","page":"Config","title":"ZenCore.rev_dict","text":"rev_dict(cfg::Dict{String,Any})\n\nTransfer configurations from dict cfg to internal dicts (including PDMFT, PIMP, and PSOLVER). This function is used to update some special configuration parameters dynamically.\n\nSee also: chk_dict.\n\n\n\n\n\n","category":"function"},{"location":"internals/config.html#ZenCore.chk_dict","page":"Config","title":"ZenCore.chk_dict","text":"chk_dict()\n\nValidate the correctness and consistency of configurations.\n\nSee also: fil_dict, _v.\n\n\n\n\n\n","category":"function"},{"location":"internals/config.html#ZenCore.exhibit","page":"Config","title":"ZenCore.exhibit","text":"exhibit()\n\nDisplay the configuration parameters for reference.\n\nSee also: setup.\n\n\n\n\n\n","category":"function"},{"location":"internals/config.html#ZenCore._v","page":"Config","title":"ZenCore._v","text":"_v(key::String, val::Array{Any,1})\n\nVerify the value array. Called by chk_dict() function only.\n\nSee also: chk_dict.\n\n\n\n\n\n","category":"function"},{"location":"internals/config.html#ZenCore.cat_c","page":"Config","title":"ZenCore.cat_c","text":"cat_c()\n\nPrint the configuration parameters to stdout: for PCASE dict.\n\nSee also: get_c, str_c.\n\n\n\n\n\n","category":"function"},{"location":"internals/config.html#ZenCore.cat_d","page":"Config","title":"ZenCore.cat_d","text":"cat_d()\n\nPrint the configuration parameters to stdout: for PDFT dict.\n\nSee also: get_d, str_d.\n\n\n\n\n\n","category":"function"},{"location":"internals/config.html#ZenCore.cat_m","page":"Config","title":"ZenCore.cat_m","text":"cat_m()\n\nPrint the configuration parameters to stdout: for PDMFT dict.\n\nSee also: get_m, str_m.\n\n\n\n\n\n","category":"function"},{"location":"internals/config.html#ZenCore.cat_i","page":"Config","title":"ZenCore.cat_i","text":"cat_i()\n\nPrint the configuration parameters to stdout: for PIMP dict.\n\nSee also: get_i, str_i.\n\n\n\n\n\n","category":"function"},{"location":"internals/config.html#ZenCore.cat_s","page":"Config","title":"ZenCore.cat_s","text":"cat_s()\n\nPrint the configuration parameters to stdout: for PSOLVER dict.\n\nSee also: get_s, str_s.\n\n\n\n\n\n","category":"function"},{"location":"internals/config.html#ZenCore.get_c","page":"Config","title":"ZenCore.get_c","text":"get_c(key::String)\n\nExtract configurations from dict: PCASE.\n\nSee also: cat_c, str_c.\n\n\n\n\n\n","category":"function"},{"location":"internals/config.html#ZenCore.get_d","page":"Config","title":"ZenCore.get_d","text":"get_d(key::String)\n\nExtract configurations from dict: PDFT.\n\nSee also: cat_d, str_d.\n\n\n\n\n\n","category":"function"},{"location":"internals/config.html#ZenCore.get_m","page":"Config","title":"ZenCore.get_m","text":"get_m(key::String)\n\nExtract configurations from dict: PDMFT.\n\nSee also: cat_m, str_m.\n\n\n\n\n\n","category":"function"},{"location":"internals/config.html#ZenCore.get_i","page":"Config","title":"ZenCore.get_i","text":"get_i(key::String)\n\nExtract configurations from dict: PIMP.\n\nSee also: cat_i, str_i.\n\n\n\n\n\n","category":"function"},{"location":"internals/config.html#ZenCore.get_s","page":"Config","title":"ZenCore.get_s","text":"get_s(key::String)\n\nExtract configurations from dict: PSOLVER.\n\nSee also: cat_s, str_s.\n\n\n\n\n\n","category":"function"},{"location":"internals/config.html#ZenCore.str_c","page":"Config","title":"ZenCore.str_c","text":"str_c(key::String)\n\nExtract configurations from dict: PCASE, convert them into strings.\n\nSee also: cat_c, get_c.\n\n\n\n\n\n","category":"function"},{"location":"internals/config.html#ZenCore.str_d","page":"Config","title":"ZenCore.str_d","text":"str_d(key::String)\n\nExtract configurations from dict: PDFT, convert them into strings.\n\nSee also: cat_d, get_d.\n\n\n\n\n\n","category":"function"},{"location":"internals/config.html#ZenCore.str_m","page":"Config","title":"ZenCore.str_m","text":"str_m(key::String)\n\nExtract configurations from dict: PDMFT, convert them into strings.\n\nSee also: cat_m, get_m.\n\n\n\n\n\n","category":"function"},{"location":"internals/config.html#ZenCore.str_i","page":"Config","title":"ZenCore.str_i","text":"str_i(key::String)\n\nExtract configurations from dict: PIMP, convert them into strings.\n\nSee also: cat_i, get_i.\n\n\n\n\n\n","category":"function"},{"location":"internals/config.html#ZenCore.str_s","page":"Config","title":"ZenCore.str_s","text":"str_s(key::String)\n\nExtract configurations from dict: PSOLVER, convert them into strings.\n\nSee also: cat_s, get_s.\n\n\n\n\n\n","category":"function"},{"location":"intro/design.html#Design-Philosophy","page":"Design Philosophy","title":"Design Philosophy","text":"","category":"section"},{"location":"intro/cite.html#Citation","page":"Citation","title":"Citation","text":"","category":"section"},{"location":"intro/cite.html","page":"Citation","title":"Citation","text":"About the Zen computation framework","category":"page"},{"location":"intro/cite.html","page":"Citation","title":"Citation","text":"[1] Jia-Ming Wang, Jing-Xuan Wang, Rong-Qiang He, Li Huang and Zhong-Yi Lu, Ab initio dynamical mean field theory with natural orbitals renormalization group impurity solver, npj Computational Materials 11, 86 (2025)","category":"page"},{"location":"intro/cite.html","page":"Citation","title":"Citation","text":"","category":"page"},{"location":"intro/cite.html","page":"Citation","title":"Citation","text":"About the quantum impurity solvers","category":"page"},{"location":"intro/cite.html","page":"Citation","title":"Citation","text":"","category":"page"},{"location":"intro/cite.html","page":"Citation","title":"Citation","text":"About the analytic continuation tools","category":"page"},{"location":"intro/cite.html","page":"Citation","title":"Citation","text":"","category":"page"},{"location":"guide/outline.html#Outline","page":"Outline","title":"Outline","text":"","category":"section"},{"location":"guide/outline.html","page":"Outline","title":"Outline","text":"Running Modes\nDetailed Recipes\nInput Files\nOutput Files\nInput Parameters\nCore Components\nAuxiliary Components\nTips And Tricks","category":"page"},{"location":"guide/block_dmft.html#PDMFT-block","page":"Block [dmft]","title":"PDMFT block","text":"","category":"section"},{"location":"guide/block_dmft.html#Contents","page":"Block [dmft]","title":"Contents","text":"","category":"section"},{"location":"guide/block_dmft.html","page":"Block [dmft]","title":"Block [dmft]","text":"Pages = [\"dmft.md\"]","category":"page"},{"location":"guide/block_dmft.html#Index","page":"Block [dmft]","title":"Index","text":"","category":"section"},{"location":"guide/block_dmft.html","page":"Block [dmft]","title":"Block [dmft]","text":"Pages = [\"dmft.md\"]","category":"page"},{"location":"guide/block_dmft.html#Parameters","page":"Block [dmft]","title":"Parameters","text":"","category":"section"},{"location":"guide/standard.html#Standard-Mode","page":"Standard Mode","title":"Standard Mode","text":"","category":"section"},{"location":"internals/solver.html#Quantum-Impurity-Solvers","page":"Solver","title":"Quantum Impurity Solvers","text":"","category":"section"},{"location":"internals/solver.html","page":"Solver","title":"Solver","text":"Wrapper for various quantum impurity solvers. Now only the CT-HYB₁, CT-HYB₂, HIA, and NORG quantum impurity solvers are supported.","category":"page"},{"location":"internals/solver.html","page":"Solver","title":"Solver","text":"Source: solver.jl","category":"page"},{"location":"internals/solver.html#Contents","page":"Solver","title":"Contents","text":"","category":"section"},{"location":"internals/solver.html","page":"Solver","title":"Solver","text":"Pages = [\"solver.md\"]","category":"page"},{"location":"internals/solver.html#Index","page":"Solver","title":"Index","text":"","category":"section"},{"location":"internals/solver.html","page":"Solver","title":"Solver","text":"Pages = [\"solver.md\"]","category":"page"},{"location":"internals/solver.html#Functions","page":"Solver","title":"Functions","text":"","category":"section"},{"location":"internals/solver.html","page":"Solver","title":"Solver","text":"solver_call\nsolver_copy\nsolver_sigma\nsolver_nimpx\nsolver_edmft\ns_qmc1_init\ns_qmc1_exec\ns_qmc1_save\ns_qmc1_copy\ns_qmc2_init\ns_qmc2_exec\ns_qmc2_save\ns_qmc2_copy\ns_hub1_init\ns_hub1_exec\ns_hub1_save\ns_hub1_copy\ns_norg_init\ns_norg_exec\ns_norg_save\ns_norg_copy\nctqmc_setup\nctqmc_atomx\nctqmc_delta\nctqmc_eimpx\nctqmc_sigma\nctqmc_nimpx\nctqmc_edmft\nnorg_setup\nnorg_delta\nnorg_eimpx\nnorg_sigma\nnorg_nimpx\nnorg_edmft\nGetSigma\nGetNimpx\nGetEdmft\nGetSymmetry\nGetImpurity\nCatImpurity\nFixImpurity","category":"page"},{"location":"internals/solver.html#ZenCore.solver_call","page":"Solver","title":"ZenCore.solver_call","text":"solver_call(::NULLSolver, it::IterInfo, imp::Impurity)\nsolver_call(::CTHYB₁Solver, it::IterInfo, imp::Impurity)\nsolver_call(::CTHYB₂Solver, it::IterInfo, imp::Impurity)\nsolver_call(::HIASolver, it::IterInfo, imp::Impurity)\nsolver_call(::NORGSolver, it::IterInfo, imp::Impurity)\nsolver_call(::ATOMSolver, it::IterInfo, imp::Impurity)\n\nTry to solve the quantum impurity problems by using various quantum impurity solvers. It acts as a dispatcher. Now it supports CTHYB₁ (ct_hyb1), CTHYB₂ (ct_hyb2), HIA (hia), NORG (norg), and ATOM (atomic) solvers.\n\nSee also: _solver_.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.solver_copy","page":"Solver","title":"ZenCore.solver_copy","text":"solver_copy(::NULLSolver, it::IterInfo, imp₁::Impurity, imp₂::Impurity)\nsolver_copy(::CTHYB₁Solver, it::IterInfo, imp₁::Impurity, imp₂::Impurity)\nsolver_copy(::CTHYB₂Solver, it::IterInfo, imp₁::Impurity, imp₂::Impurity)\nsolver_copy(::HIASolver, it::IterInfo, imp₁::Impurity, imp₂::Impurity)\nsolver_copy(::NORGSolver, it::IterInfo, imp₁::Impurity, imp₂::Impurity)\nsolver_copy(::ATOMSolver, it::IterInfo, imp₁::Impurity, imp₂::Impurity)\n\nTry to solve a quantum impurity problem by copying solution from another equivalent quantum impurity problem. It acts as a dispatcher.\n\nSee also: _solver_.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.solver_sigma","page":"Solver","title":"ZenCore.solver_sigma","text":"solver_sigma(::NULLSolver, imp::Impurity)\nsolver_sigma(::CTHYB₁Solver, imp::Impurity)\nsolver_sigma(::CTHYB₂Solver, imp::Impurity)\nsolver_sigma(::HIASolver, imp::Impurity)\nsolver_sigma(::NORGSolver, imp::Impurity)\nsolver_sigma(::ATOMSolver, imp::Impurity)\n\nTry to extract self-energy function from the output data of quantum impurity solver. It acts as a dispatcher.\n\nSee also: _solver_.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.solver_nimpx","page":"Solver","title":"ZenCore.solver_nimpx","text":"solver_nimpx(::NULLSolver, imp::Impurity)\nsolver_nimpx(::CTHYB₁Solver, imp::Impurity)\nsolver_nimpx(::CTHYB₂Solver, imp::Impurity)\nsolver_nimpx(::HIASolver, imp::Impurity)\nsolver_nimpx(::NORGSolver, imp::Impurity)\nsolver_nimpx(::ATOMSolver, imp::Impurity)\n\nTry to extract impurity occupancy from the output data of quantum impurity solver. It acts as a dispatcher.\n\nSee also: _solver_.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.solver_edmft","page":"Solver","title":"ZenCore.solver_edmft","text":"solver_edmft(::NULLSolver)\nsolver_edmft(::CTHYB₁Solver)\nsolver_edmft(::CTHYB₂Solver)\nsolver_edmft(::HIASolver)\nsolver_edmft(::NORGSolver)\nsolver_edmft(::ATOMSolver)\n\nTry to extract interaction energy from the output data of quantum impurity solver. It acts as a dispatcher.\n\nSee also: _solver_.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.s_qmc1_init","page":"Solver","title":"ZenCore.s_qmc1_init","text":"s_qmc1_init(it::IterInfo, imp::Impurity)\n\nCheck runtime environment of the CTHYB₁ quantum impurity solver. Prepare the necessary input files.\n\nThis quantum impurity solver is from the iQIST software package.\n\nSee also: s_qmc1_exec, s_qmc1_save.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.s_qmc1_exec","page":"Solver","title":"ZenCore.s_qmc1_exec","text":"s_qmc1_exec(it::IterInfo)\n\nLaunch the CTHYB₁ quantum impurity solver.\n\nThis quantum impurity solver is from the iQIST software package.\n\nSee also: s_qmc1_init, s_qmc1_save.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.s_qmc1_save","page":"Solver","title":"ZenCore.s_qmc1_save","text":"s_qmc1_save(it::IterInfo, imp::Impurity)\n\nBackup output files of the CTHYB₁ quantum impurity solver.\n\nThis quantum impurity solver is from the iQIST software package.\n\nSee also: s_qmc1_init, s_qmc1_exec.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.s_qmc1_copy","page":"Solver","title":"ZenCore.s_qmc1_copy","text":"s_qmc1_copy(it::IterInfo, imp₁::Impurity, imp₂::Impurity)\n\nDuplicate output files of the CTHYB₁ quantum impurity solver. We just copy selected output files from impurity.1 to impurity.2. Be careful, now we are already in directory impurity.2.\n\nThis quantum impurity solver is from the iQIST software package.\n\nSee also: s_qmc1_init, s_qmc1_exec.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.s_qmc2_init","page":"Solver","title":"ZenCore.s_qmc2_init","text":"s_qmc2_init(it::IterInfo)\n\nCheck runtime environment of the CTHYB₂ quantum impurity solver. Prepare the necessary input files.\n\nThis quantum impurity solver is from the iQIST software package.\n\nSee also: s_qmc2_exec, s_qmc2_save.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.s_qmc2_exec","page":"Solver","title":"ZenCore.s_qmc2_exec","text":"s_qmc2_exec(it::IterInfo)\n\nLaunch the CTHYB₂ quantum impurity solver.\n\nThis quantum impurity solver is from the iQIST software package.\n\nSee also: s_qmc2_init, s_qmc2_save.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.s_qmc2_save","page":"Solver","title":"ZenCore.s_qmc2_save","text":"s_qmc2_save(it::IterInfo)\n\nBackup output files of the CTHYB₂ quantum impurity solver.\n\nThis quantum impurity solver is from the iQIST software package.\n\nSee also: s_qmc2_init, s_qmc2_exec.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.s_qmc2_copy","page":"Solver","title":"ZenCore.s_qmc2_copy","text":"s_qmc2_copy(it::IterInfo, imp₁::Impurity, imp₂::Impurity)\n\nDuplicate output files of the CTHYB₂ quantum impurity solver. We just copy selected output files from impurity.1 to impurity.2. Be careful, now we are already in directory impurity.2.\n\nThis quantum impurity solver is from the iQIST software package.\n\nSee also: s_qmc2_init, s_qmc2_exec.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.s_hub1_init","page":"Solver","title":"ZenCore.s_hub1_init","text":"s_hub1_init(it::IterInfo)\n\nCheck runtime environment of the HIA quantum impurity solver. Prepare the necessary input files.\n\nSee also: s_hub1_exec, s_hub1_save.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.s_hub1_exec","page":"Solver","title":"ZenCore.s_hub1_exec","text":"s_hub1_exec(it::IterInfo)\n\nLaunch the HIA quantum impurity solver.\n\nSee also: s_hub1_init, s_hub1_save.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.s_hub1_save","page":"Solver","title":"ZenCore.s_hub1_save","text":"s_hub1_save(it::IterInfo)\n\nBackup output files of the HIA quantum impurity solver.\n\nSee also: s_hub1_init, s_hub1_exec.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.s_hub1_copy","page":"Solver","title":"ZenCore.s_hub1_copy","text":"s_hub1_copy(it::IterInfo, imp₁::Impurity, imp₂::Impurity)\n\nDuplicate output files of the HIA quantum impurity solver. We just copy selected output files from impurity.1 to impurity.2. Be careful, now we are already in directory impurity.2.\n\nSee also: s_hub1_init, s_hub1_exec.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.s_norg_init","page":"Solver","title":"ZenCore.s_norg_init","text":"s_norg_init(it::IterInfo, imp::Impurity)\n\nCheck runtime environment of the NORG quantum impurity solver. Prepare the necessary input files.\n\nThis quantum impurity solver is from the RUC Team.\n\nSee also: s_norg_exec, s_norg_save.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.s_norg_exec","page":"Solver","title":"ZenCore.s_norg_exec","text":"s_norg_exec(it::IterInfo)\n\nLaunch the NORG quantum impurity solver.\n\nThis quantum impurity solver is from the RUC Team.\n\nSee also: s_norg_init, s_norg_save.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.s_norg_save","page":"Solver","title":"ZenCore.s_norg_save","text":"s_norg_save(it::IterInfo, imp::Impurity)\n\nBackup output files of the NORG quantum impurity solver.\n\nThis quantum impurity solver is from the RUC Team.\n\nSee also: s_norg_init, s_norg_exec.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.s_norg_copy","page":"Solver","title":"ZenCore.s_norg_copy","text":"s_norg_copy(it::IterInfo, imp₁::Impurity, imp₂::Impurity)\n\nDuplicate output files of the NORG quantum impurity solver. We just copy selected output files from impurity.1 to impurity.2. Be careful, now we are already in directory impurity.2.\n\nThis quantum impurity solver is from the RUC Team.\n\nSee also: s_norg_init, s_norg_exec.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.ctqmc_setup","page":"Solver","title":"ZenCore.ctqmc_setup","text":"ctqmc_setup(imp::Impurity)\n\nGenerate default configuration file (solver.ctqmc.in) for the CTHYB quantum impurity solvers automatically (according to the information encoded in the Impurity struct).\n\nSee also: Impurity, ctqmc_atomx.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.ctqmc_atomx","page":"Solver","title":"ZenCore.ctqmc_atomx","text":"ctqmc_atomx(imp::Impurity)\n\nGenerate configuration file for the atomic problem solver.\n\nSee also: Impurity, ctqmc_setup.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.ctqmc_delta","page":"Solver","title":"ZenCore.ctqmc_delta","text":"ctqmc_delta(fmesh::Array{F64,1}, Delta::Array{C64,4})\n\nWrite the hybridization functions to the solver.hyb.in file, which is suitable for the CTHYB quantum impurity solver.\n\nSee also: ctqmc_eimpx.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.ctqmc_eimpx","page":"Solver","title":"ZenCore.ctqmc_eimpx","text":"ctqmc_eimpx(Eimpx::Array{C64,3})\n\nWrite the local impurity levels to the solver.eimp.in file, which is suitable for the CTHYB quantum impurity solver.\n\nSee also: ctqmc_delta.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.ctqmc_sigma","page":"Solver","title":"ZenCore.ctqmc_sigma","text":"ctqmc_sigma(imp::Impurity)\n\nParse the solver.sgm.dat file, which is generated by the CTHYB quantum impurity solver, to extract the bare self-energy functions.\n\nIn the sigma_gather() function, these data will be combined to generate the sigma.bare file, which is essential for the DMFT engine.\n\nSee also: GetSigma, solver_sigma.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.ctqmc_nimpx","page":"Solver","title":"ZenCore.ctqmc_nimpx","text":"ctqmc_nimpx(imp::Impurity)\n\nParse the solver.nmat.dat file, which is generated by the CTHYB quantum impurity solver, to extract the impurity occupancy. Then the fields nup, ndown, and occup in Impurity struct will be updated.\n\nSee also: GetNimpx, solver_nimpx.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.ctqmc_edmft","page":"Solver","title":"ZenCore.ctqmc_edmft","text":"ctqmc_edmft()\n\nParse the solver.paux.dat file, which is generated by the CTHYB quantum impurity solver, to extract the interaction energy.\n\nSee also: GetEdmft, solver_edmft.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.norg_setup","page":"Solver","title":"ZenCore.norg_setup","text":"norg_setup(imp::Impurity)\n\nGenerate default configuration file (solver.norg.in) for the NORG quantum impurity solvers automatically (according to the information encoded in the Impurity struct).\n\nSee also: Impurity, ctqmc_atomx.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.norg_delta","page":"Solver","title":"ZenCore.norg_delta","text":"norg_delta(fmesh::Array{F64,1}, Delta::Array{C64,4})\n\nWrite the hybridization functions to the solver.hyb.in file, which is suitable for the NORG quantum impurity solver.\n\nSee also: norg_eimpx.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.norg_eimpx","page":"Solver","title":"ZenCore.norg_eimpx","text":"norg_eimpx(Eimpx::Array{C64,3})\n\nWrite the local impurity levels to the solver.eimp.in file, which is suitable for the NORG quantum impurity solver.\n\nSee also: norg_delta.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.norg_sigma","page":"Solver","title":"ZenCore.norg_sigma","text":"norg_sigma(imp::Impurity)\n\nParse the seimp.txt file, which is generated by the NORG quantum impurity solver, to extract the bare self-energy functions.\n\nIn the sigma_gather() function, these data will be combined to generate the sigma.bare file, which is essential for the DMFT engine.\n\nSee also: GetSigma, solver_sigma.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.norg_nimpx","page":"Solver","title":"ZenCore.norg_nimpx","text":"norg_nimpx(imp::Impurity)\n\nParse the nmat.txt file, which is generated by the NORG quantum impurity solver, to extract the impurity occupancy. Then the fields nup, ndown, and occup in Impurity struct will be updated.\n\nSee also: GetNimpx, solver_nimpx.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.norg_edmft","page":"Solver","title":"ZenCore.norg_edmft","text":"norg_edmft()\n\nParse the solver.out file, which is generated by the NORG quantum impurity solver, to extract the interaction energy.\n\nSee also: GetEdmft, solver_edmft.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.GetSigma","page":"Solver","title":"ZenCore.GetSigma","text":"GetSigma(imp::Impurity)\n\nExtract self-energy functions from the output files of various quantum impurity solvers. The data will be combined in the sigma_gather() function. Then they will be fed back to the DMFT engine. The working directory of this function must be the root folder.\n\nSee also: Impurity, solver_sigma.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.GetNimpx","page":"Solver","title":"ZenCore.GetNimpx","text":"GetNimpx(imp::Impurity)\n\nExtract impurity occupancy from the output files of various quantum impurity solvers. Then the field occup in the Impurity struct will be updated, which will then be used to evaluate the double counting term for self-energy functions. The working directory of this function must be the root folder.\n\nThe argument imp may be modified in this function.\n\nSee also: Impurity, solver_nimpx.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.GetEdmft","page":"Solver","title":"ZenCore.GetEdmft","text":"GetEdmft(imp::Impurity)\n\nExtract interaction energy (i.e potential energy) from the output files of various quantum impurity solvers. The input Impurity struct won't be modified. The working directory of this function must be the root folder.\n\nSee also: Impurity, solver_edmft.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.GetSymmetry","page":"Solver","title":"ZenCore.GetSymmetry","text":"GetSymmetry(Eimpx::Array{C64,3})\n\nAnalyze the symmetry according to the diagonal elements of the matrix of the local impurity levels.\n\nSee also: ctqmc_eimpx.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.GetImpurity","page":"Solver","title":"ZenCore.GetImpurity","text":"GetImpurity()\n\nReturn an array of Impurity struct, which encapsulates useful information about the quantum impurity problems.\n\nSee also: Impurity.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.CatImpurity","page":"Solver","title":"ZenCore.CatImpurity","text":"CatImpurity(imp::Impurity)\n\nDisplay the Impurity struct that need to be solved.\n\nSee also: Impurity.\n\n\n\n\n\n","category":"function"},{"location":"internals/solver.html#ZenCore.FixImpurity","page":"Solver","title":"ZenCore.FixImpurity","text":"FixImpurity(ai::Array{Impurity,1})\n\nUpdate the quantum impurity problems encapsulated in ai according to the configuration parameters.\n\nSee also: Impurity.\n\n\n\n\n\n","category":"function"},{"location":"guide/dft.html#Density-Functional-Theory-Code","page":"Density Functional Theory Code","title":"Density Functional Theory Code","text":"","category":"section"},{"location":"guide/tests.html#Tests-And-Examples","page":"Tests And Examples","title":"Tests And Examples","text":"","category":"section"},{"location":"guide/block_impurity.html#PIMP-block","page":"Block [imp]","title":"PIMP block","text":"","category":"section"},{"location":"guide/block_impurity.html#Contents","page":"Block [imp]","title":"Contents","text":"","category":"section"},{"location":"guide/block_impurity.html","page":"Block [imp]","title":"Block [imp]","text":"Pages = [\"impurity.md\"]","category":"page"},{"location":"guide/block_impurity.html#Index","page":"Block [imp]","title":"Index","text":"","category":"section"},{"location":"guide/block_impurity.html","page":"Block [imp]","title":"Block [imp]","text":"Pages = [\"impurity.md\"]","category":"page"},{"location":"guide/block_impurity.html#Parameters","page":"Block [imp]","title":"Parameters","text":"","category":"section"},{"location":"intro/team.html#Team","page":"Developers","title":"Team","text":"","category":"section"},{"location":"intro/team.html","page":"Developers","title":"Developers","text":"The Zen computation framework is developed by the following contributors:","category":"page"},{"location":"intro/team.html","page":"Developers","title":"Developers","text":"Developers:","category":"page"},{"location":"intro/team.html","page":"Developers","title":"Developers","text":"Li Huang (Institute of Materials, China Academy of Engineering Physics)","category":"page"},{"location":"intro/team.html","page":"Developers","title":"Developers","text":"Contributors:","category":"page"},{"location":"intro/team.html","page":"Developers","title":"Developers","text":"Jia-Ming Wang (Renmin University)\nRong-Qiang He (Renmin University)\nZhong-Yi Lu (Renmin University)","category":"page"},{"location":"start/uncompress.html#Uncompress","page":"Uncompress","title":"Uncompress","text":"","category":"section"},{"location":"guide/docs.html#Documentation","page":"Documentation","title":"Documentation","text":"","category":"section"},{"location":"intro/outline.html#Outline","page":"Outline","title":"Outline","text":"","category":"section"},{"location":"internals/wannier.html#Wannier-Functions","page":"Wannier","title":"Wannier Functions","text":"","category":"section"},{"location":"internals/wannier.html","page":"Wannier","title":"Wannier","text":"Tools for the projection on wannier functions scheme (adaptor).","category":"page"},{"location":"internals/wannier.html","page":"Wannier","title":"Wannier","text":"Source: wannier.jl","category":"page"},{"location":"internals/wannier.html#Contents","page":"Wannier","title":"Contents","text":"","category":"section"},{"location":"internals/wannier.html","page":"Wannier","title":"Wannier","text":"Pages = [\"wannier.md\"]","category":"page"},{"location":"internals/wannier.html#Index","page":"Wannier","title":"Index","text":"","category":"section"},{"location":"internals/wannier.html","page":"Wannier","title":"Wannier","text":"Pages = [\"wannier.md\"]","category":"page"},{"location":"internals/wannier.html#Functions","page":"Wannier","title":"Functions","text":"","category":"section"},{"location":"internals/wannier.html","page":"Wannier","title":"Wannier","text":"adaptor_call(::WANNIERAdaptor, ::Dict{Symbol,Any}, ::Array{Impurity,1})\nwannier_adaptor\nwannier_init\nwannier_exec\nwannier_save\nw90_make_ctrl\nw90_make_proj\nw90_make_map\nw90_make_group\nw90_make_window\nw90_make_chipsi\nw90_make_kpath\nw90_make_rcell\nw90_make_hamr\nw90_make_hamk\nw90_diag_hamk\nw90_find_bwin\nw90_read_amat\nw90_read_eigs\nw90_read_hamr\nw90_read_umat\nw90_read_udis\nw90_read_wout\nw90_write_win\npw2wan_init\npw2wan_exec\npw2wan_save","category":"page"},{"location":"internals/wannier.html#ZenCore.adaptor_call-Tuple{WANNIERAdaptor, Dict{Symbol, Any}, Vector{Impurity}}","page":"Wannier","title":"ZenCore.adaptor_call","text":"adaptor_call(::WANNIERAdaptor,\n             D::Dict{Symbol,Any},\n             ai::Array{Impurity,1})\n\nIt is a dispatcher for the DFT-DMFT adaptor. It calls wannier_adaptor() function to deal with the outputs of wannier90 code and generate key dataset for the IR adaptor. Note that similar functions are also defined in vasp.jl, qe.jl, and plo.jl.\n\nSee also: wannier_adaptor.\n\n\n\n\n\n","category":"method"},{"location":"internals/wannier.html#ZenCore.wannier_adaptor","page":"Wannier","title":"ZenCore.wannier_adaptor","text":"wannier_adaptor(D::Dict{Symbol,Any}, ai::Array{Impurity,1})\n\nAdaptor support. It will read and parse the outputs of the wannier90 code, convert the data into IR format. The data contained in D dict will be updated.\n\nBe careful, now this adaptor only supports quantum espresso (pwscf).\n\nSee also: qe_adaptor, ir_adaptor.\n\n\n\n\n\n","category":"function"},{"location":"internals/wannier.html#ZenCore.wannier_init","page":"Wannier","title":"ZenCore.wannier_init","text":"wannier_init(D::Dict{Symbol,Any}, sp::String = \"\")\n\nTry to generate the w90.win file, which is the essential input for the wannier90 code. Here, we always use w90 as the seedname. If the system is spin polarized (the argument sp is up or dn), then the seednames will be w90up and w90dn, respectively.\n\nSee also: wannier_exec, wannier_save.\n\n\n\n\n\n","category":"function"},{"location":"internals/wannier.html#ZenCore.wannier_exec","page":"Wannier","title":"ZenCore.wannier_exec","text":"wannier_exec(sp::String = \"\"; op::String = \"\")\n\nExecute the wannier90 program, monitor the convergence progress, and output the relevant information. The argument sp denotes the spin component, while op specifies the running mode for wannier90. If op == -pp, the wannier90 code will try to generate the w90.nnkp.\n\nSee also: wannier_init, wannier_save.\n\n\n\n\n\n","category":"function"},{"location":"internals/wannier.html#ZenCore.wannier_save","page":"Wannier","title":"ZenCore.wannier_save","text":"wannier_save(sp::String = \"\"; op::String = \"\")\n\nBackup and check the output files of wannier90 if necessary. Actually, there are no files that need to be stored. We just check whether they have been created correctly.\n\nSee also: wannier_init, wannier_exec.\n\n\n\n\n\n","category":"function"},{"location":"internals/wannier.html#ZenCore.w90_make_ctrl","page":"Wannier","title":"ZenCore.w90_make_ctrl","text":"w90_make_ctrl(latt:Lattice, nband::I64, fermi::F64)\n\nTry to make the control parameters for the w90.win file. The latt object represent the crystallography information, and nband is the total number of Kohn-Sham states outputed by the DFT code, fermi is the fermi level. This function is called by wannier_init().\n\nSee also: w90_make_proj.\n\n\n\n\n\n","category":"function"},{"location":"internals/wannier.html#ZenCore.w90_make_proj","page":"Wannier","title":"ZenCore.w90_make_proj","text":"w90_make_proj()\n\nTry to make the projection block for the w90.win file. We will not check the validness of these projections here. This function is called by the wannier_init() function.\n\nSee also: w90_make_ctrl.\n\n\n\n\n\n","category":"function"},{"location":"internals/wannier.html#ZenCore.w90_make_map","page":"Wannier","title":"ZenCore.w90_make_map","text":"w90_make_map(PG::Array{PrGroup,1}, ai::Array{Impurity,1})\n\nCreate connections / mappings between projectors (or band windows) and quantum impurity problems. Return a Mapping struct. This function is just a copy of the plo_map() function.\n\nSee also: PrGroup, PrWindow, Mapping.\n\n\n\n\n\n","category":"function"},{"location":"internals/wannier.html#ZenCore.w90_make_group","page":"Wannier","title":"ZenCore.w90_make_group","text":"w90_make_group(latt::Lattice, sp::String = \"\")\n\nTry to read the w90.nnkp file, parse the projections block. Finally, it will return arrays of PrTrait and PrGroup objects, which contain the definitions of projectors. The argument latt is essential. It includes the atomic coordinates for all lattice sites, which are quite useful to distinguish these projectors. And the argument sp is optional. It is used when the system is spin-polarized.\n\nSee also: PrTrait, PrGroup.\n\n\n\n\n\nw90_make_group(MAP::Mapping, PG::Array{PrGroup,1})\n\nUse the information contained in the Mapping struct to further setup the PrGroup struct. This function is just a copy of the plo_group() function.\n\nSee also: PIMP, Mapping, PrGroup.\n\n\n\n\n\n","category":"function"},{"location":"internals/wannier.html#ZenCore.w90_make_window","page":"Wannier","title":"ZenCore.w90_make_window","text":"w90_make_window(PG::Array{PrGroup,1}, enk::Array{F64,3})\n\nMake band window to filter the projections. Actually, all of the Kohn-Sham eigenvalues are retained, so the band window is always [1, nband]. This function will return an array of PrWindow struct.\n\nSee also: PrWindow.\n\n\n\n\n\nw90_make_window(PG::Array{PrGroup,1},\n                ewin::Tuple{F64,F64},\n                bwin::Array{I64,2})\n\nMake band window to filter the projections. Actually, only those relevant bands (which are restricted by the energy window ewin or the band window bwin) are retained. This function will return an array of PrWindow struct. Be careful, ewin must be consistent with bwin (please check w90_find_bwin() for more details).\n\nSee also: PrWindow.\n\n\n\n\n\nw90_make_window(PWup::Array{PrWindow,1}, PWdn::Array{PrWindow,1})\n\nTry to merge two arrays of PrWindow struct and generate a new one. Actually, the new array is similar to the olds. We only modify one of its members, kwin.\n\nSee also: PrWindow.\n\n\n\n\n\n","category":"function"},{"location":"internals/wannier.html#ZenCore.w90_make_chipsi","page":"Wannier","title":"ZenCore.w90_make_chipsi","text":"w90_make_chipsi(umat::Array{C64,3}, udis::Array{C64,3})\n\nTry to merge the transform matrix umat with the disentanglement matrix udis to construct the final projection matrix chipsi, which actually is the overlap matrix between the wannier functions and the Kohn-Sham wave functions.\n\nSee also: w90_read_umat, w90_read_udis.\n\n\n\n\n\nw90_make_chipsi(PG::Array{PrGroup,1}, chipsi::Array{C64,4})\n\nPerform global rotations or transformations for the projectors. In this function, the projectors will be classified into different groups, and then they will be rotated group by group. This function is just a copy of the plo_rotate() function.\n\nSee also: PrGroup, plo_rotate.\n\n\n\n\n\nw90_make_chipsi(PW::Array{PrWindow,1}, chipsi::Array{Array{C64,4},1}}\n\nFilter the projector matrix according to band window. This function is just a copy of the plo_filter() function.\n\nSee also: PrWindow, plo_filter.\n\n\n\n\n\n","category":"function"},{"location":"internals/wannier.html#ZenCore.w90_make_kpath","page":"Wannier","title":"ZenCore.w90_make_kpath","text":"w90_make_kpath(ndiv::I64,\n               kstart::Array{F64,2},\n               kend::Array{F64,2})\n\nTry to generate 𝑘-path along the selected high-symmetry directions in the Brillouin zone. The argument ndiv means the number of divisions for each 𝑘-path. While kstart and kend denote the 𝑘 coordinates for the starting and ending points of the 𝑘-path, respectively. Note that this function is used to perform wannier band interpolation.\n\nSee also: w90_make_rcell.\n\n\n\n\n\n","category":"function"},{"location":"internals/wannier.html#ZenCore.w90_make_rcell","page":"Wannier","title":"ZenCore.w90_make_rcell","text":"w90_make_rcell(latt::Lattice)\n\nCalculates a grid of points that fall inside of (and eventually on the surface of) the Wigner-Seitz supercell centered on the origin of the given lattice (latt).\n\nSee also: w90_make_kpath.\n\n\n\n\n\n","category":"function"},{"location":"internals/wannier.html#ZenCore.w90_make_hamr","page":"Wannier","title":"ZenCore.w90_make_hamr","text":"w90_make_hamr(kvec::Array{F64,2},\n              rvec::Array{I64,2},\n              hamk::Array{C64,3})\n\nConvert the hamiltonian from 𝑘-space to 𝑟-space via the fast fourier transformation. The arguments kvec and rvec define the 𝑘-mesh and 𝑟-mesh, respectively. hamk means H(K) which should be defined in a uniform 𝑘-mesh.\n\nSee also: w90_make_hamk.\n\n\n\n\n\n","category":"function"},{"location":"internals/wannier.html#ZenCore.w90_make_hamk","page":"Wannier","title":"ZenCore.w90_make_hamk","text":"w90_make_hamk(kvec::Array{F64,2},\n              rdeg::Array{I64,1},\n              rvec::Array{I64,2},\n              hamr::Array{C64,3})\n\nConvert the hamiltonian from 𝑟-space to 𝑘-space via the fast fourier transformation. The arguments kvec and rvec define the 𝑘-mesh and 𝑟-mesh, respectively. hamr means H(R) which should be defined in a Wigner-Seitz cell.\n\nSee also: w90_make_hamr.\n\n\n\n\n\n","category":"function"},{"location":"internals/wannier.html#ZenCore.w90_diag_hamk","page":"Wannier","title":"ZenCore.w90_diag_hamk","text":"w90_diag_hamk(hamk::Array{C64,3})\n\nDiagonalize the hamiltonian to give band structure.\n\nSee also: w90_make_hamk.\n\n\n\n\n\n","category":"function"},{"location":"internals/wannier.html#ZenCore.w90_find_bwin","page":"Wannier","title":"ZenCore.w90_find_bwin","text":"w90_find_bwin(ewin::Tuple{F64,F64}, enk::Array{F64,3})\n\nDuring the disentanglement procedure, we can define an outer energy window to restrict the Kohn-Sham eigenvalues. This function will return the corresponding band window, which will be used to displace the disentanglement matrix. Here, ewin is the outer energy window which is extracted from w90.wout, and enk is the Kohn-Sham eigenvalues.\n\nThis function works for spin-unpolarized case only.\n\nSee also: w90_read_udis, w90_read_wout.\n\n\n\n\n\n","category":"function"},{"location":"internals/wannier.html#ZenCore.w90_read_amat","page":"Wannier","title":"ZenCore.w90_read_amat","text":"w90_read_amat(sp::String = \"\")\n\nTry to read and parse the w90.amn file to get the A_mn matrix, which represents the projection of the Bloch states onto trail localized orbitals. The argument sp denotes the spin component.\n\nNote that this function has not been used so far.\n\n\n\n\n\n","category":"function"},{"location":"internals/wannier.html#ZenCore.w90_read_eigs","page":"Wannier","title":"ZenCore.w90_read_eigs","text":"w90_read_eigs(sp::String = \"\")\n\nTry to read and parse the w90.eig file to get the band eigenvalues. Note that the eigenvalues from nscf.out are not accurate enough. We will use the data extracted from w90.eig to update them. The argument sp denotes the spin component.\n\nSee also: qeio_eigen.\n\n\n\n\n\n","category":"function"},{"location":"internals/wannier.html#ZenCore.w90_read_hamr","page":"Wannier","title":"ZenCore.w90_read_hamr","text":"w90_read_hamr(f::String, sp::String = \"\")\n\nTry to read and parse the w90_hr.dat file, return the hamiltonian matrix in WF representation, the Wigner-Seitz grid points, and their weights (degeneracies). The argument sp denotes the spin component. The data return by this function can be used to validate the projection matrix further.\n\n\n\n\n\n","category":"function"},{"location":"internals/wannier.html#ZenCore.w90_read_umat","page":"Wannier","title":"ZenCore.w90_read_umat","text":"w90_read_umat(sp::String = \"\")\n\nTry to read and parse the w90_u.mat file, return the u-matrix, which gives the unitary rotations from the optimal subspace to the optimally smooth states. The argument sp denotes the spin component.\n\nSee also: w90_read_udis.\n\n\n\n\n\n","category":"function"},{"location":"internals/wannier.html#ZenCore.w90_read_udis","page":"Wannier","title":"ZenCore.w90_read_udis","text":"w90_read_udis(bwin::Array{I64,2}, sp::String = \"\")\n\nTry to read and parse the w90_u_dis.mat file. Return the udis-matrix, which gives the nproj dimension optimal subspace from the original bloch states. Actually, it is the transform matrix for disentanglement. The argument sp denotes the spin component, the band window bwin is from w90_make_window() and w90_read_wout().\n\nSee also: w90_read_umat.\n\n\n\n\n\n","category":"function"},{"location":"internals/wannier.html#ZenCore.w90_read_wout","page":"Wannier","title":"ZenCore.w90_read_wout","text":"w90_read_wout(sp::String = \"\")\n\nTry to read and parse the w90.wout file. Return the energy window for disentanglement procedure. The argument sp denotes the spin component.\n\nSee also: w90_make_window.\n\n\n\n\n\n","category":"function"},{"location":"internals/wannier.html#ZenCore.w90_write_win","page":"Wannier","title":"ZenCore.w90_write_win","text":"w90_write_win(io::IOStream, w90c::Dict{String,Any})\n\nWrite control parameters into w90.win.\n\nSee also: wannier_init.\n\n\n\n\n\nw90_write_win(io::IOStream, proj::Array{String,1})\n\nWrite projection block into w90.win.\n\nSee also: wannier_init.\n\n\n\n\n\nw90_write_win(io::IOStream, latt::Lattice)\n\nWrite crystallography information into w90.win.\n\nSee also: Lattice, wannier_init.\n\n\n\n\n\nw90_write_win(io::IOStream, kmesh::Array{F64,2})\n\nWrite 𝑘-mesh block into w90.win.\n\nSee also: wannier_init.\n\n\n\n\n\n","category":"function"},{"location":"internals/wannier.html#ZenCore.pw2wan_init","page":"Wannier","title":"ZenCore.pw2wan_init","text":"pw2wan_init(case::String, sp::String = \"\")\n\nCheck the runtime environment of pw2wannier90, prepare necessary input files (it is case.pw2wan). The argument case means the prefix for quantum espresso, and sp determines the spin component which can be empty string, up, or dn.\n\nSee also: pw2wan_exec, pw2wan_save.\n\n\n\n\n\n","category":"function"},{"location":"internals/wannier.html#ZenCore.pw2wan_exec","page":"Wannier","title":"ZenCore.pw2wan_exec","text":"pw2wan_exec(case::String, sp::String = \"\")\n\nExecute the pw2wannier90 program, monitor the convergence progress, and output the relevant information. Here, case means the prefix for input files, and sp is up or dn.\n\nSee also: pw2wan_init, pw2wan_save.\n\n\n\n\n\n","category":"function"},{"location":"internals/wannier.html#ZenCore.pw2wan_save","page":"Wannier","title":"ZenCore.pw2wan_save","text":"pw2wan_save(sp::String = \"\")\n\nBackup and check the output files of the pw2wannier90 code if necessary. The argument sp specifies the spin component. It could be empty string, up, or dn.\n\nSee also: pw2wan_init, pw2wan_exec.\n\n\n\n\n\n","category":"function"},{"location":"guide/df.html#Dual-Fermion-Code","page":"Dual Fermion Code","title":"Dual Fermion Code","text":"","category":"section"}]
}
